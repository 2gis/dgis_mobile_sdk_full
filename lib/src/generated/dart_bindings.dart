library dart_bindings;

import 'dart:convert';
import 'dart:core';
import 'dart:core' as core show Map;
import 'dart:typed_data';
import 'dart:async';
import 'dart:ffi' as ffi;
import 'dart:io';
import 'package:ffi/ffi.dart' as ffi_package;
import 'package:async/async.dart';
import 'package:meta/meta.dart';
import 'buffered_channel.dart';
import 'channel.dart';
import 'enum_set.dart';
import 'native_exception.dart';
import 'optional.dart';
import 'stateful_channel.dart';

part 'library_loading.dart';
ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) get _lookup =>
  <T extends ffi.NativeType>(String symbolName) {
    return libraryProvider.sdkLibrary.lookup<T>(symbolName);
  };
// MARK: - BuildingId

/** Идентификатор здания. */
class BuildingId {
  final int value;

  const BuildingId([this.value = 0]);

  BuildingId copyWith({
    int? value
  }) {
    return BuildingId(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BuildingId &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CBuildingId extends ffi.Struct {
  @ffi.Uint64()
  external int value;

}
// MARK: - BuildingId <-> _CBuildingId

extension _CBuildingIdToDart on _CBuildingId {
  BuildingId _toDart() {
    return BuildingId(
      this.value
    );
  }
}

extension _DartTo_CBuildingId on BuildingId {
  _CBuildingId _copyFromDartTo_CBuildingId() {
    final res = _CBuildingIdMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CBuildingIdRelease on _CBuildingId {
  void _releaseIntermediate() {
  }
}

// MARK: - DayTime

/** Момент времени внутри дня. */
class DayTime {
  /** Часы, 0-23. */
  final int hours;
  /** Минуты, 0-59. */
  final int minutes;

  const DayTime({
    required this.hours,
    required this.minutes
  });

  DayTime copyWith({
    int? hours,
    int? minutes
  }) {
    return DayTime(
      hours: hours ?? this.hours,
      minutes: minutes ?? this.minutes
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DayTime &&
    other.runtimeType == runtimeType &&
    other.hours == hours &&
    other.minutes == minutes;

  @override
  int get hashCode {
    return Object.hash(hours, minutes);
  }

}
final class _CDayTime extends ffi.Struct {
  @ffi.Uint8()
  external int hours;

  @ffi.Uint8()
  external int minutes;

}
// MARK: - DayTime <-> _CDayTime

extension _CDayTimeToDart on _CDayTime {
  DayTime _toDart() {
    return DayTime(
      hours: this.hours,
      minutes: this.minutes
    );
  }
}

extension _DartTo_CDayTime on DayTime {
  _CDayTime _copyFromDartTo_CDayTime() {
    final res = _CDayTimeMakeDefault();
    res.hours = this.hours;
    res.minutes = this.minutes;
    return res;
  }
}
extension _CDayTimeRelease on _CDayTime {
  void _releaseIntermediate() {
  }
}

// MARK: - DgisObjectId

class DgisObjectId {
  /**
   Стабильный числовой идентификатор объекта.
  
   - Note: Нулевой идентификатор не соответствует ни одному объекту.
  */
  final int objectId;
  /**
   Стабильный числовой идентификатор входа/подъезда для объекта object_id.
  
   - Note: Нулевой идентификатор означает что вход/подъезд не задан.
  */
  final int entranceId;

  const DgisObjectId({
    this.objectId = 0,
    this.entranceId = 0
  });

  DgisObjectId copyWith({
    int? objectId,
    int? entranceId
  }) {
    return DgisObjectId(
      objectId: objectId ?? this.objectId,
      entranceId: entranceId ?? this.entranceId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DgisObjectId &&
    other.runtimeType == runtimeType &&
    other.objectId == objectId &&
    other.entranceId == entranceId;

  @override
  int get hashCode {
    return Object.hash(objectId, entranceId);
  }

}
final class _CDgisObjectId extends ffi.Struct {
  @ffi.Uint64()
  external int objectId;

  @ffi.Uint64()
  external int entranceId;

}
// MARK: - DgisObjectId <-> _CDgisObjectId

extension _CDgisObjectIdToDart on _CDgisObjectId {
  DgisObjectId _toDart() {
    return DgisObjectId(
      objectId: this.objectId,
      entranceId: this.entranceId
    );
  }
}

extension _DartTo_CDgisObjectId on DgisObjectId {
  _CDgisObjectId _copyFromDartTo_CDgisObjectId() {
    final res = _CDgisObjectIdMakeDefault();
    res.objectId = this.objectId;
    res.entranceId = this.entranceId;
    return res;
  }
}
extension _CDgisObjectIdRelease on _CDgisObjectId {
  void _releaseIntermediate() {
  }
}

// MARK: - Context

/** Контекст - окружение, необходимое для работы SDK. */
class Context implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CContext_releasePtr);

  Context._raw(this._self);
  factory Context._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Context._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Context &&
    other.runtimeType == runtimeType &&
    _CContext_cg_objectIdentifier(this._self) == _CContext_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CContext_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Context <-> CContext

final class _CContext extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CContextBasicFunctions on _CContext {
  void _releaseIntermediate() {
    _CContext_release(_impl);
  }

  _CContext _retain() {
    return _CContext_retain(_impl);
  }
}

extension _CContextToDart on _CContext {
  Context _toDart() {
    return Context._create(_retain()._impl);
  }
}


extension _DartToCContext on Context {
  _CContext _copyFromDartTo_CContext() {
    return (_CContextMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SystemMemoryManager

/** Интерфейс управления использованием системной памяти. */
class SystemMemoryManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSystemMemoryManager_releasePtr);

  SystemMemoryManager._raw(this._self);
  factory SystemMemoryManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SystemMemoryManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SystemMemoryManager &&
    other.runtimeType == runtimeType &&
    _CSystemMemoryManager_cg_objectIdentifier(this._self) == _CSystemMemoryManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSystemMemoryManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: SystemMemoryManager: Methods

  /** Уменьшение использования памяти путём очистки всевозможных кешей и буферов. */
  void reduceMemoryUsage()  {
    void res = _CSystemMemoryManager_reduceMemoryUsage(_CSystemMemoryManagerMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - SystemMemoryManager <-> CSystemMemoryManager

final class _CSystemMemoryManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSystemMemoryManagerBasicFunctions on _CSystemMemoryManager {
  void _releaseIntermediate() {
    _CSystemMemoryManager_release(_impl);
  }

  _CSystemMemoryManager _retain() {
    return _CSystemMemoryManager_retain(_impl);
  }
}

extension _CSystemMemoryManagerToDart on _CSystemMemoryManager {
  SystemMemoryManager _toDart() {
    return SystemMemoryManager._create(_retain()._impl);
  }
}


extension _DartToCSystemMemoryManager on SystemMemoryManager {
  _CSystemMemoryManager _copyFromDartTo_CSystemMemoryManager() {
    return (_CSystemMemoryManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - LevelId

/** Идентификатор этажного плана. */
class LevelId {
  final int value;

  const LevelId([this.value = 0]);

  LevelId copyWith({
    int? value
  }) {
    return LevelId(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LevelId &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CLevelId extends ffi.Struct {
  @ffi.Uint64()
  external int value;

}
// MARK: - LevelId <-> _CLevelId

extension _CLevelIdToDart on _CLevelId {
  LevelId _toDart() {
    return LevelId(
      this.value
    );
  }
}

extension _DartTo_CLevelId on LevelId {
  _CLevelId _copyFromDartTo_CLevelId() {
    final res = _CLevelIdMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CLevelIdRelease on _CLevelId {
  void _releaseIntermediate() {
  }
}

// MARK: - String <-> _CString

final class _CString extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

_CString _CStringCreateWithData(
  int size,
  ffi.Pointer<ffi_package.Utf8> utf8Data
) {
  return _CStringCreateWithDataPrivate(size, utf8Data);
}

extension _CStringBasicFunctions on _CString {
  int _getSize() {
    return _GetSizeWith_CString(this);
  }

  ffi.Pointer<ffi_package.Utf8> _getData() {
    return _GetDataWith_CString(this);
  }

  void _releaseIntermediate() {
    _CString_release(this);
  }
}

extension _CStringToDart on _CString {
  String _toDart() {
    return _getData().toDartString(length: _getSize());
  }
}

extension _DartTo_CString on String {
  _CString _copyFromDartTo_CString() {
    // Adapted from https://pub.dev/documentation/ffi/latest/ffi/StringUtf8Pointer/toNativeUtf8.html
    final units = utf8.encode(this);
    final result = ffi_package.malloc<ffi.Uint8>(units.length);
    final nativeString = result.asTypedList(units.length);
    nativeString.setAll(0, units);
    return _CStringCreateWithData(units.length, result.cast());
  }
}


// MARK: - LevelInfo

/** Информация об этаже здания. */
class LevelInfo {
  /** Идентификатор этажного плана. */
  final LevelId id;
  /** Название этажа. */
  final String name;

  const LevelInfo({
    required this.id,
    required this.name
  });

  LevelInfo copyWith({
    LevelId? id,
    String? name
  }) {
    return LevelInfo(
      id: id ?? this.id,
      name: name ?? this.name
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LevelInfo &&
    other.runtimeType == runtimeType &&
    other.id == id &&
    other.name == name;

  @override
  int get hashCode {
    return Object.hash(id, name);
  }

}
final class _CLevelInfo extends ffi.Struct {
  external _CLevelId id;

  external _CString name;

}
// MARK: - LevelInfo <-> _CLevelInfo

extension _CLevelInfoToDart on _CLevelInfo {
  LevelInfo _toDart() {
    return LevelInfo(
      id: this.id._toDart(),
      name: this.name._toDart()
    );
  }
}

extension _DartTo_CLevelInfo on LevelInfo {
  _CLevelInfo _copyFromDartTo_CLevelInfo() {
    final res = _CLevelInfoMakeDefault();
    res.id = this.id._copyFromDartTo_CLevelId();
    res.name = this.name._copyFromDartTo_CString();
    return res;
  }
}
extension _CLevelInfoRelease on _CLevelInfo {
  void _releaseIntermediate() {
    name._releaseIntermediate();
  }
}

// MARK: - Meter

/** Длина/расстояние в метрах. */
class Meter {
  final double value;

  const Meter([this.value = 0]);

  Meter copyWith({
    double? value
  }) {
    return Meter(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Meter &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CMeter extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - Meter <-> _CMeter

extension _CMeterToDart on _CMeter {
  Meter _toDart() {
    return Meter(
      this.value
    );
  }
}

extension _DartTo_CMeter on Meter {
  _CMeter _copyFromDartTo_CMeter() {
    final res = _CMeterMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CMeterRelease on _CMeter {
  void _releaseIntermediate() {
  }
}

// MARK: - PersonalDataCollectionConsent

/** Статус согласия пользователя на сбор и отправку персональных данных. */
enum PersonalDataCollectionConsent {
  /** Пользователь согласен. */
  granted(0),
  /** Пользователь не согласен. */
  denied(1),
  ;

  const PersonalDataCollectionConsent(this.rawValue);
  final int rawValue;

  static PersonalDataCollectionConsent getByValue(int value) {
    return PersonalDataCollectionConsent.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CPersonalDataCollectionConsent extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CPersonalDataCollectionConsentBasicFunctions on _CPersonalDataCollectionConsent {
  void _releaseIntermediate() {
  }
}

extension _CPersonalDataCollectionConsentToDart on _CPersonalDataCollectionConsent {
  PersonalDataCollectionConsent _toDart() {
    return PersonalDataCollectionConsent.getByValue(this.rawValue);
  }
}

extension _DartTo_CPersonalDataCollectionConsent on PersonalDataCollectionConsent {
  _CPersonalDataCollectionConsent _copyFromDartTo_CPersonalDataCollectionConsent() {
    return _CPersonalDataCollectionConsentMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ScreenSize

/** Размер в пикселях. */
class ScreenSize {
  final int width;
  final int height;

  const ScreenSize({
    this.width = 0,
    this.height = 0
  });

  ScreenSize copyWith({
    int? width,
    int? height
  }) {
    return ScreenSize(
      width: width ?? this.width,
      height: height ?? this.height
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScreenSize &&
    other.runtimeType == runtimeType &&
    other.width == width &&
    other.height == height;

  @override
  int get hashCode {
    return Object.hash(width, height);
  }

}
final class _CScreenSize extends ffi.Struct {
  @ffi.Uint32()
  external int width;

  @ffi.Uint32()
  external int height;

}
// MARK: - ScreenSize <-> _CScreenSize

extension _CScreenSizeToDart on _CScreenSize {
  ScreenSize _toDart() {
    return ScreenSize(
      width: this.width,
      height: this.height
    );
  }
}

extension _DartTo_CScreenSize on ScreenSize {
  _CScreenSize _copyFromDartTo_CScreenSize() {
    final res = _CScreenSizeMakeDefault();
    res.width = this.width;
    res.height = this.height;
    return res;
  }
}
extension _CScreenSizeRelease on _CScreenSize {
  void _releaseIntermediate() {
  }
}

// MARK: - WeekDay

/** День недели. */
enum WeekDay {
  sunday(0),
  monday(1),
  tuesday(2),
  wednesday(3),
  thursday(4),
  friday(5),
  saturday(6),
  ;

  const WeekDay(this.rawValue);
  final int rawValue;

  static WeekDay getByValue(int value) {
    return WeekDay.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CWeekDay extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CWeekDayBasicFunctions on _CWeekDay {
  void _releaseIntermediate() {
  }
}

extension _CWeekDayToDart on _CWeekDay {
  WeekDay _toDart() {
    return WeekDay.getByValue(this.rawValue);
  }
}

extension _DartTo_CWeekDay on WeekDay {
  _CWeekDay _copyFromDartTo_CWeekDay() {
    return _CWeekDayMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - WeekTime

/** Момент времени внутри недели. */
class WeekTime {
  /** День недели. */
  final WeekDay weekDay;
  /** Время. */
  final DayTime time;

  const WeekTime({
    required this.weekDay,
    required this.time
  });

  WeekTime copyWith({
    WeekDay? weekDay,
    DayTime? time
  }) {
    return WeekTime(
      weekDay: weekDay ?? this.weekDay,
      time: time ?? this.time
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is WeekTime &&
    other.runtimeType == runtimeType &&
    other.weekDay == weekDay &&
    other.time == time;

  @override
  int get hashCode {
    return Object.hash(weekDay, time);
  }

}
final class _CWeekTime extends ffi.Struct {
  external _CWeekDay weekDay;

  external _CDayTime time;

}
// MARK: - WeekTime <-> _CWeekTime

extension _CWeekTimeToDart on _CWeekTime {
  WeekTime _toDart() {
    return WeekTime(
      weekDay: this.weekDay._toDart(),
      time: this.time._toDart()
    );
  }
}

extension _DartTo_CWeekTime on WeekTime {
  _CWeekTime _copyFromDartTo_CWeekTime() {
    final res = _CWeekTimeMakeDefault();
    res.weekDay = this.weekDay._copyFromDartTo_CWeekDay();
    res.time = this.time._copyFromDartTo_CDayTime();
    return res;
  }
}
extension _CWeekTimeRelease on _CWeekTime {
  void _releaseIntermediate() {
  }
}

// MARK: - WeekTimeInterval

/** Интервал времени в течение недели. */
class WeekTimeInterval {
  /** Время начала. */
  final WeekTime startTime;
  /** Время окончания. */
  final WeekTime finishTime;

  const WeekTimeInterval({
    required this.startTime,
    required this.finishTime
  });

  WeekTimeInterval copyWith({
    WeekTime? startTime,
    WeekTime? finishTime
  }) {
    return WeekTimeInterval(
      startTime: startTime ?? this.startTime,
      finishTime: finishTime ?? this.finishTime
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is WeekTimeInterval &&
    other.runtimeType == runtimeType &&
    other.startTime == startTime &&
    other.finishTime == finishTime;

  @override
  int get hashCode {
    return Object.hash(startTime, finishTime);
  }

}
final class _CWeekTimeInterval extends ffi.Struct {
  external _CWeekTime startTime;

  external _CWeekTime finishTime;

}
// MARK: - WeekTimeInterval <-> _CWeekTimeInterval

extension _CWeekTimeIntervalToDart on _CWeekTimeInterval {
  WeekTimeInterval _toDart() {
    return WeekTimeInterval(
      startTime: this.startTime._toDart(),
      finishTime: this.finishTime._toDart()
    );
  }
}

extension _DartTo_CWeekTimeInterval on WeekTimeInterval {
  _CWeekTimeInterval _copyFromDartTo_CWeekTimeInterval() {
    final res = _CWeekTimeIntervalMakeDefault();
    res.startTime = this.startTime._copyFromDartTo_CWeekTime();
    res.finishTime = this.finishTime._copyFromDartTo_CWeekTime();
    return res;
  }
}
extension _CWeekTimeIntervalRelease on _CWeekTimeInterval {
  void _releaseIntermediate() {
  }
}

// MARK: - getSystemMemoryManager

/** Получение объекта для управления использованием системной памяти. */
SystemMemoryManager getSystemMemoryManager(
  Context context
){
  var _a0 = context._copyFromDartTo_CContext();
  _CSystemMemoryManager res = _CFunction_G_getSystemMemoryManager_With_CContext(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - makeSystemContext

/**
 Метод для создания SDK контекста.

 - Parameter keySource: Источник ключа SDK.
 - Parameter httpOptions: Настройки http клиента.
 - Parameter logOptions: Настройки логирования.
 - Parameter dataCollectConsent: Статус согласия пользователя на сбор и отправку персональных данных.
 - Parameter vendorConfig: Переопределение конфигурации SDK.
 - Parameter locationProvider: Интерфейс источника геопозиции, который реализуется пользователем на платформе.
 Если null, то используется источник по умолчанию.
 - Parameter headingProvider: Интерфейс, предоставляющий направление устройства относительно направления на север.
 Если null на iOS, то используется источник по умолчанию.
 Если null на Android, то cлежение за направлением будет реализовано на основе GPS.
*/
@internal
Context makeSystemContext(
  KeySource keySource,
  HttpOptions httpOptions,
  LogOptions logOptions,
  PersonalDataCollectionConsent dataCollectConsent,
  VendorConfig vendorConfig,
  [LocationProvider? locationProvider = null,
  HeadingProvider? headingProvider = null
  ]){
  var _a0 = keySource._copyFromDartTo_CKeySource();
  var _a1 = httpOptions._copyFromDartTo_CHttpOptions();
  var _a2 = logOptions._copyFromDartTo_CLogOptions();
  var _a3 = dataCollectConsent._copyFromDartTo_CPersonalDataCollectionConsent();
  var _a4 = vendorConfig._copyFromDartTo_CVendorConfig();
  var _a5 = locationProvider._copyFromDartTo_COptional_CLocationProvider();
  var _a6 = headingProvider._copyFromDartTo_COptional_CHeadingProvider();
  _CContext res = _CFunction_G_makeSystemContext_With_CKeySource_CHttpOptions_CLogOptions_CPersonalDataCollectionConsent_CVendorConfig_COptional_CLocationProvider_COptional_CHeadingProvider(_a0, _a1, _a2, _a3, _a4, _a5, _a6);
  _a6._releaseIntermediate();
  _a5._releaseIntermediate();
  _a4._releaseIntermediate();
  _a2._releaseIntermediate();
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - KeyFromAsset

/**
 Ключ из asset-а.
 Для Android это директория assets.
 Для iOS это директория Bundle.main.
*/
class KeyFromAsset {
  /** Путь относительно корневой директории asset-ов. */
  final String path;

  const KeyFromAsset(this.path);

  KeyFromAsset copyWith({
    String? path
  }) {
    return KeyFromAsset(
      path ?? this.path
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is KeyFromAsset &&
    other.runtimeType == runtimeType &&
    other.path == path;

  @override
  int get hashCode {
    return path.hashCode;
  }

}
final class _CKeyFromAsset extends ffi.Struct {
  external _CString path;

}
// MARK: - KeyFromAsset <-> _CKeyFromAsset

extension _CKeyFromAssetToDart on _CKeyFromAsset {
  KeyFromAsset _toDart() {
    return KeyFromAsset(
      this.path._toDart()
    );
  }
}

extension _DartTo_CKeyFromAsset on KeyFromAsset {
  _CKeyFromAsset _copyFromDartTo_CKeyFromAsset() {
    final res = _CKeyFromAssetMakeDefault();
    res.path = this.path._copyFromDartTo_CString();
    return res;
  }
}
extension _CKeyFromAssetRelease on _CKeyFromAsset {
  void _releaseIntermediate() {
    path._releaseIntermediate();
  }
}

// MARK: - KeyFromFile

/** Ключ из файла. */
class KeyFromFile {
  /** Путь к файлу. */
  final String path;

  const KeyFromFile(this.path);

  KeyFromFile copyWith({
    String? path
  }) {
    return KeyFromFile(
      path ?? this.path
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is KeyFromFile &&
    other.runtimeType == runtimeType &&
    other.path == path;

  @override
  int get hashCode {
    return path.hashCode;
  }

}
final class _CKeyFromFile extends ffi.Struct {
  external _CString path;

}
// MARK: - KeyFromFile <-> _CKeyFromFile

extension _CKeyFromFileToDart on _CKeyFromFile {
  KeyFromFile _toDart() {
    return KeyFromFile(
      this.path._toDart()
    );
  }
}

extension _DartTo_CKeyFromFile on KeyFromFile {
  _CKeyFromFile _copyFromDartTo_CKeyFromFile() {
    final res = _CKeyFromFileMakeDefault();
    res.path = this.path._copyFromDartTo_CString();
    return res;
  }
}
extension _CKeyFromFileRelease on _CKeyFromFile {
  void _releaseIntermediate() {
    path._releaseIntermediate();
  }
}

// MARK: - KeyFromString

/** Ключ из строки. */
class KeyFromString {
  /** Содержимое. */
  final String contents;

  const KeyFromString(this.contents);

  KeyFromString copyWith({
    String? contents
  }) {
    return KeyFromString(
      contents ?? this.contents
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is KeyFromString &&
    other.runtimeType == runtimeType &&
    other.contents == contents;

  @override
  int get hashCode {
    return contents.hashCode;
  }

}
final class _CKeyFromString extends ffi.Struct {
  external _CString contents;

}
// MARK: - KeyFromString <-> _CKeyFromString

extension _CKeyFromStringToDart on _CKeyFromString {
  KeyFromString _toDart() {
    return KeyFromString(
      this.contents._toDart()
    );
  }
}

extension _DartTo_CKeyFromString on KeyFromString {
  _CKeyFromString _copyFromDartTo_CKeyFromString() {
    final res = _CKeyFromStringMakeDefault();
    res.contents = this.contents._copyFromDartTo_CString();
    return res;
  }
}
extension _CKeyFromStringRelease on _CKeyFromString {
  void _releaseIntermediate() {
    contents._releaseIntermediate();
  }
}

// MARK: - KeySource

/** Источник ключа. */
final class KeySource {
  final Object? _value;
  final int _index;

  KeySource._raw(this._value, this._index);

  KeySource.fromAsset(KeyFromAsset value) : this._raw(value, 0);
  KeySource.fromFile(KeyFromFile value) : this._raw(value, 1);
  KeySource.fromString(KeyFromString value) : this._raw(value, 2);

  bool get isFromAsset => this._index == 0;
  KeyFromAsset? get asFromAsset => this.isFromAsset ? this._value as KeyFromAsset : null;

  bool get isFromFile => this._index == 1;
  KeyFromFile? get asFromFile => this.isFromFile ? this._value as KeyFromFile : null;

  bool get isFromString => this._index == 2;
  KeyFromString? get asFromString => this.isFromString ? this._value as KeyFromString : null;

  T match<T>({
    required T Function(KeyFromAsset value) fromAsset,
    required T Function(KeyFromFile value) fromFile,
    required T Function(KeyFromString value) fromString,
  }) {
    return switch (this._index) {
      0 => fromAsset(this._value as KeyFromAsset),
      1 => fromFile(this._value as KeyFromFile),
      2 => fromString(this._value as KeyFromString),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "KeySource(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is KeySource &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CKeySourceImpl extends ffi.Union {
  external _CKeyFromAsset _fromAsset;
  external _CKeyFromFile _fromFile;
  external _CKeyFromString _fromString;
}

final class _CKeySource extends ffi.Struct {
  external _CKeySourceImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CKeySourceBasicFunctions on _CKeySource {
  void _releaseIntermediate() {
    _CKeySource_release(this);
  }
}
	
// MARK: - KeySource <-> CKeySource

extension _CKeySourceToDart on _CKeySource {
  KeySource _toDart() {
    return switch (this._index) {
      0 => KeySource.fromAsset(this._impl._fromAsset._toDart()),
      1 => KeySource.fromFile(this._impl._fromFile._toDart()),
      2 => KeySource.fromString(this._impl._fromString._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CKeySource on KeySource {
  _CKeySource _copyFromDartTo_CKeySource() {
    var res = _CKeySourceMakeDefault();
    this.match<void>(
      fromAsset: (KeyFromAsset value) {
        res._impl._fromAsset = value._copyFromDartTo_CKeyFromAsset();
        res._index = 0;
      },
      fromFile: (KeyFromFile value) {
        res._impl._fromFile = value._copyFromDartTo_CKeyFromFile();
        res._index = 1;
      },
      fromString: (KeyFromString value) {
        res._impl._fromString = value._copyFromDartTo_CKeyFromString();
        res._index = 2;
      },
    );
    return res;
  }
}

// MARK: - Duration <-> _CTimeInterval

final class _CTimeInterval extends ffi.Struct {
  @ffi.Double()
  external double timeInterval;
}

extension _CTimeIntervalBasicFunctions on _CTimeInterval {
  void _releaseIntermediate() {
  }
}

extension _CTimeIntervalToDart on _CTimeInterval {
  Duration _toDart() {
    return Duration(milliseconds: (timeInterval * 1000).ceil());
  }
}

extension _DartTo_CTimeInterval on Duration {
  _CTimeInterval _copyFromDartTo_CTimeInterval() {
    return _CTimeIntervalMakeDefault()..timeInterval = inMilliseconds.toDouble() / 1000;
  }
}
	
// MARK: - String? <-> _COptional_CString

final class _COptional_CString extends ffi.Struct {
  
  external _CString value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CStringBasicFunctions on _COptional_CString {
  void _releaseIntermediate() {
    _COptional_CString_release(this);
  }
}

extension _COptional_CStringToDart on _COptional_CString {
  String? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CString on String? {
  _COptional_CString _copyFromDartTo_COptional_CString() {
    final cOptional = _COptional_CStringMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CString();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - int? <-> _COptional_uint64_t

final class _COptional_uint64_t extends ffi.Struct {
  @ffi.Uint64()
  external int value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_uint64_tBasicFunctions on _COptional_uint64_t {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_uint64_tToDart on _COptional_uint64_t {
  int? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_uint64_t on int? {
  _COptional_uint64_t _copyFromDartTo_COptional_uint64_t() {
    final cOptional = _COptional_uint64_tMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - HttpOptions

/** Опции Http-клиента. */
class HttpOptions {
  /** Таймаут для HTTP-запросов. */
  final Duration timeout;
  /** Использовать HTTP кэш. */
  final bool useCache;
  /**
   Путь к каталогу верхнего уровня для основного файлового хранилища HTTP кэша.
   Файловое хранилище будет находиться в подкаталоге http_cache в данном каталоге.
   Если путь не указан, будет использоваться директория по умолчанию.
  */
  final String? cacheStoragePath;
  /**
   Максимальный размер HTTP-кеша в байтах.
   Если не указан, по умолчанию максимальный размер HTTP кэша составляет 300 Мб.
  */
  final int? cacheMaxSize;

  const HttpOptions({
    this.timeout = const Duration(milliseconds: 15000),
    this.useCache = true,
    this.cacheStoragePath = null,
    this.cacheMaxSize = null
  });

  HttpOptions copyWith({
    Duration? timeout,
    bool? useCache,
    Optional<String?>? cacheStoragePath,
    Optional<int?>? cacheMaxSize
  }) {
    return HttpOptions(
      timeout: timeout ?? this.timeout,
      useCache: useCache ?? this.useCache,
      cacheStoragePath: cacheStoragePath != null ? cacheStoragePath.value : this.cacheStoragePath,
      cacheMaxSize: cacheMaxSize != null ? cacheMaxSize.value : this.cacheMaxSize
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is HttpOptions &&
    other.runtimeType == runtimeType &&
    other.timeout == timeout &&
    other.useCache == useCache &&
    other.cacheStoragePath == cacheStoragePath &&
    other.cacheMaxSize == cacheMaxSize;

  @override
  int get hashCode {
    return Object.hash(timeout, useCache, cacheStoragePath, cacheMaxSize);
  }

}
final class _CHttpOptions extends ffi.Struct {
  external _CTimeInterval timeout;

  @ffi.Bool()
  external bool useCache;

  external _COptional_CString cacheStoragePath;

  external _COptional_uint64_t cacheMaxSize;

}
// MARK: - HttpOptions <-> _CHttpOptions

extension _CHttpOptionsToDart on _CHttpOptions {
  HttpOptions _toDart() {
    return HttpOptions(
      timeout: this.timeout._toDart(),
      useCache: this.useCache,
      cacheStoragePath: this.cacheStoragePath._toDart(),
      cacheMaxSize: this.cacheMaxSize._toDart()
    );
  }
}

extension _DartTo_CHttpOptions on HttpOptions {
  _CHttpOptions _copyFromDartTo_CHttpOptions() {
    final res = _CHttpOptionsMakeDefault();
    res.timeout = this.timeout._copyFromDartTo_CTimeInterval();
    res.useCache = this.useCache;
    res.cacheStoragePath = this.cacheStoragePath._copyFromDartTo_COptional_CString();
    res.cacheMaxSize = this.cacheMaxSize._copyFromDartTo_COptional_uint64_t();
    return res;
  }
}
extension _CHttpOptionsRelease on _CHttpOptions {
  void _releaseIntermediate() {
    cacheStoragePath._releaseIntermediate();
  }
}

// MARK: - LogLevel

/** Уровень логирования. */
enum LogLevel {
  verbose(0),
  info(1),
  warning(2),
  error(3),
  fatal(4),
  off(5),
  ;

  const LogLevel(this.rawValue);
  final int rawValue;

  static LogLevel getByValue(int value) {
    return LogLevel.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CLogLevel extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CLogLevelBasicFunctions on _CLogLevel {
  void _releaseIntermediate() {
  }
}

extension _CLogLevelToDart on _CLogLevel {
  LogLevel _toDart() {
    return LogLevel.getByValue(this.rawValue);
  }
}

extension _DartTo_CLogLevel on LogLevel {
  _CLogLevel _copyFromDartTo_CLogLevel() {
    return _CLogLevelMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - LogSink

/** Приемник логирования. */
abstract class LogSink {
  void write(
    LogMessage message
  );
}

class _LogSink {
  final LogSink object;
  int refCounter = 1;

  _LogSink(this.object);
}

final class _CLogSink extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CLogMessage)>> _write_CLogMessage;
}

extension _CLogSinkBasicFunctions on _CLogSink {
  void _releaseIntermediate() {
    _CLogSink_release(this);
  }
}

int _CLogSinkInstanceCounter = 1;
final _CLogSinkInstanceMap = <int, _LogSink>{};

extension _CLogSinkToDart on _CLogSink {
  LogSink _toDart() {
    late LogSink? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CLogSinkInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CLogSinkCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CLogSink");
    }
    return result;
  }
}

extension _DartTo_CLogSink on LogSink {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CLogSinkInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CLogSinkInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CLogSinkInstanceMap.remove(platformValue.address);
  }

  _CLogSink _copyFromDartTo_CLogSink() {
    var res = _CLogSinkMakeDefault();
    if (this is _LogSinkCpp) {
      final cppValue = this as _LogSinkCpp;
      res._cppValue = cppValue._copyFromDartTo_CLogSinkCpp()._impl;
      return res;
    }
    final instanceId = _CLogSinkInstanceCounter;
    _CLogSinkInstanceCounter += 1;
    _CLogSinkInstanceMap[instanceId] = _LogSink(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final write_CLogMessageFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CLogMessage)>.listener(write_CLogMessageFunction);
    res._write_CLogMessage = write_CLogMessageFunctionCallable.nativeFunction;
    return res;
  }

  static void write_CLogMessageFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _CLogMessage message) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CLogSink");
    }
    final platformObject = _CLogSinkInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CLogSink");
    }

    final messageDart = message._toDart();
    platformObject.object.write(messageDart);
    message._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }


}

// MARK: - LogSink? <-> _COptional_CLogSink

final class _COptional_CLogSink extends ffi.Struct {
  
  external _CLogSink value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLogSinkBasicFunctions on _COptional_CLogSink {
  void _releaseIntermediate() {
    _COptional_CLogSink_release(this);
  }
}

extension _COptional_CLogSinkToDart on _COptional_CLogSink {
  LogSink? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLogSink on LogSink? {
  _COptional_CLogSink _copyFromDartTo_COptional_CLogSink() {
    final cOptional = _COptional_CLogSinkMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLogSink();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - LogOptions

/** Настройки логирования. */
class LogOptions {
  /** Уровень логирования в системный лог. */
  final LogLevel systemLevel;
  /** Уровень логирования в пользовательский приемник. */
  final LogLevel customLevel;
  /** Пользовательский приемник логирования. */
  final LogSink? customSink;

  const LogOptions({
    this.systemLevel = LogLevel.warning,
    this.customLevel = LogLevel.warning,
    this.customSink = null
  });

  LogOptions copyWith({
    LogLevel? systemLevel,
    LogLevel? customLevel,
    Optional<LogSink?>? customSink
  }) {
    return LogOptions(
      systemLevel: systemLevel ?? this.systemLevel,
      customLevel: customLevel ?? this.customLevel,
      customSink: customSink != null ? customSink.value : this.customSink
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LogOptions &&
    other.runtimeType == runtimeType &&
    other.systemLevel == systemLevel &&
    other.customLevel == customLevel &&
    other.customSink == customSink;

  @override
  int get hashCode {
    return Object.hash(systemLevel, customLevel, customSink);
  }

}
final class _CLogOptions extends ffi.Struct {
  external _CLogLevel systemLevel;

  external _CLogLevel customLevel;

  external _COptional_CLogSink customSink;

}
// MARK: - LogOptions <-> _CLogOptions

extension _CLogOptionsToDart on _CLogOptions {
  LogOptions _toDart() {
    return LogOptions(
      systemLevel: this.systemLevel._toDart(),
      customLevel: this.customLevel._toDart(),
      customSink: this.customSink._toDart()
    );
  }
}

extension _DartTo_CLogOptions on LogOptions {
  _CLogOptions _copyFromDartTo_CLogOptions() {
    final res = _CLogOptionsMakeDefault();
    res.systemLevel = this.systemLevel._copyFromDartTo_CLogLevel();
    res.customLevel = this.customLevel._copyFromDartTo_CLogLevel();
    res.customSink = this.customSink._copyFromDartTo_COptional_CLogSink();
    return res;
  }
}
extension _CLogOptionsRelease on _CLogOptions {
  void _releaseIntermediate() {
    customSink._releaseIntermediate();
  }
}

// MARK: - _LogSinkCpp

/** Приемник логирования. */
class _LogSinkCpp extends LogSink implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CLogSinkCpp_releasePtr);

  _LogSinkCpp._raw(this._self);
  factory _LogSinkCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _LogSinkCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _LogSinkCpp &&
    other.runtimeType == runtimeType &&
    _CLogSinkCpp_cg_objectIdentifier(this._self) == _CLogSinkCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLogSinkCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _LogSinkCpp: Methods

  /**
   Запись в лог.
   Метод может вызываться на произвольном потоке.
  */
  void write(
    LogMessage message
  )  {
    var _a1 = message._copyFromDartTo_CLogMessage();
    void res = _CLogSinkCpp_write_CLogMessage(_CLogSinkCppMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - _LogSinkCpp <-> CLogSinkCpp

final class _CLogSinkCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLogSinkCppBasicFunctions on _CLogSinkCpp {
  void _releaseIntermediate() {
    _CLogSinkCpp_release(_impl);
  }

  _CLogSinkCpp _retain() {
    return _CLogSinkCpp_retain(_impl);
  }
}

extension _CLogSinkCppToDart on _CLogSinkCpp {
  _LogSinkCpp _toDart() {
    return _LogSinkCpp._create(_retain()._impl);
  }
}


extension _DartToCLogSinkCpp on _LogSinkCpp {
  _CLogSinkCpp _copyFromDartTo_CLogSinkCpp() {
    return (_CLogSinkCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - LogMessage

/** Сообщение, записываемое в лог. */
class LogMessage {
  /** Уровень логирования. */
  final LogLevel level;
  /** Содержимое сообщения. */
  final String text;
  /** Имя файла, в котором было записано сообщение. */
  final String file;
  /** Номер строки, в которой было записано сообщение. */
  final int line;

  const LogMessage({
    required this.level,
    required this.text,
    required this.file,
    required this.line
  });

  LogMessage copyWith({
    LogLevel? level,
    String? text,
    String? file,
    int? line
  }) {
    return LogMessage(
      level: level ?? this.level,
      text: text ?? this.text,
      file: file ?? this.file,
      line: line ?? this.line
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LogMessage &&
    other.runtimeType == runtimeType &&
    other.level == level &&
    other.text == text &&
    other.file == file &&
    other.line == line;

  @override
  int get hashCode {
    return Object.hash(level, text, file, line);
  }

}
final class _CLogMessage extends ffi.Struct {
  external _CLogLevel level;

  external _CString text;

  external _CString file;

  @ffi.Uint32()
  external int line;

}
// MARK: - LogMessage <-> _CLogMessage

extension _CLogMessageToDart on _CLogMessage {
  LogMessage _toDart() {
    return LogMessage(
      level: this.level._toDart(),
      text: this.text._toDart(),
      file: this.file._toDart(),
      line: this.line
    );
  }
}

extension _DartTo_CLogMessage on LogMessage {
  _CLogMessage _copyFromDartTo_CLogMessage() {
    final res = _CLogMessageMakeDefault();
    res.level = this.level._copyFromDartTo_CLogLevel();
    res.text = this.text._copyFromDartTo_CString();
    res.file = this.file._copyFromDartTo_CString();
    res.line = this.line;
    return res;
  }
}
extension _CLogMessageRelease on _CLogMessage {
  void _releaseIntermediate() {
    text._releaseIntermediate();
    file._releaseIntermediate();
  }
}

// MARK: - CEmpty <-> _CEmpty

final class _CEmpty extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
	
// MARK: - VendorConfigFromAsset

/**
 Переопределение настроек SDK через указание пути к asset-у приложения.
 Для Android это директория assets.
 Для iOS это директория Bundle.main.
*/
class VendorConfigFromAsset {
  /** Путь относительно корневой директории asset-ов. */
  final String path;

  const VendorConfigFromAsset(this.path);

  VendorConfigFromAsset copyWith({
    String? path
  }) {
    return VendorConfigFromAsset(
      path ?? this.path
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is VendorConfigFromAsset &&
    other.runtimeType == runtimeType &&
    other.path == path;

  @override
  int get hashCode {
    return path.hashCode;
  }

}
final class _CVendorConfigFromAsset extends ffi.Struct {
  external _CString path;

}
// MARK: - VendorConfigFromAsset <-> _CVendorConfigFromAsset

extension _CVendorConfigFromAssetToDart on _CVendorConfigFromAsset {
  VendorConfigFromAsset _toDart() {
    return VendorConfigFromAsset(
      this.path._toDart()
    );
  }
}

extension _DartTo_CVendorConfigFromAsset on VendorConfigFromAsset {
  _CVendorConfigFromAsset _copyFromDartTo_CVendorConfigFromAsset() {
    final res = _CVendorConfigFromAssetMakeDefault();
    res.path = this.path._copyFromDartTo_CString();
    return res;
  }
}
extension _CVendorConfigFromAssetRelease on _CVendorConfigFromAsset {
  void _releaseIntermediate() {
    path._releaseIntermediate();
  }
}

// MARK: - VendorConfigFromFile

/** Переопределение настроек SDK через указание пути к файлу в файловой системе устройства. */
class VendorConfigFromFile {
  /** Путь к файлу. */
  final String path;

  const VendorConfigFromFile(this.path);

  VendorConfigFromFile copyWith({
    String? path
  }) {
    return VendorConfigFromFile(
      path ?? this.path
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is VendorConfigFromFile &&
    other.runtimeType == runtimeType &&
    other.path == path;

  @override
  int get hashCode {
    return path.hashCode;
  }

}
final class _CVendorConfigFromFile extends ffi.Struct {
  external _CString path;

}
// MARK: - VendorConfigFromFile <-> _CVendorConfigFromFile

extension _CVendorConfigFromFileToDart on _CVendorConfigFromFile {
  VendorConfigFromFile _toDart() {
    return VendorConfigFromFile(
      this.path._toDart()
    );
  }
}

extension _DartTo_CVendorConfigFromFile on VendorConfigFromFile {
  _CVendorConfigFromFile _copyFromDartTo_CVendorConfigFromFile() {
    final res = _CVendorConfigFromFileMakeDefault();
    res.path = this.path._copyFromDartTo_CString();
    return res;
  }
}
extension _CVendorConfigFromFileRelease on _CVendorConfigFromFile {
  void _releaseIntermediate() {
    path._releaseIntermediate();
  }
}

// MARK: - VendorConfigFromString

/** Переопределение настроек SDK через указание содержимого файла. */
class VendorConfigFromString {
  /** Содержимое файла переопределения настроек. */
  final String contents;

  const VendorConfigFromString(this.contents);

  VendorConfigFromString copyWith({
    String? contents
  }) {
    return VendorConfigFromString(
      contents ?? this.contents
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is VendorConfigFromString &&
    other.runtimeType == runtimeType &&
    other.contents == contents;

  @override
  int get hashCode {
    return contents.hashCode;
  }

}
final class _CVendorConfigFromString extends ffi.Struct {
  external _CString contents;

}
// MARK: - VendorConfigFromString <-> _CVendorConfigFromString

extension _CVendorConfigFromStringToDart on _CVendorConfigFromString {
  VendorConfigFromString _toDart() {
    return VendorConfigFromString(
      this.contents._toDart()
    );
  }
}

extension _DartTo_CVendorConfigFromString on VendorConfigFromString {
  _CVendorConfigFromString _copyFromDartTo_CVendorConfigFromString() {
    final res = _CVendorConfigFromStringMakeDefault();
    res.contents = this.contents._copyFromDartTo_CString();
    return res;
  }
}
extension _CVendorConfigFromStringRelease on _CVendorConfigFromString {
  void _releaseIntermediate() {
    contents._releaseIntermediate();
  }
}

// MARK: - VendorConfig

/** Переопределение конфигурации SDK. */
final class VendorConfig {
  final Object? _value;
  final int _index;

  VendorConfig._raw(this._value, this._index);

  VendorConfig.none() : this._raw(null, 0);
  VendorConfig.fromAsset(VendorConfigFromAsset value) : this._raw(value, 1);
  VendorConfig.fromFile(VendorConfigFromFile value) : this._raw(value, 2);
  VendorConfig.fromString(VendorConfigFromString value) : this._raw(value, 3);

  bool get isNone => this._index == 0;
  Object? get asNone => this.isNone ? this._value as Object : null;

  bool get isFromAsset => this._index == 1;
  VendorConfigFromAsset? get asFromAsset => this.isFromAsset ? this._value as VendorConfigFromAsset : null;

  bool get isFromFile => this._index == 2;
  VendorConfigFromFile? get asFromFile => this.isFromFile ? this._value as VendorConfigFromFile : null;

  bool get isFromString => this._index == 3;
  VendorConfigFromString? get asFromString => this.isFromString ? this._value as VendorConfigFromString : null;

  T match<T>({
    required T Function() none,
    required T Function(VendorConfigFromAsset value) fromAsset,
    required T Function(VendorConfigFromFile value) fromFile,
    required T Function(VendorConfigFromString value) fromString,
  }) {
    return switch (this._index) {
      0 => none(),
      1 => fromAsset(this._value as VendorConfigFromAsset),
      2 => fromFile(this._value as VendorConfigFromFile),
      3 => fromString(this._value as VendorConfigFromString),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "VendorConfig(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is VendorConfig &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CVendorConfigImpl extends ffi.Union {
  external _CEmpty _none;
  external _CVendorConfigFromAsset _fromAsset;
  external _CVendorConfigFromFile _fromFile;
  external _CVendorConfigFromString _fromString;
}

final class _CVendorConfig extends ffi.Struct {
  external _CVendorConfigImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CVendorConfigBasicFunctions on _CVendorConfig {
  void _releaseIntermediate() {
    _CVendorConfig_release(this);
  }
}
	
// MARK: - VendorConfig <-> CVendorConfig

extension _CVendorConfigToDart on _CVendorConfig {
  VendorConfig _toDart() {
    return switch (this._index) {
      0 => VendorConfig.none(),
      1 => VendorConfig.fromAsset(this._impl._fromAsset._toDart()),
      2 => VendorConfig.fromFile(this._impl._fromFile._toDart()),
      3 => VendorConfig.fromString(this._impl._fromString._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CVendorConfig on VendorConfig {
  _CVendorConfig _copyFromDartTo_CVendorConfig() {
    var res = _CVendorConfigMakeDefault();
    this.match<void>(
      none: () {
        res._index = 0;
      },
      fromAsset: (VendorConfigFromAsset value) {
        res._impl._fromAsset = value._copyFromDartTo_CVendorConfigFromAsset();
        res._index = 1;
      },
      fromFile: (VendorConfigFromFile value) {
        res._impl._fromFile = value._copyFromDartTo_CVendorConfigFromFile();
        res._index = 2;
      },
      fromString: (VendorConfigFromString value) {
        res._impl._fromString = value._copyFromDartTo_CVendorConfigFromString();
        res._index = 3;
      },
    );
    return res;
  }
}

// MARK: - DesiredAccuracy

/** Ожидаемая точность определения местоположения. */
enum DesiredAccuracy {
  /**
   Низкая точность определения геопозиции.
   Наиболее подходящий для определения текущего города/района режим.
   Этот режим отличается низким энергопотреблением.
   В данном режиме устройство может как полагаться исключительно на сети (Wi-Fi, 3GPP, IP),
   так и использовать GNSS-приемник в режиме пониженного энергопотребления
   (с кешированием геопозиции на длительное время).
  */
  low(0),
  /**
   Точность определения геопозиции, предоставляемая стандартным GNSS-приёмником.
   Наиболее подходящий для отображения текущего местоположения на карте режим.
   Если на устройстве установлен GNSS-приемник и спутники находятся в зоне видимости, то для
   определения местоположения используются данные со спутников. В противном случае
   используются альтернативные источники геопозиции.
  */
  medium(1),
  /**
   Точность определения геопозиции, предоставляемая стандартным GNSS-приёмником и, возможно,
   улучшенная дополнительными средствами.
   Наиболее подходящий для ведения по маршруту режим.
   Аналогичен режиму Medium, но приемник GNSS может быть переведен в режим повышенной точности либо
   для уточнения геопозиции могут использоваться дополнительные датчики.
   Может потреблять много энергии (устройство в таком режиме, как правило, подключено к источнику питания).
  */
  high(2),
  ;

  const DesiredAccuracy(this.rawValue);
  final int rawValue;

  static DesiredAccuracy getByValue(int value) {
    return DesiredAccuracy.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CDesiredAccuracy extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CDesiredAccuracyBasicFunctions on _CDesiredAccuracy {
  void _releaseIntermediate() {
  }
}

extension _CDesiredAccuracyToDart on _CDesiredAccuracy {
  DesiredAccuracy _toDart() {
    return DesiredAccuracy.getByValue(this.rawValue);
  }
}

extension _DartTo_CDesiredAccuracy on DesiredAccuracy {
  _CDesiredAccuracy _copyFromDartTo_CDesiredAccuracy() {
    return _CDesiredAccuracyMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - LocationProvider

/**
 Интерфейс источника геопозиции, который реализуется пользователем на платформе.

 - Note: Все методы данного интерфейса должны вызываться из одного потока.
*/
abstract class LocationProvider {
  Location? lastLocation();
  void setNotifiers(
    LocationNotifier? locationNotifier,
    LocationAvailableNotifier? availableNotifier
  );
  void setDesiredAccuracy(
    DesiredAccuracy desiredAccuracy
  );
}

class _LocationProvider {
  final LocationProvider object;
  int refCounter = 1;

  _LocationProvider(this.object);
}

final class _CLocationProvider extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CLocation)>>)>> _lastLocation;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptional_CLocationNotifier, _COptional_CLocationAvailableNotifier)>> _setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifier;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CDesiredAccuracy)>> _setDesiredAccuracy_CDesiredAccuracy;
}

extension _CLocationProviderBasicFunctions on _CLocationProvider {
  void _releaseIntermediate() {
    _CLocationProvider_release(this);
  }
}

int _CLocationProviderInstanceCounter = 1;
final _CLocationProviderInstanceMap = <int, _LocationProvider>{};

extension _CLocationProviderToDart on _CLocationProvider {
  LocationProvider _toDart() {
    late LocationProvider? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CLocationProviderInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CLocationProviderCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CLocationProvider");
    }
    return result;
  }
}

extension _DartTo_CLocationProvider on LocationProvider {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CLocationProviderInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CLocationProviderInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CLocationProviderInstanceMap.remove(platformValue.address);
  }

  _CLocationProvider _copyFromDartTo_CLocationProvider() {
    var res = _CLocationProviderMakeDefault();
    if (this is _LocationProviderCpp) {
      final cppValue = this as _LocationProviderCpp;
      res._cppValue = cppValue._copyFromDartTo_CLocationProviderCpp()._impl;
      return res;
    }
    final instanceId = _CLocationProviderInstanceCounter;
    _CLocationProviderInstanceCounter += 1;
    _CLocationProviderInstanceMap[instanceId] = _LocationProvider(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final lastLocationFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CLocation)>>)>.listener(lastLocationFunction);
    res._lastLocation = lastLocationFunctionCallable.nativeFunction;
    final setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifierFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptional_CLocationNotifier, _COptional_CLocationAvailableNotifier)>.listener(setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifierFunction);
    res._setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifier = setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifierFunctionCallable.nativeFunction;
    final setDesiredAccuracy_CDesiredAccuracyFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CDesiredAccuracy)>.listener(setDesiredAccuracy_CDesiredAccuracyFunction);
    res._setDesiredAccuracy_CDesiredAccuracy = setDesiredAccuracy_CDesiredAccuracyFunctionCallable.nativeFunction;
    return res;
  }

  static void lastLocationFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CLocation)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CLocationProvider");
    }
    final platformObject = _CLocationProviderInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CLocationProvider");
    }

    final res = platformObject.object.lastLocation();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _COptional_CLocation)>();
    callbackFunction(context, res._copyFromDartTo_COptional_CLocation());
  }

  static void setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifierFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _COptional_CLocationNotifier locationNotifier, _COptional_CLocationAvailableNotifier availableNotifier) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CLocationProvider");
    }
    final platformObject = _CLocationProviderInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CLocationProvider");
    }

    final locationNotifierDart = locationNotifier._toDart();
    final availableNotifierDart = availableNotifier._toDart();
    platformObject.object.setNotifiers(locationNotifierDart, availableNotifierDart);
    locationNotifier._releaseIntermediate();
    availableNotifier._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }

  static void setDesiredAccuracy_CDesiredAccuracyFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _CDesiredAccuracy desiredAccuracy) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CLocationProvider");
    }
    final platformObject = _CLocationProviderInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CLocationProvider");
    }

    final desiredAccuracyDart = desiredAccuracy._toDart();
    platformObject.object.setDesiredAccuracy(desiredAccuracyDart);
    desiredAccuracy._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }


}

// MARK: - LocationProvider? <-> _COptional_CLocationProvider

final class _COptional_CLocationProvider extends ffi.Struct {
  
  external _CLocationProvider value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocationProviderBasicFunctions on _COptional_CLocationProvider {
  void _releaseIntermediate() {
    _COptional_CLocationProvider_release(this);
  }
}

extension _COptional_CLocationProviderToDart on _COptional_CLocationProvider {
  LocationProvider? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocationProvider on LocationProvider? {
  _COptional_CLocationProvider _copyFromDartTo_COptional_CLocationProvider() {
    final cOptional = _COptional_CLocationProviderMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocationProvider();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - _LocationProviderCpp

/**
 Интерфейс источника геопозиции, который реализуется пользователем на платформе.

 - Note: Все методы данного интерфейса должны вызываться из одного потока.
*/
class _LocationProviderCpp extends LocationProvider implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CLocationProviderCpp_releasePtr);

  _LocationProviderCpp._raw(this._self);
  factory _LocationProviderCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _LocationProviderCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _LocationProviderCpp &&
    other.runtimeType == runtimeType &&
    _CLocationProviderCpp_cg_objectIdentifier(this._self) == _CLocationProviderCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLocationProviderCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _LocationProviderCpp: Methods

  /**
   Наилучшая известная на текущий момент геопозиция.
   Если известная на текущий момент геопозиция отсутствует или не предоставляется API платформы - метод вернет
   null.
  
   - Note: Возвращаемая данным методом геопозиция может быть недостоверной (см. set_callbacks()).
   - Note: Этот метод должен запросить у системы наилучшую известную на текущий момент геопозицию
   и вернуть её даже если она является устаревшей и/или не соответствует требуемой точности.
   - Note: Если API платформы не предоставляет аналогичный по функциональности метод,
   то данный метод всегда должен возвращать null.
  */
  Location? lastLocation()  {
    _COptional_CLocation res = _CLocationProviderCpp_lastLocation(_CLocationProviderCppMakeDefault().._impl=_self);
    return res._toDart();
  }

  /**
   Устанавливает интерфейсы для оповещения об обновлении текущей гепозиции и изменении доступности источника
   геопозиции.
  
   - Note: Повторный вызов данного метода перезаписывает предыдущие интерфейсы.
   - Note: Если оба параметра равны null, то слежение за обновлением геопозиции нужно отключить.
   - Parameter locationNotifier: Интерфейс для оповещения об обновлении текущей гепозиции.
   - Note: Если провайдер доступен (был вызван available_callback со значением true),
   то метод LocationNotifier.send всегда возвращает достоверную геопозицию.
   Достоверная геопозиция - это геопозиция, в которой все поля имеют актуальное значение на момент ее
   отправки в этот канал (т.е. если accuracy геопозиции >= половине длины экватора Земли,
   то геопозиция является достоверной для любых от указанных в ней корректных координат).
   - Note: Если location.coordinates.accuracy
   <
   = 0, то позиция считается недостоверной даже если available == true.
   - Parameter availableNotifier: Интерфейс для оповещения об изменении доступности источника геопозиции.
   - Note: Если вызван метод AvailableNotifier.send true, то все последующие вызовы
   location_callback будут содержать достоверную (актуальную) геопозицию.
   - Note: Даже если слежение за изменением геопозиции недоступно, LocationProvider может присылать новую геопозицию,
   но она будет считаться недостоверной.
  */
  void setNotifiers(
    LocationNotifier? locationNotifier,
    LocationAvailableNotifier? availableNotifier
  )  {
    var _a1 = locationNotifier._copyFromDartTo_COptional_CLocationNotifier();
    var _a2 = availableNotifier._copyFromDartTo_COptional_CLocationAvailableNotifier();
    void res = _CLocationProviderCpp_setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifier(_CLocationProviderCppMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Задает желаемую точность определения местоположения.
  
   - Note: Если устройство не может вернуть местоположение с желаемой точностью,
   то оно может вернуть местоположение с меньшей точностью.
   - Note: Если API платформы не предоставляет аналогичный по функциональности метод,
   то данный метод должен иметь пустую реализацию.
  */
  void setDesiredAccuracy(
    DesiredAccuracy desiredAccuracy
  )  {
    var _a1 = desiredAccuracy._copyFromDartTo_CDesiredAccuracy();
    void res = _CLocationProviderCpp_setDesiredAccuracy_CDesiredAccuracy(_CLocationProviderCppMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - _LocationProviderCpp <-> CLocationProviderCpp

final class _CLocationProviderCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLocationProviderCppBasicFunctions on _CLocationProviderCpp {
  void _releaseIntermediate() {
    _CLocationProviderCpp_release(_impl);
  }

  _CLocationProviderCpp _retain() {
    return _CLocationProviderCpp_retain(_impl);
  }
}

extension _CLocationProviderCppToDart on _CLocationProviderCpp {
  _LocationProviderCpp _toDart() {
    return _LocationProviderCpp._create(_retain()._impl);
  }
}


extension _DartToCLocationProviderCpp on _LocationProviderCpp {
  _CLocationProviderCpp _copyFromDartTo_CLocationProviderCpp() {
    return (_CLocationProviderCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Latitude

/** Географическая широта. */
class Latitude {
  final double value;

  const Latitude([this.value = 0]);

  Latitude copyWith({
    double? value
  }) {
    return Latitude(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Latitude &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CLatitude extends ffi.Struct {
  @ffi.Double()
  external double value;

}
// MARK: - Latitude <-> _CLatitude

extension _CLatitudeToDart on _CLatitude {
  Latitude _toDart() {
    return Latitude(
      this.value
    );
  }
}

extension _DartTo_CLatitude on Latitude {
  _CLatitude _copyFromDartTo_CLatitude() {
    final res = _CLatitudeMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CLatitudeRelease on _CLatitude {
  void _releaseIntermediate() {
  }
}

// MARK: - Longitude

/** Географическая долгота. */
class Longitude {
  final double value;

  const Longitude([this.value = 0]);

  Longitude copyWith({
    double? value
  }) {
    return Longitude(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Longitude &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CLongitude extends ffi.Struct {
  @ffi.Double()
  external double value;

}
// MARK: - Longitude <-> _CLongitude

extension _CLongitudeToDart on _CLongitude {
  Longitude _toDart() {
    return Longitude(
      this.value
    );
  }
}

extension _DartTo_CLongitude on Longitude {
  _CLongitude _copyFromDartTo_CLongitude() {
    final res = _CLongitudeMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CLongitudeRelease on _CLongitude {
  void _releaseIntermediate() {
  }
}

// MARK: - GeoPoint

/**
 Точка в сферической системе координат, которая совместно с геодезической системой координат (например, WGS84)
 указывает на точку на поверхности Земли.
 Данная структура не привязана к конкретной геодезической системе координат.
 Но данный модуль содержит свободные функции, которые оперируют данной структурой уже
 в конкретной в системе координат (в какой именно см. в документации к функциям).
*/
class GeoPoint {
  final Latitude latitude;
  final Longitude longitude;

  const GeoPoint({
    required this.latitude,
    required this.longitude
  });

  GeoPoint copyWith({
    Latitude? latitude,
    Longitude? longitude
  }) {
    return GeoPoint(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeoPoint &&
    other.runtimeType == runtimeType &&
    other.latitude == latitude &&
    other.longitude == longitude;

  @override
  int get hashCode {
    return Object.hash(latitude, longitude);
  }

}
final class _CGeoPoint extends ffi.Struct {
  external _CLatitude latitude;

  external _CLongitude longitude;

}
// MARK: - GeoPoint <-> _CGeoPoint

extension _CGeoPointToDart on _CGeoPoint {
  GeoPoint _toDart() {
    return GeoPoint(
      latitude: this.latitude._toDart(),
      longitude: this.longitude._toDart()
    );
  }
}

extension _DartTo_CGeoPoint on GeoPoint {
  _CGeoPoint _copyFromDartTo_CGeoPoint() {
    final res = _CGeoPointMakeDefault();
    res.latitude = this.latitude._copyFromDartTo_CLatitude();
    res.longitude = this.longitude._copyFromDartTo_CLongitude();
    return res;
  }
}
extension _CGeoPointRelease on _CGeoPoint {
  void _releaseIntermediate() {
  }
}

// MARK: - LocationCoordinates

class LocationCoordinates {
  final GeoPoint value;
  final double accuracy;

  const LocationCoordinates({
    required this.value,
    required this.accuracy
  });

  LocationCoordinates copyWith({
    GeoPoint? value,
    double? accuracy
  }) {
    return LocationCoordinates(
      value: value ?? this.value,
      accuracy: accuracy ?? this.accuracy
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocationCoordinates &&
    other.runtimeType == runtimeType &&
    other.value == value &&
    other.accuracy == accuracy;

  @override
  int get hashCode {
    return Object.hash(value, accuracy);
  }

}
final class _CLocationCoordinates extends ffi.Struct {
  external _CGeoPoint value;

  @ffi.Double()
  external double accuracy;

}
// MARK: - LocationCoordinates <-> _CLocationCoordinates

extension _CLocationCoordinatesToDart on _CLocationCoordinates {
  LocationCoordinates _toDart() {
    return LocationCoordinates(
      value: this.value._toDart(),
      accuracy: this.accuracy
    );
  }
}

extension _DartTo_CLocationCoordinates on LocationCoordinates {
  _CLocationCoordinates _copyFromDartTo_CLocationCoordinates() {
    final res = _CLocationCoordinatesMakeDefault();
    res.value = this.value._copyFromDartTo_CGeoPoint();
    res.accuracy = this.accuracy;
    return res;
  }
}
extension _CLocationCoordinatesRelease on _CLocationCoordinates {
  void _releaseIntermediate() {
  }
}

// MARK: - double? <-> _COptional_double

final class _COptional_double extends ffi.Struct {
  @ffi.Double()
  external double value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_doubleBasicFunctions on _COptional_double {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_doubleToDart on _COptional_double {
  double? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_double on double? {
  _COptional_double _copyFromDartTo_COptional_double() {
    final cOptional = _COptional_doubleMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - LocationFuzzyDouble

class LocationFuzzyDouble {
  final double value;
  final double? accuracy;

  const LocationFuzzyDouble({
    required this.value,
    required this.accuracy
  });

  LocationFuzzyDouble copyWith({
    double? value,
    Optional<double?>? accuracy
  }) {
    return LocationFuzzyDouble(
      value: value ?? this.value,
      accuracy: accuracy != null ? accuracy.value : this.accuracy
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocationFuzzyDouble &&
    other.runtimeType == runtimeType &&
    other.value == value &&
    other.accuracy == accuracy;

  @override
  int get hashCode {
    return Object.hash(value, accuracy);
  }

}
final class _CLocationFuzzyDouble extends ffi.Struct {
  @ffi.Double()
  external double value;

  external _COptional_double accuracy;

}
// MARK: - LocationFuzzyDouble <-> _CLocationFuzzyDouble

extension _CLocationFuzzyDoubleToDart on _CLocationFuzzyDouble {
  LocationFuzzyDouble _toDart() {
    return LocationFuzzyDouble(
      value: this.value,
      accuracy: this.accuracy._toDart()
    );
  }
}

extension _DartTo_CLocationFuzzyDouble on LocationFuzzyDouble {
  _CLocationFuzzyDouble _copyFromDartTo_CLocationFuzzyDouble() {
    final res = _CLocationFuzzyDoubleMakeDefault();
    res.value = this.value;
    res.accuracy = this.accuracy._copyFromDartTo_COptional_double();
    return res;
  }
}
extension _CLocationFuzzyDoubleRelease on _CLocationFuzzyDouble {
  void _releaseIntermediate() {
  }
}

// MARK: - LocationFuzzyDouble? <-> _COptional_CLocationFuzzyDouble

final class _COptional_CLocationFuzzyDouble extends ffi.Struct {
  
  external _CLocationFuzzyDouble value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocationFuzzyDoubleBasicFunctions on _COptional_CLocationFuzzyDouble {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CLocationFuzzyDoubleToDart on _COptional_CLocationFuzzyDouble {
  LocationFuzzyDouble? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocationFuzzyDouble on LocationFuzzyDouble? {
  _COptional_CLocationFuzzyDouble _copyFromDartTo_COptional_CLocationFuzzyDouble() {
    final cOptional = _COptional_CLocationFuzzyDoubleMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocationFuzzyDouble();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Bearing

/**
 Угол между направлением на один объект и на другой объект, либо между направлением на объект и север.
 Угол отсчитывается по часовой стрелке. Диапазон значений [0°, 360°].
*/
class Bearing {
  final double value;

  const Bearing([this.value = 0]);

  Bearing copyWith({
    double? value
  }) {
    return Bearing(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Bearing &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CBearing extends ffi.Struct {
  @ffi.Double()
  external double value;

}
// MARK: - Bearing <-> _CBearing

extension _CBearingToDart on _CBearing {
  Bearing _toDart() {
    return Bearing(
      this.value
    );
  }
}

extension _DartTo_CBearing on Bearing {
  _CBearing _copyFromDartTo_CBearing() {
    final res = _CBearingMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CBearingRelease on _CBearing {
  void _releaseIntermediate() {
  }
}

// MARK: - Bearing? <-> _COptional_CBearing

final class _COptional_CBearing extends ffi.Struct {
  
  external _CBearing value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CBearingBasicFunctions on _COptional_CBearing {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CBearingToDart on _COptional_CBearing {
  Bearing? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CBearing on Bearing? {
  _COptional_CBearing _copyFromDartTo_COptional_CBearing() {
    final cOptional = _COptional_CBearingMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CBearing();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - LocationCourse

class LocationCourse {
  final Bearing value;
  final Bearing? accuracy;

  const LocationCourse({
    required this.value,
    required this.accuracy
  });

  LocationCourse copyWith({
    Bearing? value,
    Optional<Bearing?>? accuracy
  }) {
    return LocationCourse(
      value: value ?? this.value,
      accuracy: accuracy != null ? accuracy.value : this.accuracy
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocationCourse &&
    other.runtimeType == runtimeType &&
    other.value == value &&
    other.accuracy == accuracy;

  @override
  int get hashCode {
    return Object.hash(value, accuracy);
  }

}
final class _CLocationCourse extends ffi.Struct {
  external _CBearing value;

  external _COptional_CBearing accuracy;

}
// MARK: - LocationCourse <-> _CLocationCourse

extension _CLocationCourseToDart on _CLocationCourse {
  LocationCourse _toDart() {
    return LocationCourse(
      value: this.value._toDart(),
      accuracy: this.accuracy._toDart()
    );
  }
}

extension _DartTo_CLocationCourse on LocationCourse {
  _CLocationCourse _copyFromDartTo_CLocationCourse() {
    final res = _CLocationCourseMakeDefault();
    res.value = this.value._copyFromDartTo_CBearing();
    res.accuracy = this.accuracy._copyFromDartTo_COptional_CBearing();
    return res;
  }
}
extension _CLocationCourseRelease on _CLocationCourse {
  void _releaseIntermediate() {
  }
}

// MARK: - LocationCourse? <-> _COptional_CLocationCourse

final class _COptional_CLocationCourse extends ffi.Struct {
  
  external _CLocationCourse value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocationCourseBasicFunctions on _COptional_CLocationCourse {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CLocationCourseToDart on _COptional_CLocationCourse {
  LocationCourse? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocationCourse on LocationCourse? {
  _COptional_CLocationCourse _copyFromDartTo_COptional_CLocationCourse() {
    final cOptional = _COptional_CLocationCourseMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocationCourse();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Location

/** Геопозиция. */
class Location {
  /**
   coordinates::value - координаты геопозиции в системе координат WGS 84.
   coordinates::accuracy - горизонтальная точность определения координат геопозиции (DRMS), м.
   https://en.wikipedia.org/wiki/Circular_error_probable
   Область значений: >= 0.
  */
  final LocationCoordinates coordinates;
  /**
   altitude::value - высота над опорным эллипсоидом WGS 84, м.
   altitude::accuracy - стандартное отклонение ошибки измерения высоты, м.
   null означает, что платформа не предоставляет данное поле.
   https://en.wikipedia.org/wiki/Standard_deviation
   Область значений: (null, > 0).
  */
  final LocationFuzzyDouble? altitude;
  /**
   course::value - путевой угол (направление движения вдоль поверхности Земли).
   Угол измеряется относительно географического севера).
   course::accuracy - стандартное отклонение ошибки измерения путевого угла.
   null означает, что платформа не предоставляет данное поле.
   https://en.wikipedia.org/wiki/Standard_deviation
   Область значений: (null, > 0).
  */
  final LocationCourse? course;
  /**
   ground_speed - скорость движения вдоль поверхности Земли, м/с.
   Область значений: >= 0.
   ground_speed::accuracy - среднеквадратичное отклонение ошибки измерения скорости, м/с.
   null означает, что платформа не предоставляет данное поле.
   https://en.wikipedia.org/wiki/Standard_deviation
   Область значений: (null, > 0).
  */
  final LocationFuzzyDouble? groundSpeed;
  /**
   Временная точка, в которой была определена геопозиция.
   Эта точка не привязана ни к какой конкретной дате и используется исключительно для того,
   чтобы вычислить время между двумя измерениями геопозиции,
   полученными от одного источника геопозиции в одной сессии.
   Это поле должно монотонно возрастать (даже когда система находится в спящем режиме).
  */
  final Duration timestamp;

  const Location({
    required this.coordinates,
    required this.altitude,
    required this.course,
    required this.groundSpeed,
    required this.timestamp
  });

  Location copyWith({
    LocationCoordinates? coordinates,
    Optional<LocationFuzzyDouble?>? altitude,
    Optional<LocationCourse?>? course,
    Optional<LocationFuzzyDouble?>? groundSpeed,
    Duration? timestamp
  }) {
    return Location(
      coordinates: coordinates ?? this.coordinates,
      altitude: altitude != null ? altitude.value : this.altitude,
      course: course != null ? course.value : this.course,
      groundSpeed: groundSpeed != null ? groundSpeed.value : this.groundSpeed,
      timestamp: timestamp ?? this.timestamp
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Location &&
    other.runtimeType == runtimeType &&
    other.coordinates == coordinates &&
    other.altitude == altitude &&
    other.course == course &&
    other.groundSpeed == groundSpeed &&
    other.timestamp == timestamp;

  @override
  int get hashCode {
    return Object.hash(coordinates, altitude, course, groundSpeed, timestamp);
  }

}
final class _CLocation extends ffi.Struct {
  external _CLocationCoordinates coordinates;

  external _COptional_CLocationFuzzyDouble altitude;

  external _COptional_CLocationCourse course;

  external _COptional_CLocationFuzzyDouble groundSpeed;

  external _CTimeInterval timestamp;

}
// MARK: - Location <-> _CLocation

extension _CLocationToDart on _CLocation {
  Location _toDart() {
    return Location(
      coordinates: this.coordinates._toDart(),
      altitude: this.altitude._toDart(),
      course: this.course._toDart(),
      groundSpeed: this.groundSpeed._toDart(),
      timestamp: this.timestamp._toDart()
    );
  }
}

extension _DartTo_CLocation on Location {
  _CLocation _copyFromDartTo_CLocation() {
    final res = _CLocationMakeDefault();
    res.coordinates = this.coordinates._copyFromDartTo_CLocationCoordinates();
    res.altitude = this.altitude._copyFromDartTo_COptional_CLocationFuzzyDouble();
    res.course = this.course._copyFromDartTo_COptional_CLocationCourse();
    res.groundSpeed = this.groundSpeed._copyFromDartTo_COptional_CLocationFuzzyDouble();
    res.timestamp = this.timestamp._copyFromDartTo_CTimeInterval();
    return res;
  }
}
extension _CLocationRelease on _CLocation {
  void _releaseIntermediate() {
  }
}

// MARK: - Location? <-> _COptional_CLocation

final class _COptional_CLocation extends ffi.Struct {
  
  external _CLocation value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocationBasicFunctions on _COptional_CLocation {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CLocationToDart on _COptional_CLocation {
  Location? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocation on Location? {
  _COptional_CLocation _copyFromDartTo_COptional_CLocation() {
    final cOptional = _COptional_CLocationMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocation();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - LocationNotifier

/** Интерфейс объекта, который сообщает об обновлении геопозиции. */
class LocationNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CLocationNotifier_releasePtr);

  LocationNotifier._raw(this._self);
  factory LocationNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = LocationNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocationNotifier &&
    other.runtimeType == runtimeType &&
    _CLocationNotifier_cg_objectIdentifier(this._self) == _CLocationNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLocationNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: LocationNotifier: Methods

  /** Необходимо вызывать, чтобы сообщить об обновлении геопозиции. */
  void send(
    List<Location> locations
  )  {
    var _a1 = locations._copyFromDartTo_CArray_CLocation();
    void res = _CLocationNotifier_send_CArray_CLocation(_CLocationNotifierMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - LocationNotifier <-> CLocationNotifier

final class _CLocationNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLocationNotifierBasicFunctions on _CLocationNotifier {
  void _releaseIntermediate() {
    _CLocationNotifier_release(_impl);
  }

  _CLocationNotifier _retain() {
    return _CLocationNotifier_retain(_impl);
  }
}

extension _CLocationNotifierToDart on _CLocationNotifier {
  LocationNotifier _toDart() {
    return LocationNotifier._create(_retain()._impl);
  }
}


extension _DartToCLocationNotifier on LocationNotifier {
  _CLocationNotifier _copyFromDartTo_CLocationNotifier() {
    return (_CLocationNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - LocationNotifier? <-> _COptional_CLocationNotifier

final class _COptional_CLocationNotifier extends ffi.Struct {
  
  external _CLocationNotifier value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocationNotifierBasicFunctions on _COptional_CLocationNotifier {
  void _releaseIntermediate() {
    _COptional_CLocationNotifier_release(this);
  }
}

extension _COptional_CLocationNotifierToDart on _COptional_CLocationNotifier {
  LocationNotifier? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocationNotifier on LocationNotifier? {
  _COptional_CLocationNotifier _copyFromDartTo_COptional_CLocationNotifier() {
    final cOptional = _COptional_CLocationNotifierMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocationNotifier();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<Location> <-> _CArray_CLocation

final class _CArray_CLocation extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CLocationToDart on _CArray_CLocation {
  List<Location> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CLocation on List<Location> {
  _CArray_CLocation _copyFromDartTo_CArray_CLocation() {
    final cArray = _CArray_CLocationmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CLocation();
        _CArray_CLocationaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CLocationBasicFunctions on _CArray_CLocation {
  void _releaseIntermediate() {
    _CArray_CLocation_release(this);
  }

  static final _listToFill = <Location>[];

  static void _iterate(_CLocation item) {
    _listToFill.add(item._toDart());
  }

  List<Location> _fillFromC() {
    _forEach_CArray_CLocation(this, ffi.Pointer.fromFunction<ffi.Void Function(_CLocation)>(_iterate));
    final result = List<Location>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - LocationAvailableNotifier

/** Интерфейс объекта, который сообщает об изменении доступности источника геопозиции. */
class LocationAvailableNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CLocationAvailableNotifier_releasePtr);

  LocationAvailableNotifier._raw(this._self);
  factory LocationAvailableNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = LocationAvailableNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocationAvailableNotifier &&
    other.runtimeType == runtimeType &&
    _CLocationAvailableNotifier_cg_objectIdentifier(this._self) == _CLocationAvailableNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLocationAvailableNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: LocationAvailableNotifier: Methods

  /** Необходимо вызывать, чтобы сообщить об изменении. */
  void send(
    bool available
  )  {
    void res = _CLocationAvailableNotifier_send_bool(_CLocationAvailableNotifierMakeDefault().._impl=_self, available);
    return res;
  }

}

// MARK: - LocationAvailableNotifier <-> CLocationAvailableNotifier

final class _CLocationAvailableNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLocationAvailableNotifierBasicFunctions on _CLocationAvailableNotifier {
  void _releaseIntermediate() {
    _CLocationAvailableNotifier_release(_impl);
  }

  _CLocationAvailableNotifier _retain() {
    return _CLocationAvailableNotifier_retain(_impl);
  }
}

extension _CLocationAvailableNotifierToDart on _CLocationAvailableNotifier {
  LocationAvailableNotifier _toDart() {
    return LocationAvailableNotifier._create(_retain()._impl);
  }
}


extension _DartToCLocationAvailableNotifier on LocationAvailableNotifier {
  _CLocationAvailableNotifier _copyFromDartTo_CLocationAvailableNotifier() {
    return (_CLocationAvailableNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - LocationAvailableNotifier? <-> _COptional_CLocationAvailableNotifier

final class _COptional_CLocationAvailableNotifier extends ffi.Struct {
  
  external _CLocationAvailableNotifier value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocationAvailableNotifierBasicFunctions on _COptional_CLocationAvailableNotifier {
  void _releaseIntermediate() {
    _COptional_CLocationAvailableNotifier_release(this);
  }
}

extension _COptional_CLocationAvailableNotifierToDart on _COptional_CLocationAvailableNotifier {
  LocationAvailableNotifier? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocationAvailableNotifier on LocationAvailableNotifier? {
  _COptional_CLocationAvailableNotifier _copyFromDartTo_COptional_CLocationAvailableNotifier() {
    final cOptional = _COptional_CLocationAvailableNotifierMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocationAvailableNotifier();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - HeadingProvider

/**
 Интерфейс, предоставляющий направление устройства относительно направления на север,
 который реализуется на платформе.

 - Note: Все методы данного интерфейса должны вызываться из одного потока.
*/
abstract class HeadingProvider {
  void setNotifiers(
    HeadingNotifier? headingNotifier,
    HeadingAvailableNotifier? availableNotifier
  );
}

class _HeadingProvider {
  final HeadingProvider object;
  int refCounter = 1;

  _HeadingProvider(this.object);
}

final class _CHeadingProvider extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptional_CHeadingNotifier, _COptional_CHeadingAvailableNotifier)>> _setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifier;
}

extension _CHeadingProviderBasicFunctions on _CHeadingProvider {
  void _releaseIntermediate() {
    _CHeadingProvider_release(this);
  }
}

int _CHeadingProviderInstanceCounter = 1;
final _CHeadingProviderInstanceMap = <int, _HeadingProvider>{};

extension _CHeadingProviderToDart on _CHeadingProvider {
  HeadingProvider _toDart() {
    late HeadingProvider? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CHeadingProviderInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CHeadingProviderCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CHeadingProvider");
    }
    return result;
  }
}

extension _DartTo_CHeadingProvider on HeadingProvider {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CHeadingProviderInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CHeadingProviderInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CHeadingProviderInstanceMap.remove(platformValue.address);
  }

  _CHeadingProvider _copyFromDartTo_CHeadingProvider() {
    var res = _CHeadingProviderMakeDefault();
    if (this is _HeadingProviderCpp) {
      final cppValue = this as _HeadingProviderCpp;
      res._cppValue = cppValue._copyFromDartTo_CHeadingProviderCpp()._impl;
      return res;
    }
    final instanceId = _CHeadingProviderInstanceCounter;
    _CHeadingProviderInstanceCounter += 1;
    _CHeadingProviderInstanceMap[instanceId] = _HeadingProvider(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifierFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptional_CHeadingNotifier, _COptional_CHeadingAvailableNotifier)>.listener(setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifierFunction);
    res._setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifier = setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifierFunctionCallable.nativeFunction;
    return res;
  }

  static void setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifierFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _COptional_CHeadingNotifier headingNotifier, _COptional_CHeadingAvailableNotifier availableNotifier) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CHeadingProvider");
    }
    final platformObject = _CHeadingProviderInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CHeadingProvider");
    }

    final headingNotifierDart = headingNotifier._toDart();
    final availableNotifierDart = availableNotifier._toDart();
    platformObject.object.setNotifiers(headingNotifierDart, availableNotifierDart);
    headingNotifier._releaseIntermediate();
    availableNotifier._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }


}

// MARK: - HeadingProvider? <-> _COptional_CHeadingProvider

final class _COptional_CHeadingProvider extends ffi.Struct {
  
  external _CHeadingProvider value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CHeadingProviderBasicFunctions on _COptional_CHeadingProvider {
  void _releaseIntermediate() {
    _COptional_CHeadingProvider_release(this);
  }
}

extension _COptional_CHeadingProviderToDart on _COptional_CHeadingProvider {
  HeadingProvider? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CHeadingProvider on HeadingProvider? {
  _COptional_CHeadingProvider _copyFromDartTo_COptional_CHeadingProvider() {
    final cOptional = _COptional_CHeadingProviderMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CHeadingProvider();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - _HeadingProviderCpp

/**
 Интерфейс, предоставляющий направление устройства относительно направления на север,
 который реализуется на платформе.

 - Note: Все методы данного интерфейса должны вызываться из одного потока.
*/
class _HeadingProviderCpp extends HeadingProvider implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CHeadingProviderCpp_releasePtr);

  _HeadingProviderCpp._raw(this._self);
  factory _HeadingProviderCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _HeadingProviderCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _HeadingProviderCpp &&
    other.runtimeType == runtimeType &&
    _CHeadingProviderCpp_cg_objectIdentifier(this._self) == _CHeadingProviderCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CHeadingProviderCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _HeadingProviderCpp: Methods

  /**
   Устанавливает интерфейсы для оповещения об обновлении текущего направления и изменении доступности источника
   направления.
  
   - Note: Повторный вызов данного метода перезаписывает предыдущие функции обратного вызова.
   - Note: Если оба параметра равны null, то слежение за обновлением направления нужно отключить.
   - Parameter headingNotifier: Интерфейс для оповещения об обновлении текущего направления.
   - Parameter availableNotifier: Интерфейс для оповещения об изменении доступности источника направления.
   - Note: Даже если слежение за изменением направления недоступно, provider может присылать новое направление,
   но оно будет считаться недостоверным.
  */
  void setNotifiers(
    HeadingNotifier? headingNotifier,
    HeadingAvailableNotifier? availableNotifier
  )  {
    var _a1 = headingNotifier._copyFromDartTo_COptional_CHeadingNotifier();
    var _a2 = availableNotifier._copyFromDartTo_COptional_CHeadingAvailableNotifier();
    void res = _CHeadingProviderCpp_setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifier(_CHeadingProviderCppMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - _HeadingProviderCpp <-> CHeadingProviderCpp

final class _CHeadingProviderCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CHeadingProviderCppBasicFunctions on _CHeadingProviderCpp {
  void _releaseIntermediate() {
    _CHeadingProviderCpp_release(_impl);
  }

  _CHeadingProviderCpp _retain() {
    return _CHeadingProviderCpp_retain(_impl);
  }
}

extension _CHeadingProviderCppToDart on _CHeadingProviderCpp {
  _HeadingProviderCpp _toDart() {
    return _HeadingProviderCpp._create(_retain()._impl);
  }
}


extension _DartToCHeadingProviderCpp on _HeadingProviderCpp {
  _CHeadingProviderCpp _copyFromDartTo_CHeadingProviderCpp() {
    return (_CHeadingProviderCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - HeadingNotifier

/** Интерфейс объекта на обновление текущего направления. */
class HeadingNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CHeadingNotifier_releasePtr);

  HeadingNotifier._raw(this._self);
  factory HeadingNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = HeadingNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is HeadingNotifier &&
    other.runtimeType == runtimeType &&
    _CHeadingNotifier_cg_objectIdentifier(this._self) == _CHeadingNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CHeadingNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: HeadingNotifier: Methods

  /** Необходимо вызывать, чтобы сообщить об обновлении направления. */
  void send(
    PlatformHeading platformHeading
  )  {
    var _a1 = platformHeading._copyFromDartTo_CPlatformHeading();
    void res = _CHeadingNotifier_send_CPlatformHeading(_CHeadingNotifierMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - HeadingNotifier <-> CHeadingNotifier

final class _CHeadingNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CHeadingNotifierBasicFunctions on _CHeadingNotifier {
  void _releaseIntermediate() {
    _CHeadingNotifier_release(_impl);
  }

  _CHeadingNotifier _retain() {
    return _CHeadingNotifier_retain(_impl);
  }
}

extension _CHeadingNotifierToDart on _CHeadingNotifier {
  HeadingNotifier _toDart() {
    return HeadingNotifier._create(_retain()._impl);
  }
}


extension _DartToCHeadingNotifier on HeadingNotifier {
  _CHeadingNotifier _copyFromDartTo_CHeadingNotifier() {
    return (_CHeadingNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - HeadingNotifier? <-> _COptional_CHeadingNotifier

final class _COptional_CHeadingNotifier extends ffi.Struct {
  
  external _CHeadingNotifier value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CHeadingNotifierBasicFunctions on _COptional_CHeadingNotifier {
  void _releaseIntermediate() {
    _COptional_CHeadingNotifier_release(this);
  }
}

extension _COptional_CHeadingNotifierToDart on _COptional_CHeadingNotifier {
  HeadingNotifier? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CHeadingNotifier on HeadingNotifier? {
  _COptional_CHeadingNotifier _copyFromDartTo_COptional_CHeadingNotifier() {
    final cOptional = _COptional_CHeadingNotifierMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CHeadingNotifier();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - PlatformHeading

/** Информация о направлении устройста, которую отдает платформа. */
class PlatformHeading {
  /** Направление. */
  final LocationCourse heading;
  /**
   Временная точка, в которой было определено направление.
   Эта точка не привязана ни к какой конкретной дате и используется исключительно для того,
   чтобы вычислить время между двумя измерениями направления,
   полученными от одного источника направления в одной сессии.
   Это поле должно монотонно возрастать.
  */
  final Duration timestamp;

  const PlatformHeading({
    required this.heading,
    required this.timestamp
  });

  PlatformHeading copyWith({
    LocationCourse? heading,
    Duration? timestamp
  }) {
    return PlatformHeading(
      heading: heading ?? this.heading,
      timestamp: timestamp ?? this.timestamp
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PlatformHeading &&
    other.runtimeType == runtimeType &&
    other.heading == heading &&
    other.timestamp == timestamp;

  @override
  int get hashCode {
    return Object.hash(heading, timestamp);
  }

}
final class _CPlatformHeading extends ffi.Struct {
  external _CLocationCourse heading;

  external _CTimeInterval timestamp;

}
// MARK: - PlatformHeading <-> _CPlatformHeading

extension _CPlatformHeadingToDart on _CPlatformHeading {
  PlatformHeading _toDart() {
    return PlatformHeading(
      heading: this.heading._toDart(),
      timestamp: this.timestamp._toDart()
    );
  }
}

extension _DartTo_CPlatformHeading on PlatformHeading {
  _CPlatformHeading _copyFromDartTo_CPlatformHeading() {
    final res = _CPlatformHeadingMakeDefault();
    res.heading = this.heading._copyFromDartTo_CLocationCourse();
    res.timestamp = this.timestamp._copyFromDartTo_CTimeInterval();
    return res;
  }
}
extension _CPlatformHeadingRelease on _CPlatformHeading {
  void _releaseIntermediate() {
  }
}

// MARK: - HeadingAvailableNotifier

/** Интерфейс объекта, который сообщает об изменении доступности источника направления. */
class HeadingAvailableNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CHeadingAvailableNotifier_releasePtr);

  HeadingAvailableNotifier._raw(this._self);
  factory HeadingAvailableNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = HeadingAvailableNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is HeadingAvailableNotifier &&
    other.runtimeType == runtimeType &&
    _CHeadingAvailableNotifier_cg_objectIdentifier(this._self) == _CHeadingAvailableNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CHeadingAvailableNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: HeadingAvailableNotifier: Methods

  /** Необходимо вызывать, чтобы сообщить об изменении. */
  void send(
    bool available
  )  {
    void res = _CHeadingAvailableNotifier_send_bool(_CHeadingAvailableNotifierMakeDefault().._impl=_self, available);
    return res;
  }

}

// MARK: - HeadingAvailableNotifier <-> CHeadingAvailableNotifier

final class _CHeadingAvailableNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CHeadingAvailableNotifierBasicFunctions on _CHeadingAvailableNotifier {
  void _releaseIntermediate() {
    _CHeadingAvailableNotifier_release(_impl);
  }

  _CHeadingAvailableNotifier _retain() {
    return _CHeadingAvailableNotifier_retain(_impl);
  }
}

extension _CHeadingAvailableNotifierToDart on _CHeadingAvailableNotifier {
  HeadingAvailableNotifier _toDart() {
    return HeadingAvailableNotifier._create(_retain()._impl);
  }
}


extension _DartToCHeadingAvailableNotifier on HeadingAvailableNotifier {
  _CHeadingAvailableNotifier _copyFromDartTo_CHeadingAvailableNotifier() {
    return (_CHeadingAvailableNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - HeadingAvailableNotifier? <-> _COptional_CHeadingAvailableNotifier

final class _COptional_CHeadingAvailableNotifier extends ffi.Struct {
  
  external _CHeadingAvailableNotifier value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CHeadingAvailableNotifierBasicFunctions on _COptional_CHeadingAvailableNotifier {
  void _releaseIntermediate() {
    _COptional_CHeadingAvailableNotifier_release(this);
  }
}

extension _COptional_CHeadingAvailableNotifierToDart on _COptional_CHeadingAvailableNotifier {
  HeadingAvailableNotifier? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CHeadingAvailableNotifier on HeadingAvailableNotifier? {
  _COptional_CHeadingAvailableNotifier _copyFromDartTo_COptional_CHeadingAvailableNotifier() {
    final cOptional = _COptional_CHeadingAvailableNotifierMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CHeadingAvailableNotifier();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - File

/**
 Идентификатор файла.

 Может являться не только файлом на файловой системе, но и произвольным источником данных.
*/
class File implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CFile_releasePtr);

  File._raw(this._self);
  factory File._create(ffi.Pointer<ffi.Void> self) {
    final classObject = File._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Файл в файловой системе.
  
   - Parameter path: Путь к файлу.
  */
  factory File(
    String path
  ) {
    var _a0 = path._copyFromDartTo_CString();
    _CFile res = _CFile_C_createWith_CString(_a0);
    _a0._releaseIntermediate();
    return File._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is File &&
    other.runtimeType == runtimeType &&
    _CFile_cg_objectIdentifier(this._self) == _CFile_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CFile_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CFile: Static Methods

  /**
   Файл с содержимым из заданной строки.
  
   - Parameter contents: Содержимое файла.
  */
  static File fromString(
    String contents
  )  {
    var _a0 = contents._copyFromDartTo_CString();
    _CFile res = _CFile_S_fromString_CString(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - File <-> CFile

final class _CFile extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CFileBasicFunctions on _CFile {
  void _releaseIntermediate() {
    _CFile_release(_impl);
  }

  _CFile _retain() {
    return _CFile_retain(_impl);
  }
}

extension _CFileToDart on _CFile {
  File _toDart() {
    return File._create(_retain()._impl);
  }
}


extension _DartToCFile on File {
  _CFile _copyFromDartTo_CFile() {
    return (_CFileMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GeoRect

/**
 Прямоугольная область в сферической системе координат (например, WGS84).
 Данная структура не привязана к конкретной геодезической системе координат.
*/
class GeoRect {
  /** Юго-западная точка, левая нижняя граница прямоугольника. */
  final GeoPoint southWestPoint;
  /** Северо-восточная точка, правая верхняя граница прямоугольника. */
  final GeoPoint northEastPoint;

  const GeoRect({
    required this.southWestPoint,
    required this.northEastPoint
  });

  GeoRect copyWith({
    GeoPoint? southWestPoint,
    GeoPoint? northEastPoint
  }) {
    return GeoRect(
      southWestPoint: southWestPoint ?? this.southWestPoint,
      northEastPoint: northEastPoint ?? this.northEastPoint
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeoRect &&
    other.runtimeType == runtimeType &&
    other.southWestPoint == southWestPoint &&
    other.northEastPoint == northEastPoint;

  @override
  int get hashCode {
    return Object.hash(southWestPoint, northEastPoint);
  }

}
final class _CGeoRect extends ffi.Struct {
  external _CGeoPoint southWestPoint;

  external _CGeoPoint northEastPoint;

}
// MARK: - GeoRect <-> _CGeoRect

extension _CGeoRectToDart on _CGeoRect {
  GeoRect _toDart() {
    return GeoRect(
      southWestPoint: this.southWestPoint._toDart(),
      northEastPoint: this.northEastPoint._toDart()
    );
  }
}

extension _DartTo_CGeoRect on GeoRect {
  _CGeoRect _copyFromDartTo_CGeoRect() {
    final res = _CGeoRectMakeDefault();
    res.southWestPoint = this.southWestPoint._copyFromDartTo_CGeoPoint();
    res.northEastPoint = this.northEastPoint._copyFromDartTo_CGeoPoint();
    return res;
  }
}
extension _CGeoRectRelease on _CGeoRect {
  void _releaseIntermediate() {
  }
}

// MARK: - calculateBearing

/**
 Вычисляет направление (путевой угол, т.е. угол между направлением на географический север и направлением движения,
 отсчитываемый по часовой стрелке) между двумя точками
 (решает первую часть обратной геодезической задачи https://en.wikipedia.org/wiki/Geodesy#Geodetic_problems).

 - Parameter from: ссылка на исходную точку.
 - Parameter to: ссылка на конечную точку.
 - Returns: направление в диапазоне [0, 360) градусов.
*/
@internal
Bearing calculateBearing(
  GeoPoint from,
  GeoPoint to
){
  var _a0 = from._copyFromDartTo_CGeoPoint();
  var _a1 = to._copyFromDartTo_CGeoPoint();
  _CBearing res = _CFunction_G_calculateBearing_With_CGeoPoint_CGeoPoint(_a0, _a1);
  return res._toDart();
}

// MARK: - calculateDistance

/**
 Вычисляет минимальное (по ортодромии) расстояние между двумя точками
 (решает вторую часть обратной геодезической задачи https://en.wikipedia.org/wiki/Geodesy#Geodetic_problems).

 - Parameter from: ссылка на исходную точку.
 - Parameter to: ссылка на конечную точку.
 - Returns: расстояние в метрах.
*/
@internal
double calculateDistance(
  GeoPoint from,
  GeoPoint to
){
  var _a0 = from._copyFromDartTo_CGeoPoint();
  var _a1 = to._copyFromDartTo_CGeoPoint();
  double res = _CFunction_G_calculateDistance_With_CGeoPoint_CGeoPoint(_a0, _a1);
  return res;
}

// MARK: - move

/**
 Вычисляет точку, полученную перемещением исходной точки в указанном направлении на указанное расстояние
 (решает прямую геодезическую задачу https://en.wikipedia.org/wiki/Geodesy#Geodetic_problems).

 - Parameter point: ссылка на исходную точку.
 - Parameter bearing: направление перемещения в градусах.
 - Parameter distance: расстояние перемещения в метрах.
*/
@internal
GeoPoint move(
  GeoPoint point,
  Bearing bearing,
  double distance
){
  var _a0 = point._copyFromDartTo_CGeoPoint();
  var _a1 = bearing._copyFromDartTo_CBearing();
  _CGeoPoint res = _CFunction_G_move_With_CGeoPoint_CBearing_double(_a0, _a1, distance);
  return res._toDart();
}

// MARK: - isGeoPointValid

bool isGeoPointValid(
  GeoPoint geoPoint
){
  var _a0 = geoPoint._copyFromDartTo_CGeoPoint();
  bool res = _CFunction_G_isGeoPointValid_With_CGeoPoint(_a0);
  return res;
}

// MARK: - isGeoRectValid

bool isGeoRectValid(
  GeoRect geoRect
){
  var _a0 = geoRect._copyFromDartTo_CGeoRect();
  bool res = _CFunction_G_isGeoRectValid_With_CGeoRect(_a0);
  return res;
}

// MARK: - containsPoint

bool containsPoint(
  GeoRect rect,
  GeoPoint point
){
  var _a0 = rect._copyFromDartTo_CGeoRect();
  var _a1 = point._copyFromDartTo_CGeoPoint();
  bool res = _CFunction_G_containsPoint_With_CGeoRect_CGeoPoint(_a0, _a1);
  return res;
}

// MARK: - containsRect

bool containsRect(
  GeoRect rect1,
  GeoRect rect2
){
  var _a0 = rect1._copyFromDartTo_CGeoRect();
  var _a1 = rect2._copyFromDartTo_CGeoRect();
  bool res = _CFunction_G_containsRect_With_CGeoRect_CGeoRect(_a0, _a1);
  return res;
}

// MARK: - expandPoint

GeoRect expandPoint(
  GeoRect rect,
  GeoPoint point
){
  var _a0 = rect._copyFromDartTo_CGeoRect();
  var _a1 = point._copyFromDartTo_CGeoPoint();
  _CGeoRect res = _CFunction_G_expandPoint_With_CGeoRect_CGeoPoint(_a0, _a1);
  return res._toDart();
}

// MARK: - expandRect

GeoRect expandRect(
  GeoRect rect1,
  GeoRect rect2
){
  var _a0 = rect1._copyFromDartTo_CGeoRect();
  var _a1 = rect2._copyFromDartTo_CGeoRect();
  _CGeoRect res = _CFunction_G_expandRect_With_CGeoRect_CGeoRect(_a0, _a1);
  return res._toDart();
}

// MARK: - GeoRect

extension GeoRectIsDegenerate on GeoRect {
  /**
   Проверяет прямоугольник на вырожденность.
   Если точки в прямоугольнике равны, то он вырождается в точку.
   Вырожденный прямоугольник является корректным прямоугольником. Некорректный прямоугольник не является вырожденным.
  */
  bool get isDegenerate {
    var _a0 = this._copyFromDartTo_CGeoRect();
    bool res = _CFunction_G_isDegenerate_With_CGeoRect(_a0);
    return res;
  }
}
// MARK: - GeoRect

extension GeoRectIntersects on GeoRect {
  /**
   Пересекаются ли прямоугольники, т.е. имеют общие точки.
   Прямогольники, с общими точками лишь на границе, так же считаются пересекающимися.
  */
  bool intersects(
    GeoRect rect2
  )  {
    var _a0 = this._copyFromDartTo_CGeoRect();
    var _a1 = rect2._copyFromDartTo_CGeoRect();
    bool res = _CFunction_G_intersects_With_CGeoRect_CGeoRect(_a0, _a1);
    return res;
  }

}
// MARK: - ApartmentRange

/** Диапазон квартир. */
class ApartmentRange {
  /**
   Начало диапазона/хранимое значение.
   На текущий момент возможны только числовые значения, а квартиры с суффиксами в данных пока отсутствуют.
  */
  final String start;
  /**
   Окончание диапазона. Если отсутствует, то диапазон состоит из одного значения start. Иначе это арифметическая
   прогрессия от start до end с шагом 1.
  */
  final String? end;

  const ApartmentRange({
    required this.start,
    this.end = null
  });

  ApartmentRange copyWith({
    String? start,
    Optional<String?>? end
  }) {
    return ApartmentRange(
      start: start ?? this.start,
      end: end != null ? end.value : this.end
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ApartmentRange &&
    other.runtimeType == runtimeType &&
    other.start == start &&
    other.end == end;

  @override
  int get hashCode {
    return Object.hash(start, end);
  }

}
final class _CApartmentRange extends ffi.Struct {
  external _CString start;

  external _COptional_CString end;

}
// MARK: - ApartmentRange <-> _CApartmentRange

extension _CApartmentRangeToDart on _CApartmentRange {
  ApartmentRange _toDart() {
    return ApartmentRange(
      start: this.start._toDart(),
      end: this.end._toDart()
    );
  }
}

extension _DartTo_CApartmentRange on ApartmentRange {
  _CApartmentRange _copyFromDartTo_CApartmentRange() {
    final res = _CApartmentRangeMakeDefault();
    res.start = this.start._copyFromDartTo_CString();
    res.end = this.end._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CApartmentRangeRelease on _CApartmentRange {
  void _releaseIntermediate() {
    start._releaseIntermediate();
    end._releaseIntermediate();
  }
}

// MARK: - Attribute

/**
 Дополнительный атрибут.
 Пример:
 {
 tag: "hotel_room_internet",
 name: "Бесплатный интернет в номерах"
 }
*/
class Attribute {
  /** Тег. */
  final String tag;
  /** Значение. */
  final String value;

  const Attribute({
    required this.tag,
    required this.value
  });

  Attribute copyWith({
    String? tag,
    String? value
  }) {
    return Attribute(
      tag: tag ?? this.tag,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Attribute &&
    other.runtimeType == runtimeType &&
    other.tag == tag &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(tag, value);
  }

}
final class _CAttribute extends ffi.Struct {
  external _CString tag;

  external _CString value;

}
// MARK: - Attribute <-> _CAttribute

extension _CAttributeToDart on _CAttribute {
  Attribute _toDart() {
    return Attribute(
      tag: this.tag._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CAttribute on Attribute {
  _CAttribute _copyFromDartTo_CAttribute() {
    final res = _CAttributeMakeDefault();
    res.tag = this.tag._copyFromDartTo_CString();
    res.value = this.value._copyFromDartTo_CString();
    return res;
  }
}
extension _CAttributeRelease on _CAttribute {
  void _releaseIntermediate() {
    tag._releaseIntermediate();
    value._releaseIntermediate();
  }
}

// MARK: - PurposeCode

/** Код назначения здания. */
class PurposeCode {
  final int value;

  const PurposeCode([this.value = 0]);

  PurposeCode copyWith({
    int? value
  }) {
    return PurposeCode(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PurposeCode &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CPurposeCode extends ffi.Struct {
  @ffi.Uint64()
  external int value;

}
// MARK: - PurposeCode <-> _CPurposeCode

extension _CPurposeCodeToDart on _CPurposeCode {
  PurposeCode _toDart() {
    return PurposeCode(
      this.value
    );
  }
}

extension _DartTo_CPurposeCode on PurposeCode {
  _CPurposeCode _copyFromDartTo_CPurposeCode() {
    final res = _CPurposeCodeMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CPurposeCodeRelease on _CPurposeCode {
  void _releaseIntermediate() {
  }
}

// MARK: - List<LevelInfo> <-> _CArray_CLevelInfo

final class _CArray_CLevelInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CLevelInfoToDart on _CArray_CLevelInfo {
  List<LevelInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CLevelInfo on List<LevelInfo> {
  _CArray_CLevelInfo _copyFromDartTo_CArray_CLevelInfo() {
    final cArray = _CArray_CLevelInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CLevelInfo();
        _CArray_CLevelInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CLevelInfoBasicFunctions on _CArray_CLevelInfo {
  void _releaseIntermediate() {
    _CArray_CLevelInfo_release(this);
  }

  static final _listToFill = <LevelInfo>[];

  static void _iterate(_CLevelInfo item) {
    _listToFill.add(item._toDart());
  }

  List<LevelInfo> _fillFromC() {
    _forEach_CArray_CLevelInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CLevelInfo)>(_iterate));
    final result = List<LevelInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - BuildingLevels

/** Информация об этажных планах здания. */
class BuildingLevels {
  /** Идентификатор этажного плана по умолчанию. */
  final LevelId defaultLevelId;
  /** Все этажные планы здания. */
  final List<LevelInfo> levels;

  const BuildingLevels({
    required this.defaultLevelId,
    required this.levels
  });

  BuildingLevels copyWith({
    LevelId? defaultLevelId,
    List<LevelInfo>? levels
  }) {
    return BuildingLevels(
      defaultLevelId: defaultLevelId ?? this.defaultLevelId,
      levels: levels ?? this.levels
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BuildingLevels &&
    other.runtimeType == runtimeType &&
    other.defaultLevelId == defaultLevelId &&
    other.levels == levels;

  @override
  int get hashCode {
    return Object.hash(defaultLevelId, levels);
  }

}
final class _CBuildingLevels extends ffi.Struct {
  external _CLevelId defaultLevelId;

  external _CArray_CLevelInfo levels;

}
// MARK: - BuildingLevels <-> _CBuildingLevels

extension _CBuildingLevelsToDart on _CBuildingLevels {
  BuildingLevels _toDart() {
    return BuildingLevels(
      defaultLevelId: this.defaultLevelId._toDart(),
      levels: this.levels._toDart()
    );
  }
}

extension _DartTo_CBuildingLevels on BuildingLevels {
  _CBuildingLevels _copyFromDartTo_CBuildingLevels() {
    final res = _CBuildingLevelsMakeDefault();
    res.defaultLevelId = this.defaultLevelId._copyFromDartTo_CLevelId();
    res.levels = this.levels._copyFromDartTo_CArray_CLevelInfo();
    return res;
  }
}
extension _CBuildingLevelsRelease on _CBuildingLevels {
  void _releaseIntermediate() {
    levels._releaseIntermediate();
  }
}

// MARK: - PurposeCode? <-> _COptional_CPurposeCode

final class _COptional_CPurposeCode extends ffi.Struct {
  
  external _CPurposeCode value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CPurposeCodeBasicFunctions on _COptional_CPurposeCode {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CPurposeCodeToDart on _COptional_CPurposeCode {
  PurposeCode? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CPurposeCode on PurposeCode? {
  _COptional_CPurposeCode _copyFromDartTo_COptional_CPurposeCode() {
    final cOptional = _COptional_CPurposeCodeMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CPurposeCode();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - BuildingLevels? <-> _COptional_CBuildingLevels

final class _COptional_CBuildingLevels extends ffi.Struct {
  
  external _CBuildingLevels value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CBuildingLevelsBasicFunctions on _COptional_CBuildingLevels {
  void _releaseIntermediate() {
    _COptional_CBuildingLevels_release(this);
  }
}

extension _COptional_CBuildingLevelsToDart on _COptional_CBuildingLevels {
  BuildingLevels? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CBuildingLevels on BuildingLevels? {
  _COptional_CBuildingLevels _copyFromDartTo_COptional_CBuildingLevels() {
    final cOptional = _COptional_CBuildingLevelsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CBuildingLevels();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - BuildingId? <-> _COptional_CBuildingId

final class _COptional_CBuildingId extends ffi.Struct {
  
  external _CBuildingId value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CBuildingIdBasicFunctions on _COptional_CBuildingId {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CBuildingIdToDart on _COptional_CBuildingId {
  BuildingId? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CBuildingId on BuildingId? {
  _COptional_CBuildingId _copyFromDartTo_COptional_CBuildingId() {
    final cOptional = _COptional_CBuildingIdMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CBuildingId();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - BuildingInfo

/** Информация о здании. */
class BuildingInfo {
  /** Собственное имя здания. */
  final String? buildingName;
  /** Описание назначения здания. */
  final String? purposeName;
  /** Код назначения здания. */
  final PurposeCode? purposeCode;
  /** Информация об этажных планах здания. */
  final BuildingLevels? buildingLevels;
  /** Уникальный идентификатор здания. */
  final BuildingId? buildingId;

  const BuildingInfo({
    this.buildingName = null,
    this.purposeName = null,
    this.purposeCode = null,
    this.buildingLevels = null,
    required this.buildingId
  });

  BuildingInfo copyWith({
    Optional<String?>? buildingName,
    Optional<String?>? purposeName,
    Optional<PurposeCode?>? purposeCode,
    Optional<BuildingLevels?>? buildingLevels,
    Optional<BuildingId?>? buildingId
  }) {
    return BuildingInfo(
      buildingName: buildingName != null ? buildingName.value : this.buildingName,
      purposeName: purposeName != null ? purposeName.value : this.purposeName,
      purposeCode: purposeCode != null ? purposeCode.value : this.purposeCode,
      buildingLevels: buildingLevels != null ? buildingLevels.value : this.buildingLevels,
      buildingId: buildingId != null ? buildingId.value : this.buildingId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BuildingInfo &&
    other.runtimeType == runtimeType &&
    other.buildingName == buildingName &&
    other.purposeName == purposeName &&
    other.purposeCode == purposeCode &&
    other.buildingLevels == buildingLevels &&
    other.buildingId == buildingId;

  @override
  int get hashCode {
    return Object.hash(buildingName, purposeName, purposeCode, buildingLevels, buildingId);
  }

}
final class _CBuildingInfo extends ffi.Struct {
  external _COptional_CString buildingName;

  external _COptional_CString purposeName;

  external _COptional_CPurposeCode purposeCode;

  external _COptional_CBuildingLevels buildingLevels;

  external _COptional_CBuildingId buildingId;

}
// MARK: - BuildingInfo <-> _CBuildingInfo

extension _CBuildingInfoToDart on _CBuildingInfo {
  BuildingInfo _toDart() {
    return BuildingInfo(
      buildingName: this.buildingName._toDart(),
      purposeName: this.purposeName._toDart(),
      purposeCode: this.purposeCode._toDart(),
      buildingLevels: this.buildingLevels._toDart(),
      buildingId: this.buildingId._toDart()
    );
  }
}

extension _DartTo_CBuildingInfo on BuildingInfo {
  _CBuildingInfo _copyFromDartTo_CBuildingInfo() {
    final res = _CBuildingInfoMakeDefault();
    res.buildingName = this.buildingName._copyFromDartTo_COptional_CString();
    res.purposeName = this.purposeName._copyFromDartTo_COptional_CString();
    res.purposeCode = this.purposeCode._copyFromDartTo_COptional_CPurposeCode();
    res.buildingLevels = this.buildingLevels._copyFromDartTo_COptional_CBuildingLevels();
    res.buildingId = this.buildingId._copyFromDartTo_COptional_CBuildingId();
    return res;
  }
}
extension _CBuildingInfoRelease on _CBuildingInfo {
  void _releaseIntermediate() {
    buildingName._releaseIntermediate();
    purposeName._releaseIntermediate();
    buildingLevels._releaseIntermediate();
  }
}

// MARK: - ContactInfo

/** Способ связаться с организацией. */
class ContactInfo {
  /**
   Тип контакта. Один из следующих:
   * email — электронная почта
   * website — сайт
   * phone — телефон
   * fax — факс
   * pobox — абонентский ящик
   * icq
   * jabber
   * skype
   * vkontakte
   * twitter
   * odnoklassniki
   * youtube
   * linkedin
   * googleplus
   * pinterest
   * whatsapp
   * viber
   * telegram
  */
  final String type;
  /** Значение контакта для вывода на экран. */
  final String displayText;
  /**
   Техническое значение контакта. В зависимости от типа контакта имеет следующую семантику:
   * email — адрес почты
   * website — полный url
   * phone — номер телефона в международном формате, например: "+73831234567"
   * fax — номер телефона в международном формате, например: "+73831234567"
   * pobox — адрес почтового ящика
   * icq — идентификатор пользователя
   * jabber — идентификатор пользователя
   * skype — идентификатор пользователя
   * vkontakte — полный url
   * twitter — полный url
   * odnoklassniki — полный url
   * youtube — полный url
   * linkedin — полный url
   * googleplus — полный url
   * pinterest — полный url
   * whatsapp — полный url
   * viber — полный url
   * telegram — полный url
  */
  final String value;
  /** Уточняющая информация о контакте. */
  final String? comment;

  const ContactInfo({
    required this.type,
    required this.displayText,
    required this.value,
    required this.comment
  });

  ContactInfo copyWith({
    String? type,
    String? displayText,
    String? value,
    Optional<String?>? comment
  }) {
    return ContactInfo(
      type: type ?? this.type,
      displayText: displayText ?? this.displayText,
      value: value ?? this.value,
      comment: comment != null ? comment.value : this.comment
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ContactInfo &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.displayText == displayText &&
    other.value == value &&
    other.comment == comment;

  @override
  int get hashCode {
    return Object.hash(type, displayText, value, comment);
  }

}
final class _CContactInfo extends ffi.Struct {
  external _CString type;

  external _CString displayText;

  external _CString value;

  external _COptional_CString comment;

}
// MARK: - ContactInfo <-> _CContactInfo

extension _CContactInfoToDart on _CContactInfo {
  ContactInfo _toDart() {
    return ContactInfo(
      type: this.type._toDart(),
      displayText: this.displayText._toDart(),
      value: this.value._toDart(),
      comment: this.comment._toDart()
    );
  }
}

extension _DartTo_CContactInfo on ContactInfo {
  _CContactInfo _copyFromDartTo_CContactInfo() {
    final res = _CContactInfoMakeDefault();
    res.type = this.type._copyFromDartTo_CString();
    res.displayText = this.displayText._copyFromDartTo_CString();
    res.value = this.value._copyFromDartTo_CString();
    res.comment = this.comment._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CContactInfoRelease on _CContactInfo {
  void _releaseIntermediate() {
    type._releaseIntermediate();
    displayText._releaseIntermediate();
    value._releaseIntermediate();
    comment._releaseIntermediate();
  }
}

// MARK: - IsOpenNow

/** Открыто сейчас. */
class IsOpenNow {

  const IsOpenNow();

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IsOpenNow &&
    other.runtimeType == runtimeType;

  @override
  int get hashCode {
    return 0;
  }

}
final class _CIsOpenNow extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
// MARK: - IsOpenNow <-> _CIsOpenNow

extension _CIsOpenNowToDart on _CIsOpenNow {
  IsOpenNow _toDart() {
    return IsOpenNow(
    );
  }
}

extension _DartTo_CIsOpenNow on IsOpenNow {
  _CIsOpenNow _copyFromDartTo_CIsOpenNow() {
    final res = _CIsOpenNowMakeDefault();
    return res;
  }
}
extension _CIsOpenNowRelease on _CIsOpenNow {
  void _releaseIntermediate() {
  }
}

// MARK: - WorkTimeFilter

/**
 Фильтр по времени работы объекта.
 Либо открыт сейчас, либо открыт на конкретные дата и время.
*/
final class WorkTimeFilter {
  final Object? _value;
  final int _index;

  WorkTimeFilter._raw(this._value, this._index);

  WorkTimeFilter.workTime(WeekTime value) : this._raw(value, 0);
  WorkTimeFilter.isOpenNow(IsOpenNow value) : this._raw(value, 1);

  bool get isWorkTime => this._index == 0;
  WeekTime? get asWorkTime => this.isWorkTime ? this._value as WeekTime : null;

  bool get isIsOpenNow => this._index == 1;
  IsOpenNow? get asIsOpenNow => this.isIsOpenNow ? this._value as IsOpenNow : null;

  T match<T>({
    required T Function(WeekTime value) workTime,
    required T Function(IsOpenNow value) isOpenNow,
  }) {
    return switch (this._index) {
      0 => workTime(this._value as WeekTime),
      1 => isOpenNow(this._value as IsOpenNow),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "WorkTimeFilter(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is WorkTimeFilter &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CWorkTimeFilterImpl extends ffi.Union {
  external _CWeekTime _workTime;
  external _CIsOpenNow _isOpenNow;
}

final class _CWorkTimeFilter extends ffi.Struct {
  external _CWorkTimeFilterImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CWorkTimeFilterBasicFunctions on _CWorkTimeFilter {
  void _releaseIntermediate() {
    _CWorkTimeFilter_release(this);
  }
}
	
// MARK: - WorkTimeFilter <-> CWorkTimeFilter

extension _CWorkTimeFilterToDart on _CWorkTimeFilter {
  WorkTimeFilter _toDart() {
    return switch (this._index) {
      0 => WorkTimeFilter.workTime(this._impl._workTime._toDart()),
      1 => WorkTimeFilter.isOpenNow(this._impl._isOpenNow._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CWorkTimeFilter on WorkTimeFilter {
  _CWorkTimeFilter _copyFromDartTo_CWorkTimeFilter() {
    var res = _CWorkTimeFilterMakeDefault();
    this.match<void>(
      workTime: (WeekTime value) {
        res._impl._workTime = value._copyFromDartTo_CWeekTime();
        res._index = 0;
      },
      isOpenNow: (IsOpenNow value) {
        res._impl._isOpenNow = value._copyFromDartTo_CIsOpenNow();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - bool? <-> _COptional_bool

final class _COptional_bool extends ffi.Struct {
  @ffi.Bool()
  external bool value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_boolBasicFunctions on _COptional_bool {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_boolToDart on _COptional_bool {
  bool? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_bool on bool? {
  _COptional_bool _copyFromDartTo_COptional_bool() {
    final cOptional = _COptional_boolMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - FlagFilter

/** Фильтр - флаг. */
class FlagFilter {
  /** Тэг фильтра. */
  final String tagName;
  /**
   Название фильтра для отображения.
  
   - Note: Зависит от языка выдачи. Не все названия могут быть переведены.
  */
  final String displayName;
  /** Значение флага. */
  final bool? flagValue;

  const FlagFilter({
    required this.tagName,
    required this.displayName,
    required this.flagValue
  });

  FlagFilter copyWith({
    String? tagName,
    String? displayName,
    Optional<bool?>? flagValue
  }) {
    return FlagFilter(
      tagName: tagName ?? this.tagName,
      displayName: displayName ?? this.displayName,
      flagValue: flagValue != null ? flagValue.value : this.flagValue
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FlagFilter &&
    other.runtimeType == runtimeType &&
    other.tagName == tagName &&
    other.displayName == displayName &&
    other.flagValue == flagValue;

  @override
  int get hashCode {
    return Object.hash(tagName, displayName, flagValue);
  }

}
final class _CFlagFilter extends ffi.Struct {
  external _CString tagName;

  external _CString displayName;

  external _COptional_bool flagValue;

}
// MARK: - FlagFilter <-> _CFlagFilter

extension _CFlagFilterToDart on _CFlagFilter {
  FlagFilter _toDart() {
    return FlagFilter(
      tagName: this.tagName._toDart(),
      displayName: this.displayName._toDart(),
      flagValue: this.flagValue._toDart()
    );
  }
}

extension _DartTo_CFlagFilter on FlagFilter {
  _CFlagFilter _copyFromDartTo_CFlagFilter() {
    final res = _CFlagFilterMakeDefault();
    res.tagName = this.tagName._copyFromDartTo_CString();
    res.displayName = this.displayName._copyFromDartTo_CString();
    res.flagValue = this.flagValue._copyFromDartTo_COptional_bool();
    return res;
  }
}
extension _CFlagFilterRelease on _CFlagFilter {
  void _releaseIntermediate() {
    tagName._releaseIntermediate();
    displayName._releaseIntermediate();
  }
}

// MARK: - RangeFilter

/** Фильтр диапазонов значений. */
class RangeFilter {
  /** Тэг фильтра. */
  final String tagName;
  /**
   Название фильтра для отображения.
  
   - Note: Зависит от языка выдачи. Не все названия могут быть переведены.
  */
  final String displayName;
  /** Минимальное значение диапазона. */
  final double minValue;
  /** Максимальное значение диапазона. */
  final double maxValue;

  const RangeFilter({
    required this.tagName,
    required this.displayName,
    required this.minValue,
    required this.maxValue
  });

  RangeFilter copyWith({
    String? tagName,
    String? displayName,
    double? minValue,
    double? maxValue
  }) {
    return RangeFilter(
      tagName: tagName ?? this.tagName,
      displayName: displayName ?? this.displayName,
      minValue: minValue ?? this.minValue,
      maxValue: maxValue ?? this.maxValue
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RangeFilter &&
    other.runtimeType == runtimeType &&
    other.tagName == tagName &&
    other.displayName == displayName &&
    other.minValue == minValue &&
    other.maxValue == maxValue;

  @override
  int get hashCode {
    return Object.hash(tagName, displayName, minValue, maxValue);
  }

}
final class _CRangeFilter extends ffi.Struct {
  external _CString tagName;

  external _CString displayName;

  @ffi.Double()
  external double minValue;

  @ffi.Double()
  external double maxValue;

}
// MARK: - RangeFilter <-> _CRangeFilter

extension _CRangeFilterToDart on _CRangeFilter {
  RangeFilter _toDart() {
    return RangeFilter(
      tagName: this.tagName._toDart(),
      displayName: this.displayName._toDart(),
      minValue: this.minValue,
      maxValue: this.maxValue
    );
  }
}

extension _DartTo_CRangeFilter on RangeFilter {
  _CRangeFilter _copyFromDartTo_CRangeFilter() {
    final res = _CRangeFilterMakeDefault();
    res.tagName = this.tagName._copyFromDartTo_CString();
    res.displayName = this.displayName._copyFromDartTo_CString();
    res.minValue = this.minValue;
    res.maxValue = this.maxValue;
    return res;
  }
}
extension _CRangeFilterRelease on _CRangeFilter {
  void _releaseIntermediate() {
    tagName._releaseIntermediate();
    displayName._releaseIntermediate();
  }
}

// MARK: - SortingFilter

/** Фильтр сортировки. */
class SortingFilter {
  /** Тэг фильтра. */
  final String tagName;
  /**
   Название фильтра для отображения.
  
   - Note: Зависит от языка выдачи. Не все названия могут быть переведены.
  */
  final String displayName;

  const SortingFilter({
    required this.tagName,
    required this.displayName
  });

  SortingFilter copyWith({
    String? tagName,
    String? displayName
  }) {
    return SortingFilter(
      tagName: tagName ?? this.tagName,
      displayName: displayName ?? this.displayName
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SortingFilter &&
    other.runtimeType == runtimeType &&
    other.tagName == tagName &&
    other.displayName == displayName;

  @override
  int get hashCode {
    return Object.hash(tagName, displayName);
  }

}
final class _CSortingFilter extends ffi.Struct {
  external _CString tagName;

  external _CString displayName;

}
// MARK: - SortingFilter <-> _CSortingFilter

extension _CSortingFilterToDart on _CSortingFilter {
  SortingFilter _toDart() {
    return SortingFilter(
      tagName: this.tagName._toDart(),
      displayName: this.displayName._toDart()
    );
  }
}

extension _DartTo_CSortingFilter on SortingFilter {
  _CSortingFilter _copyFromDartTo_CSortingFilter() {
    final res = _CSortingFilterMakeDefault();
    res.tagName = this.tagName._copyFromDartTo_CString();
    res.displayName = this.displayName._copyFromDartTo_CString();
    return res;
  }
}
extension _CSortingFilterRelease on _CSortingFilter {
  void _releaseIntermediate() {
    tagName._releaseIntermediate();
    displayName._releaseIntermediate();
  }
}

// MARK: - DynamicFilter

/** Динамические фильтры поисковой выдачи. */
final class DynamicFilter {
  final Object? _value;
  final int _index;

  DynamicFilter._raw(this._value, this._index);

  DynamicFilter.flagFilter(FlagFilter value) : this._raw(value, 0);
  DynamicFilter.rangeFilter(RangeFilter value) : this._raw(value, 1);
  DynamicFilter.sortingFilter(SortingFilter value) : this._raw(value, 2);

  bool get isFlagFilter => this._index == 0;
  FlagFilter? get asFlagFilter => this.isFlagFilter ? this._value as FlagFilter : null;

  bool get isRangeFilter => this._index == 1;
  RangeFilter? get asRangeFilter => this.isRangeFilter ? this._value as RangeFilter : null;

  bool get isSortingFilter => this._index == 2;
  SortingFilter? get asSortingFilter => this.isSortingFilter ? this._value as SortingFilter : null;

  T match<T>({
    required T Function(FlagFilter value) flagFilter,
    required T Function(RangeFilter value) rangeFilter,
    required T Function(SortingFilter value) sortingFilter,
  }) {
    return switch (this._index) {
      0 => flagFilter(this._value as FlagFilter),
      1 => rangeFilter(this._value as RangeFilter),
      2 => sortingFilter(this._value as SortingFilter),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "DynamicFilter(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DynamicFilter &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CDynamicFilterImpl extends ffi.Union {
  external _CFlagFilter _flagFilter;
  external _CRangeFilter _rangeFilter;
  external _CSortingFilter _sortingFilter;
}

final class _CDynamicFilter extends ffi.Struct {
  external _CDynamicFilterImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CDynamicFilterBasicFunctions on _CDynamicFilter {
  void _releaseIntermediate() {
    _CDynamicFilter_release(this);
  }
}
	
// MARK: - DynamicFilter <-> CDynamicFilter

extension _CDynamicFilterToDart on _CDynamicFilter {
  DynamicFilter _toDart() {
    return switch (this._index) {
      0 => DynamicFilter.flagFilter(this._impl._flagFilter._toDart()),
      1 => DynamicFilter.rangeFilter(this._impl._rangeFilter._toDart()),
      2 => DynamicFilter.sortingFilter(this._impl._sortingFilter._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CDynamicFilter on DynamicFilter {
  _CDynamicFilter _copyFromDartTo_CDynamicFilter() {
    var res = _CDynamicFilterMakeDefault();
    this.match<void>(
      flagFilter: (FlagFilter value) {
        res._impl._flagFilter = value._copyFromDartTo_CFlagFilter();
        res._index = 0;
      },
      rangeFilter: (RangeFilter value) {
        res._impl._rangeFilter = value._copyFromDartTo_CRangeFilter();
        res._index = 1;
      },
      sortingFilter: (SortingFilter value) {
        res._impl._sortingFilter = value._copyFromDartTo_CSortingFilter();
        res._index = 2;
      },
    );
    return res;
  }
}

// MARK: - WorkTimeFilter? <-> _COptional_CWorkTimeFilter

final class _COptional_CWorkTimeFilter extends ffi.Struct {
  
  external _CWorkTimeFilter value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CWorkTimeFilterBasicFunctions on _COptional_CWorkTimeFilter {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CWorkTimeFilterToDart on _COptional_CWorkTimeFilter {
  WorkTimeFilter? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CWorkTimeFilter on WorkTimeFilter? {
  _COptional_CWorkTimeFilter _copyFromDartTo_COptional_CWorkTimeFilter() {
    final cOptional = _COptional_CWorkTimeFilterMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CWorkTimeFilter();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<DynamicFilter> <-> _CArray_CDynamicFilter

final class _CArray_CDynamicFilter extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CDynamicFilterToDart on _CArray_CDynamicFilter {
  List<DynamicFilter> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CDynamicFilter on List<DynamicFilter> {
  _CArray_CDynamicFilter _copyFromDartTo_CArray_CDynamicFilter() {
    final cArray = _CArray_CDynamicFiltermakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CDynamicFilter();
        _CArray_CDynamicFilteraddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CDynamicFilterBasicFunctions on _CArray_CDynamicFilter {
  void _releaseIntermediate() {
    _CArray_CDynamicFilter_release(this);
  }

  static final _listToFill = <DynamicFilter>[];

  static void _iterate(_CDynamicFilter item) {
    _listToFill.add(item._toDart());
  }

  List<DynamicFilter> _fillFromC() {
    _forEach_CArray_CDynamicFilter(this, ffi.Pointer.fromFunction<ffi.Void Function(_CDynamicFilter)>(_iterate));
    final result = List<DynamicFilter>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - DirectoryFilter

/** Фильтры для справочника. */
class DirectoryFilter {
  /** Фильтр по времени работы. */
  final WorkTimeFilter? workTime;
  /** Динамические фильтры. */
  final List<DynamicFilter> dynamic_;

  const DirectoryFilter({
    required this.workTime,
    required this.dynamic_
  });

  DirectoryFilter copyWith({
    Optional<WorkTimeFilter?>? workTime,
    List<DynamicFilter>? dynamic_
  }) {
    return DirectoryFilter(
      workTime: workTime != null ? workTime.value : this.workTime,
      dynamic_: dynamic_ ?? this.dynamic_
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectoryFilter &&
    other.runtimeType == runtimeType &&
    other.workTime == workTime &&
    other.dynamic_ == dynamic_;

  @override
  int get hashCode {
    return Object.hash(workTime, dynamic_);
  }

}
final class _CDirectoryFilter extends ffi.Struct {
  external _COptional_CWorkTimeFilter workTime;

  external _CArray_CDynamicFilter dynamic_;

}
// MARK: - DirectoryFilter <-> _CDirectoryFilter

extension _CDirectoryFilterToDart on _CDirectoryFilter {
  DirectoryFilter _toDart() {
    return DirectoryFilter(
      workTime: this.workTime._toDart(),
      dynamic_: this.dynamic_._toDart()
    );
  }
}

extension _DartTo_CDirectoryFilter on DirectoryFilter {
  _CDirectoryFilter _copyFromDartTo_CDirectoryFilter() {
    final res = _CDirectoryFilterMakeDefault();
    res.workTime = this.workTime._copyFromDartTo_COptional_CWorkTimeFilter();
    res.dynamic_ = this.dynamic_._copyFromDartTo_CArray_CDynamicFilter();
    return res;
  }
}
extension _CDirectoryFilterRelease on _CDirectoryFilter {
  void _releaseIntermediate() {
    dynamic_._releaseIntermediate();
  }
}

// MARK: - List<GeoPoint> <-> _CArray_CGeoPoint

final class _CArray_CGeoPoint extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CGeoPointToDart on _CArray_CGeoPoint {
  List<GeoPoint> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CGeoPoint on List<GeoPoint> {
  _CArray_CGeoPoint _copyFromDartTo_CArray_CGeoPoint() {
    final cArray = _CArray_CGeoPointmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CGeoPoint();
        _CArray_CGeoPointaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CGeoPointBasicFunctions on _CArray_CGeoPoint {
  void _releaseIntermediate() {
    _CArray_CGeoPoint_release(this);
  }

  static final _listToFill = <GeoPoint>[];

  static void _iterate(_CGeoPoint item) {
    _listToFill.add(item._toDart());
  }

  List<GeoPoint> _fillFromC() {
    _forEach_CArray_CGeoPoint(this, ffi.Pointer.fromFunction<ffi.Void Function(_CGeoPoint)>(_iterate));
    final result = List<GeoPoint>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<List<GeoPoint>> <-> _CArray_CArray_CGeoPoint

final class _CArray_CArray_CGeoPoint extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CArray_CGeoPointToDart on _CArray_CArray_CGeoPoint {
  List<List<GeoPoint>> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CArray_CGeoPoint on List<List<GeoPoint>> {
  _CArray_CArray_CGeoPoint _copyFromDartTo_CArray_CArray_CGeoPoint() {
    final cArray = _CArray_CArray_CGeoPointmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CArray_CGeoPoint();
        _CArray_CArray_CGeoPointaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CArray_CGeoPointBasicFunctions on _CArray_CArray_CGeoPoint {
  void _releaseIntermediate() {
    _CArray_CArray_CGeoPoint_release(this);
  }

  static final _listToFill = <List<GeoPoint>>[];

  static void _iterate(_CArray_CGeoPoint item) {
    _listToFill.add(item._toDart());
  }

  List<List<GeoPoint>> _fillFromC() {
    _forEach_CArray_CArray_CGeoPoint(this, ffi.Pointer.fromFunction<ffi.Void Function(_CArray_CGeoPoint)>(_iterate));
    final result = List<List<GeoPoint>>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - EntranceGeometry

/** Геометрии для отображения входа на карте. */
class EntranceGeometry {
  /** Местоположение входа. */
  final List<GeoPoint> entrancePoints;
  /** Геометрии стрелок, указывающих на вход. */
  final List<List<GeoPoint>> entrancePolylines;

  const EntranceGeometry({
    required this.entrancePoints,
    required this.entrancePolylines
  });

  EntranceGeometry copyWith({
    List<GeoPoint>? entrancePoints,
    List<List<GeoPoint>>? entrancePolylines
  }) {
    return EntranceGeometry(
      entrancePoints: entrancePoints ?? this.entrancePoints,
      entrancePolylines: entrancePolylines ?? this.entrancePolylines
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is EntranceGeometry &&
    other.runtimeType == runtimeType &&
    other.entrancePoints == entrancePoints &&
    other.entrancePolylines == entrancePolylines;

  @override
  int get hashCode {
    return Object.hash(entrancePoints, entrancePolylines);
  }

}
final class _CEntranceGeometry extends ffi.Struct {
  external _CArray_CGeoPoint entrancePoints;

  external _CArray_CArray_CGeoPoint entrancePolylines;

}
// MARK: - EntranceGeometry <-> _CEntranceGeometry

extension _CEntranceGeometryToDart on _CEntranceGeometry {
  EntranceGeometry _toDart() {
    return EntranceGeometry(
      entrancePoints: this.entrancePoints._toDart(),
      entrancePolylines: this.entrancePolylines._toDart()
    );
  }
}

extension _DartTo_CEntranceGeometry on EntranceGeometry {
  _CEntranceGeometry _copyFromDartTo_CEntranceGeometry() {
    final res = _CEntranceGeometryMakeDefault();
    res.entrancePoints = this.entrancePoints._copyFromDartTo_CArray_CGeoPoint();
    res.entrancePolylines = this.entrancePolylines._copyFromDartTo_CArray_CArray_CGeoPoint();
    return res;
  }
}
extension _CEntranceGeometryRelease on _CEntranceGeometry {
  void _releaseIntermediate() {
    entrancePoints._releaseIntermediate();
    entrancePolylines._releaseIntermediate();
  }
}

// MARK: - List<ApartmentRange> <-> _CArray_CApartmentRange

final class _CArray_CApartmentRange extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CApartmentRangeToDart on _CArray_CApartmentRange {
  List<ApartmentRange> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CApartmentRange on List<ApartmentRange> {
  _CArray_CApartmentRange _copyFromDartTo_CArray_CApartmentRange() {
    final cArray = _CArray_CApartmentRangemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CApartmentRange();
        _CArray_CApartmentRangeaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CApartmentRangeBasicFunctions on _CArray_CApartmentRange {
  void _releaseIntermediate() {
    _CArray_CApartmentRange_release(this);
  }

  static final _listToFill = <ApartmentRange>[];

  static void _iterate(_CApartmentRange item) {
    _listToFill.add(item._toDart());
  }

  List<ApartmentRange> _fillFromC() {
    _forEach_CArray_CApartmentRange(this, ffi.Pointer.fromFunction<ffi.Void Function(_CApartmentRange)>(_iterate));
    final result = List<ApartmentRange>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - EntranceGeometry? <-> _COptional_CEntranceGeometry

final class _COptional_CEntranceGeometry extends ffi.Struct {
  
  external _CEntranceGeometry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CEntranceGeometryBasicFunctions on _COptional_CEntranceGeometry {
  void _releaseIntermediate() {
    _COptional_CEntranceGeometry_release(this);
  }
}

extension _COptional_CEntranceGeometryToDart on _COptional_CEntranceGeometry {
  EntranceGeometry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CEntranceGeometry on EntranceGeometry? {
  _COptional_CEntranceGeometry _copyFromDartTo_COptional_CEntranceGeometry() {
    final cOptional = _COptional_CEntranceGeometryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CEntranceGeometry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - EntranceInfo

/** Информация о входе в здание. */
class EntranceInfo {
  /** Идентификатор объекта входа. */
  final DgisObjectId id;
  /** Номер дома, к которому относится вход. */
  final String? buildingNumber;
  /**
   Непустое имя подъезда. Заполняется только для подъездов.
   Может принимать значения имени подъезда (например "Подъезд 1") или
   номера здания, если подъезд имеет собственный адрес.
  */
  final String? porchName;
  /**
   Непустой номер подъезда. Заполняется только для подъездов.
   Может принимать значения номера подъезда (например "1") или
   номера здания, если подъезд имеет собственный адрес.
  */
  final String? porchNumber;
  /** Номера квартир, относящихся к подъезду. */
  final List<ApartmentRange> apartmentRanges;
  /** Геометрии для отображения входа на карте. */
  final EntranceGeometry? geometry;

  const EntranceInfo({
    required this.id,
    required this.buildingNumber,
    required this.porchName,
    required this.porchNumber,
    required this.apartmentRanges,
    required this.geometry
  });

  EntranceInfo copyWith({
    DgisObjectId? id,
    Optional<String?>? buildingNumber,
    Optional<String?>? porchName,
    Optional<String?>? porchNumber,
    List<ApartmentRange>? apartmentRanges,
    Optional<EntranceGeometry?>? geometry
  }) {
    return EntranceInfo(
      id: id ?? this.id,
      buildingNumber: buildingNumber != null ? buildingNumber.value : this.buildingNumber,
      porchName: porchName != null ? porchName.value : this.porchName,
      porchNumber: porchNumber != null ? porchNumber.value : this.porchNumber,
      apartmentRanges: apartmentRanges ?? this.apartmentRanges,
      geometry: geometry != null ? geometry.value : this.geometry
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is EntranceInfo &&
    other.runtimeType == runtimeType &&
    other.id == id &&
    other.buildingNumber == buildingNumber &&
    other.porchName == porchName &&
    other.porchNumber == porchNumber &&
    other.apartmentRanges == apartmentRanges &&
    other.geometry == geometry;

  @override
  int get hashCode {
    return Object.hash(id, buildingNumber, porchName, porchNumber, apartmentRanges, geometry);
  }

}
final class _CEntranceInfo extends ffi.Struct {
  external _CDgisObjectId id;

  external _COptional_CString buildingNumber;

  external _COptional_CString porchName;

  external _COptional_CString porchNumber;

  external _CArray_CApartmentRange apartmentRanges;

  external _COptional_CEntranceGeometry geometry;

}
// MARK: - EntranceInfo <-> _CEntranceInfo

extension _CEntranceInfoToDart on _CEntranceInfo {
  EntranceInfo _toDart() {
    return EntranceInfo(
      id: this.id._toDart(),
      buildingNumber: this.buildingNumber._toDart(),
      porchName: this.porchName._toDart(),
      porchNumber: this.porchNumber._toDart(),
      apartmentRanges: this.apartmentRanges._toDart(),
      geometry: this.geometry._toDart()
    );
  }
}

extension _DartTo_CEntranceInfo on EntranceInfo {
  _CEntranceInfo _copyFromDartTo_CEntranceInfo() {
    final res = _CEntranceInfoMakeDefault();
    res.id = this.id._copyFromDartTo_CDgisObjectId();
    res.buildingNumber = this.buildingNumber._copyFromDartTo_COptional_CString();
    res.porchName = this.porchName._copyFromDartTo_COptional_CString();
    res.porchNumber = this.porchNumber._copyFromDartTo_COptional_CString();
    res.apartmentRanges = this.apartmentRanges._copyFromDartTo_CArray_CApartmentRange();
    res.geometry = this.geometry._copyFromDartTo_COptional_CEntranceGeometry();
    return res;
  }
}
extension _CEntranceInfoRelease on _CEntranceInfo {
  void _releaseIntermediate() {
    buildingNumber._releaseIntermediate();
    porchName._releaseIntermediate();
    porchNumber._releaseIntermediate();
    apartmentRanges._releaseIntermediate();
    geometry._releaseIntermediate();
  }
}

// MARK: - FilterType

/** Тип фильтра */
enum FilterType {
  /** Фильтр задаёт порядок сортировки результата поиска. */
  sort(0),
  /** Фильтр указывает на наличие определенного признака у объекта в результатах поиска. */
  filter(1),
  ;

  const FilterType(this.rawValue);
  final int rawValue;

  static FilterType getByValue(int value) {
    return FilterType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CFilterType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CFilterTypeBasicFunctions on _CFilterType {
  void _releaseIntermediate() {
  }
}

extension _CFilterTypeToDart on _CFilterType {
  FilterType _toDart() {
    return FilterType.getByValue(this.rawValue);
  }
}

extension _DartTo_CFilterType on FilterType {
  _CFilterType _copyFromDartTo_CFilterType() {
    return _CFilterTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - FloorInfo

/** Информация об этажном плане для маркера - элемента поисковой выдачи. */
class FloorInfo {
  /** Идентификатор этажного плана. */
  final LevelId levelId;
  /** Идентификатор здания. */
  final BuildingId buildingId;

  const FloorInfo({
    required this.levelId,
    required this.buildingId
  });

  FloorInfo copyWith({
    LevelId? levelId,
    BuildingId? buildingId
  }) {
    return FloorInfo(
      levelId: levelId ?? this.levelId,
      buildingId: buildingId ?? this.buildingId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FloorInfo &&
    other.runtimeType == runtimeType &&
    other.levelId == levelId &&
    other.buildingId == buildingId;

  @override
  int get hashCode {
    return Object.hash(levelId, buildingId);
  }

}
final class _CFloorInfo extends ffi.Struct {
  external _CLevelId levelId;

  external _CBuildingId buildingId;

}
// MARK: - FloorInfo <-> _CFloorInfo

extension _CFloorInfoToDart on _CFloorInfo {
  FloorInfo _toDart() {
    return FloorInfo(
      levelId: this.levelId._toDart(),
      buildingId: this.buildingId._toDart()
    );
  }
}

extension _DartTo_CFloorInfo on FloorInfo {
  _CFloorInfo _copyFromDartTo_CFloorInfo() {
    final res = _CFloorInfoMakeDefault();
    res.levelId = this.levelId._copyFromDartTo_CLevelId();
    res.buildingId = this.buildingId._copyFromDartTo_CBuildingId();
    return res;
  }
}
extension _CFloorInfoRelease on _CFloorInfo {
  void _releaseIntermediate() {
  }
}

// MARK: - FormattedAddress

/** Человекочитаемое представление адреса. */
class FormattedAddress {
  /**
   Адрес из дриллдауна.
   Пример: "Новосибирск, Кировский район".
  */
  final String? drilldownAddress;
  /**
   Адрес внутри населённого пункта.
   Пример: "Николаева, 11".
  */
  final String? streetAddress;
  /**
   Комментарий к адресу.
   Пример: "301 офис; 9 этаж".
  */
  final String? addressComment;
  /**
   Почтовый индекс объекта с кодом здания, если есть.
   Пример: "630088", "630007/XBVJF8".
  */
  final String? postCode;

  const FormattedAddress({
    required this.drilldownAddress,
    required this.streetAddress,
    required this.addressComment,
    required this.postCode
  });

  FormattedAddress copyWith({
    Optional<String?>? drilldownAddress,
    Optional<String?>? streetAddress,
    Optional<String?>? addressComment,
    Optional<String?>? postCode
  }) {
    return FormattedAddress(
      drilldownAddress: drilldownAddress != null ? drilldownAddress.value : this.drilldownAddress,
      streetAddress: streetAddress != null ? streetAddress.value : this.streetAddress,
      addressComment: addressComment != null ? addressComment.value : this.addressComment,
      postCode: postCode != null ? postCode.value : this.postCode
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FormattedAddress &&
    other.runtimeType == runtimeType &&
    other.drilldownAddress == drilldownAddress &&
    other.streetAddress == streetAddress &&
    other.addressComment == addressComment &&
    other.postCode == postCode;

  @override
  int get hashCode {
    return Object.hash(drilldownAddress, streetAddress, addressComment, postCode);
  }

}
final class _CFormattedAddress extends ffi.Struct {
  external _COptional_CString drilldownAddress;

  external _COptional_CString streetAddress;

  external _COptional_CString addressComment;

  external _COptional_CString postCode;

}
// MARK: - FormattedAddress <-> _CFormattedAddress

extension _CFormattedAddressToDart on _CFormattedAddress {
  FormattedAddress _toDart() {
    return FormattedAddress(
      drilldownAddress: this.drilldownAddress._toDart(),
      streetAddress: this.streetAddress._toDart(),
      addressComment: this.addressComment._toDart(),
      postCode: this.postCode._toDart()
    );
  }
}

extension _DartTo_CFormattedAddress on FormattedAddress {
  _CFormattedAddress _copyFromDartTo_CFormattedAddress() {
    final res = _CFormattedAddressMakeDefault();
    res.drilldownAddress = this.drilldownAddress._copyFromDartTo_COptional_CString();
    res.streetAddress = this.streetAddress._copyFromDartTo_COptional_CString();
    res.addressComment = this.addressComment._copyFromDartTo_COptional_CString();
    res.postCode = this.postCode._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CFormattedAddressRelease on _CFormattedAddress {
  void _releaseIntermediate() {
    drilldownAddress._releaseIntermediate();
    streetAddress._releaseIntermediate();
    addressComment._releaseIntermediate();
    postCode._releaseIntermediate();
  }
}

// MARK: - FormattingType

/** Требование к длине строкового представления адреса. */
enum FormattingType {
  /** Короткая форма адреса. Для многокомпонентных адресов некоторые компоненты могут быть опущены. */
  short(0),
  /** Полная форма адреса. Все компоненты будут представлены. */
  full(1),
  ;

  const FormattingType(this.rawValue);
  final int rawValue;

  static FormattingType getByValue(int value) {
    return FormattingType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CFormattingType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CFormattingTypeBasicFunctions on _CFormattingType {
  void _releaseIntermediate() {
  }
}

extension _CFormattingTypeToDart on _CFormattingType {
  FormattingType _toDart() {
    return FormattingType.getByValue(this.rawValue);
  }
}

extension _DartTo_CFormattingType on FormattingType {
  _CFormattingType _copyFromDartTo_CFormattingType() {
    return _CFormattingTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Aggregate

/** Обобщенное описание станции зарядки автомобилей. */
class Aggregate {
  /** Количество доступных коннекторов. */
  final int connectorsFree;
  /** Общее количество коннекторов (кроме недоступных). */
  final int connectorsTotal;
  /** Статус активности. true, если есть хотя бы один доступный, зарезервированный или на зарядке коннектор. */
  final bool isActive;
  /** Статус занятости. true, если половина или более коннекторов заняты. */
  final bool isBusy;
  /** Максимальная мощность из всех коннекторов. */
  final int power;

  const Aggregate({
    required this.connectorsFree,
    required this.connectorsTotal,
    required this.isActive,
    required this.isBusy,
    required this.power
  });

  Aggregate copyWith({
    int? connectorsFree,
    int? connectorsTotal,
    bool? isActive,
    bool? isBusy,
    int? power
  }) {
    return Aggregate(
      connectorsFree: connectorsFree ?? this.connectorsFree,
      connectorsTotal: connectorsTotal ?? this.connectorsTotal,
      isActive: isActive ?? this.isActive,
      isBusy: isBusy ?? this.isBusy,
      power: power ?? this.power
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Aggregate &&
    other.runtimeType == runtimeType &&
    other.connectorsFree == connectorsFree &&
    other.connectorsTotal == connectorsTotal &&
    other.isActive == isActive &&
    other.isBusy == isBusy &&
    other.power == power;

  @override
  int get hashCode {
    return Object.hash(connectorsFree, connectorsTotal, isActive, isBusy, power);
  }

}
final class _CAggregate extends ffi.Struct {
  @ffi.Uint16()
  external int connectorsFree;

  @ffi.Uint16()
  external int connectorsTotal;

  @ffi.Bool()
  external bool isActive;

  @ffi.Bool()
  external bool isBusy;

  @ffi.Uint16()
  external int power;

}
// MARK: - Aggregate <-> _CAggregate

extension _CAggregateToDart on _CAggregate {
  Aggregate _toDart() {
    return Aggregate(
      connectorsFree: this.connectorsFree,
      connectorsTotal: this.connectorsTotal,
      isActive: this.isActive,
      isBusy: this.isBusy,
      power: this.power
    );
  }
}

extension _DartTo_CAggregate on Aggregate {
  _CAggregate _copyFromDartTo_CAggregate() {
    final res = _CAggregateMakeDefault();
    res.connectorsFree = this.connectorsFree;
    res.connectorsTotal = this.connectorsTotal;
    res.isActive = this.isActive;
    res.isBusy = this.isBusy;
    res.power = this.power;
    return res;
  }
}
extension _CAggregateRelease on _CAggregate {
  void _releaseIntermediate() {
  }
}

// MARK: - StatusType

/** Статус коннектора. */
enum StatusType {
  /** Доступно. */
  available(0),
  /** Зарядка. */
  charging(1),
  /** Зарезервировано. */
  reserved(2),
  /** Недоступно. */
  unavailable(3),
  /** Неизвестно. */
  unknown(4),
  ;

  const StatusType(this.rawValue);
  final int rawValue;

  static StatusType getByValue(int value) {
    return StatusType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CStatusType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CStatusTypeBasicFunctions on _CStatusType {
  void _releaseIntermediate() {
  }
}

extension _CStatusTypeToDart on _CStatusType {
  StatusType _toDart() {
    return StatusType.getByValue(this.rawValue);
  }
}

extension _DartTo_CStatusType on StatusType {
  _CStatusType _copyFromDartTo_CStatusType() {
    return _CStatusTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Connector

class Connector {
  /** Мощность зарядки в кВт. */
  final int power;
  /** Стоимость за один кВт·ч. */
  final int price;
  /** Статус. */
  final StatusType status;
  /** Тип коннектора. */
  final String type;

  const Connector({
    required this.power,
    required this.price,
    required this.status,
    required this.type
  });

  Connector copyWith({
    int? power,
    int? price,
    StatusType? status,
    String? type
  }) {
    return Connector(
      power: power ?? this.power,
      price: price ?? this.price,
      status: status ?? this.status,
      type: type ?? this.type
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Connector &&
    other.runtimeType == runtimeType &&
    other.power == power &&
    other.price == price &&
    other.status == status &&
    other.type == type;

  @override
  int get hashCode {
    return Object.hash(power, price, status, type);
  }

}
final class _CConnector extends ffi.Struct {
  @ffi.Uint16()
  external int power;

  @ffi.Uint16()
  external int price;

  external _CStatusType status;

  external _CString type;

}
// MARK: - Connector <-> _CConnector

extension _CConnectorToDart on _CConnector {
  Connector _toDart() {
    return Connector(
      power: this.power,
      price: this.price,
      status: this.status._toDart(),
      type: this.type._toDart()
    );
  }
}

extension _DartTo_CConnector on Connector {
  _CConnector _copyFromDartTo_CConnector() {
    final res = _CConnectorMakeDefault();
    res.power = this.power;
    res.price = this.price;
    res.status = this.status._copyFromDartTo_CStatusType();
    res.type = this.type._copyFromDartTo_CString();
    return res;
  }
}
extension _CConnectorRelease on _CConnector {
  void _releaseIntermediate() {
    type._releaseIntermediate();
  }
}

// MARK: - List<Connector> <-> _CArray_CConnector

final class _CArray_CConnector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CConnectorToDart on _CArray_CConnector {
  List<Connector> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CConnector on List<Connector> {
  _CArray_CConnector _copyFromDartTo_CArray_CConnector() {
    final cArray = _CArray_CConnectormakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CConnector();
        _CArray_CConnectoraddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CConnectorBasicFunctions on _CArray_CConnector {
  void _releaseIntermediate() {
    _CArray_CConnector_release(this);
  }

  static final _listToFill = <Connector>[];

  static void _iterate(_CConnector item) {
    _listToFill.add(item._toDart());
  }

  List<Connector> _fillFromC() {
    _forEach_CArray_CConnector(this, ffi.Pointer.fromFunction<ffi.Void Function(_CConnector)>(_iterate));
    final result = List<Connector>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - ChargingStation

/** Атрибуты для электрозаправок. */
class ChargingStation {
  final Aggregate aggregate;
  final List<Connector> connectors;

  const ChargingStation({
    required this.aggregate,
    required this.connectors
  });

  ChargingStation copyWith({
    Aggregate? aggregate,
    List<Connector>? connectors
  }) {
    return ChargingStation(
      aggregate: aggregate ?? this.aggregate,
      connectors: connectors ?? this.connectors
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ChargingStation &&
    other.runtimeType == runtimeType &&
    other.aggregate == aggregate &&
    other.connectors == connectors;

  @override
  int get hashCode {
    return Object.hash(aggregate, connectors);
  }

}
final class _CChargingStation extends ffi.Struct {
  external _CAggregate aggregate;

  external _CArray_CConnector connectors;

}
// MARK: - ChargingStation <-> _CChargingStation

extension _CChargingStationToDart on _CChargingStation {
  ChargingStation _toDart() {
    return ChargingStation(
      aggregate: this.aggregate._toDart(),
      connectors: this.connectors._toDart()
    );
  }
}

extension _DartTo_CChargingStation on ChargingStation {
  _CChargingStation _copyFromDartTo_CChargingStation() {
    final res = _CChargingStationMakeDefault();
    res.aggregate = this.aggregate._copyFromDartTo_CAggregate();
    res.connectors = this.connectors._copyFromDartTo_CArray_CConnector();
    return res;
  }
}
extension _CChargingStationRelease on _CChargingStation {
  void _releaseIntermediate() {
    connectors._releaseIntermediate();
  }
}

// MARK: - RubricId

/** Идентификатор рубрики. */
class RubricId {
  final int value;

  const RubricId([this.value = 0]);

  RubricId copyWith({
    int? value
  }) {
    return RubricId(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RubricId &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CRubricId extends ffi.Struct {
  @ffi.Uint64()
  external int value;

}
// MARK: - RubricId <-> _CRubricId

extension _CRubricIdToDart on _CRubricId {
  RubricId _toDart() {
    return RubricId(
      this.value
    );
  }
}

extension _DartTo_CRubricId on RubricId {
  _CRubricId _copyFromDartTo_CRubricId() {
    final res = _CRubricIdMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CRubricIdRelease on _CRubricId {
  void _releaseIntermediate() {
  }
}

// MARK: - ItemMarkerInfo

/** Идентификатор объекта и его координаты. */
class ItemMarkerInfo implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  DgisObjectId? get objectId {
    _COptional_CDgisObjectId res = _CItemMarkerInfo_objectId(_CItemMarkerInfoMakeDefault().._impl=_self);
    return res._toDart();
  }
  GeoPointWithElevation get geoPoint {
    _CGeoPointWithElevation res = _CItemMarkerInfo_geoPoint(_CItemMarkerInfoMakeDefault().._impl=_self);
    return res._toDart();
  }
  FloorInfo? get floorInfo {
    _COptional_CFloorInfo res = _CItemMarkerInfo_floorInfo(_CItemMarkerInfoMakeDefault().._impl=_self);
    return res._toDart();
  }
  String? get title {
    _COptional_CString res = _CItemMarkerInfo_title(_CItemMarkerInfoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  List<RubricId> get rubricIds {
    _CArray_CRubricId res = _CItemMarkerInfo_rubricIds(_CItemMarkerInfoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CItemMarkerInfo_releasePtr);

  ItemMarkerInfo._raw(this._self);
  factory ItemMarkerInfo._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ItemMarkerInfo._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ItemMarkerInfo &&
    other.runtimeType == runtimeType &&
    _CItemMarkerInfo_cg_objectIdentifier(this._self) == _CItemMarkerInfo_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CItemMarkerInfo_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ItemMarkerInfo <-> CItemMarkerInfo

final class _CItemMarkerInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CItemMarkerInfoBasicFunctions on _CItemMarkerInfo {
  void _releaseIntermediate() {
    _CItemMarkerInfo_release(_impl);
  }

  _CItemMarkerInfo _retain() {
    return _CItemMarkerInfo_retain(_impl);
  }
}

extension _CItemMarkerInfoToDart on _CItemMarkerInfo {
  ItemMarkerInfo _toDart() {
    return ItemMarkerInfo._create(_retain()._impl);
  }
}


extension _DartToCItemMarkerInfo on ItemMarkerInfo {
  _CItemMarkerInfo _copyFromDartTo_CItemMarkerInfo() {
    return (_CItemMarkerInfoMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DgisObjectId? <-> _COptional_CDgisObjectId

final class _COptional_CDgisObjectId extends ffi.Struct {
  
  external _CDgisObjectId value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CDgisObjectIdBasicFunctions on _COptional_CDgisObjectId {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CDgisObjectIdToDart on _COptional_CDgisObjectId {
  DgisObjectId? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CDgisObjectId on DgisObjectId? {
  _COptional_CDgisObjectId _copyFromDartTo_COptional_CDgisObjectId() {
    final cOptional = _COptional_CDgisObjectIdMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CDgisObjectId();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Elevation

/** Неотрицательная высота точки над поверхностью в метрах. */
class Elevation {
  final double value;

  const Elevation([this.value = 0]);

  Elevation copyWith({
    double? value
  }) {
    return Elevation(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Elevation &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CElevation extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - Elevation <-> _CElevation

extension _CElevationToDart on _CElevation {
  Elevation _toDart() {
    return Elevation(
      this.value
    );
  }
}

extension _DartTo_CElevation on Elevation {
  _CElevation _copyFromDartTo_CElevation() {
    final res = _CElevationMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CElevationRelease on _CElevation {
  void _releaseIntermediate() {
  }
}

// MARK: - GeoPointWithElevation

/**
 Точка в географической системе координат (широта, долгота, возвышение).

 - Note: возвышение (Elevation) в метрах над поверхностью, а не над уровнем моря.
*/
class GeoPointWithElevation {
  final Latitude latitude;
  final Longitude longitude;
  final Elevation elevation;

  const GeoPointWithElevation({
    required this.latitude,
    required this.longitude,
    this.elevation = const Elevation(0)
  });

  GeoPointWithElevation copyWith({
    Latitude? latitude,
    Longitude? longitude,
    Elevation? elevation
  }) {
    return GeoPointWithElevation(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      elevation: elevation ?? this.elevation
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeoPointWithElevation &&
    other.runtimeType == runtimeType &&
    other.latitude == latitude &&
    other.longitude == longitude &&
    other.elevation == elevation;

  @override
  int get hashCode {
    return Object.hash(latitude, longitude, elevation);
  }

}
final class _CGeoPointWithElevation extends ffi.Struct {
  external _CLatitude latitude;

  external _CLongitude longitude;

  external _CElevation elevation;

}
// MARK: - GeoPointWithElevation <-> _CGeoPointWithElevation

extension _CGeoPointWithElevationToDart on _CGeoPointWithElevation {
  GeoPointWithElevation _toDart() {
    return GeoPointWithElevation(
      latitude: this.latitude._toDart(),
      longitude: this.longitude._toDart(),
      elevation: this.elevation._toDart()
    );
  }
}

extension _DartTo_CGeoPointWithElevation on GeoPointWithElevation {
  _CGeoPointWithElevation _copyFromDartTo_CGeoPointWithElevation() {
    final res = _CGeoPointWithElevationMakeDefault();
    res.latitude = this.latitude._copyFromDartTo_CLatitude();
    res.longitude = this.longitude._copyFromDartTo_CLongitude();
    res.elevation = this.elevation._copyFromDartTo_CElevation();
    return res;
  }
}
extension _CGeoPointWithElevationRelease on _CGeoPointWithElevation {
  void _releaseIntermediate() {
  }
}

// MARK: - FloorInfo? <-> _COptional_CFloorInfo

final class _COptional_CFloorInfo extends ffi.Struct {
  
  external _CFloorInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CFloorInfoBasicFunctions on _COptional_CFloorInfo {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CFloorInfoToDart on _COptional_CFloorInfo {
  FloorInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CFloorInfo on FloorInfo? {
  _COptional_CFloorInfo _copyFromDartTo_COptional_CFloorInfo() {
    final cOptional = _COptional_CFloorInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CFloorInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<RubricId> <-> _CArray_CRubricId

final class _CArray_CRubricId extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRubricIdToDart on _CArray_CRubricId {
  List<RubricId> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRubricId on List<RubricId> {
  _CArray_CRubricId _copyFromDartTo_CArray_CRubricId() {
    final cArray = _CArray_CRubricIdmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRubricId();
        _CArray_CRubricIdaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CRubricIdBasicFunctions on _CArray_CRubricId {
  void _releaseIntermediate() {
    _CArray_CRubricId_release(this);
  }

  static final _listToFill = <RubricId>[];

  static void _iterate(_CRubricId item) {
    _listToFill.add(item._toDart());
  }

  List<RubricId> _fillFromC() {
    _forEach_CArray_CRubricId(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRubricId)>(_iterate));
    final result = List<RubricId>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - ObjectType

/** Тип объекта справочника. */
enum ObjectType {
  /** Административная единица. */
  admDiv(0),
  /** Город. */
  admDivCity(1),
  /** Страна. */
  admDivCountry(2),
  /** Район. */
  admDivDistrict(3),
  /** Район области. */
  admDivDistrictArea(4),
  /** Округ. */
  admDivDivision(5),
  /** Жилмассив, микрорайон. */
  admDivLivingArea(6),
  /** Разные площадные объекты: парки, пляжи, территории баз отдыха, озёра и прочие места. */
  admDivPlace(7),
  /** Регион (область/край/республика и т.п.). */
  admDivRegion(8),
  /** Населённый пункт (деревня, посёлок и т.п.). */
  admDivSettlement(9),
  /** Достопримечательность. */
  attraction(10),
  /** Компания. */
  branch(11),
  /** Здание. */
  building(12),
  /** Глобальная координата в системе координат WGS84 в формате lon, lat. */
  coordinates(13),
  /** Перекрёсток. */
  crossroad(14),
  /** Проход/проезд. */
  gate(15),
  /** Знак километра. */
  kilometerRoadSign(16),
  /** Парковка. */
  parking(17),
  /** Дорога. */
  road(18),
  /** Маршрут. */
  route(19),
  /** Остановки или станция общественного транспорта. */
  station(20),
  /** Вход на станцию. */
  stationEntrance(21),
  /** Станция метро. */
  stationMetro(22),
  /** Остановочная платформа. */
  stationPlatform(23),
  /** Улица. */
  street(24),
  /** На случай получения неожиданного типа. */
  unknown(25),
  ;

  const ObjectType(this.rawValue);
  final int rawValue;

  static ObjectType getByValue(int value) {
    return ObjectType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CObjectType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CObjectTypeBasicFunctions on _CObjectType {
  void _releaseIntermediate() {
  }
}

extension _CObjectTypeToDart on _CObjectType {
  ObjectType _toDart() {
    return ObjectType.getByValue(this.rawValue);
  }
}

extension _DartTo_CObjectType on ObjectType {
  _CObjectType _copyFromDartTo_CObjectType() {
    return _CObjectTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - List<List<WeekTimeInterval>> <-> _CArray_CArray_CWeekTimeInterval

final class _CArray_CArray_CWeekTimeInterval extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CArray_CWeekTimeIntervalToDart on _CArray_CArray_CWeekTimeInterval {
  List<List<WeekTimeInterval>> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CArray_CWeekTimeInterval on List<List<WeekTimeInterval>> {
  _CArray_CArray_CWeekTimeInterval _copyFromDartTo_CArray_CArray_CWeekTimeInterval() {
    final cArray = _CArray_CArray_CWeekTimeIntervalmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CArray_CWeekTimeInterval();
        _CArray_CArray_CWeekTimeIntervaladdElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CArray_CWeekTimeIntervalBasicFunctions on _CArray_CArray_CWeekTimeInterval {
  void _releaseIntermediate() {
    _CArray_CArray_CWeekTimeInterval_release(this);
  }

  static final _listToFill = <List<WeekTimeInterval>>[];

  static void _iterate(_CArray_CWeekTimeInterval item) {
    _listToFill.add(item._toDart());
  }

  List<List<WeekTimeInterval>> _fillFromC() {
    _forEach_CArray_CArray_CWeekTimeInterval(this, ffi.Pointer.fromFunction<ffi.Void Function(_CArray_CWeekTimeInterval)>(_iterate));
    final result = List<List<WeekTimeInterval>>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - OpeningHours

/** Часы работы организации. */
class OpeningHours {
  /** Часы работы для каждого дня недели, начиная с понедельника. */
  final List<List<WeekTimeInterval>> weekOpeningHours;
  final bool isOpen24x7;

  const OpeningHours({
    required this.weekOpeningHours,
    required this.isOpen24x7
  });

  OpeningHours copyWith({
    List<List<WeekTimeInterval>>? weekOpeningHours,
    bool? isOpen24x7
  }) {
    return OpeningHours(
      weekOpeningHours: weekOpeningHours ?? this.weekOpeningHours,
      isOpen24x7: isOpen24x7 ?? this.isOpen24x7
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is OpeningHours &&
    other.runtimeType == runtimeType &&
    other.weekOpeningHours == weekOpeningHours &&
    other.isOpen24x7 == isOpen24x7;

  @override
  int get hashCode {
    return Object.hash(weekOpeningHours, isOpen24x7);
  }

}
final class _COpeningHours extends ffi.Struct {
  external _CArray_CArray_CWeekTimeInterval weekOpeningHours;

  @ffi.Bool()
  external bool isOpen24x7;

}
// MARK: - OpeningHours <-> _COpeningHours

extension _COpeningHoursToDart on _COpeningHours {
  OpeningHours _toDart() {
    return OpeningHours(
      weekOpeningHours: this.weekOpeningHours._toDart(),
      isOpen24x7: this.isOpen24x7
    );
  }
}

extension _DartTo_COpeningHours on OpeningHours {
  _COpeningHours _copyFromDartTo_COpeningHours() {
    final res = _COpeningHoursMakeDefault();
    res.weekOpeningHours = this.weekOpeningHours._copyFromDartTo_CArray_CArray_CWeekTimeInterval();
    res.isOpen24x7 = this.isOpen24x7;
    return res;
  }
}
extension _COpeningHoursRelease on _COpeningHours {
  void _releaseIntermediate() {
    weekOpeningHours._releaseIntermediate();
  }
}

// MARK: - List<WeekTimeInterval> <-> _CArray_CWeekTimeInterval

final class _CArray_CWeekTimeInterval extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CWeekTimeIntervalToDart on _CArray_CWeekTimeInterval {
  List<WeekTimeInterval> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CWeekTimeInterval on List<WeekTimeInterval> {
  _CArray_CWeekTimeInterval _copyFromDartTo_CArray_CWeekTimeInterval() {
    final cArray = _CArray_CWeekTimeIntervalmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CWeekTimeInterval();
        _CArray_CWeekTimeIntervaladdElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CWeekTimeIntervalBasicFunctions on _CArray_CWeekTimeInterval {
  void _releaseIntermediate() {
    _CArray_CWeekTimeInterval_release(this);
  }

  static final _listToFill = <WeekTimeInterval>[];

  static void _iterate(_CWeekTimeInterval item) {
    _listToFill.add(item._toDart());
  }

  List<WeekTimeInterval> _fillFromC() {
    _forEach_CArray_CWeekTimeInterval(this, ffi.Pointer.fromFunction<ffi.Void Function(_CWeekTimeInterval)>(_iterate));
    final result = List<WeekTimeInterval>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - OrgId

/** Идентификатор организации. */
class OrgId {
  final int value;

  const OrgId([this.value = 0]);

  OrgId copyWith({
    int? value
  }) {
    return OrgId(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is OrgId &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _COrgId extends ffi.Struct {
  @ffi.Uint64()
  external int value;

}
// MARK: - OrgId <-> _COrgId

extension _COrgIdToDart on _COrgId {
  OrgId _toDart() {
    return OrgId(
      this.value
    );
  }
}

extension _DartTo_COrgId on OrgId {
  _COrgId _copyFromDartTo_COrgId() {
    final res = _COrgIdMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _COrgIdRelease on _COrgId {
  void _releaseIntermediate() {
  }
}

// MARK: - OrgInfo

/** Информация об организации. */
class OrgInfo {
  /** Количество филиалов организации. */
  final int branchCount;
  /** Уникальный идентификатор организации. */
  final OrgId id;
  /** Название организации. */
  final String? name;

  const OrgInfo({
    required this.branchCount,
    required this.id,
    required this.name
  });

  OrgInfo copyWith({
    int? branchCount,
    OrgId? id,
    Optional<String?>? name
  }) {
    return OrgInfo(
      branchCount: branchCount ?? this.branchCount,
      id: id ?? this.id,
      name: name != null ? name.value : this.name
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is OrgInfo &&
    other.runtimeType == runtimeType &&
    other.branchCount == branchCount &&
    other.id == id &&
    other.name == name;

  @override
  int get hashCode {
    return Object.hash(branchCount, id, name);
  }

}
final class _COrgInfo extends ffi.Struct {
  @ffi.Uint32()
  external int branchCount;

  external _COrgId id;

  external _COptional_CString name;

}
// MARK: - OrgInfo <-> _COrgInfo

extension _COrgInfoToDart on _COrgInfo {
  OrgInfo _toDart() {
    return OrgInfo(
      branchCount: this.branchCount,
      id: this.id._toDart(),
      name: this.name._toDart()
    );
  }
}

extension _DartTo_COrgInfo on OrgInfo {
  _COrgInfo _copyFromDartTo_COrgInfo() {
    final res = _COrgInfoMakeDefault();
    res.branchCount = this.branchCount;
    res.id = this.id._copyFromDartTo_COrgId();
    res.name = this.name._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _COrgInfoRelease on _COrgInfo {
  void _releaseIntermediate() {
    name._releaseIntermediate();
  }
}

// MARK: - ParkingAccess

/** Тип доступа для парковки. */
enum ParkingAccess {
  /** Общедоступная. */
  public(0),
  /** Только для инвалидов. */
  handicappedOnly(1),
  /** Только для клиентов. */
  customersOnly(2),
  /** Только для резидентов. */
  residentsOnly(3),
  /** Место стоянки для такси. */
  taxiOnly(4),
  ;

  const ParkingAccess(this.rawValue);
  final int rawValue;

  static ParkingAccess getByValue(int value) {
    return ParkingAccess.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CParkingAccess extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CParkingAccessBasicFunctions on _CParkingAccess {
  void _releaseIntermediate() {
  }
}

extension _CParkingAccessToDart on _CParkingAccess {
  ParkingAccess _toDart() {
    return ParkingAccess.getByValue(this.rawValue);
  }
}

extension _DartTo_CParkingAccess on ParkingAccess {
  _CParkingAccess _copyFromDartTo_CParkingAccess() {
    return _CParkingAccessMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SpecialSpaceType

/** Тип особого места. */
enum SpecialSpaceType {
  /** Для велосипедов. */
  bicycle(0),
  /** Для мотоциклов. */
  motorbike(1),
  /** Для семей. */
  family(2),
  /** Для инвалидов. */
  handicapped(3),
  /** Для колясок. */
  babyCarriage(4),
  /** Для грузовиков. */
  truck(5),
  /** Для самокатов. */
  scooter(6),
  ;

  const SpecialSpaceType(this.rawValue);
  final int rawValue;

  static SpecialSpaceType getByValue(int value) {
    return SpecialSpaceType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSpecialSpaceType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSpecialSpaceTypeBasicFunctions on _CSpecialSpaceType {
  void _releaseIntermediate() {
  }
}

extension _CSpecialSpaceTypeToDart on _CSpecialSpaceType {
  SpecialSpaceType _toDart() {
    return SpecialSpaceType.getByValue(this.rawValue);
  }
}

extension _DartTo_CSpecialSpaceType on SpecialSpaceType {
  _CSpecialSpaceType _copyFromDartTo_CSpecialSpaceType() {
    return _CSpecialSpaceTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SpecialSpace

/** Особое место для парковки. */
class SpecialSpace {
  /** Тип. */
  final SpecialSpaceType type;
  /** Локализованное название особого места. */
  final String name;
  /** Количество мест такого типа на парковке. */
  final String? count;

  const SpecialSpace({
    required this.type,
    required this.name,
    required this.count
  });

  SpecialSpace copyWith({
    SpecialSpaceType? type,
    String? name,
    Optional<String?>? count
  }) {
    return SpecialSpace(
      type: type ?? this.type,
      name: name ?? this.name,
      count: count != null ? count.value : this.count
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SpecialSpace &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.name == name &&
    other.count == count;

  @override
  int get hashCode {
    return Object.hash(type, name, count);
  }

}
final class _CSpecialSpace extends ffi.Struct {
  external _CSpecialSpaceType type;

  external _CString name;

  external _COptional_CString count;

}
// MARK: - SpecialSpace <-> _CSpecialSpace

extension _CSpecialSpaceToDart on _CSpecialSpace {
  SpecialSpace _toDart() {
    return SpecialSpace(
      type: this.type._toDart(),
      name: this.name._toDart(),
      count: this.count._toDart()
    );
  }
}

extension _DartTo_CSpecialSpace on SpecialSpace {
  _CSpecialSpace _copyFromDartTo_CSpecialSpace() {
    final res = _CSpecialSpaceMakeDefault();
    res.type = this.type._copyFromDartTo_CSpecialSpaceType();
    res.name = this.name._copyFromDartTo_CString();
    res.count = this.count._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CSpecialSpaceRelease on _CSpecialSpace {
  void _releaseIntermediate() {
    name._releaseIntermediate();
    count._releaseIntermediate();
  }
}

// MARK: - List<SpecialSpace> <-> _CArray_CSpecialSpace

final class _CArray_CSpecialSpace extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSpecialSpaceToDart on _CArray_CSpecialSpace {
  List<SpecialSpace> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSpecialSpace on List<SpecialSpace> {
  _CArray_CSpecialSpace _copyFromDartTo_CArray_CSpecialSpace() {
    final cArray = _CArray_CSpecialSpacemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSpecialSpace();
        _CArray_CSpecialSpaceaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CSpecialSpaceBasicFunctions on _CArray_CSpecialSpace {
  void _releaseIntermediate() {
    _CArray_CSpecialSpace_release(this);
  }

  static final _listToFill = <SpecialSpace>[];

  static void _iterate(_CSpecialSpace item) {
    _listToFill.add(item._toDart());
  }

  List<SpecialSpace> _fillFromC() {
    _forEach_CArray_CSpecialSpace(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSpecialSpace)>(_iterate));
    final result = List<SpecialSpace>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - ParkingCapacity

/** Вместимость парковки. */
class ParkingCapacity {
  /** Общая вместимость парковки, машиномест. */
  final String? total;
  /** Описание особых мест для парковки. */
  final List<SpecialSpace> specialSpaces;

  const ParkingCapacity({
    required this.total,
    required this.specialSpaces
  });

  ParkingCapacity copyWith({
    Optional<String?>? total,
    List<SpecialSpace>? specialSpaces
  }) {
    return ParkingCapacity(
      total: total != null ? total.value : this.total,
      specialSpaces: specialSpaces ?? this.specialSpaces
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ParkingCapacity &&
    other.runtimeType == runtimeType &&
    other.total == total &&
    other.specialSpaces == specialSpaces;

  @override
  int get hashCode {
    return Object.hash(total, specialSpaces);
  }

}
final class _CParkingCapacity extends ffi.Struct {
  external _COptional_CString total;

  external _CArray_CSpecialSpace specialSpaces;

}
// MARK: - ParkingCapacity <-> _CParkingCapacity

extension _CParkingCapacityToDart on _CParkingCapacity {
  ParkingCapacity _toDart() {
    return ParkingCapacity(
      total: this.total._toDart(),
      specialSpaces: this.specialSpaces._toDart()
    );
  }
}

extension _DartTo_CParkingCapacity on ParkingCapacity {
  _CParkingCapacity _copyFromDartTo_CParkingCapacity() {
    final res = _CParkingCapacityMakeDefault();
    res.total = this.total._copyFromDartTo_COptional_CString();
    res.specialSpaces = this.specialSpaces._copyFromDartTo_CArray_CSpecialSpace();
    return res;
  }
}
extension _CParkingCapacityRelease on _CParkingCapacity {
  void _releaseIntermediate() {
    total._releaseIntermediate();
    specialSpaces._releaseIntermediate();
  }
}

// MARK: - ParkingType

/** Тип парковки. */
enum ParkingType {
  /** Наземная парковка. */
  ground(0),
  /** Подземная парковка. */
  underground(1),
  /** Многоуровневая парковка. */
  multilevel(2),
  ;

  const ParkingType(this.rawValue);
  final int rawValue;

  static ParkingType getByValue(int value) {
    return ParkingType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CParkingType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CParkingTypeBasicFunctions on _CParkingType {
  void _releaseIntermediate() {
  }
}

extension _CParkingTypeToDart on _CParkingType {
  ParkingType _toDart() {
    return ParkingType.getByValue(this.rawValue);
  }
}

extension _DartTo_CParkingType on ParkingType {
  _CParkingType _copyFromDartTo_CParkingType() {
    return _CParkingTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ParkingPurpose

/** Назначение парковки. */
enum ParkingPurpose {
  /** Для автомобилей. */
  car(0),
  /** Для велосипедов. */
  bike(1),
  /** Для мотоциклов/мопедов. */
  motorbike(2),
  /** Для колясок. */
  babyCarriage(3),
  /** Для самокатов. */
  scooter(4),
  ;

  const ParkingPurpose(this.rawValue);
  final int rawValue;

  static ParkingPurpose getByValue(int value) {
    return ParkingPurpose.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CParkingPurpose extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CParkingPurposeBasicFunctions on _CParkingPurpose {
  void _releaseIntermediate() {
  }
}

extension _CParkingPurposeToDart on _CParkingPurpose {
  ParkingPurpose _toDart() {
    return ParkingPurpose.getByValue(this.rawValue);
  }
}

extension _DartTo_CParkingPurpose on ParkingPurpose {
  _CParkingPurpose _copyFromDartTo_CParkingPurpose() {
    return _CParkingPurposeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ParkingPavingType

/** Тип покрытия парковки. */
enum ParkingPavingType {
  /** Асфальтированное покрытие. */
  asphalt(0),
  /** Бетонное покрытие. */
  concrete(1),
  /** Гравийное покрытие. */
  gravel(2),
  /** Без покрытия. */
  unpaved(3),
  ;

  const ParkingPavingType(this.rawValue);
  final int rawValue;

  static ParkingPavingType getByValue(int value) {
    return ParkingPavingType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CParkingPavingType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CParkingPavingTypeBasicFunctions on _CParkingPavingType {
  void _releaseIntermediate() {
  }
}

extension _CParkingPavingTypeToDart on _CParkingPavingType {
  ParkingPavingType _toDart() {
    return ParkingPavingType.getByValue(this.rawValue);
  }
}

extension _DartTo_CParkingPavingType on ParkingPavingType {
  _CParkingPavingType _copyFromDartTo_CParkingPavingType() {
    return _CParkingPavingTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ParkingType? <-> _COptional_CParkingType

final class _COptional_CParkingType extends ffi.Struct {
  
  external _CParkingType value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CParkingTypeBasicFunctions on _COptional_CParkingType {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CParkingTypeToDart on _COptional_CParkingType {
  ParkingType? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CParkingType on ParkingType? {
  _COptional_CParkingType _copyFromDartTo_COptional_CParkingType() {
    final cOptional = _COptional_CParkingTypeMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CParkingType();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ParkingPavingType? <-> _COptional_CParkingPavingType

final class _COptional_CParkingPavingType extends ffi.Struct {
  
  external _CParkingPavingType value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CParkingPavingTypeBasicFunctions on _COptional_CParkingPavingType {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CParkingPavingTypeToDart on _COptional_CParkingPavingType {
  ParkingPavingType? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CParkingPavingType on ParkingPavingType? {
  _COptional_CParkingPavingType _copyFromDartTo_COptional_CParkingPavingType() {
    final cOptional = _COptional_CParkingPavingTypeMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CParkingPavingType();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - int? <-> _COptional_uint16_t

final class _COptional_uint16_t extends ffi.Struct {
  @ffi.Uint16()
  external int value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_uint16_tBasicFunctions on _COptional_uint16_t {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_uint16_tToDart on _COptional_uint16_t {
  int? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_uint16_t on int? {
  _COptional_uint16_t _copyFromDartTo_COptional_uint16_t() {
    final cOptional = _COptional_uint16_tMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ParkingCapacity? <-> _COptional_CParkingCapacity

final class _COptional_CParkingCapacity extends ffi.Struct {
  
  external _CParkingCapacity value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CParkingCapacityBasicFunctions on _COptional_CParkingCapacity {
  void _releaseIntermediate() {
    _COptional_CParkingCapacity_release(this);
  }
}

extension _COptional_CParkingCapacityToDart on _COptional_CParkingCapacity {
  ParkingCapacity? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CParkingCapacity on ParkingCapacity? {
  _COptional_CParkingCapacity _copyFromDartTo_COptional_CParkingCapacity() {
    final cOptional = _COptional_CParkingCapacityMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CParkingCapacity();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ParkingInfo

/** Общая информация о парковке. */
class ParkingInfo {
  /** Тип. */
  final ParkingType? type;
  /** Назначение. */
  final ParkingPurpose purpose;
  /** Тип доступа. */
  final ParkingAccess access;
  /** Тип покрытия. */
  final ParkingPavingType? pavingType;
  /** Является ли парковка платной. */
  final bool isPaid;
  /** Является ли парковка перехватывающей. */
  final bool isIncentive;
  /** Есть места для грузовиков. */
  final bool forTrucks;
  /** Количество уровней. */
  final int? levelCount;
  /** Вместимость. */
  final ParkingCapacity? capacity;

  const ParkingInfo({
    required this.type,
    required this.purpose,
    required this.access,
    required this.pavingType,
    required this.isPaid,
    required this.isIncentive,
    required this.forTrucks,
    required this.levelCount,
    required this.capacity
  });

  ParkingInfo copyWith({
    Optional<ParkingType?>? type,
    ParkingPurpose? purpose,
    ParkingAccess? access,
    Optional<ParkingPavingType?>? pavingType,
    bool? isPaid,
    bool? isIncentive,
    bool? forTrucks,
    Optional<int?>? levelCount,
    Optional<ParkingCapacity?>? capacity
  }) {
    return ParkingInfo(
      type: type != null ? type.value : this.type,
      purpose: purpose ?? this.purpose,
      access: access ?? this.access,
      pavingType: pavingType != null ? pavingType.value : this.pavingType,
      isPaid: isPaid ?? this.isPaid,
      isIncentive: isIncentive ?? this.isIncentive,
      forTrucks: forTrucks ?? this.forTrucks,
      levelCount: levelCount != null ? levelCount.value : this.levelCount,
      capacity: capacity != null ? capacity.value : this.capacity
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ParkingInfo &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.purpose == purpose &&
    other.access == access &&
    other.pavingType == pavingType &&
    other.isPaid == isPaid &&
    other.isIncentive == isIncentive &&
    other.forTrucks == forTrucks &&
    other.levelCount == levelCount &&
    other.capacity == capacity;

  @override
  int get hashCode {
    return Object.hash(type, purpose, access, pavingType, isPaid, isIncentive, forTrucks, levelCount, capacity);
  }

}
final class _CParkingInfo extends ffi.Struct {
  external _COptional_CParkingType type;

  external _CParkingPurpose purpose;

  external _CParkingAccess access;

  external _COptional_CParkingPavingType pavingType;

  @ffi.Bool()
  external bool isPaid;

  @ffi.Bool()
  external bool isIncentive;

  @ffi.Bool()
  external bool forTrucks;

  external _COptional_uint16_t levelCount;

  external _COptional_CParkingCapacity capacity;

}
// MARK: - ParkingInfo <-> _CParkingInfo

extension _CParkingInfoToDart on _CParkingInfo {
  ParkingInfo _toDart() {
    return ParkingInfo(
      type: this.type._toDart(),
      purpose: this.purpose._toDart(),
      access: this.access._toDart(),
      pavingType: this.pavingType._toDart(),
      isPaid: this.isPaid,
      isIncentive: this.isIncentive,
      forTrucks: this.forTrucks,
      levelCount: this.levelCount._toDart(),
      capacity: this.capacity._toDart()
    );
  }
}

extension _DartTo_CParkingInfo on ParkingInfo {
  _CParkingInfo _copyFromDartTo_CParkingInfo() {
    final res = _CParkingInfoMakeDefault();
    res.type = this.type._copyFromDartTo_COptional_CParkingType();
    res.purpose = this.purpose._copyFromDartTo_CParkingPurpose();
    res.access = this.access._copyFromDartTo_CParkingAccess();
    res.pavingType = this.pavingType._copyFromDartTo_COptional_CParkingPavingType();
    res.isPaid = this.isPaid;
    res.isIncentive = this.isIncentive;
    res.forTrucks = this.forTrucks;
    res.levelCount = this.levelCount._copyFromDartTo_COptional_uint16_t();
    res.capacity = this.capacity._copyFromDartTo_COptional_CParkingCapacity();
    return res;
  }
}
extension _CParkingInfoRelease on _CParkingInfo {
  void _releaseIntermediate() {
    capacity._releaseIntermediate();
  }
}

// MARK: - Reviews

/** Отзывы. */
class Reviews {
  /** Рейтинг в диапазоне от 0 до 5. */
  final double rating;
  /** Количество отзывов. */
  final int count;

  const Reviews({
    required this.rating,
    required this.count
  });

  Reviews copyWith({
    double? rating,
    int? count
  }) {
    return Reviews(
      rating: rating ?? this.rating,
      count: count ?? this.count
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Reviews &&
    other.runtimeType == runtimeType &&
    other.rating == rating &&
    other.count == count;

  @override
  int get hashCode {
    return Object.hash(rating, count);
  }

}
final class _CReviews extends ffi.Struct {
  @ffi.Float()
  external double rating;

  @ffi.Uint32()
  external int count;

}
// MARK: - Reviews <-> _CReviews

extension _CReviewsToDart on _CReviews {
  Reviews _toDart() {
    return Reviews(
      rating: this.rating,
      count: this.count
    );
  }
}

extension _DartTo_CReviews on Reviews {
  _CReviews _copyFromDartTo_CReviews() {
    final res = _CReviewsMakeDefault();
    res.rating = this.rating;
    res.count = this.count;
    return res;
  }
}
extension _CReviewsRelease on _CReviews {
  void _releaseIntermediate() {
  }
}

// MARK: - SearchResultType

/** Тип результата (не поискового запроса!). */
enum SearchResultType {
  /** По запросу найден конкретный объект. */
  recovery(0),
  /** По запросу найдена рубрика, в результатах - список объектов из этой рубрики. */
  discovery(1),
  ;

  const SearchResultType(this.rawValue);
  final int rawValue;

  static SearchResultType getByValue(int value) {
    return SearchResultType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSearchResultType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSearchResultTypeBasicFunctions on _CSearchResultType {
  void _releaseIntermediate() {
  }
}

extension _CSearchResultTypeToDart on _CSearchResultType {
  SearchResultType _toDart() {
    return SearchResultType.getByValue(this.rawValue);
  }
}

extension _DartTo_CSearchResultType on SearchResultType {
  _CSearchResultType _copyFromDartTo_CSearchResultType() {
    return _CSearchResultTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SortingType

/** Тип сортировки. */
enum SortingType {
  /** По релевантности. Используется по умолчанию. */
  byRelevance(0),
  /** По расстоянию от текущего положения пользователя. */
  byDistance(1),
  /** По рейтингу. */
  byRating(2),
  ;

  const SortingType(this.rawValue);
  final int rawValue;

  static SortingType getByValue(int value) {
    return SortingType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSortingType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSortingTypeBasicFunctions on _CSortingType {
  void _releaseIntermediate() {
  }
}

extension _CSortingTypeToDart on _CSortingType {
  SortingType _toDart() {
    return SortingType.getByValue(this.rawValue);
  }
}

extension _DartTo_CSortingType on SortingType {
  _CSortingType _copyFromDartTo_CSortingType() {
    return _CSortingTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - TradeLicense

/** Лицензия организации. */
class TradeLicense {
  /** Тип. */
  final String type;
  /** Номер. */
  final String license;
  /** Форма собственности компании. */
  final String legalForm;
  /** Дата, до которой действует лицензия. */
  final String endDate;

  const TradeLicense({
    required this.type,
    required this.license,
    required this.legalForm,
    required this.endDate
  });

  TradeLicense copyWith({
    String? type,
    String? license,
    String? legalForm,
    String? endDate
  }) {
    return TradeLicense(
      type: type ?? this.type,
      license: license ?? this.license,
      legalForm: legalForm ?? this.legalForm,
      endDate: endDate ?? this.endDate
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TradeLicense &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.license == license &&
    other.legalForm == legalForm &&
    other.endDate == endDate;

  @override
  int get hashCode {
    return Object.hash(type, license, legalForm, endDate);
  }

}
final class _CTradeLicense extends ffi.Struct {
  external _CString type;

  external _CString license;

  external _CString legalForm;

  external _CString endDate;

}
// MARK: - TradeLicense <-> _CTradeLicense

extension _CTradeLicenseToDart on _CTradeLicense {
  TradeLicense _toDart() {
    return TradeLicense(
      type: this.type._toDart(),
      license: this.license._toDart(),
      legalForm: this.legalForm._toDart(),
      endDate: this.endDate._toDart()
    );
  }
}

extension _DartTo_CTradeLicense on TradeLicense {
  _CTradeLicense _copyFromDartTo_CTradeLicense() {
    final res = _CTradeLicenseMakeDefault();
    res.type = this.type._copyFromDartTo_CString();
    res.license = this.license._copyFromDartTo_CString();
    res.legalForm = this.legalForm._copyFromDartTo_CString();
    res.endDate = this.endDate._copyFromDartTo_CString();
    return res;
  }
}
extension _CTradeLicenseRelease on _CTradeLicense {
  void _releaseIntermediate() {
    type._releaseIntermediate();
    license._releaseIntermediate();
    legalForm._releaseIntermediate();
    endDate._releaseIntermediate();
  }
}

// MARK: - UIMarkerInfo

/** Идентификатор объекта с подписью. */
class UIMarkerInfo {
  final DgisObjectId objectId;
  final String? label;

  const UIMarkerInfo({
    required this.objectId,
    required this.label
  });

  UIMarkerInfo copyWith({
    DgisObjectId? objectId,
    Optional<String?>? label
  }) {
    return UIMarkerInfo(
      objectId: objectId ?? this.objectId,
      label: label != null ? label.value : this.label
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is UIMarkerInfo &&
    other.runtimeType == runtimeType &&
    other.objectId == objectId &&
    other.label == label;

  @override
  int get hashCode {
    return Object.hash(objectId, label);
  }

}
final class _CUIMarkerInfo extends ffi.Struct {
  external _CDgisObjectId objectId;

  external _COptional_CString label;

}
// MARK: - UIMarkerInfo <-> _CUIMarkerInfo

extension _CUIMarkerInfoToDart on _CUIMarkerInfo {
  UIMarkerInfo _toDart() {
    return UIMarkerInfo(
      objectId: this.objectId._toDart(),
      label: this.label._toDart()
    );
  }
}

extension _DartTo_CUIMarkerInfo on UIMarkerInfo {
  _CUIMarkerInfo _copyFromDartTo_CUIMarkerInfo() {
    final res = _CUIMarkerInfoMakeDefault();
    res.objectId = this.objectId._copyFromDartTo_CDgisObjectId();
    res.label = this.label._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CUIMarkerInfoRelease on _CUIMarkerInfo {
  void _releaseIntermediate() {
    label._releaseIntermediate();
  }
}

// MARK: - WorkStatus

/** Статус работы. */
class WorkStatus {
  /** Открыто ли сейчас. */
  final bool isOpen;
  /**
   Текстовое описание.
   Например, "Открыто до 21:00", "Круглосуточно", "Закроется через 5 минут".
  */
  final String description;

  const WorkStatus({
    required this.isOpen,
    required this.description
  });

  WorkStatus copyWith({
    bool? isOpen,
    String? description
  }) {
    return WorkStatus(
      isOpen: isOpen ?? this.isOpen,
      description: description ?? this.description
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is WorkStatus &&
    other.runtimeType == runtimeType &&
    other.isOpen == isOpen &&
    other.description == description;

  @override
  int get hashCode {
    return Object.hash(isOpen, description);
  }

}
final class _CWorkStatus extends ffi.Struct {
  @ffi.Bool()
  external bool isOpen;

  external _CString description;

}
// MARK: - WorkStatus <-> _CWorkStatus

extension _CWorkStatusToDart on _CWorkStatus {
  WorkStatus _toDart() {
    return WorkStatus(
      isOpen: this.isOpen,
      description: this.description._toDart()
    );
  }
}

extension _DartTo_CWorkStatus on WorkStatus {
  _CWorkStatus _copyFromDartTo_CWorkStatus() {
    final res = _CWorkStatusMakeDefault();
    res.isOpen = this.isOpen;
    res.description = this.description._copyFromDartTo_CString();
    return res;
  }
}
extension _CWorkStatusRelease on _CWorkStatus {
  void _releaseIntermediate() {
    description._releaseIntermediate();
  }
}

// MARK: - AddressAdmDiv

/** Объект административного деления. */
class AddressAdmDiv {
  /**
   Тип административной единицы. Один из следующих:
   * country — страна
   * region — регион (область/край/республика и т.п.)
   * district_area — район области
   * city — город
   * settlement — населённый пункт
   * division — округ
   * district — район
   * living_area — жилмассив, микрорайон
   * place — место
  */
  final String type;
  final String name;

  const AddressAdmDiv({
    required this.type,
    required this.name
  });

  AddressAdmDiv copyWith({
    String? type,
    String? name
  }) {
    return AddressAdmDiv(
      type: type ?? this.type,
      name: name ?? this.name
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AddressAdmDiv &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.name == name;

  @override
  int get hashCode {
    return Object.hash(type, name);
  }

}
final class _CAddressAdmDiv extends ffi.Struct {
  external _CString type;

  external _CString name;

}
// MARK: - AddressAdmDiv <-> _CAddressAdmDiv

extension _CAddressAdmDivToDart on _CAddressAdmDiv {
  AddressAdmDiv _toDart() {
    return AddressAdmDiv(
      type: this.type._toDart(),
      name: this.name._toDart()
    );
  }
}

extension _DartTo_CAddressAdmDiv on AddressAdmDiv {
  _CAddressAdmDiv _copyFromDartTo_CAddressAdmDiv() {
    final res = _CAddressAdmDivMakeDefault();
    res.type = this.type._copyFromDartTo_CString();
    res.name = this.name._copyFromDartTo_CString();
    return res;
  }
}
extension _CAddressAdmDivRelease on _CAddressAdmDiv {
  void _releaseIntermediate() {
    type._releaseIntermediate();
    name._releaseIntermediate();
  }
}

// MARK: - AddressStreet

/** Обычный адрес, есть улица и номер дома. */
class AddressStreet {
  /** Название улицы. */
  final String street;
  /** Номер дома, включая дроби, корпусы и буквенные обозначения. */
  final String number;
  /** Код ФИАС улицы. */
  final String? fiasCode;

  const AddressStreet({
    required this.street,
    required this.number,
    required this.fiasCode
  });

  AddressStreet copyWith({
    String? street,
    String? number,
    Optional<String?>? fiasCode
  }) {
    return AddressStreet(
      street: street ?? this.street,
      number: number ?? this.number,
      fiasCode: fiasCode != null ? fiasCode.value : this.fiasCode
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AddressStreet &&
    other.runtimeType == runtimeType &&
    other.street == street &&
    other.number == number &&
    other.fiasCode == fiasCode;

  @override
  int get hashCode {
    return Object.hash(street, number, fiasCode);
  }

}
final class _CAddressStreet extends ffi.Struct {
  external _CString street;

  external _CString number;

  external _COptional_CString fiasCode;

}
// MARK: - AddressStreet <-> _CAddressStreet

extension _CAddressStreetToDart on _CAddressStreet {
  AddressStreet _toDart() {
    return AddressStreet(
      street: this.street._toDart(),
      number: this.number._toDart(),
      fiasCode: this.fiasCode._toDart()
    );
  }
}

extension _DartTo_CAddressStreet on AddressStreet {
  _CAddressStreet _copyFromDartTo_CAddressStreet() {
    final res = _CAddressStreetMakeDefault();
    res.street = this.street._copyFromDartTo_CString();
    res.number = this.number._copyFromDartTo_CString();
    res.fiasCode = this.fiasCode._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CAddressStreetRelease on _CAddressStreet {
  void _releaseIntermediate() {
    street._releaseIntermediate();
    number._releaseIntermediate();
    fiasCode._releaseIntermediate();
  }
}

// MARK: - AddressNumber

/** В некоторых населённых пунктах обозначается только номер дома, без улицы (например, Краснообск). */
class AddressNumber {
  /** Номер дома, включая дроби и буквенные обозначения. Возможно, имя собственное, если так принято. */
  final String number;
  /** Код ФИАС улицы. */
  final String? fiasCode;

  const AddressNumber({
    required this.number,
    required this.fiasCode
  });

  AddressNumber copyWith({
    String? number,
    Optional<String?>? fiasCode
  }) {
    return AddressNumber(
      number: number ?? this.number,
      fiasCode: fiasCode != null ? fiasCode.value : this.fiasCode
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AddressNumber &&
    other.runtimeType == runtimeType &&
    other.number == number &&
    other.fiasCode == fiasCode;

  @override
  int get hashCode {
    return Object.hash(number, fiasCode);
  }

}
final class _CAddressNumber extends ffi.Struct {
  external _CString number;

  external _COptional_CString fiasCode;

}
// MARK: - AddressNumber <-> _CAddressNumber

extension _CAddressNumberToDart on _CAddressNumber {
  AddressNumber _toDart() {
    return AddressNumber(
      number: this.number._toDart(),
      fiasCode: this.fiasCode._toDart()
    );
  }
}

extension _DartTo_CAddressNumber on AddressNumber {
  _CAddressNumber _copyFromDartTo_CAddressNumber() {
    final res = _CAddressNumberMakeDefault();
    res.number = this.number._copyFromDartTo_CString();
    res.fiasCode = this.fiasCode._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CAddressNumberRelease on _CAddressNumber {
  void _releaseIntermediate() {
    number._releaseIntermediate();
    fiasCode._releaseIntermediate();
  }
}

// MARK: - AddressLocation

/** Применяется для компонентов, которые тяжело описать конкретным адресом. */
class AddressLocation {
  /** Словесное описание местоположения строения. */
  final String comment;

  const AddressLocation(this.comment);

  AddressLocation copyWith({
    String? comment
  }) {
    return AddressLocation(
      comment ?? this.comment
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AddressLocation &&
    other.runtimeType == runtimeType &&
    other.comment == comment;

  @override
  int get hashCode {
    return comment.hashCode;
  }

}
final class _CAddressLocation extends ffi.Struct {
  external _CString comment;

}
// MARK: - AddressLocation <-> _CAddressLocation

extension _CAddressLocationToDart on _CAddressLocation {
  AddressLocation _toDart() {
    return AddressLocation(
      this.comment._toDart()
    );
  }
}

extension _DartTo_CAddressLocation on AddressLocation {
  _CAddressLocation _copyFromDartTo_CAddressLocation() {
    final res = _CAddressLocationMakeDefault();
    res.comment = this.comment._copyFromDartTo_CString();
    return res;
  }
}
extension _CAddressLocationRelease on _CAddressLocation {
  void _releaseIntermediate() {
    comment._releaseIntermediate();
  }
}

// MARK: - AddressComponent

/** Компонент адреса: улица, номер дома или словесное описание местоположения. */
final class AddressComponent {
  final Object? _value;
  final int _index;

  AddressComponent._raw(this._value, this._index);

  AddressComponent.streetAddress(AddressStreet value) : this._raw(value, 0);
  AddressComponent.number(AddressNumber value) : this._raw(value, 1);
  AddressComponent.location(AddressLocation value) : this._raw(value, 2);

  bool get isStreetAddress => this._index == 0;
  AddressStreet? get asStreetAddress => this.isStreetAddress ? this._value as AddressStreet : null;

  bool get isNumber => this._index == 1;
  AddressNumber? get asNumber => this.isNumber ? this._value as AddressNumber : null;

  bool get isLocation => this._index == 2;
  AddressLocation? get asLocation => this.isLocation ? this._value as AddressLocation : null;

  T match<T>({
    required T Function(AddressStreet value) streetAddress,
    required T Function(AddressNumber value) number,
    required T Function(AddressLocation value) location,
  }) {
    return switch (this._index) {
      0 => streetAddress(this._value as AddressStreet),
      1 => number(this._value as AddressNumber),
      2 => location(this._value as AddressLocation),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "AddressComponent(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AddressComponent &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CAddressComponentImpl extends ffi.Union {
  external _CAddressStreet _streetAddress;
  external _CAddressNumber _number;
  external _CAddressLocation _location;
}

final class _CAddressComponent extends ffi.Struct {
  external _CAddressComponentImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CAddressComponentBasicFunctions on _CAddressComponent {
  void _releaseIntermediate() {
    _CAddressComponent_release(this);
  }
}
	
// MARK: - AddressComponent <-> CAddressComponent

extension _CAddressComponentToDart on _CAddressComponent {
  AddressComponent _toDart() {
    return switch (this._index) {
      0 => AddressComponent.streetAddress(this._impl._streetAddress._toDart()),
      1 => AddressComponent.number(this._impl._number._toDart()),
      2 => AddressComponent.location(this._impl._location._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CAddressComponent on AddressComponent {
  _CAddressComponent _copyFromDartTo_CAddressComponent() {
    var res = _CAddressComponentMakeDefault();
    this.match<void>(
      streetAddress: (AddressStreet value) {
        res._impl._streetAddress = value._copyFromDartTo_CAddressStreet();
        res._index = 0;
      },
      number: (AddressNumber value) {
        res._impl._number = value._copyFromDartTo_CAddressNumber();
        res._index = 1;
      },
      location: (AddressLocation value) {
        res._impl._location = value._copyFromDartTo_CAddressLocation();
        res._index = 2;
      },
    );
    return res;
  }
}

// MARK: - List<AddressAdmDiv> <-> _CArray_CAddressAdmDiv

final class _CArray_CAddressAdmDiv extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CAddressAdmDivToDart on _CArray_CAddressAdmDiv {
  List<AddressAdmDiv> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CAddressAdmDiv on List<AddressAdmDiv> {
  _CArray_CAddressAdmDiv _copyFromDartTo_CArray_CAddressAdmDiv() {
    final cArray = _CArray_CAddressAdmDivmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CAddressAdmDiv();
        _CArray_CAddressAdmDivaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CAddressAdmDivBasicFunctions on _CArray_CAddressAdmDiv {
  void _releaseIntermediate() {
    _CArray_CAddressAdmDiv_release(this);
  }

  static final _listToFill = <AddressAdmDiv>[];

  static void _iterate(_CAddressAdmDiv item) {
    _listToFill.add(item._toDart());
  }

  List<AddressAdmDiv> _fillFromC() {
    _forEach_CArray_CAddressAdmDiv(this, ffi.Pointer.fromFunction<ffi.Void Function(_CAddressAdmDiv)>(_iterate));
    final result = List<AddressAdmDiv>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<AddressComponent> <-> _CArray_CAddressComponent

final class _CArray_CAddressComponent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CAddressComponentToDart on _CArray_CAddressComponent {
  List<AddressComponent> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CAddressComponent on List<AddressComponent> {
  _CArray_CAddressComponent _copyFromDartTo_CArray_CAddressComponent() {
    final cArray = _CArray_CAddressComponentmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CAddressComponent();
        _CArray_CAddressComponentaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CAddressComponentBasicFunctions on _CArray_CAddressComponent {
  void _releaseIntermediate() {
    _CArray_CAddressComponent_release(this);
  }

  static final _listToFill = <AddressComponent>[];

  static void _iterate(_CAddressComponent item) {
    _listToFill.add(item._toDart());
  }

  List<AddressComponent> _fillFromC() {
    _forEach_CArray_CAddressComponent(this, ffi.Pointer.fromFunction<ffi.Void Function(_CAddressComponent)>(_iterate));
    final result = List<AddressComponent>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - Address

/** Адрес в виде набора отдельных компонентов. */
class Address {
  /** Набор объектов административного деления, в которых находится описываемый объект. */
  final List<AddressAdmDiv> drillDown;
  /** Полный адрес объекта может содержать несколько отдельных адресных компонент. */
  final List<AddressComponent> components;
  /** Название здания. */
  final String? buildingName;
  /** Уникальный идентификатор здания. */
  final BuildingId? buildingId;
  /** Почтовый индекс. */
  final String? postCode;
  /** Уникальный почтовый код здания. */
  final String? buildingCode;
  /** Код ФИАС объекта. */
  final String? fiasCode;
  /**
   Комментарий к адресу.
   Пример: "301 офис; 9 этаж"
  */
  final String? addressComment;

  const Address({
    required this.drillDown,
    required this.components,
    required this.buildingName,
    required this.buildingId,
    required this.postCode,
    required this.buildingCode,
    required this.fiasCode,
    required this.addressComment
  });

  Address copyWith({
    List<AddressAdmDiv>? drillDown,
    List<AddressComponent>? components,
    Optional<String?>? buildingName,
    Optional<BuildingId?>? buildingId,
    Optional<String?>? postCode,
    Optional<String?>? buildingCode,
    Optional<String?>? fiasCode,
    Optional<String?>? addressComment
  }) {
    return Address(
      drillDown: drillDown ?? this.drillDown,
      components: components ?? this.components,
      buildingName: buildingName != null ? buildingName.value : this.buildingName,
      buildingId: buildingId != null ? buildingId.value : this.buildingId,
      postCode: postCode != null ? postCode.value : this.postCode,
      buildingCode: buildingCode != null ? buildingCode.value : this.buildingCode,
      fiasCode: fiasCode != null ? fiasCode.value : this.fiasCode,
      addressComment: addressComment != null ? addressComment.value : this.addressComment
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Address &&
    other.runtimeType == runtimeType &&
    other.drillDown == drillDown &&
    other.components == components &&
    other.buildingName == buildingName &&
    other.buildingId == buildingId &&
    other.postCode == postCode &&
    other.buildingCode == buildingCode &&
    other.fiasCode == fiasCode &&
    other.addressComment == addressComment;

  @override
  int get hashCode {
    return Object.hash(drillDown, components, buildingName, buildingId, postCode, buildingCode, fiasCode, addressComment);
  }

}
final class _CAddress extends ffi.Struct {
  external _CArray_CAddressAdmDiv drillDown;

  external _CArray_CAddressComponent components;

  external _COptional_CString buildingName;

  external _COptional_CBuildingId buildingId;

  external _COptional_CString postCode;

  external _COptional_CString buildingCode;

  external _COptional_CString fiasCode;

  external _COptional_CString addressComment;

}
// MARK: - Address <-> _CAddress

extension _CAddressToDart on _CAddress {
  Address _toDart() {
    return Address(
      drillDown: this.drillDown._toDart(),
      components: this.components._toDart(),
      buildingName: this.buildingName._toDart(),
      buildingId: this.buildingId._toDart(),
      postCode: this.postCode._toDart(),
      buildingCode: this.buildingCode._toDart(),
      fiasCode: this.fiasCode._toDart(),
      addressComment: this.addressComment._toDart()
    );
  }
}

extension _DartTo_CAddress on Address {
  _CAddress _copyFromDartTo_CAddress() {
    final res = _CAddressMakeDefault();
    res.drillDown = this.drillDown._copyFromDartTo_CArray_CAddressAdmDiv();
    res.components = this.components._copyFromDartTo_CArray_CAddressComponent();
    res.buildingName = this.buildingName._copyFromDartTo_COptional_CString();
    res.buildingId = this.buildingId._copyFromDartTo_COptional_CBuildingId();
    res.postCode = this.postCode._copyFromDartTo_COptional_CString();
    res.buildingCode = this.buildingCode._copyFromDartTo_COptional_CString();
    res.fiasCode = this.fiasCode._copyFromDartTo_COptional_CString();
    res.addressComment = this.addressComment._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CAddressRelease on _CAddress {
  void _releaseIntermediate() {
    drillDown._releaseIntermediate();
    components._releaseIntermediate();
    buildingName._releaseIntermediate();
    postCode._releaseIntermediate();
    buildingCode._releaseIntermediate();
    fiasCode._releaseIntermediate();
    addressComment._releaseIntermediate();
  }
}

// MARK: - DirectoryObject

/** Объект справочника. */
class DirectoryObject implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Тип объекта.
   Может быть несколько, например, ТЦ Сан Сити - филиал организации и здание одновременно.
   Первый тип в этом списке - основной.
  */
  List<ObjectType> get types {
    _CArray_CObjectType res = _CDirectoryObject_types(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Заголовок объекта. */
  String get title {
    _CString res = _CDirectoryObject_title(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Дополнительная информация заголовка
   Пример: "(кв. 1-12)"
  */
  String get titleAddition {
    _CString res = _CDirectoryObject_titleAddition(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Подзаголовок объекта.
  
   - Note: при отсутствии может быть пустой строкой
  */
  String get subtitle {
    _CString res = _CDirectoryObject_subtitle(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Описание объекта. */
  String get description {
    _CString res = _CDirectoryObject_description(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Стабильный числовой идентификатор объекта. */
  DgisObjectId? get id {
    _COptional_CDgisObjectId res = _CDirectoryObject_id(_CDirectoryObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Точка объекта, где следует разместить маркер. */
  GeoPointWithElevation? get markerPosition {
    _COptional_CGeoPointWithElevation res = _CDirectoryObject_markerPosition(_CDirectoryObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Адрес объекта в виде набора компонент. */
  Address? get address {
    _COptional_CAddress res = _CDirectoryObject_address(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Дополнительные атрибуты объекта. */
  List<Attribute> get attributes {
    _CArray_CAttribute res = _CDirectoryObject_attributes(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Контекстные дополнительные атрибуты объекта. */
  List<Attribute> get contextAttributes {
    _CArray_CAttribute res = _CDirectoryObject_contextAttributes(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Сдвиг локального времени объекта относительно UTC в секундах в текущий момент. */
  Duration? get timeZoneOffset {
    _COptional_CTimeInterval res = _CDirectoryObject_timeZoneOffset(_CDirectoryObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Время работы объекта. */
  OpeningHours? get openingHours {
    _COptional_COpeningHours res = _CDirectoryObject_openingHours(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Контакты объекта. */
  List<ContactInfo> get contactInfos {
    _CArray_CContactInfo res = _CDirectoryObject_contactInfos(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Отзывы. */
  Reviews? get reviews {
    _COptional_CReviews res = _CDirectoryObject_reviews(_CDirectoryObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Дополнительная информация о парковке. */
  ParkingInfo? get parkingInfo {
    _COptional_CParkingInfo res = _CDirectoryObject_parkingInfo(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Статус работы. */
  WorkStatus? get workStatus {
    _COptional_CWorkStatus res = _CDirectoryObject_workStatus(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Идентификатор этажа, на котором расположен объект. */
  LevelId? get levelId {
    _COptional_CLevelId res = _CDirectoryObject_levelId(_CDirectoryObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Информация об этажных планах здания. */
  BuildingLevels? get buildingLevels {
    _COptional_CBuildingLevels res = _CDirectoryObject_buildingLevels(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о входах. */
  List<EntranceInfo> get entrances {
    _CArray_CEntranceInfo res = _CDirectoryObject_entrances(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Данные о лицензии организации. */
  TradeLicense? get tradeLicense {
    _COptional_CTradeLicense res = _CDirectoryObject_tradeLicense(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о здании. */
  BuildingInfo get buildingInfo {
    _CBuildingInfo res = _CDirectoryObject_buildingInfo(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Атрибуты для электрозаправки. */
  ChargingStation? get chargingStation {
    _COptional_CChargingStation res = _CDirectoryObject_chargingStation(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Идентификаторы рубрик. */
  List<RubricId> get rubricIds {
    _CArray_CRubricId res = _CDirectoryObject_rubricIds(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация об организации. */
  OrgInfo? get orgInfo {
    _COptional_COrgInfo res = _CDirectoryObject_orgInfo(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CDirectoryObject_releasePtr);

  DirectoryObject._raw(this._self);
  factory DirectoryObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectoryObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectoryObject &&
    other.runtimeType == runtimeType &&
    _CDirectoryObject_cg_objectIdentifier(this._self) == _CDirectoryObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectoryObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: DirectoryObject: Methods

  /** Cтроковое представление адреса, отформатированное в соответствии с указанным требованием к длине. */
  FormattedAddress? formattedAddress(
    FormattingType type
  )  {
    var _a1 = type._copyFromDartTo_CFormattingType();
    _COptional_CFormattedAddress res = _CDirectoryObject_formattedAddress_CFormattingType(_CDirectoryObjectMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - DirectoryObject <-> CDirectoryObject

final class _CDirectoryObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectoryObjectBasicFunctions on _CDirectoryObject {
  void _releaseIntermediate() {
    _CDirectoryObject_release(_impl);
  }

  _CDirectoryObject _retain() {
    return _CDirectoryObject_retain(_impl);
  }
}

extension _CDirectoryObjectToDart on _CDirectoryObject {
  DirectoryObject _toDart() {
    return DirectoryObject._create(_retain()._impl);
  }
}


extension _DartToCDirectoryObject on DirectoryObject {
  _CDirectoryObject _copyFromDartTo_CDirectoryObject() {
    return (_CDirectoryObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<ObjectType> <-> _CArray_CObjectType

final class _CArray_CObjectType extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CObjectTypeToDart on _CArray_CObjectType {
  List<ObjectType> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CObjectType on List<ObjectType> {
  _CArray_CObjectType _copyFromDartTo_CArray_CObjectType() {
    final cArray = _CArray_CObjectTypemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CObjectType();
        _CArray_CObjectTypeaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CObjectTypeBasicFunctions on _CArray_CObjectType {
  void _releaseIntermediate() {
    _CArray_CObjectType_release(this);
  }

  static final _listToFill = <ObjectType>[];

  static void _iterate(_CObjectType item) {
    _listToFill.add(item._toDart());
  }

  List<ObjectType> _fillFromC() {
    _forEach_CArray_CObjectType(this, ffi.Pointer.fromFunction<ffi.Void Function(_CObjectType)>(_iterate));
    final result = List<ObjectType>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - GeoPointWithElevation? <-> _COptional_CGeoPointWithElevation

final class _COptional_CGeoPointWithElevation extends ffi.Struct {
  
  external _CGeoPointWithElevation value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGeoPointWithElevationBasicFunctions on _COptional_CGeoPointWithElevation {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CGeoPointWithElevationToDart on _COptional_CGeoPointWithElevation {
  GeoPointWithElevation? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGeoPointWithElevation on GeoPointWithElevation? {
  _COptional_CGeoPointWithElevation _copyFromDartTo_COptional_CGeoPointWithElevation() {
    final cOptional = _COptional_CGeoPointWithElevationMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGeoPointWithElevation();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Address? <-> _COptional_CAddress

final class _COptional_CAddress extends ffi.Struct {
  
  external _CAddress value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CAddressBasicFunctions on _COptional_CAddress {
  void _releaseIntermediate() {
    _COptional_CAddress_release(this);
  }
}

extension _COptional_CAddressToDart on _COptional_CAddress {
  Address? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CAddress on Address? {
  _COptional_CAddress _copyFromDartTo_COptional_CAddress() {
    final cOptional = _COptional_CAddressMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CAddress();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<Attribute> <-> _CArray_CAttribute

final class _CArray_CAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CAttributeToDart on _CArray_CAttribute {
  List<Attribute> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CAttribute on List<Attribute> {
  _CArray_CAttribute _copyFromDartTo_CArray_CAttribute() {
    final cArray = _CArray_CAttributemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CAttribute();
        _CArray_CAttributeaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CAttributeBasicFunctions on _CArray_CAttribute {
  void _releaseIntermediate() {
    _CArray_CAttribute_release(this);
  }

  static final _listToFill = <Attribute>[];

  static void _iterate(_CAttribute item) {
    _listToFill.add(item._toDart());
  }

  List<Attribute> _fillFromC() {
    _forEach_CArray_CAttribute(this, ffi.Pointer.fromFunction<ffi.Void Function(_CAttribute)>(_iterate));
    final result = List<Attribute>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - FormattedAddress? <-> _COptional_CFormattedAddress

final class _COptional_CFormattedAddress extends ffi.Struct {
  
  external _CFormattedAddress value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CFormattedAddressBasicFunctions on _COptional_CFormattedAddress {
  void _releaseIntermediate() {
    _COptional_CFormattedAddress_release(this);
  }
}

extension _COptional_CFormattedAddressToDart on _COptional_CFormattedAddress {
  FormattedAddress? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CFormattedAddress on FormattedAddress? {
  _COptional_CFormattedAddress _copyFromDartTo_COptional_CFormattedAddress() {
    final cOptional = _COptional_CFormattedAddressMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CFormattedAddress();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Duration? <-> _COptional_CTimeInterval

final class _COptional_CTimeInterval extends ffi.Struct {
  
  external _CTimeInterval value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CTimeIntervalBasicFunctions on _COptional_CTimeInterval {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CTimeIntervalToDart on _COptional_CTimeInterval {
  Duration? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CTimeInterval on Duration? {
  _COptional_CTimeInterval _copyFromDartTo_COptional_CTimeInterval() {
    final cOptional = _COptional_CTimeIntervalMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CTimeInterval();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - OpeningHours? <-> _COptional_COpeningHours

final class _COptional_COpeningHours extends ffi.Struct {
  
  external _COpeningHours value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_COpeningHoursBasicFunctions on _COptional_COpeningHours {
  void _releaseIntermediate() {
    _COptional_COpeningHours_release(this);
  }
}

extension _COptional_COpeningHoursToDart on _COptional_COpeningHours {
  OpeningHours? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_COpeningHours on OpeningHours? {
  _COptional_COpeningHours _copyFromDartTo_COptional_COpeningHours() {
    final cOptional = _COptional_COpeningHoursMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_COpeningHours();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<ContactInfo> <-> _CArray_CContactInfo

final class _CArray_CContactInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CContactInfoToDart on _CArray_CContactInfo {
  List<ContactInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CContactInfo on List<ContactInfo> {
  _CArray_CContactInfo _copyFromDartTo_CArray_CContactInfo() {
    final cArray = _CArray_CContactInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CContactInfo();
        _CArray_CContactInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CContactInfoBasicFunctions on _CArray_CContactInfo {
  void _releaseIntermediate() {
    _CArray_CContactInfo_release(this);
  }

  static final _listToFill = <ContactInfo>[];

  static void _iterate(_CContactInfo item) {
    _listToFill.add(item._toDart());
  }

  List<ContactInfo> _fillFromC() {
    _forEach_CArray_CContactInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CContactInfo)>(_iterate));
    final result = List<ContactInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - Reviews? <-> _COptional_CReviews

final class _COptional_CReviews extends ffi.Struct {
  
  external _CReviews value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CReviewsBasicFunctions on _COptional_CReviews {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CReviewsToDart on _COptional_CReviews {
  Reviews? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CReviews on Reviews? {
  _COptional_CReviews _copyFromDartTo_COptional_CReviews() {
    final cOptional = _COptional_CReviewsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CReviews();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ParkingInfo? <-> _COptional_CParkingInfo

final class _COptional_CParkingInfo extends ffi.Struct {
  
  external _CParkingInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CParkingInfoBasicFunctions on _COptional_CParkingInfo {
  void _releaseIntermediate() {
    _COptional_CParkingInfo_release(this);
  }
}

extension _COptional_CParkingInfoToDart on _COptional_CParkingInfo {
  ParkingInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CParkingInfo on ParkingInfo? {
  _COptional_CParkingInfo _copyFromDartTo_COptional_CParkingInfo() {
    final cOptional = _COptional_CParkingInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CParkingInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - WorkStatus? <-> _COptional_CWorkStatus

final class _COptional_CWorkStatus extends ffi.Struct {
  
  external _CWorkStatus value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CWorkStatusBasicFunctions on _COptional_CWorkStatus {
  void _releaseIntermediate() {
    _COptional_CWorkStatus_release(this);
  }
}

extension _COptional_CWorkStatusToDart on _COptional_CWorkStatus {
  WorkStatus? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CWorkStatus on WorkStatus? {
  _COptional_CWorkStatus _copyFromDartTo_COptional_CWorkStatus() {
    final cOptional = _COptional_CWorkStatusMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CWorkStatus();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - LevelId? <-> _COptional_CLevelId

final class _COptional_CLevelId extends ffi.Struct {
  
  external _CLevelId value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLevelIdBasicFunctions on _COptional_CLevelId {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CLevelIdToDart on _COptional_CLevelId {
  LevelId? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLevelId on LevelId? {
  _COptional_CLevelId _copyFromDartTo_COptional_CLevelId() {
    final cOptional = _COptional_CLevelIdMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLevelId();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<EntranceInfo> <-> _CArray_CEntranceInfo

final class _CArray_CEntranceInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CEntranceInfoToDart on _CArray_CEntranceInfo {
  List<EntranceInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CEntranceInfo on List<EntranceInfo> {
  _CArray_CEntranceInfo _copyFromDartTo_CArray_CEntranceInfo() {
    final cArray = _CArray_CEntranceInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CEntranceInfo();
        _CArray_CEntranceInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CEntranceInfoBasicFunctions on _CArray_CEntranceInfo {
  void _releaseIntermediate() {
    _CArray_CEntranceInfo_release(this);
  }

  static final _listToFill = <EntranceInfo>[];

  static void _iterate(_CEntranceInfo item) {
    _listToFill.add(item._toDart());
  }

  List<EntranceInfo> _fillFromC() {
    _forEach_CArray_CEntranceInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CEntranceInfo)>(_iterate));
    final result = List<EntranceInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - TradeLicense? <-> _COptional_CTradeLicense

final class _COptional_CTradeLicense extends ffi.Struct {
  
  external _CTradeLicense value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CTradeLicenseBasicFunctions on _COptional_CTradeLicense {
  void _releaseIntermediate() {
    _COptional_CTradeLicense_release(this);
  }
}

extension _COptional_CTradeLicenseToDart on _COptional_CTradeLicense {
  TradeLicense? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CTradeLicense on TradeLicense? {
  _COptional_CTradeLicense _copyFromDartTo_COptional_CTradeLicense() {
    final cOptional = _COptional_CTradeLicenseMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CTradeLicense();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ChargingStation? <-> _COptional_CChargingStation

final class _COptional_CChargingStation extends ffi.Struct {
  
  external _CChargingStation value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CChargingStationBasicFunctions on _COptional_CChargingStation {
  void _releaseIntermediate() {
    _COptional_CChargingStation_release(this);
  }
}

extension _COptional_CChargingStationToDart on _COptional_CChargingStation {
  ChargingStation? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CChargingStation on ChargingStation? {
  _COptional_CChargingStation _copyFromDartTo_COptional_CChargingStation() {
    final cOptional = _COptional_CChargingStationMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CChargingStation();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - OrgInfo? <-> _COptional_COrgInfo

final class _COptional_COrgInfo extends ffi.Struct {
  
  external _COrgInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_COrgInfoBasicFunctions on _COptional_COrgInfo {
  void _releaseIntermediate() {
    _COptional_COrgInfo_release(this);
  }
}

extension _COptional_COrgInfoToDart on _COptional_COrgInfo {
  OrgInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_COrgInfo on OrgInfo? {
  _COptional_COrgInfo _copyFromDartTo_COptional_COrgInfo() {
    final cOptional = _COptional_COrgInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_COrgInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Page

/** Страница результатов поиска. */
class Page implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Непустой набор объектов справочника этой страницы. */
  List<DirectoryObject> get items {
    _CArray_CDirectoryObject res = _CPage_items(_CPageMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPage_releasePtr);

  Page._raw(this._self);
  factory Page._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Page._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Page &&
    other.runtimeType == runtimeType &&
    _CPage_cg_objectIdentifier(this._self) == _CPage_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPage_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Page: Methods

  /**
   Получить предыдущую страницу результатов.
  
   - Returns: future, резолвящаяся в ненулевой указатель на предыдущую страницу, если страница успешно получена
   future, резолвящаяся в нулевой указатель, если предыдущая страница отсутствует
   exceptional future, если произошла ошибка при получении страницы
  */
  CancelableOperation<Page?> fetchPrevPage()  {
    _CFuture_COptional_CPage res = _CPage_fetchPrevPage(_CPageMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получить следующую страницу результатов.
  
   - Returns: future, резолвящаяся в ненулевой указатель на следующую страницу, если страница успешно получена
   future, резолвящаяся в нулевой указатель, если следующая страница отсутствует
   exceptional future, если произошла ошибка при получении страницы
  */
  CancelableOperation<Page?> fetchNextPage()  {
    _CFuture_COptional_CPage res = _CPage_fetchNextPage(_CPageMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - Page <-> CPage

final class _CPage extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPageBasicFunctions on _CPage {
  void _releaseIntermediate() {
    _CPage_release(_impl);
  }

  _CPage _retain() {
    return _CPage_retain(_impl);
  }
}

extension _CPageToDart on _CPage {
  Page _toDart() {
    return Page._create(_retain()._impl);
  }
}


extension _DartToCPage on Page {
  _CPage _copyFromDartTo_CPage() {
    return (_CPageMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<DirectoryObject> <-> _CArray_CDirectoryObject

final class _CArray_CDirectoryObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CDirectoryObjectToDart on _CArray_CDirectoryObject {
  List<DirectoryObject> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CDirectoryObject on List<DirectoryObject> {
  _CArray_CDirectoryObject _copyFromDartTo_CArray_CDirectoryObject() {
    final cArray = _CArray_CDirectoryObjectmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CDirectoryObject();
        _CArray_CDirectoryObjectaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CDirectoryObjectBasicFunctions on _CArray_CDirectoryObject {
  void _releaseIntermediate() {
    _CArray_CDirectoryObject_release(this);
  }

  static final _listToFill = <DirectoryObject>[];

  static void _iterate(_CDirectoryObject item) {
    _listToFill.add(item._toDart());
  }

  List<DirectoryObject> _fillFromC() {
    _forEach_CArray_CDirectoryObject(this, ffi.Pointer.fromFunction<ffi.Void Function(_CDirectoryObject)>(_iterate));
    final result = List<DirectoryObject>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - CancelableOperation<Page?> <-> _CFuture_COptional_CPage

final class _CFuture_COptional_CPage extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_COptional_CPage_Cancellable {
  final Completer<Page?> completer;
  final _CFuture_COptional_CPage _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_COptional_CPage, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_COptional_CPage_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_COptional_CPageBasicFunctions on _CFuture_COptional_CPage {
  void _releaseIntermediate() {
    _CFuture_COptional_CPage_release(this);
  }

  _CFuture_COptional_CPage _retain() {
    return _CFuture_COptional_CPage_retain(this);
  }
}

extension _CFuture_COptional_CPageToDart on _CFuture_COptional_CPage {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_COptional_CPage_Cancellable>{};

  static void valueFunction(_COptional_CPage cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<Page?> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<Page?>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CPage, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_COptional_CPageReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_COptional_CPage_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_COptional_CPage on CancelableOperation<Page?> {
  _CFuture_COptional_CPage _copyFromDartTo_CFuture_COptional_CPage() {
    return _CFuture_COptional_CPageMakeDefault();
  }
}
	
// MARK: - Page? <-> _COptional_CPage

final class _COptional_CPage extends ffi.Struct {
  
  external _CPage value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CPageBasicFunctions on _COptional_CPage {
  void _releaseIntermediate() {
    _COptional_CPage_release(this);
  }
}

extension _COptional_CPageToDart on _COptional_CPage {
  Page? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CPage on Page? {
  _COptional_CPage _copyFromDartTo_COptional_CPage() {
    final cOptional = _COptional_CPageMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CPage();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CCancellable <-> _CCancellable

final class _CCancellable extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCancellableBasicFunctions on _CCancellable {
  void _releaseIntermediate() {
    _CCancellable_release(this);
  }

  _CCancellable _retain() {
    return _CCancellable_retain(this);
  }

  void _cancel() {
    _CCancellableCancel(this);
    this._releaseIntermediate();
  }
}
	
// MARK: - CError <-> _CError

final class _CError extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CErrorBasicFunctions on _CError {
  void _releaseIntermediate() {
    _CError_release(this);
  }
}

extension _CErrorToDart on _CError {
  NativeException _toDart() {
    final res = _CErrorGetDescription(_CErrorMakeDefault().._impl = _impl);
    return NativeException(res.toDartString());
  }
}

extension _DartTo_CError on NativeException {
  _CError _copyFromDartTo_CError() {
    _CString description = this.toString()._copyFromDartTo_CString();
    final res = _CErrorCreateWithDescription(description._getData());
    description._releaseIntermediate();
    return res;
  }
}
	
// MARK: - WidgetType

/** Тип виджета. */
enum WidgetType {
  /** Одиночный чекбокс. */
  checkbox(0),
  /** Группа элементов, каждый из которых может быть отмечен независимо или сгруппирован в */
  checkableItemGroup(1),
  /** Представление непрерывного или дискретного набора упорядоченных значений. */
  range(2),
  ;

  const WidgetType(this.rawValue);
  final int rawValue;

  static WidgetType getByValue(int value) {
    return WidgetType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CWidgetType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CWidgetTypeBasicFunctions on _CWidgetType {
  void _releaseIntermediate() {
  }
}

extension _CWidgetTypeToDart on _CWidgetType {
  WidgetType _toDart() {
    return WidgetType.getByValue(this.rawValue);
  }
}

extension _DartTo_CWidgetType on WidgetType {
  _CWidgetType _copyFromDartTo_CWidgetType() {
    return _CWidgetTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Widget

/**
 Базовый класс, представляющий виджет для фильтрации поисковой выдачи.

 Виджеты возвращаются в результате поиска и предназначены для фильтрации или сортировки результата по определенным
 параметрам. Виджеты генерируются динамически для каждого результата поиска и могут отсутствовать для некоторых
 запросов. Виджет представляет один конкретный фильтр или их группу, объединённую общим признаком. Например, тип
 кухни в результатах поиска по запросу "Поесть".
*/
class Widget implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Получение типа виджета.
  
   - Returns: тип виджета.
  */
  WidgetType get type {
    _CWidgetType res = _CWidget_type(_CWidgetMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Получение заголовка виджета. Может отсутствовать.
  
   - Returns: заголовок виджета.
  */
  String? get caption {
    _COptional_CString res = _CWidget_caption(_CWidgetMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение списка фильтров, описывающих текущее состояние виджета. Может быть использован при
   формировании поискового запроса.
  
   - Returns: список фильтров.
  */
  List<DynamicFilter> get filters {
    _CArray_CDynamicFilter res = _CWidget_filters(_CWidgetMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CWidget_releasePtr);

  Widget._raw(this._self);
  factory Widget._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Widget._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Widget &&
    other.runtimeType == runtimeType &&
    _CWidget_cg_objectIdentifier(this._self) == _CWidget_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CWidget_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Widget <-> CWidget

final class _CWidget extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CWidgetBasicFunctions on _CWidget {
  void _releaseIntermediate() {
    _CWidget_release(_impl);
  }

  _CWidget _retain() {
    return _CWidget_retain(_impl);
  }
}

extension _CWidgetToDart on _CWidget {
  Widget _toDart() {
    final selector = _CWidget_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = Widget._create(_retain()._impl);
        return res;
      case 1:
        final res = Checkbox._create(_retain()._impl);
        return res;
      case 2:
        final res = CheckableItemsGroup._create(_retain()._impl);
        return res;
      case 3:
        final res = RangeWidget._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCWidget on Widget {
  _CWidget _copyFromDartTo_CWidget() {
    return (_CWidgetMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Checkbox

/** Виджет-чекбокс. */
class Checkbox extends Widget implements ffi.Finalizable {
  /**
   Получение типа фильтра, который представляет виджет.
  
   - Returns: тип фильтра.
  */
  FilterType get filterType {
    _CFilterType res = _CCheckbox_filterType(_CCheckboxMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Получение текста подписи для "отмеченного" чекбокса.
  
   - Returns: текст подписи.
  */
  String? get checkedText {
    _COptional_CString res = _CCheckbox_checkedText(_CCheckboxMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение текста подписи для "неотмеченного" чекбокса.
  
   - Returns: текст подписи.
  */
  String? get uncheckedText {
    _COptional_CString res = _CCheckbox_uncheckedText(_CCheckboxMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение списка значений, по которым происходит фильтрация.
   Обычно одно значение.
  
   - Returns: список значений фильтров.
  */
  List<String> get values {
    _CArray_CString res = _CCheckbox_values(_CCheckboxMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение состояния виджета.
  
   - Returns: состояние виджета. True - элемент отмечен.
  */
  bool get isChecked {
    bool res = _CCheckbox_isChecked(_CCheckboxMakeDefault().._impl=_self);
    return res;
  }
  set isChecked(bool checked) {
    void res = _CCheckbox_setChecked_bool(_CCheckboxMakeDefault().._impl=_self, checked);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CCheckbox_releasePtr);

  Checkbox._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Checkbox._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Checkbox._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Checkbox &&
    other.runtimeType == runtimeType &&
    _CCheckbox_cg_objectIdentifier(this._self) == _CCheckbox_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCheckbox_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Checkbox <-> CCheckbox

final class _CCheckbox extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCheckboxBasicFunctions on _CCheckbox {
  void _releaseIntermediate() {
    _CCheckbox_release(_impl);
  }

  _CCheckbox _retain() {
    return _CCheckbox_retain(_impl);
  }
}

extension _CCheckboxToDart on _CCheckbox {
  Checkbox _toDart() {
    return Checkbox._create(_retain()._impl);
  }
}


extension _DartToCCheckbox on Checkbox {
  _CCheckbox _copyFromDartTo_CCheckbox() {
    return (_CCheckboxMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<String> <-> _CArray_CString

final class _CArray_CString extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CStringToDart on _CArray_CString {
  List<String> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CString on List<String> {
  _CArray_CString _copyFromDartTo_CArray_CString() {
    final cArray = _CArray_CStringmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CString();
        _CArray_CStringaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CStringBasicFunctions on _CArray_CString {
  void _releaseIntermediate() {
    _CArray_CString_release(this);
  }

  static final _listToFill = <String>[];

  static void _iterate(_CString item) {
    _listToFill.add(item._toDart());
  }

  List<String> _fillFromC() {
    _forEach_CArray_CString(this, ffi.Pointer.fromFunction<ffi.Void Function(_CString)>(_iterate));
    final result = List<String>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - CheckableItemType

/** Тип отмечаемого элемента. */
enum CheckableItemType {
  /** Простой элемент. */
  simple(0),
  /** Набор элементов, работающих как радио-группа. */
  group(1),
  ;

  const CheckableItemType(this.rawValue);
  final int rawValue;

  static CheckableItemType getByValue(int value) {
    return CheckableItemType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCheckableItemType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCheckableItemTypeBasicFunctions on _CCheckableItemType {
  void _releaseIntermediate() {
  }
}

extension _CCheckableItemTypeToDart on _CCheckableItemType {
  CheckableItemType _toDart() {
    return CheckableItemType.getByValue(this.rawValue);
  }
}

extension _DartTo_CCheckableItemType on CheckableItemType {
  _CCheckableItemType _copyFromDartTo_CCheckableItemType() {
    return _CCheckableItemTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CheckableItem

/** Базовое представление отмечаемого элемента из CheckableItemsGroup. */
class CheckableItem implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Получение типа отмечаемого элемента.
  
   - Returns: тип получаемого элемента.
  */
  CheckableItemType get type {
    _CCheckableItemType res = _CCheckableItem_type(_CCheckableItemMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Получение списка фильтров, описывающих текущее состояние виджета. Может быть использован при
   формировании поискового запроса.
  
   - Returns: список фильтров.
  */
  FilterType get filterType {
    _CFilterType res = _CCheckableItem_filterType(_CCheckableItemMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CCheckableItem_releasePtr);

  CheckableItem._raw(this._self);
  factory CheckableItem._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CheckableItem._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CheckableItem &&
    other.runtimeType == runtimeType &&
    _CCheckableItem_cg_objectIdentifier(this._self) == _CCheckableItem_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCheckableItem_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - CheckableItem <-> CCheckableItem

final class _CCheckableItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCheckableItemBasicFunctions on _CCheckableItem {
  void _releaseIntermediate() {
    _CCheckableItem_release(_impl);
  }

  _CCheckableItem _retain() {
    return _CCheckableItem_retain(_impl);
  }
}

extension _CCheckableItemToDart on _CCheckableItem {
  CheckableItem _toDart() {
    final selector = _CCheckableItem_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = CheckableItem._create(_retain()._impl);
        return res;
      case 1:
        final res = SimpleCheckableItem._create(_retain()._impl);
        return res;
      case 2:
        final res = GroupCheckableItem._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCCheckableItem on CheckableItem {
  _CCheckableItem _copyFromDartTo_CCheckableItem() {
    return (_CCheckableItemMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CheckableGroupedItem

/** Единичный элемент из GroupCheckableItem. */
class CheckableGroupedItem implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Получение текстового описания элемента.
  
   - Returns: текстовое описание элемента.
  */
  String get text {
    _CString res = _CCheckableGroupedItem_text(_CCheckableGroupedItemMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение списка значений, по которым происходит фильтрация.
   Обычно одно значение.
  
   - Returns: список значений фильтров.
  */
  List<String> get values {
    _CArray_CString res = _CCheckableGroupedItem_values(_CCheckableGroupedItemMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение состояния элемента.
  
   - Returns: состояние элемента. True - элемент отмечен.
  */
  bool get isChecked {
    bool res = _CCheckableGroupedItem_isChecked(_CCheckableGroupedItemMakeDefault().._impl=_self);
    return res;
  }
  set isChecked(bool checked) {
    void res = _CCheckableGroupedItem_setChecked_bool(_CCheckableGroupedItemMakeDefault().._impl=_self, checked);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CCheckableGroupedItem_releasePtr);

  CheckableGroupedItem._raw(this._self);
  factory CheckableGroupedItem._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CheckableGroupedItem._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CheckableGroupedItem &&
    other.runtimeType == runtimeType &&
    _CCheckableGroupedItem_cg_objectIdentifier(this._self) == _CCheckableGroupedItem_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCheckableGroupedItem_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - CheckableGroupedItem <-> CCheckableGroupedItem

final class _CCheckableGroupedItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCheckableGroupedItemBasicFunctions on _CCheckableGroupedItem {
  void _releaseIntermediate() {
    _CCheckableGroupedItem_release(_impl);
  }

  _CCheckableGroupedItem _retain() {
    return _CCheckableGroupedItem_retain(_impl);
  }
}

extension _CCheckableGroupedItemToDart on _CCheckableGroupedItem {
  CheckableGroupedItem _toDart() {
    return CheckableGroupedItem._create(_retain()._impl);
  }
}


extension _DartToCCheckableGroupedItem on CheckableGroupedItem {
  _CCheckableGroupedItem _copyFromDartTo_CCheckableGroupedItem() {
    return (_CCheckableGroupedItemMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CheckableItemsGroup

/** Виджет для представления группы отмечаемых элементов. */
class CheckableItemsGroup extends Widget implements ffi.Finalizable {
  /**
   Получение группы элементов виджета.
  
   - Returns: группа элементов.
  */
  List<CheckableItem> get items {
    _CArray_CCheckableItem res = _CCheckableItemsGroup_items(_CCheckableItemsGroupMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CCheckableItemsGroup_releasePtr);

  CheckableItemsGroup._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory CheckableItemsGroup._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CheckableItemsGroup._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CheckableItemsGroup &&
    other.runtimeType == runtimeType &&
    _CCheckableItemsGroup_cg_objectIdentifier(this._self) == _CCheckableItemsGroup_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCheckableItemsGroup_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - CheckableItemsGroup <-> CCheckableItemsGroup

final class _CCheckableItemsGroup extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCheckableItemsGroupBasicFunctions on _CCheckableItemsGroup {
  void _releaseIntermediate() {
    _CCheckableItemsGroup_release(_impl);
  }

  _CCheckableItemsGroup _retain() {
    return _CCheckableItemsGroup_retain(_impl);
  }
}

extension _CCheckableItemsGroupToDart on _CCheckableItemsGroup {
  CheckableItemsGroup _toDart() {
    return CheckableItemsGroup._create(_retain()._impl);
  }
}


extension _DartToCCheckableItemsGroup on CheckableItemsGroup {
  _CCheckableItemsGroup _copyFromDartTo_CCheckableItemsGroup() {
    return (_CCheckableItemsGroupMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<CheckableItem> <-> _CArray_CCheckableItem

final class _CArray_CCheckableItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CCheckableItemToDart on _CArray_CCheckableItem {
  List<CheckableItem> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CCheckableItem on List<CheckableItem> {
  _CArray_CCheckableItem _copyFromDartTo_CArray_CCheckableItem() {
    final cArray = _CArray_CCheckableItemmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CCheckableItem();
        _CArray_CCheckableItemaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CCheckableItemBasicFunctions on _CArray_CCheckableItem {
  void _releaseIntermediate() {
    _CArray_CCheckableItem_release(this);
  }

  static final _listToFill = <CheckableItem>[];

  static void _iterate(_CCheckableItem item) {
    _listToFill.add(item._toDart());
  }

  List<CheckableItem> _fillFromC() {
    _forEach_CArray_CCheckableItem(this, ffi.Pointer.fromFunction<ffi.Void Function(_CCheckableItem)>(_iterate));
    final result = List<CheckableItem>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - SimpleCheckableItem

/** Простой отмечаемый элемент из CheckableItemsGroup. */
class SimpleCheckableItem extends CheckableItem implements ffi.Finalizable {
  /**
   Получение текстового описания элемента.
  
   - Returns: текстовое описание элемента.
  */
  String get text {
    _CString res = _CSimpleCheckableItem_text(_CSimpleCheckableItemMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение списка значений, по которым происходит фильтрация.
   Обычно одно значение.
  
   - Returns: список значений фильтров.
  */
  List<String> get values {
    _CArray_CString res = _CSimpleCheckableItem_values(_CSimpleCheckableItemMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение состояния элемента.
  
   - Returns: состояние элемента. True - элемент отмечен.
  */
  bool get isChecked {
    bool res = _CSimpleCheckableItem_isChecked(_CSimpleCheckableItemMakeDefault().._impl=_self);
    return res;
  }
  set isChecked(bool checked) {
    void res = _CSimpleCheckableItem_setChecked_bool(_CSimpleCheckableItemMakeDefault().._impl=_self, checked);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSimpleCheckableItem_releasePtr);

  SimpleCheckableItem._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory SimpleCheckableItem._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SimpleCheckableItem._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SimpleCheckableItem &&
    other.runtimeType == runtimeType &&
    _CSimpleCheckableItem_cg_objectIdentifier(this._self) == _CSimpleCheckableItem_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSimpleCheckableItem_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SimpleCheckableItem <-> CSimpleCheckableItem

final class _CSimpleCheckableItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSimpleCheckableItemBasicFunctions on _CSimpleCheckableItem {
  void _releaseIntermediate() {
    _CSimpleCheckableItem_release(_impl);
  }

  _CSimpleCheckableItem _retain() {
    return _CSimpleCheckableItem_retain(_impl);
  }
}

extension _CSimpleCheckableItemToDart on _CSimpleCheckableItem {
  SimpleCheckableItem _toDart() {
    return SimpleCheckableItem._create(_retain()._impl);
  }
}


extension _DartToCSimpleCheckableItem on SimpleCheckableItem {
  _CSimpleCheckableItem _copyFromDartTo_CSimpleCheckableItem() {
    return (_CSimpleCheckableItemMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GroupCheckableItem

/** Набор отмечаемых элементов, работающих как радио-группа. */
class GroupCheckableItem extends CheckableItem implements ffi.Finalizable {
  /**
   Получение набора элементов группы.
  
   - Returns: набор элементов.
  */
  List<CheckableGroupedItem> get items {
    _CArray_CCheckableGroupedItem res = _CGroupCheckableItem_items(_CGroupCheckableItemMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CGroupCheckableItem_releasePtr);

  GroupCheckableItem._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory GroupCheckableItem._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GroupCheckableItem._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GroupCheckableItem &&
    other.runtimeType == runtimeType &&
    _CGroupCheckableItem_cg_objectIdentifier(this._self) == _CGroupCheckableItem_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGroupCheckableItem_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - GroupCheckableItem <-> CGroupCheckableItem

final class _CGroupCheckableItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGroupCheckableItemBasicFunctions on _CGroupCheckableItem {
  void _releaseIntermediate() {
    _CGroupCheckableItem_release(_impl);
  }

  _CGroupCheckableItem _retain() {
    return _CGroupCheckableItem_retain(_impl);
  }
}

extension _CGroupCheckableItemToDart on _CGroupCheckableItem {
  GroupCheckableItem _toDart() {
    return GroupCheckableItem._create(_retain()._impl);
  }
}


extension _DartToCGroupCheckableItem on GroupCheckableItem {
  _CGroupCheckableItem _copyFromDartTo_CGroupCheckableItem() {
    return (_CGroupCheckableItemMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<CheckableGroupedItem> <-> _CArray_CCheckableGroupedItem

final class _CArray_CCheckableGroupedItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CCheckableGroupedItemToDart on _CArray_CCheckableGroupedItem {
  List<CheckableGroupedItem> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CCheckableGroupedItem on List<CheckableGroupedItem> {
  _CArray_CCheckableGroupedItem _copyFromDartTo_CArray_CCheckableGroupedItem() {
    final cArray = _CArray_CCheckableGroupedItemmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CCheckableGroupedItem();
        _CArray_CCheckableGroupedItemaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CCheckableGroupedItemBasicFunctions on _CArray_CCheckableGroupedItem {
  void _releaseIntermediate() {
    _CArray_CCheckableGroupedItem_release(this);
  }

  static final _listToFill = <CheckableGroupedItem>[];

  static void _iterate(_CCheckableGroupedItem item) {
    _listToFill.add(item._toDart());
  }

  List<CheckableGroupedItem> _fillFromC() {
    _forEach_CArray_CCheckableGroupedItem(this, ffi.Pointer.fromFunction<ffi.Void Function(_CCheckableGroupedItem)>(_iterate));
    final result = List<CheckableGroupedItem>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - Borders

/** Описывает набор непрерывного упорядоченных значений. */
class Borders {
  /** Задаёт притяжку до значения, кратного этому числу. */
  final double? snapping;
  /** Признак использования логарифмической шкалы. */
  final bool isLg;
  /** Значение, по которым происходит фильтрация. */
  final String value;
  /** Нижняя граница набора значений. */
  final double min;
  /** Верхняя граница набора значений. */
  final double max;
  /** Текущее установленное минимальное значение. */
  final double? currentMin;
  /** Текущее установленное максимальное значение. */
  final double? currentMax;

  const Borders({
    required this.snapping,
    required this.isLg,
    required this.value,
    required this.min,
    required this.max,
    this.currentMin = null,
    this.currentMax = null
  });

  Borders copyWith({
    Optional<double?>? snapping,
    bool? isLg,
    String? value,
    double? min,
    double? max,
    Optional<double?>? currentMin,
    Optional<double?>? currentMax
  }) {
    return Borders(
      snapping: snapping != null ? snapping.value : this.snapping,
      isLg: isLg ?? this.isLg,
      value: value ?? this.value,
      min: min ?? this.min,
      max: max ?? this.max,
      currentMin: currentMin != null ? currentMin.value : this.currentMin,
      currentMax: currentMax != null ? currentMax.value : this.currentMax
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Borders &&
    other.runtimeType == runtimeType &&
    other.snapping == snapping &&
    other.isLg == isLg &&
    other.value == value &&
    other.min == min &&
    other.max == max &&
    other.currentMin == currentMin &&
    other.currentMax == currentMax;

  @override
  int get hashCode {
    return Object.hash(snapping, isLg, value, min, max, currentMin, currentMax);
  }

}
final class _CBorders extends ffi.Struct {
  external _COptional_double snapping;

  @ffi.Bool()
  external bool isLg;

  external _CString value;

  @ffi.Double()
  external double min;

  @ffi.Double()
  external double max;

  external _COptional_double currentMin;

  external _COptional_double currentMax;

}
// MARK: - Borders <-> _CBorders

extension _CBordersToDart on _CBorders {
  Borders _toDart() {
    return Borders(
      snapping: this.snapping._toDart(),
      isLg: this.isLg,
      value: this.value._toDart(),
      min: this.min,
      max: this.max,
      currentMin: this.currentMin._toDart(),
      currentMax: this.currentMax._toDart()
    );
  }
}

extension _DartTo_CBorders on Borders {
  _CBorders _copyFromDartTo_CBorders() {
    final res = _CBordersMakeDefault();
    res.snapping = this.snapping._copyFromDartTo_COptional_double();
    res.isLg = this.isLg;
    res.value = this.value._copyFromDartTo_CString();
    res.min = this.min;
    res.max = this.max;
    res.currentMin = this.currentMin._copyFromDartTo_COptional_double();
    res.currentMax = this.currentMax._copyFromDartTo_COptional_double();
    return res;
  }
}
extension _CBordersRelease on _CBorders {
  void _releaseIntermediate() {
    value._releaseIntermediate();
  }
}

// MARK: - OrderedValue

/** Описывает одно значение из набора. */
class OrderedValue {
  /** Значение, по которым происходит фильтрация. */
  final String value;
  /** Название значения. */
  final String? text;

  const OrderedValue({
    required this.value,
    required this.text
  });

  OrderedValue copyWith({
    String? value,
    Optional<String?>? text
  }) {
    return OrderedValue(
      value: value ?? this.value,
      text: text != null ? text.value : this.text
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is OrderedValue &&
    other.runtimeType == runtimeType &&
    other.value == value &&
    other.text == text;

  @override
  int get hashCode {
    return Object.hash(value, text);
  }

}
final class _COrderedValue extends ffi.Struct {
  external _CString value;

  external _COptional_CString text;

}
// MARK: - OrderedValue <-> _COrderedValue

extension _COrderedValueToDart on _COrderedValue {
  OrderedValue _toDart() {
    return OrderedValue(
      value: this.value._toDart(),
      text: this.text._toDart()
    );
  }
}

extension _DartTo_COrderedValue on OrderedValue {
  _COrderedValue _copyFromDartTo_COrderedValue() {
    final res = _COrderedValueMakeDefault();
    res.value = this.value._copyFromDartTo_CString();
    res.text = this.text._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _COrderedValueRelease on _COrderedValue {
  void _releaseIntermediate() {
    value._releaseIntermediate();
    text._releaseIntermediate();
  }
}

// MARK: - List<OrderedValue> <-> _CArray_COrderedValue

final class _CArray_COrderedValue extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_COrderedValueToDart on _CArray_COrderedValue {
  List<OrderedValue> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_COrderedValue on List<OrderedValue> {
  _CArray_COrderedValue _copyFromDartTo_CArray_COrderedValue() {
    final cArray = _CArray_COrderedValuemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_COrderedValue();
        _CArray_COrderedValueaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_COrderedValueBasicFunctions on _CArray_COrderedValue {
  void _releaseIntermediate() {
    _CArray_COrderedValue_release(this);
  }

  static final _listToFill = <OrderedValue>[];

  static void _iterate(_COrderedValue item) {
    _listToFill.add(item._toDart());
  }

  List<OrderedValue> _fillFromC() {
    _forEach_CArray_COrderedValue(this, ffi.Pointer.fromFunction<ffi.Void Function(_COrderedValue)>(_iterate));
    final result = List<OrderedValue>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - OrderedValues

/** Описывает набор дискретных упорядоченных значений. */
class OrderedValues {
  /** Набор значений. Упорядочен по возрастанию. */
  final List<OrderedValue> values;
  /** Индекс текущего установленного минимального значения. */
  final int? currentMinIndex;
  /** Индекс текущего установленного максимального значения. */
  final int? currentMaxIndex;

  const OrderedValues({
    required this.values,
    this.currentMinIndex = null,
    this.currentMaxIndex = null
  });

  OrderedValues copyWith({
    List<OrderedValue>? values,
    Optional<int?>? currentMinIndex,
    Optional<int?>? currentMaxIndex
  }) {
    return OrderedValues(
      values: values ?? this.values,
      currentMinIndex: currentMinIndex != null ? currentMinIndex.value : this.currentMinIndex,
      currentMaxIndex: currentMaxIndex != null ? currentMaxIndex.value : this.currentMaxIndex
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is OrderedValues &&
    other.runtimeType == runtimeType &&
    other.values == values &&
    other.currentMinIndex == currentMinIndex &&
    other.currentMaxIndex == currentMaxIndex;

  @override
  int get hashCode {
    return Object.hash(values, currentMinIndex, currentMaxIndex);
  }

}
final class _COrderedValues extends ffi.Struct {
  external _CArray_COrderedValue values;

  external _COptional_uint64_t currentMinIndex;

  external _COptional_uint64_t currentMaxIndex;

}
// MARK: - OrderedValues <-> _COrderedValues

extension _COrderedValuesToDart on _COrderedValues {
  OrderedValues _toDart() {
    return OrderedValues(
      values: this.values._toDart(),
      currentMinIndex: this.currentMinIndex._toDart(),
      currentMaxIndex: this.currentMaxIndex._toDart()
    );
  }
}

extension _DartTo_COrderedValues on OrderedValues {
  _COrderedValues _copyFromDartTo_COrderedValues() {
    final res = _COrderedValuesMakeDefault();
    res.values = this.values._copyFromDartTo_CArray_COrderedValue();
    res.currentMinIndex = this.currentMinIndex._copyFromDartTo_COptional_uint64_t();
    res.currentMaxIndex = this.currentMaxIndex._copyFromDartTo_COptional_uint64_t();
    return res;
  }
}
extension _COrderedValuesRelease on _COrderedValues {
  void _releaseIntermediate() {
    values._releaseIntermediate();
  }
}

// MARK: - Range

/** Описывает набор непрерывных или дискретных упорядоченных значений. */
final class Range {
  final Object? _value;
  final int _index;

  Range._raw(this._value, this._index);

  Range.borders(Borders value) : this._raw(value, 0);
  Range.orderedValues(OrderedValues value) : this._raw(value, 1);

  bool get isBorders => this._index == 0;
  Borders? get asBorders => this.isBorders ? this._value as Borders : null;

  bool get isOrderedValues => this._index == 1;
  OrderedValues? get asOrderedValues => this.isOrderedValues ? this._value as OrderedValues : null;

  T match<T>({
    required T Function(Borders value) borders,
    required T Function(OrderedValues value) orderedValues,
  }) {
    return switch (this._index) {
      0 => borders(this._value as Borders),
      1 => orderedValues(this._value as OrderedValues),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "Range(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Range &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CRangeImpl extends ffi.Union {
  external _CBorders _borders;
  external _COrderedValues _orderedValues;
}

final class _CRange extends ffi.Struct {
  external _CRangeImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CRangeBasicFunctions on _CRange {
  void _releaseIntermediate() {
    _CRange_release(this);
  }
}
	
// MARK: - Range <-> CRange

extension _CRangeToDart on _CRange {
  Range _toDart() {
    return switch (this._index) {
      0 => Range.borders(this._impl._borders._toDart()),
      1 => Range.orderedValues(this._impl._orderedValues._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CRange on Range {
  _CRange _copyFromDartTo_CRange() {
    var res = _CRangeMakeDefault();
    this.match<void>(
      borders: (Borders value) {
        res._impl._borders = value._copyFromDartTo_CBorders();
        res._index = 0;
      },
      orderedValues: (OrderedValues value) {
        res._impl._orderedValues = value._copyFromDartTo_COrderedValues();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - RangeWidget

/** Виджет для представления непрерывного или дискретного набора упорядоченных значений. */
class RangeWidget extends Widget implements ffi.Finalizable {
  /**
   Получение набора упорядоченных значений.
  
   - Returns: набор упорядоченных значений.
  */
  Range get range {
    _CRange res = _CRangeWidget_range(_CRangeWidgetMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRangeWidget_releasePtr);

  RangeWidget._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RangeWidget._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RangeWidget._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RangeWidget &&
    other.runtimeType == runtimeType &&
    _CRangeWidget_cg_objectIdentifier(this._self) == _CRangeWidget_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRangeWidget_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RangeWidget: Methods

  /**
   Установка текущих выбранных значений.
  
   - Parameter min: текущее минимальное значение.
   - Parameter max: текущее максимальное значение.
  */
  void setValues(
    double min,
    double max
  )  {
    void res = _CRangeWidget_setValues_double_double(_CRangeWidgetMakeDefault().._impl=_self, min, max);
    return res;
  }

}

// MARK: - RangeWidget <-> CRangeWidget

final class _CRangeWidget extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRangeWidgetBasicFunctions on _CRangeWidget {
  void _releaseIntermediate() {
    _CRangeWidget_release(_impl);
  }

  _CRangeWidget _retain() {
    return _CRangeWidget_retain(_impl);
  }
}

extension _CRangeWidgetToDart on _CRangeWidget {
  RangeWidget _toDart() {
    return RangeWidget._create(_retain()._impl);
  }
}


extension _DartToCRangeWidget on RangeWidget {
  _CRangeWidget _copyFromDartTo_CRangeWidget() {
    return (_CRangeWidgetMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SearchResult

/** Результат работы поисковика. */
class SearchResult implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Первая страница результатов поиска.
  
   - Returns: ненулевой указатель на первую страницу, если результаты есть
   нулевой указатель, если ничего не найдено
  */
  Page? get firstPage {
    _COptional_CPage res = _CSearchResult_firstPage(_CSearchResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Прямоугольная область, подходящая для отображения результатов поиска. */
  Geometry? get representativeArea {
    _COptional_CGeometry res = _CSearchResult_representativeArea(_CSearchResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Асинхронное получение маркеров. */
  CancelableOperation<List<ItemMarkerInfo>?> get itemMarkerInfos {
    _CFuture_COptional_CArray_CItemMarkerInfo res = _CSearchResult_itemMarkerInfos(_CSearchResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Тип поискового запроса. */
  SearchResultType get searchResultType {
    _CSearchResultType res = _CSearchResult_searchResultType(_CSearchResultMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Динамические фильтры для этого запроса. */
  List<DynamicFilter> get dynamicFilters {
    _CArray_CDynamicFilter res = _CSearchResult_dynamicFilters(_CSearchResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Виджеты быстрых фильтров.
  
   - Note: Это так называемые "быстрые фильтры" - фильтры, наиболее интересные пользователю. Их не больше 5.
  */
  List<Widget> get actionWidgets {
    _CArray_CWidget res = _CSearchResult_actionWidgets(_CSearchResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Виджеты фильтров. */
  List<Widget> get mainWidgets {
    _CArray_CWidget res = _CSearchResult_mainWidgets(_CSearchResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Признак того, что первый результат пригоден для непосредственного использования. */
  bool get autoUseFirstResult {
    bool res = _CSearchResult_autoUseFirstResult(_CSearchResultMakeDefault().._impl=_self);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSearchResult_releasePtr);

  SearchResult._raw(this._self);
  factory SearchResult._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchResult._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchResult &&
    other.runtimeType == runtimeType &&
    _CSearchResult_cg_objectIdentifier(this._self) == _CSearchResult_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchResult_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: SearchResult: Methods

  /**
   Получение текстов маркеров по их идентификаторам.
   Возвращается vector
   <future
   >,
   так как в облако за запрос можно отправить не более 50 идентификаторов.
  
   - Parameter objectIds: Идентификаторы маркеров.
  */
  List<CancelableOperation<List<UIMarkerInfo>>> markerTitles(
    List<DgisObjectId> objectIds
  )  {
    var _a1 = objectIds._copyFromDartTo_CArray_CDgisObjectId();
    _CArray_CFuture_CArray_CUIMarkerInfo res = _CSearchResult_markerTitles_CArray_CDgisObjectId(_CSearchResultMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - SearchResult <-> CSearchResult

final class _CSearchResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchResultBasicFunctions on _CSearchResult {
  void _releaseIntermediate() {
    _CSearchResult_release(_impl);
  }

  _CSearchResult _retain() {
    return _CSearchResult_retain(_impl);
  }
}

extension _CSearchResultToDart on _CSearchResult {
  SearchResult _toDart() {
    return SearchResult._create(_retain()._impl);
  }
}


extension _DartToCSearchResult on SearchResult {
  _CSearchResult _copyFromDartTo_CSearchResult() {
    return (_CSearchResultMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GeometryKind

enum GeometryKind {
  point(0),
  polyline(1),
  polygon(2),
  complex(3),
  ;

  const GeometryKind(this.rawValue);
  final int rawValue;

  static GeometryKind getByValue(int value) {
    return GeometryKind.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CGeometryKind extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CGeometryKindBasicFunctions on _CGeometryKind {
  void _releaseIntermediate() {
  }
}

extension _CGeometryKindToDart on _CGeometryKind {
  GeometryKind _toDart() {
    return GeometryKind.getByValue(this.rawValue);
  }
}

extension _DartTo_CGeometryKind on GeometryKind {
  _CGeometryKind _copyFromDartTo_CGeometryKind() {
    return _CGeometryKindMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Geometry

/** Объект геометрии. */
class Geometry implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  GeometryKind get kind {
    _CGeometryKind res = _CGeometry_kind(_CGeometryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Прямоугольник минимального размера, содержащий геометрию. */
  GeoRect get bounds {
    _CGeoRect res = _CGeometry_bounds(_CGeometryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Минимальнная точка ограничивающего прямоугольника. */
  GeoPoint get minPoint {
    _CGeoPoint res = _CGeometry_minPoint(_CGeometryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Максимальная точка ограничивающего прямоугольника. */
  GeoPoint get maxPoint {
    _CGeoPoint res = _CGeometry_maxPoint(_CGeometryMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CGeometry_releasePtr);

  Geometry._raw(this._self);
  factory Geometry._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Geometry._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Geometry &&
    other.runtimeType == runtimeType &&
    _CGeometry_cg_objectIdentifier(this._self) == _CGeometry_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGeometry_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Geometry: Methods

  /**
   Функция intersects позволяет определить, имеет ли данная геометрия
   пересечение с другим объектом геометрии
  
   - Parameter geometry: объект геометрии для проверки пересечения
   При вычислении пересечения с IPointGeometry высота (elevation) игнорируется
  */
  bool intersects(
    Geometry geometry
  )  {
    var _a1 = geometry._copyFromDartTo_CGeometry();
    bool res = _CGeometry_intersects_CGeometry(_CGeometryMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - Geometry <-> CGeometry

final class _CGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGeometryBasicFunctions on _CGeometry {
  void _releaseIntermediate() {
    _CGeometry_release(_impl);
  }

  _CGeometry _retain() {
    return _CGeometry_retain(_impl);
  }
}

extension _CGeometryToDart on _CGeometry {
  Geometry _toDart() {
    final selector = _CGeometry_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = Geometry._create(_retain()._impl);
        return res;
      case 1:
        final res = PointGeometry._create(_retain()._impl);
        return res;
      case 2:
        final res = PolygonGeometry._create(_retain()._impl);
        return res;
      case 3:
        final res = PolylineGeometry._create(_retain()._impl);
        return res;
      case 4:
        final res = ComplexGeometry._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCGeometry on Geometry {
  _CGeometry _copyFromDartTo_CGeometry() {
    return (_CGeometryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Geometry? <-> _COptional_CGeometry

final class _COptional_CGeometry extends ffi.Struct {
  
  external _CGeometry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGeometryBasicFunctions on _COptional_CGeometry {
  void _releaseIntermediate() {
    _COptional_CGeometry_release(this);
  }
}

extension _COptional_CGeometryToDart on _COptional_CGeometry {
  Geometry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGeometry on Geometry? {
  _COptional_CGeometry _copyFromDartTo_COptional_CGeometry() {
    final cOptional = _COptional_CGeometryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGeometry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CancelableOperation<List<ItemMarkerInfo>?> <-> _CFuture_COptional_CArray_CItemMarkerInfo

final class _CFuture_COptional_CArray_CItemMarkerInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_COptional_CArray_CItemMarkerInfo_Cancellable {
  final Completer<List<ItemMarkerInfo>?> completer;
  final _CFuture_COptional_CArray_CItemMarkerInfo _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_COptional_CArray_CItemMarkerInfo, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_COptional_CArray_CItemMarkerInfo_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_COptional_CArray_CItemMarkerInfoBasicFunctions on _CFuture_COptional_CArray_CItemMarkerInfo {
  void _releaseIntermediate() {
    _CFuture_COptional_CArray_CItemMarkerInfo_release(this);
  }

  _CFuture_COptional_CArray_CItemMarkerInfo _retain() {
    return _CFuture_COptional_CArray_CItemMarkerInfo_retain(this);
  }
}

extension _CFuture_COptional_CArray_CItemMarkerInfoToDart on _CFuture_COptional_CArray_CItemMarkerInfo {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_COptional_CArray_CItemMarkerInfo_Cancellable>{};

  static void valueFunction(_COptional_CArray_CItemMarkerInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<List<ItemMarkerInfo>?> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<List<ItemMarkerInfo>?>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CArray_CItemMarkerInfo, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_COptional_CArray_CItemMarkerInfoReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_COptional_CArray_CItemMarkerInfo_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_COptional_CArray_CItemMarkerInfo on CancelableOperation<List<ItemMarkerInfo>?> {
  _CFuture_COptional_CArray_CItemMarkerInfo _copyFromDartTo_CFuture_COptional_CArray_CItemMarkerInfo() {
    return _CFuture_COptional_CArray_CItemMarkerInfoMakeDefault();
  }
}
	
// MARK: - List<ItemMarkerInfo> <-> _CArray_CItemMarkerInfo

final class _CArray_CItemMarkerInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CItemMarkerInfoToDart on _CArray_CItemMarkerInfo {
  List<ItemMarkerInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CItemMarkerInfo on List<ItemMarkerInfo> {
  _CArray_CItemMarkerInfo _copyFromDartTo_CArray_CItemMarkerInfo() {
    final cArray = _CArray_CItemMarkerInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CItemMarkerInfo();
        _CArray_CItemMarkerInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CItemMarkerInfoBasicFunctions on _CArray_CItemMarkerInfo {
  void _releaseIntermediate() {
    _CArray_CItemMarkerInfo_release(this);
  }

  static final _listToFill = <ItemMarkerInfo>[];

  static void _iterate(_CItemMarkerInfo item) {
    _listToFill.add(item._toDart());
  }

  List<ItemMarkerInfo> _fillFromC() {
    _forEach_CArray_CItemMarkerInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CItemMarkerInfo)>(_iterate));
    final result = List<ItemMarkerInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<ItemMarkerInfo>? <-> _COptional_CArray_CItemMarkerInfo

final class _COptional_CArray_CItemMarkerInfo extends ffi.Struct {
  
  external _CArray_CItemMarkerInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CArray_CItemMarkerInfoBasicFunctions on _COptional_CArray_CItemMarkerInfo {
  void _releaseIntermediate() {
    _COptional_CArray_CItemMarkerInfo_release(this);
  }
}

extension _COptional_CArray_CItemMarkerInfoToDart on _COptional_CArray_CItemMarkerInfo {
  List<ItemMarkerInfo>? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CArray_CItemMarkerInfo on List<ItemMarkerInfo>? {
  _COptional_CArray_CItemMarkerInfo _copyFromDartTo_COptional_CArray_CItemMarkerInfo() {
    final cOptional = _COptional_CArray_CItemMarkerInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CArray_CItemMarkerInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<CancelableOperation<List<UIMarkerInfo>>> <-> _CArray_CFuture_CArray_CUIMarkerInfo

final class _CArray_CFuture_CArray_CUIMarkerInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CFuture_CArray_CUIMarkerInfoToDart on _CArray_CFuture_CArray_CUIMarkerInfo {
  List<CancelableOperation<List<UIMarkerInfo>>> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CFuture_CArray_CUIMarkerInfo on List<CancelableOperation<List<UIMarkerInfo>>> {
  _CArray_CFuture_CArray_CUIMarkerInfo _copyFromDartTo_CArray_CFuture_CArray_CUIMarkerInfo() {
    final cArray = _CArray_CFuture_CArray_CUIMarkerInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CFuture_CArray_CUIMarkerInfo();
        _CArray_CFuture_CArray_CUIMarkerInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CFuture_CArray_CUIMarkerInfoBasicFunctions on _CArray_CFuture_CArray_CUIMarkerInfo {
  void _releaseIntermediate() {
    _CArray_CFuture_CArray_CUIMarkerInfo_release(this);
  }

  static final _listToFill = <CancelableOperation<List<UIMarkerInfo>>>[];

  static void _iterate(_CFuture_CArray_CUIMarkerInfo item) {
    _listToFill.add(item._toDart());
  }

  List<CancelableOperation<List<UIMarkerInfo>>> _fillFromC() {
    _forEach_CArray_CFuture_CArray_CUIMarkerInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CFuture_CArray_CUIMarkerInfo)>(_iterate));
    final result = List<CancelableOperation<List<UIMarkerInfo>>>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - CancelableOperation<List<UIMarkerInfo>> <-> _CFuture_CArray_CUIMarkerInfo

final class _CFuture_CArray_CUIMarkerInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CArray_CUIMarkerInfo_Cancellable {
  final Completer<List<UIMarkerInfo>> completer;
  final _CFuture_CArray_CUIMarkerInfo _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CArray_CUIMarkerInfo, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CArray_CUIMarkerInfo_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CArray_CUIMarkerInfoBasicFunctions on _CFuture_CArray_CUIMarkerInfo {
  void _releaseIntermediate() {
    _CFuture_CArray_CUIMarkerInfo_release(this);
  }

  _CFuture_CArray_CUIMarkerInfo _retain() {
    return _CFuture_CArray_CUIMarkerInfo_retain(this);
  }
}

extension _CFuture_CArray_CUIMarkerInfoToDart on _CFuture_CArray_CUIMarkerInfo {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CArray_CUIMarkerInfo_Cancellable>{};

  static void valueFunction(_CArray_CUIMarkerInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<List<UIMarkerInfo>> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<List<UIMarkerInfo>>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CUIMarkerInfo, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CArray_CUIMarkerInfoReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CArray_CUIMarkerInfo_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CArray_CUIMarkerInfo on CancelableOperation<List<UIMarkerInfo>> {
  _CFuture_CArray_CUIMarkerInfo _copyFromDartTo_CFuture_CArray_CUIMarkerInfo() {
    return _CFuture_CArray_CUIMarkerInfoMakeDefault();
  }
}
	
// MARK: - List<UIMarkerInfo> <-> _CArray_CUIMarkerInfo

final class _CArray_CUIMarkerInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CUIMarkerInfoToDart on _CArray_CUIMarkerInfo {
  List<UIMarkerInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CUIMarkerInfo on List<UIMarkerInfo> {
  _CArray_CUIMarkerInfo _copyFromDartTo_CArray_CUIMarkerInfo() {
    final cArray = _CArray_CUIMarkerInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CUIMarkerInfo();
        _CArray_CUIMarkerInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CUIMarkerInfoBasicFunctions on _CArray_CUIMarkerInfo {
  void _releaseIntermediate() {
    _CArray_CUIMarkerInfo_release(this);
  }

  static final _listToFill = <UIMarkerInfo>[];

  static void _iterate(_CUIMarkerInfo item) {
    _listToFill.add(item._toDart());
  }

  List<UIMarkerInfo> _fillFromC() {
    _forEach_CArray_CUIMarkerInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CUIMarkerInfo)>(_iterate));
    final result = List<UIMarkerInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<DgisObjectId> <-> _CArray_CDgisObjectId

final class _CArray_CDgisObjectId extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CDgisObjectIdToDart on _CArray_CDgisObjectId {
  List<DgisObjectId> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CDgisObjectId on List<DgisObjectId> {
  _CArray_CDgisObjectId _copyFromDartTo_CArray_CDgisObjectId() {
    final cArray = _CArray_CDgisObjectIdmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CDgisObjectId();
        _CArray_CDgisObjectIdaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CDgisObjectIdBasicFunctions on _CArray_CDgisObjectId {
  void _releaseIntermediate() {
    _CArray_CDgisObjectId_release(this);
  }

  static final _listToFill = <DgisObjectId>[];

  static void _iterate(_CDgisObjectId item) {
    _listToFill.add(item._toDart());
  }

  List<DgisObjectId> _fillFromC() {
    _forEach_CArray_CDgisObjectId(this, ffi.Pointer.fromFunction<ffi.Void Function(_CDgisObjectId)>(_iterate));
    final result = List<DgisObjectId>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<Widget> <-> _CArray_CWidget

final class _CArray_CWidget extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CWidgetToDart on _CArray_CWidget {
  List<Widget> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CWidget on List<Widget> {
  _CArray_CWidget _copyFromDartTo_CArray_CWidget() {
    final cArray = _CArray_CWidgetmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CWidget();
        _CArray_CWidgetaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CWidgetBasicFunctions on _CArray_CWidget {
  void _releaseIntermediate() {
    _CArray_CWidget_release(this);
  }

  static final _listToFill = <Widget>[];

  static void _iterate(_CWidget item) {
    _listToFill.add(item._toDart());
  }

  List<Widget> _fillFromC() {
    _forEach_CArray_CWidget(this, ffi.Pointer.fromFunction<ffi.Void Function(_CWidget)>(_iterate));
    final result = List<Widget>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - SearchQuery

/** Поисковый запрос. */
class SearchQuery implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSearchQuery_releasePtr);

  SearchQuery._raw(this._self);
  factory SearchQuery._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchQuery._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchQuery &&
    other.runtimeType == runtimeType &&
    _CSearchQuery_cg_objectIdentifier(this._self) == _CSearchQuery_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchQuery_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SearchQuery <-> CSearchQuery

final class _CSearchQuery extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchQueryBasicFunctions on _CSearchQuery {
  void _releaseIntermediate() {
    _CSearchQuery_release(_impl);
  }

  _CSearchQuery _retain() {
    return _CSearchQuery_retain(_impl);
  }
}

extension _CSearchQueryToDart on _CSearchQuery {
  SearchQuery _toDart() {
    return SearchQuery._create(_retain()._impl);
  }
}


extension _DartToCSearchQuery on SearchQuery {
  _CSearchQuery _copyFromDartTo_CSearchQuery() {
    return (_CSearchQueryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SuggestObjectHandler

/** Предложен конкретный объект справочника. */
class SuggestObjectHandler implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Подсказанный объект. */
  DirectoryObject get item {
    _CDirectoryObject res = _CSuggestObjectHandler_item(_CSuggestObjectHandlerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSuggestObjectHandler_releasePtr);

  SuggestObjectHandler._raw(this._self);
  factory SuggestObjectHandler._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SuggestObjectHandler._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SuggestObjectHandler &&
    other.runtimeType == runtimeType &&
    _CSuggestObjectHandler_cg_objectIdentifier(this._self) == _CSuggestObjectHandler_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSuggestObjectHandler_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SuggestObjectHandler <-> CSuggestObjectHandler

final class _CSuggestObjectHandler extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSuggestObjectHandlerBasicFunctions on _CSuggestObjectHandler {
  void _releaseIntermediate() {
    _CSuggestObjectHandler_release(_impl);
  }

  _CSuggestObjectHandler _retain() {
    return _CSuggestObjectHandler_retain(_impl);
  }
}

extension _CSuggestObjectHandlerToDart on _CSuggestObjectHandler {
  SuggestObjectHandler _toDart() {
    return SuggestObjectHandler._create(_retain()._impl);
  }
}


extension _DartToCSuggestObjectHandler on SuggestObjectHandler {
  _CSuggestObjectHandler _copyFromDartTo_CSuggestObjectHandler() {
    return (_CSuggestObjectHandlerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PerformSearchHandler

/** Предложено поискать определенный набор объектов. */
class PerformSearchHandler implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Запрос для прогона через поисковик. */
  SearchQuery get searchQuery {
    _CSearchQuery res = _CPerformSearchHandler_searchQuery(_CPerformSearchHandlerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPerformSearchHandler_releasePtr);

  PerformSearchHandler._raw(this._self);
  factory PerformSearchHandler._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PerformSearchHandler._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PerformSearchHandler &&
    other.runtimeType == runtimeType &&
    _CPerformSearchHandler_cg_objectIdentifier(this._self) == _CPerformSearchHandler_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPerformSearchHandler_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - PerformSearchHandler <-> CPerformSearchHandler

final class _CPerformSearchHandler extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPerformSearchHandlerBasicFunctions on _CPerformSearchHandler {
  void _releaseIntermediate() {
    _CPerformSearchHandler_release(_impl);
  }

  _CPerformSearchHandler _retain() {
    return _CPerformSearchHandler_retain(_impl);
  }
}

extension _CPerformSearchHandlerToDart on _CPerformSearchHandler {
  PerformSearchHandler _toDart() {
    return PerformSearchHandler._create(_retain()._impl);
  }
}


extension _DartToCPerformSearchHandler on PerformSearchHandler {
  _CPerformSearchHandler _copyFromDartTo_CPerformSearchHandler() {
    return (_CPerformSearchHandlerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - IncompleteTextHandler

/** Предложено автодополнение для введенного пользователем текста. */
class IncompleteTextHandler implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Нужно подставить в строку поиска этот текст и дать пользователю продолжить вводить запрос. */
  String get queryText {
    _CString res = _CIncompleteTextHandler_queryText(_CIncompleteTextHandlerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CIncompleteTextHandler_releasePtr);

  IncompleteTextHandler._raw(this._self);
  factory IncompleteTextHandler._create(ffi.Pointer<ffi.Void> self) {
    final classObject = IncompleteTextHandler._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IncompleteTextHandler &&
    other.runtimeType == runtimeType &&
    _CIncompleteTextHandler_cg_objectIdentifier(this._self) == _CIncompleteTextHandler_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CIncompleteTextHandler_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - IncompleteTextHandler <-> CIncompleteTextHandler

final class _CIncompleteTextHandler extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CIncompleteTextHandlerBasicFunctions on _CIncompleteTextHandler {
  void _releaseIntermediate() {
    _CIncompleteTextHandler_release(_impl);
  }

  _CIncompleteTextHandler _retain() {
    return _CIncompleteTextHandler_retain(_impl);
  }
}

extension _CIncompleteTextHandlerToDart on _CIncompleteTextHandler {
  IncompleteTextHandler _toDart() {
    return IncompleteTextHandler._create(_retain()._impl);
  }
}


extension _DartToCIncompleteTextHandler on IncompleteTextHandler {
  _CIncompleteTextHandler _copyFromDartTo_CIncompleteTextHandler() {
    return (_CIncompleteTextHandlerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SuggestObjectHandler? <-> _COptional_CSuggestObjectHandler

final class _COptional_CSuggestObjectHandler extends ffi.Struct {
  
  external _CSuggestObjectHandler value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CSuggestObjectHandlerBasicFunctions on _COptional_CSuggestObjectHandler {
  void _releaseIntermediate() {
    _COptional_CSuggestObjectHandler_release(this);
  }
}

extension _COptional_CSuggestObjectHandlerToDart on _COptional_CSuggestObjectHandler {
  SuggestObjectHandler? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CSuggestObjectHandler on SuggestObjectHandler? {
  _COptional_CSuggestObjectHandler _copyFromDartTo_COptional_CSuggestObjectHandler() {
    final cOptional = _COptional_CSuggestObjectHandlerMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CSuggestObjectHandler();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - PerformSearchHandler? <-> _COptional_CPerformSearchHandler

final class _COptional_CPerformSearchHandler extends ffi.Struct {
  
  external _CPerformSearchHandler value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CPerformSearchHandlerBasicFunctions on _COptional_CPerformSearchHandler {
  void _releaseIntermediate() {
    _COptional_CPerformSearchHandler_release(this);
  }
}

extension _COptional_CPerformSearchHandlerToDart on _COptional_CPerformSearchHandler {
  PerformSearchHandler? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CPerformSearchHandler on PerformSearchHandler? {
  _COptional_CPerformSearchHandler _copyFromDartTo_COptional_CPerformSearchHandler() {
    final cOptional = _COptional_CPerformSearchHandlerMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CPerformSearchHandler();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - IncompleteTextHandler? <-> _COptional_CIncompleteTextHandler

final class _COptional_CIncompleteTextHandler extends ffi.Struct {
  
  external _CIncompleteTextHandler value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CIncompleteTextHandlerBasicFunctions on _COptional_CIncompleteTextHandler {
  void _releaseIntermediate() {
    _COptional_CIncompleteTextHandler_release(this);
  }
}

extension _COptional_CIncompleteTextHandlerToDart on _COptional_CIncompleteTextHandler {
  IncompleteTextHandler? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CIncompleteTextHandler on IncompleteTextHandler? {
  _COptional_CIncompleteTextHandler _copyFromDartTo_COptional_CIncompleteTextHandler() {
    final cOptional = _COptional_CIncompleteTextHandlerMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CIncompleteTextHandler();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - SuggestHandler

/** Обработчик выбора подсказки. */
final class SuggestHandler {
  final Object? _value;
  final int _index;

  SuggestHandler._raw(this._value, this._index);

  SuggestHandler.objectHandler(SuggestObjectHandler? value) : this._raw(value, 0);
  SuggestHandler.performSearchHandler(PerformSearchHandler? value) : this._raw(value, 1);
  SuggestHandler.incompleteTextHandler(IncompleteTextHandler? value) : this._raw(value, 2);

  bool get isObjectHandler => this._index == 0;
  SuggestObjectHandler? get asObjectHandler => this.isObjectHandler ? this._value as SuggestObjectHandler? : null;

  bool get isPerformSearchHandler => this._index == 1;
  PerformSearchHandler? get asPerformSearchHandler => this.isPerformSearchHandler ? this._value as PerformSearchHandler? : null;

  bool get isIncompleteTextHandler => this._index == 2;
  IncompleteTextHandler? get asIncompleteTextHandler => this.isIncompleteTextHandler ? this._value as IncompleteTextHandler? : null;

  T match<T>({
    required T Function(SuggestObjectHandler? value) objectHandler,
    required T Function(PerformSearchHandler? value) performSearchHandler,
    required T Function(IncompleteTextHandler? value) incompleteTextHandler,
  }) {
    return switch (this._index) {
      0 => objectHandler(this._value as SuggestObjectHandler?),
      1 => performSearchHandler(this._value as PerformSearchHandler?),
      2 => incompleteTextHandler(this._value as IncompleteTextHandler?),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "SuggestHandler(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SuggestHandler &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CSuggestHandlerImpl extends ffi.Union {
  external _COptional_CSuggestObjectHandler _objectHandler;
  external _COptional_CPerformSearchHandler _performSearchHandler;
  external _COptional_CIncompleteTextHandler _incompleteTextHandler;
}

final class _CSuggestHandler extends ffi.Struct {
  external _CSuggestHandlerImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CSuggestHandlerBasicFunctions on _CSuggestHandler {
  void _releaseIntermediate() {
    _CSuggestHandler_release(this);
  }
}
	
// MARK: - SuggestHandler <-> CSuggestHandler

extension _CSuggestHandlerToDart on _CSuggestHandler {
  SuggestHandler _toDart() {
    return switch (this._index) {
      0 => SuggestHandler.objectHandler(this._impl._objectHandler._toDart()),
      1 => SuggestHandler.performSearchHandler(this._impl._performSearchHandler._toDart()),
      2 => SuggestHandler.incompleteTextHandler(this._impl._incompleteTextHandler._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CSuggestHandler on SuggestHandler {
  _CSuggestHandler _copyFromDartTo_CSuggestHandler() {
    var res = _CSuggestHandlerMakeDefault();
    this.match<void>(
      objectHandler: (SuggestObjectHandler? value) {
        res._impl._objectHandler = value._copyFromDartTo_COptional_CSuggestObjectHandler();
        res._index = 0;
      },
      performSearchHandler: (PerformSearchHandler? value) {
        res._impl._performSearchHandler = value._copyFromDartTo_COptional_CPerformSearchHandler();
        res._index = 1;
      },
      incompleteTextHandler: (IncompleteTextHandler? value) {
        res._impl._incompleteTextHandler = value._copyFromDartTo_COptional_CIncompleteTextHandler();
        res._index = 2;
      },
    );
    return res;
  }
}

// MARK: - MarkedUpTextSpan

/** Описывает поднабор байтов строки text. */
class MarkedUpTextSpan {
  final int offset;
  final int length;

  const MarkedUpTextSpan({
    required this.offset,
    required this.length
  });

  MarkedUpTextSpan copyWith({
    int? offset,
    int? length
  }) {
    return MarkedUpTextSpan(
      offset: offset ?? this.offset,
      length: length ?? this.length
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MarkedUpTextSpan &&
    other.runtimeType == runtimeType &&
    other.offset == offset &&
    other.length == length;

  @override
  int get hashCode {
    return Object.hash(offset, length);
  }

}
final class _CMarkedUpTextSpan extends ffi.Struct {
  @ffi.Uint64()
  external int offset;

  @ffi.Uint64()
  external int length;

}
// MARK: - MarkedUpTextSpan <-> _CMarkedUpTextSpan

extension _CMarkedUpTextSpanToDart on _CMarkedUpTextSpan {
  MarkedUpTextSpan _toDart() {
    return MarkedUpTextSpan(
      offset: this.offset,
      length: this.length
    );
  }
}

extension _DartTo_CMarkedUpTextSpan on MarkedUpTextSpan {
  _CMarkedUpTextSpan _copyFromDartTo_CMarkedUpTextSpan() {
    final res = _CMarkedUpTextSpanMakeDefault();
    res.offset = this.offset;
    res.length = this.length;
    return res;
  }
}
extension _CMarkedUpTextSpanRelease on _CMarkedUpTextSpan {
  void _releaseIntermediate() {
  }
}

// MARK: - List<MarkedUpTextSpan> <-> _CArray_CMarkedUpTextSpan

final class _CArray_CMarkedUpTextSpan extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CMarkedUpTextSpanToDart on _CArray_CMarkedUpTextSpan {
  List<MarkedUpTextSpan> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CMarkedUpTextSpan on List<MarkedUpTextSpan> {
  _CArray_CMarkedUpTextSpan _copyFromDartTo_CArray_CMarkedUpTextSpan() {
    final cArray = _CArray_CMarkedUpTextSpanmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CMarkedUpTextSpan();
        _CArray_CMarkedUpTextSpanaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CMarkedUpTextSpanBasicFunctions on _CArray_CMarkedUpTextSpan {
  void _releaseIntermediate() {
    _CArray_CMarkedUpTextSpan_release(this);
  }

  static final _listToFill = <MarkedUpTextSpan>[];

  static void _iterate(_CMarkedUpTextSpan item) {
    _listToFill.add(item._toDart());
  }

  List<MarkedUpTextSpan> _fillFromC() {
    _forEach_CArray_CMarkedUpTextSpan(this, ffi.Pointer.fromFunction<ffi.Void Function(_CMarkedUpTextSpan)>(_iterate));
    final result = List<MarkedUpTextSpan>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - MarkedUpText

/** Размеченный текст. */
class MarkedUpText {
  /** Текст. */
  final String text;
  /**
   Набор непересекающихся Span в порядке их расположения в строке text, описывающих части, совпадающие
   с пользовательским запросом.
  */
  final List<MarkedUpTextSpan> matchedParts;

  const MarkedUpText({
    required this.text,
    required this.matchedParts
  });

  MarkedUpText copyWith({
    String? text,
    List<MarkedUpTextSpan>? matchedParts
  }) {
    return MarkedUpText(
      text: text ?? this.text,
      matchedParts: matchedParts ?? this.matchedParts
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MarkedUpText &&
    other.runtimeType == runtimeType &&
    other.text == text &&
    other.matchedParts == matchedParts;

  @override
  int get hashCode {
    return Object.hash(text, matchedParts);
  }

}
final class _CMarkedUpText extends ffi.Struct {
  external _CString text;

  external _CArray_CMarkedUpTextSpan matchedParts;

}
// MARK: - MarkedUpText <-> _CMarkedUpText

extension _CMarkedUpTextToDart on _CMarkedUpText {
  MarkedUpText _toDart() {
    return MarkedUpText(
      text: this.text._toDart(),
      matchedParts: this.matchedParts._toDart()
    );
  }
}

extension _DartTo_CMarkedUpText on MarkedUpText {
  _CMarkedUpText _copyFromDartTo_CMarkedUpText() {
    final res = _CMarkedUpTextMakeDefault();
    res.text = this.text._copyFromDartTo_CString();
    res.matchedParts = this.matchedParts._copyFromDartTo_CArray_CMarkedUpTextSpan();
    return res;
  }
}
extension _CMarkedUpTextRelease on _CMarkedUpText {
  void _releaseIntermediate() {
    text._releaseIntermediate();
    matchedParts._releaseIntermediate();
  }
}

// MARK: - SuggestedType

/** Тип поисковой подсказки. */
enum SuggestedType {
  /** Город. */
  admDivCity(0),
  /** Страна. */
  admDivCountry(1),
  /** Район. */
  admDivDistrict(2),
  /** Район области. */
  admDivDistrictArea(3),
  /** Округ. */
  admDivDivision(4),
  /** Жилмассив, микрорайон. */
  admDivLivingArea(5),
  /** Разные площадные объекты: парки, пляжи, территории баз отдыха, озёра и прочие места. */
  admDivPlace(6),
  /** Регион (область/край/республика и т.п.). */
  admDivRegion(7),
  /** Населённый пункт (деревня, посёлок и т.п.). */
  admDivSettlement(8),
  /** Достопримечательность. */
  attraction(9),
  /** Дополнительный атрибут. */
  attribute(10),
  /** Компания. */
  branch(11),
  /** Здание. */
  building(12),
  /** Глобальная координата в системе координат WGS84 в формате lon, lat. */
  coordinates(13),
  /** Перекрёсток. */
  crossroad(14),
  /** Знак километра. */
  kilometerRoadSign(15),
  /** Наименования товаров. */
  marketAttribute(16),
  /** Бренд товаров. */
  marketBrand(17),
  /** Категории товаров. Требует наличия market.suggestor_category. */
  marketCategory(18),
  /** Необходим для раскрытия категорий товаров. */
  marketSuggestorCategory(19),
  /** Метакатегория. */
  metaRubric(20),
  /** Организация. */
  org(21),
  /** Парковка. */
  parking(22),
  /** Дорога. */
  road(23),
  /** Маршрут. */
  route(24),
  /** Тип маршрута. */
  routeType(25),
  /** Категория. */
  rubric(26),
  /** Остановка или станция общественного транспорта. */
  station(27),
  /** Вход на станцию. */
  stationEntrance(28),
  /** Станция метро. */
  stationMetro(29),
  /** Улица. */
  street(30),
  /** Текстовая подсказка. */
  text(31),
  /** На случай получения неожиданного типа. */
  unknown(32),
  ;

  const SuggestedType(this.rawValue);
  final int rawValue;

  static SuggestedType getByValue(int value) {
    return SuggestedType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSuggestedType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSuggestedTypeBasicFunctions on _CSuggestedType {
  void _releaseIntermediate() {
  }
}

extension _CSuggestedTypeToDart on _CSuggestedType {
  SuggestedType _toDart() {
    return SuggestedType.getByValue(this.rawValue);
  }
}

extension _DartTo_CSuggestedType on SuggestedType {
  _CSuggestedType _copyFromDartTo_CSuggestedType() {
    return _CSuggestedTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SuggestorType

/** Тип подсказчика. */
enum SuggestorType {
  /** Подсказка адресов. */
  address(0),
  /** Подсказка населённых пунктов. Может использоваться без указания проекта. */
  citySelector(1),
  /** Подсказка по объектам справочника (категории, фирмы, улицы, города и т.д.). */
  object(2),
  /** Подсказка мест. */
  places(3),
  /** Идеально подходит для быстрого поиска конечных объектов маршрута. Все результаты имеют id и координаты. */
  routeEndpoint(4),
  /** Подсказка категорий. */
  rubric(5),
  ;

  const SuggestorType(this.rawValue);
  final int rawValue;

  static SuggestorType getByValue(int value) {
    return SuggestorType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSuggestorType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSuggestorTypeBasicFunctions on _CSuggestorType {
  void _releaseIntermediate() {
  }
}

extension _CSuggestorTypeToDart on _CSuggestorType {
  SuggestorType _toDart() {
    return SuggestorType.getByValue(this.rawValue);
  }
}

extension _DartTo_CSuggestorType on SuggestorType {
  _CSuggestorType _copyFromDartTo_CSuggestorType() {
    return _CSuggestorTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Suggest

/** Поисковая подсказка. */
class Suggest implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Обработчик выбора подсказки. */
  SuggestHandler get handler {
    _CSuggestHandler res = _CSuggest_handler(_CSuggestMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Тип подсказки. */
  SuggestedType get suggestedType {
    _CSuggestedType res = _CSuggest_suggestedType(_CSuggestMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Заголовок подсказки. */
  MarkedUpText get title {
    _CMarkedUpText res = _CSuggest_title(_CSuggestMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Подзаголовок подсказки. */
  MarkedUpText get subtitle {
    _CMarkedUpText res = _CSuggest_subtitle(_CSuggestMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSuggest_releasePtr);

  Suggest._raw(this._self);
  factory Suggest._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Suggest._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Suggest &&
    other.runtimeType == runtimeType &&
    _CSuggest_cg_objectIdentifier(this._self) == _CSuggest_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSuggest_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Suggest <-> CSuggest

final class _CSuggest extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSuggestBasicFunctions on _CSuggest {
  void _releaseIntermediate() {
    _CSuggest_release(_impl);
  }

  _CSuggest _retain() {
    return _CSuggest_retain(_impl);
  }
}

extension _CSuggestToDart on _CSuggest {
  Suggest _toDart() {
    return Suggest._create(_retain()._impl);
  }
}


extension _DartToCSuggest on Suggest {
  _CSuggest _copyFromDartTo_CSuggest() {
    return (_CSuggestMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SuggestResult

/** Результат работы подсказчика. */
class SuggestResult implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Набор предложенных вариантов подсказок.
  
   - Note: набор пуст, если подходящие подсказки не найдены
  */
  List<Suggest> get suggests {
    _CArray_CSuggest res = _CSuggestResult_suggests(_CSuggestResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSuggestResult_releasePtr);

  SuggestResult._raw(this._self);
  factory SuggestResult._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SuggestResult._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SuggestResult &&
    other.runtimeType == runtimeType &&
    _CSuggestResult_cg_objectIdentifier(this._self) == _CSuggestResult_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSuggestResult_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SuggestResult <-> CSuggestResult

final class _CSuggestResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSuggestResultBasicFunctions on _CSuggestResult {
  void _releaseIntermediate() {
    _CSuggestResult_release(_impl);
  }

  _CSuggestResult _retain() {
    return _CSuggestResult_retain(_impl);
  }
}

extension _CSuggestResultToDart on _CSuggestResult {
  SuggestResult _toDart() {
    return SuggestResult._create(_retain()._impl);
  }
}


extension _DartToCSuggestResult on SuggestResult {
  _CSuggestResult _copyFromDartTo_CSuggestResult() {
    return (_CSuggestResultMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<Suggest> <-> _CArray_CSuggest

final class _CArray_CSuggest extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSuggestToDart on _CArray_CSuggest {
  List<Suggest> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSuggest on List<Suggest> {
  _CArray_CSuggest _copyFromDartTo_CArray_CSuggest() {
    final cArray = _CArray_CSuggestmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSuggest();
        _CArray_CSuggestaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CSuggestBasicFunctions on _CArray_CSuggest {
  void _releaseIntermediate() {
    _CArray_CSuggest_release(this);
  }

  static final _listToFill = <Suggest>[];

  static void _iterate(_CSuggest item) {
    _listToFill.add(item._toDart());
  }

  List<Suggest> _fillFromC() {
    _forEach_CArray_CSuggest(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSuggest)>(_iterate));
    final result = List<Suggest>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - SuggestQuery

/** Запрос поисковой подсказки. */
class SuggestQuery implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSuggestQuery_releasePtr);

  SuggestQuery._raw(this._self);
  factory SuggestQuery._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SuggestQuery._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SuggestQuery &&
    other.runtimeType == runtimeType &&
    _CSuggestQuery_cg_objectIdentifier(this._self) == _CSuggestQuery_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSuggestQuery_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SuggestQuery <-> CSuggestQuery

final class _CSuggestQuery extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSuggestQueryBasicFunctions on _CSuggestQuery {
  void _releaseIntermediate() {
    _CSuggestQuery_release(_impl);
  }

  _CSuggestQuery _retain() {
    return _CSuggestQuery_retain(_impl);
  }
}

extension _CSuggestQueryToDart on _CSuggestQuery {
  SuggestQuery _toDart() {
    return SuggestQuery._create(_retain()._impl);
  }
}


extension _DartToCSuggestQuery on SuggestQuery {
  _CSuggestQuery _copyFromDartTo_CSuggestQuery() {
    return (_CSuggestQueryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SearchManager

/**
 Поисковик.
 Основная точка входа для справочного API.
*/
class SearchManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSearchManager_releasePtr);

  SearchManager._raw(this._self);
  factory SearchManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchManager &&
    other.runtimeType == runtimeType &&
    _CSearchManager_cg_objectIdentifier(this._self) == _CSearchManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CSearchManager: Static Methods

  /** Создать поисковик, работающий онлайн. */
  static SearchManager createOnlineManager(
    Context context
  )  {
    var _a0 = context._copyFromDartTo_CContext();
    _CResult_CSearchManager res = _CSearchManager_S_createOnlineManager_CContext(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Создать поисковик, работающий с предзагруженными данными. */
  static SearchManager createOfflineManager(
    Context context
  )  {
    var _a0 = context._copyFromDartTo_CContext();
    _CResult_CSearchManager res = _CSearchManager_S_createOfflineManager_CContext(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создать поисковик, работающий онлайн или с предзагруженными данными в зависимости
   от наличия подключения к сети интернет.
  */
  static SearchManager createSmartManager(
    Context context
  )  {
    var _a0 = context._copyFromDartTo_CContext();
    _CResult_CSearchManager res = _CSearchManager_S_createSmartManager_CContext(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: SearchManager: Methods

  /**
   Получить подсказки, соответствующие данному запросу.
  
   - Returns: future, резолвящаяся в ненулевой указатель на результат подбора подсказок
   или exceptional future, если произошла ошибка при получении подсказок
  */
  CancelableOperation<SuggestResult> suggest(
    SuggestQuery query
  )  {
    var _a1 = query._copyFromDartTo_CSuggestQuery();
    _CFuture_CSuggestResult res = _CSearchManager_suggest_CSuggestQuery(_CSearchManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получить объекты справочника, соответствующие данному запросу.
  
   - Returns: future, резолвящаяся в ненулевой указатель на результат поиска
   или exceptional future, если произошла ошибка при получении результатов поиска
  */
  CancelableOperation<SearchResult> search(
    SearchQuery query
  )  {
    var _a1 = query._copyFromDartTo_CSearchQuery();
    _CFuture_CSearchResult res = _CSearchManager_search_CSearchQuery(_CSearchManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получить объект справочника по строковому идентификатору.
  
   - Returns: future, резолвящаяся в указатель на объект справочника.
   Если объект не найден, то вернется пустой указатель
  */
  CancelableOperation<DirectoryObject?> searchById(
    String id
  )  {
    var _a1 = id._copyFromDartTo_CString();
    _CFuture_COptional_CDirectoryObject res = _CSearchManager_searchById_CString(_CSearchManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получить объект справочника по идентификатору.
  
   - Returns: future, резолвящаяся в указатель на объект справочника.
   Если объект не найден, то вернется пустой указатель
  */
  CancelableOperation<DirectoryObject?> searchByDirectoryObjectId(
    DgisObjectId objectId
  )  {
    var _a1 = objectId._copyFromDartTo_CDgisObjectId();
    _CFuture_COptional_CDirectoryObject res = _CSearchManager_searchByDirectoryObjectId_CDgisObjectId(_CSearchManagerMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - SearchManager <-> CSearchManager

final class _CSearchManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchManagerBasicFunctions on _CSearchManager {
  void _releaseIntermediate() {
    _CSearchManager_release(_impl);
  }

  _CSearchManager _retain() {
    return _CSearchManager_retain(_impl);
  }
}

extension _CSearchManagerToDart on _CSearchManager {
  SearchManager _toDart() {
    return SearchManager._create(_retain()._impl);
  }
}


extension _DartToCSearchManager on SearchManager {
  _CSearchManager _copyFromDartTo_CSearchManager() {
    return (_CSearchManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SearchManager <-> _CResult_CSearchManager

final class _CResult_CSearchManagerImpl extends ffi.Union {
  
  external _CSearchManager _value;
  external _CError _error;
}

final class _CResult_CSearchManager extends ffi.Struct {
  external _CResult_CSearchManagerImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CSearchManagerBasicFunctions on _CResult_CSearchManager {
  void _releaseIntermediate() {
    _CResult_CSearchManager_release(this);
  }
}

extension _CResult_CSearchManagerToDart on _CResult_CSearchManager {
  SearchManager _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CSearchManager _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - CancelableOperation<SuggestResult> <-> _CFuture_CSuggestResult

final class _CFuture_CSuggestResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CSuggestResult_Cancellable {
  final Completer<SuggestResult> completer;
  final _CFuture_CSuggestResult _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CSuggestResult, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CSuggestResult_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CSuggestResultBasicFunctions on _CFuture_CSuggestResult {
  void _releaseIntermediate() {
    _CFuture_CSuggestResult_release(this);
  }

  _CFuture_CSuggestResult _retain() {
    return _CFuture_CSuggestResult_retain(this);
  }
}

extension _CFuture_CSuggestResultToDart on _CFuture_CSuggestResult {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CSuggestResult_Cancellable>{};

  static void valueFunction(_CSuggestResult cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<SuggestResult> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<SuggestResult>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CSuggestResult, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CSuggestResultReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CSuggestResult_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CSuggestResult on CancelableOperation<SuggestResult> {
  _CFuture_CSuggestResult _copyFromDartTo_CFuture_CSuggestResult() {
    return _CFuture_CSuggestResultMakeDefault();
  }
}
	
// MARK: - CancelableOperation<SearchResult> <-> _CFuture_CSearchResult

final class _CFuture_CSearchResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CSearchResult_Cancellable {
  final Completer<SearchResult> completer;
  final _CFuture_CSearchResult _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CSearchResult, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CSearchResult_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CSearchResultBasicFunctions on _CFuture_CSearchResult {
  void _releaseIntermediate() {
    _CFuture_CSearchResult_release(this);
  }

  _CFuture_CSearchResult _retain() {
    return _CFuture_CSearchResult_retain(this);
  }
}

extension _CFuture_CSearchResultToDart on _CFuture_CSearchResult {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CSearchResult_Cancellable>{};

  static void valueFunction(_CSearchResult cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<SearchResult> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<SearchResult>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CSearchResult, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CSearchResultReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CSearchResult_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CSearchResult on CancelableOperation<SearchResult> {
  _CFuture_CSearchResult _copyFromDartTo_CFuture_CSearchResult() {
    return _CFuture_CSearchResultMakeDefault();
  }
}
	
// MARK: - CancelableOperation<DirectoryObject?> <-> _CFuture_COptional_CDirectoryObject

final class _CFuture_COptional_CDirectoryObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_COptional_CDirectoryObject_Cancellable {
  final Completer<DirectoryObject?> completer;
  final _CFuture_COptional_CDirectoryObject _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_COptional_CDirectoryObject, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_COptional_CDirectoryObject_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_COptional_CDirectoryObjectBasicFunctions on _CFuture_COptional_CDirectoryObject {
  void _releaseIntermediate() {
    _CFuture_COptional_CDirectoryObject_release(this);
  }

  _CFuture_COptional_CDirectoryObject _retain() {
    return _CFuture_COptional_CDirectoryObject_retain(this);
  }
}

extension _CFuture_COptional_CDirectoryObjectToDart on _CFuture_COptional_CDirectoryObject {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_COptional_CDirectoryObject_Cancellable>{};

  static void valueFunction(_COptional_CDirectoryObject cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<DirectoryObject?> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<DirectoryObject?>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CDirectoryObject, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_COptional_CDirectoryObjectReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_COptional_CDirectoryObject_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_COptional_CDirectoryObject on CancelableOperation<DirectoryObject?> {
  _CFuture_COptional_CDirectoryObject _copyFromDartTo_CFuture_COptional_CDirectoryObject() {
    return _CFuture_COptional_CDirectoryObjectMakeDefault();
  }
}
	
// MARK: - DirectoryObject? <-> _COptional_CDirectoryObject

final class _COptional_CDirectoryObject extends ffi.Struct {
  
  external _CDirectoryObject value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CDirectoryObjectBasicFunctions on _COptional_CDirectoryObject {
  void _releaseIntermediate() {
    _COptional_CDirectoryObject_release(this);
  }
}

extension _COptional_CDirectoryObjectToDart on _COptional_CDirectoryObject {
  DirectoryObject? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CDirectoryObject on DirectoryObject? {
  _COptional_CDirectoryObject _copyFromDartTo_COptional_CDirectoryObject() {
    final cOptional = _COptional_CDirectoryObjectMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CDirectoryObject();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - SearchQueryBuilder

/**
 Построитель поисковых запросов.
 Поиск осуществляется по глобальному индексу, а также по локальным индексам сегментов,
 где сегмент - это некоторый кусок разбиения глобальной карты.
 Процедура выбора сегментов для поиска осуществляется следующими способами (по убыванию приоритета):
 1. Если явно задается область в виде полигона в запросе (spatial_restriction), то она учитывается в первую очередь.
 Способы ниже по приоритету отключаются, однако используются для учёта расстояний в релевантности поиска.
 2. При указании прямоугольной области интереса (bounding_rect), поиск ведется в некоторой ее окрестности.
 3. Если не указаны вышестоящие по приоритету параметры, то учитывается точка положения пользователя.

 - Todo: Данное условие пока не работает. Будет исправлено в ближайших релизах.
 4. При упоминании в тексте запроса широко известного объекта (город, область или другой топоним)
 добавляется в поиск тот сегмент, в который попадает точка найденного объекта из глобального индекса.
 5. Если не указано ничего из вышеперечисленного, то осуществляется поиск по глобальному индексу.
*/
class SearchQueryBuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSearchQueryBuilder_releasePtr);

  SearchQueryBuilder._raw(this._self);
  factory SearchQueryBuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchQueryBuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchQueryBuilder &&
    other.runtimeType == runtimeType &&
    _CSearchQueryBuilder_cg_objectIdentifier(this._self) == _CSearchQueryBuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchQueryBuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CSearchQueryBuilder: Static Methods

  /** Начать построение текстового поискового запроса c указанным текстом. */
  static SearchQueryBuilder fromQueryText(
    String queryText
  )  {
    var _a0 = queryText._copyFromDartTo_CString();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromQueryText_CString(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Начать построение поискового запроса на основе идентификаторов рубрик. */
  static SearchQueryBuilder fromRubricIds(
    List<RubricId> rubricIds
  )  {
    var _a0 = rubricIds._copyFromDartTo_CArray_CRubricId();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromRubricIds_CArray_CRubricId(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Начать построение текстового поискового запроса с фильтрацией по идентификаторам рубрик. */
  static SearchQueryBuilder fromQueryTextAndRubricIds(
    String queryText,
    List<RubricId> rubricIds
  )  {
    var _a0 = queryText._copyFromDartTo_CString();
    var _a1 = rubricIds._copyFromDartTo_CArray_CRubricId();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromQueryTextAndRubricIds_CString_CArray_CRubricId(_a0, _a1);
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Начать построение запроса на основе запроса #query для изменения части параметров.
  
   - Note: Исходный запрос #query остается без изменений
  */
  static SearchQueryBuilder fromQuery(
    SearchQuery query
  )  {
    var _a0 = query._copyFromDartTo_CSearchQuery();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromQuery_CSearchQuery(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Начать построение поискового запроса c указанным идентификатором организации. */
  static SearchQueryBuilder fromOrgId(
    OrgId orgId
  )  {
    var _a0 = orgId._copyFromDartTo_COrgId();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromOrgId_COrgId(_a0);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Начать построение поискового запроса c указанным идентификатором здания. */
  static SearchQueryBuilder fromBuildingId(
    BuildingId buildingId
  )  {
    var _a0 = buildingId._copyFromDartTo_CBuildingId();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromBuildingId_CBuildingId(_a0);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Начать построение поискового запроса c указанным центром области поиска. Радиус по умолчанию равен 250.
   Конфликтует с методом set_spatial_restriction.
   Работает только с онлайн поиском.
  */
  static SearchQueryBuilder fromGeoPoint(
    GeoPoint geoPoint
  )  {
    var _a0 = geoPoint._copyFromDartTo_CGeoPoint();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromGeoPoint_CGeoPoint(_a0);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: SearchQueryBuilder: Methods

  /**
   Задать ограничение области поиска в форме полигона.
   Первая и последняя точки полигона не обязаны совпадать.
   Конфликтует с методоми set_geo_point и from_geo_point.
  
   - Note: по умолчанию ограничение отсутствует.
  */
  SearchQueryBuilder setSpatialRestriction(
    List<GeoPoint>? spatialRestriction
  )  {
    var _a1 = spatialRestriction._copyFromDartTo_COptional_CArray_CGeoPoint();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPoint(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать прямоугольную область интереса в географических координатах.
   Типичным значением является visible_rect из ICamera - объемлющий прямоугольник области просмотра.
  */
  SearchQueryBuilder setAreaOfInterest(
    GeoRect? rect
  )  {
    var _a1 = rect._copyFromDartTo_COptional_CGeoRect();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setAreaOfInterest_COptional_CGeoRect(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать типы объектов, разрешенные в результате запроса.
  
   - Note: по умолчанию все, кроме Route
  */
  SearchQueryBuilder setAllowedResultTypes(
    List<ObjectType> allowedResultTypes
  )  {
    var _a1 = allowedResultTypes._copyFromDartTo_CArray_CObjectType();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setAllowedResultTypes_CArray_CObjectType(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать предпочитаемое количество элементов на странице результатов.
   Допустимы значения из диапазона [1; 50]
  
   - Note: по умолчанию 10
  */
  SearchQueryBuilder setPageSize(
    int pageSize
  )  {
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setPageSize_int32_t(_CSearchQueryBuilderMakeDefault().._impl=_self, pageSize);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Задать фильтрацию для поискового запроса. */
  SearchQueryBuilder setDirectoryFilter(
    DirectoryFilter filter
  )  {
    var _a1 = filter._copyFromDartTo_CDirectoryFilter();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setDirectoryFilter_CDirectoryFilter(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Задать сортировку для поискового запроса. */
  SearchQueryBuilder setSortingType(
    SortingType sortingType
  )  {
    var _a1 = sortingType._copyFromDartTo_CSortingType();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setSortingType_CSortingType(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать центр для поискового запроса. Радиус по умолчанию равен 250 метров.
   Конфликтует с методом set_spatial_restriction.
  */
  SearchQueryBuilder setGeoPoint(
    GeoPoint geoPoint
  )  {
    var _a1 = geoPoint._copyFromDartTo_CGeoPoint();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setGeoPoint_CGeoPoint(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать радиус поиска в метрах.
   Работает в сочетании с установленным geo_point.
   Для поискового запроса в точке ограничение от 0 до 2000.
   Для остальных запросов ограничение от 0 до 50000.
  */
  SearchQueryBuilder setRadius(
    Meter radius
  )  {
    var _a1 = radius._copyFromDartTo_CMeter();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setRadius_CMeter(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Сформировать поисковый запрос. */
  SearchQuery build()  {
    _CSearchQuery res = _CSearchQueryBuilder_build(_CSearchQueryBuilderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - SearchQueryBuilder <-> CSearchQueryBuilder

final class _CSearchQueryBuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchQueryBuilderBasicFunctions on _CSearchQueryBuilder {
  void _releaseIntermediate() {
    _CSearchQueryBuilder_release(_impl);
  }

  _CSearchQueryBuilder _retain() {
    return _CSearchQueryBuilder_retain(_impl);
  }
}

extension _CSearchQueryBuilderToDart on _CSearchQueryBuilder {
  SearchQueryBuilder _toDart() {
    return SearchQueryBuilder._create(_retain()._impl);
  }
}


extension _DartToCSearchQueryBuilder on SearchQueryBuilder {
  _CSearchQueryBuilder _copyFromDartTo_CSearchQueryBuilder() {
    return (_CSearchQueryBuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<GeoPoint>? <-> _COptional_CArray_CGeoPoint

final class _COptional_CArray_CGeoPoint extends ffi.Struct {
  
  external _CArray_CGeoPoint value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CArray_CGeoPointBasicFunctions on _COptional_CArray_CGeoPoint {
  void _releaseIntermediate() {
    _COptional_CArray_CGeoPoint_release(this);
  }
}

extension _COptional_CArray_CGeoPointToDart on _COptional_CArray_CGeoPoint {
  List<GeoPoint>? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CArray_CGeoPoint on List<GeoPoint>? {
  _COptional_CArray_CGeoPoint _copyFromDartTo_COptional_CArray_CGeoPoint() {
    final cOptional = _COptional_CArray_CGeoPointMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CArray_CGeoPoint();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - GeoRect? <-> _COptional_CGeoRect

final class _COptional_CGeoRect extends ffi.Struct {
  
  external _CGeoRect value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGeoRectBasicFunctions on _COptional_CGeoRect {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CGeoRectToDart on _COptional_CGeoRect {
  GeoRect? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGeoRect on GeoRect? {
  _COptional_CGeoRect _copyFromDartTo_COptional_CGeoRect() {
    final cOptional = _COptional_CGeoRectMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGeoRect();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - SuggestQueryBuilder

/** Построитель запросов к подсказчику. */
class SuggestQueryBuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSuggestQueryBuilder_releasePtr);

  SuggestQueryBuilder._raw(this._self);
  factory SuggestQueryBuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SuggestQueryBuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SuggestQueryBuilder &&
    other.runtimeType == runtimeType &&
    _CSuggestQueryBuilder_cg_objectIdentifier(this._self) == _CSuggestQueryBuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSuggestQueryBuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CSuggestQueryBuilder: Static Methods

  /** Начать построение запроса подсказки для заданного текста и области интереса. */
  static SuggestQueryBuilder fromQueryText(
    String queryText
  )  {
    var _a0 = queryText._copyFromDartTo_CString();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_S_fromQueryText_CString(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Начать построение запроса подсказки на основе запроса #query для изменения части параметров.
  
   - Note: Исходный запрос #query остается без изменений
  */
  static SuggestQueryBuilder fromQuery(
    SuggestQuery query
  )  {
    var _a0 = query._copyFromDartTo_CSuggestQuery();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_S_fromQuery_CSuggestQuery(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: SuggestQueryBuilder: Methods

  /**
   Задать ограничение области поиска в форме полигона.
   Первая и последняя точки полигона не обязаны совпадать.
  
   - Note: по умолчанию ограничение отсутствует
  */
  SuggestQueryBuilder setSpatialRestriction(
    List<GeoPoint>? spatialRestriction
  )  {
    var _a1 = spatialRestriction._copyFromDartTo_COptional_CArray_CGeoPoint();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPoint(_CSuggestQueryBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать прямоугольную область интереса в географических координатах.
   Типичным значением является visible_rect из ICamera - объемлющий прямоугольник области просмотра.
  */
  SuggestQueryBuilder setAreaOfInterest(
    GeoRect? rect
  )  {
    var _a1 = rect._copyFromDartTo_COptional_CGeoRect();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_setAreaOfInterest_COptional_CGeoRect(_CSuggestQueryBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать типы объектов, разрешенные в результате запроса.
  
   - Note: по умолчанию все, кроме Route
  */
  SuggestQueryBuilder setAllowedResultTypes(
    List<SuggestedType> allowedResultTypes
  )  {
    var _a1 = allowedResultTypes._copyFromDartTo_CArray_CSuggestedType();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_setAllowedResultTypes_CArray_CSuggestedType(_CSuggestQueryBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать тип подсказчика.
  
   - Note: по умолчанию #SuggestorType::Object
  */
  SuggestQueryBuilder setSuggestorType(
    SuggestorType suggestorType
  )  {
    var _a1 = suggestorType._copyFromDartTo_CSuggestorType();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_setSuggestorType_CSuggestorType(_CSuggestQueryBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать желаемое количество подсказок.
   Допустимы значения из диапазона [1; 50]
  
   - Note: по умолчанию 10
  */
  SuggestQueryBuilder setLimit(
    int limit
  )  {
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_setLimit_int32_t(_CSuggestQueryBuilderMakeDefault().._impl=_self, limit);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Сформировать запрос к подсказчику. */
  SuggestQuery build()  {
    _CSuggestQuery res = _CSuggestQueryBuilder_build(_CSuggestQueryBuilderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - SuggestQueryBuilder <-> CSuggestQueryBuilder

final class _CSuggestQueryBuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSuggestQueryBuilderBasicFunctions on _CSuggestQueryBuilder {
  void _releaseIntermediate() {
    _CSuggestQueryBuilder_release(_impl);
  }

  _CSuggestQueryBuilder _retain() {
    return _CSuggestQueryBuilder_retain(_impl);
  }
}

extension _CSuggestQueryBuilderToDart on _CSuggestQueryBuilder {
  SuggestQueryBuilder _toDart() {
    return SuggestQueryBuilder._create(_retain()._impl);
  }
}


extension _DartToCSuggestQueryBuilder on SuggestQueryBuilder {
  _CSuggestQueryBuilder _copyFromDartTo_CSuggestQueryBuilder() {
    return (_CSuggestQueryBuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<SuggestedType> <-> _CArray_CSuggestedType

final class _CArray_CSuggestedType extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSuggestedTypeToDart on _CArray_CSuggestedType {
  List<SuggestedType> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSuggestedType on List<SuggestedType> {
  _CArray_CSuggestedType _copyFromDartTo_CArray_CSuggestedType() {
    final cArray = _CArray_CSuggestedTypemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSuggestedType();
        _CArray_CSuggestedTypeaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CSuggestedTypeBasicFunctions on _CArray_CSuggestedType {
  void _releaseIntermediate() {
    _CArray_CSuggestedType_release(this);
  }

  static final _listToFill = <SuggestedType>[];

  static void _iterate(_CSuggestedType item) {
    _listToFill.add(item._toDart());
  }

  List<SuggestedType> _fillFromC() {
    _forEach_CArray_CSuggestedType(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSuggestedType)>(_iterate));
    final result = List<SuggestedType>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - ChangeType

enum ChangeType {
  add(0),
  remove(1),
  ;

  const ChangeType(this.rawValue);
  final int rawValue;

  static ChangeType getByValue(int value) {
    return ChangeType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CChangeType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CChangeTypeBasicFunctions on _CChangeType {
  void _releaseIntermediate() {
  }
}

extension _CChangeTypeToDart on _CChangeType {
  ChangeType _toDart() {
    return ChangeType.getByValue(this.rawValue);
  }
}

extension _DartTo_CChangeType on ChangeType {
  _CChangeType _copyFromDartTo_CChangeType() {
    return _CChangeTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SearchQueryWithInfo

/** Класс с дополнительной информацией о поисковом запросе для вывода в UI-элементах. */
class SearchQueryWithInfo implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Возвращает объект поискового запроса. */
  SearchQuery get searchQuery {
    _CSearchQuery res = _CSearchQueryWithInfo_searchQuery(_CSearchQueryWithInfoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Возвращает текст заголовка, который описывает объекты поискового
   запроса. Например, это может быть текст из поля title объекта
   ISuggest.
  */
  String get title {
    _CString res = _CSearchQueryWithInfo_title(_CSearchQueryWithInfoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Возвращает текст подзаголовка. Например, это может быть текст из поля
   subtitle объекта ISuggest.
  */
  String get subtitle {
    _CString res = _CSearchQueryWithInfo_subtitle(_CSearchQueryWithInfoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSearchQueryWithInfo_releasePtr);

  SearchQueryWithInfo._raw(this._self);
  factory SearchQueryWithInfo._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchQueryWithInfo._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory SearchQueryWithInfo(
    SearchQuery searchQuery,
    String title,
    String subtitle
  ) {
    var _a0 = searchQuery._copyFromDartTo_CSearchQuery();
    var _a1 = title._copyFromDartTo_CString();
    var _a2 = subtitle._copyFromDartTo_CString();
    _CSearchQueryWithInfo res = _CSearchQueryWithInfo_C_createWith_CSearchQuery_CString_CString(_a0, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    return SearchQueryWithInfo._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchQueryWithInfo &&
    other.runtimeType == runtimeType &&
    _CSearchQueryWithInfo_cg_objectIdentifier(this._self) == _CSearchQueryWithInfo_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchQueryWithInfo_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SearchQueryWithInfo <-> CSearchQueryWithInfo

final class _CSearchQueryWithInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchQueryWithInfoBasicFunctions on _CSearchQueryWithInfo {
  void _releaseIntermediate() {
    _CSearchQueryWithInfo_release(_impl);
  }

  _CSearchQueryWithInfo _retain() {
    return _CSearchQueryWithInfo_retain(_impl);
  }
}

extension _CSearchQueryWithInfoToDart on _CSearchQueryWithInfo {
  SearchQueryWithInfo _toDart() {
    return SearchQueryWithInfo._create(_retain()._impl);
  }
}


extension _DartToCSearchQueryWithInfo on SearchQueryWithInfo {
  _CSearchQueryWithInfo _copyFromDartTo_CSearchQueryWithInfo() {
    return (_CSearchQueryWithInfoMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SearchHistoryItem

/** Тип данных для элемента поиска, сохраненного в истории поиска: может быть объект или поисковый запрос. */
final class SearchHistoryItem {
  final Object? _value;
  final int _index;

  SearchHistoryItem._raw(this._value, this._index);

  SearchHistoryItem.directoryObject(DirectoryObject value) : this._raw(value, 0);
  SearchHistoryItem.searchQuery(SearchQueryWithInfo value) : this._raw(value, 1);

  bool get isDirectoryObject => this._index == 0;
  DirectoryObject? get asDirectoryObject => this.isDirectoryObject ? this._value as DirectoryObject : null;

  bool get isSearchQuery => this._index == 1;
  SearchQueryWithInfo? get asSearchQuery => this.isSearchQuery ? this._value as SearchQueryWithInfo : null;

  T match<T>({
    required T Function(DirectoryObject value) directoryObject,
    required T Function(SearchQueryWithInfo value) searchQuery,
  }) {
    return switch (this._index) {
      0 => directoryObject(this._value as DirectoryObject),
      1 => searchQuery(this._value as SearchQueryWithInfo),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "SearchHistoryItem(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchHistoryItem &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CSearchHistoryItemImpl extends ffi.Union {
  external _CDirectoryObject _directoryObject;
  external _CSearchQueryWithInfo _searchQuery;
}

final class _CSearchHistoryItem extends ffi.Struct {
  external _CSearchHistoryItemImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CSearchHistoryItemBasicFunctions on _CSearchHistoryItem {
  void _releaseIntermediate() {
    _CSearchHistoryItem_release(this);
  }
}
	
// MARK: - SearchHistoryItem <-> CSearchHistoryItem

extension _CSearchHistoryItemToDart on _CSearchHistoryItem {
  SearchHistoryItem _toDart() {
    return switch (this._index) {
      0 => SearchHistoryItem.directoryObject(this._impl._directoryObject._toDart()),
      1 => SearchHistoryItem.searchQuery(this._impl._searchQuery._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CSearchHistoryItem on SearchHistoryItem {
  _CSearchHistoryItem _copyFromDartTo_CSearchHistoryItem() {
    var res = _CSearchHistoryItemMakeDefault();
    this.match<void>(
      directoryObject: (DirectoryObject value) {
        res._impl._directoryObject = value._copyFromDartTo_CDirectoryObject();
        res._index = 0;
      },
      searchQuery: (SearchQueryWithInfo value) {
        res._impl._searchQuery = value._copyFromDartTo_CSearchQueryWithInfo();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - SearchHistoryResult

/** Результат работы истории поиска при запросе истории. */
class SearchHistoryResult implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Набор элементов истории поиска. */
  List<SearchHistoryItem> get items {
    _CArray_CSearchHistoryItem res = _CSearchHistoryResult_items(_CSearchHistoryResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSearchHistoryResult_releasePtr);

  SearchHistoryResult._raw(this._self);
  factory SearchHistoryResult._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchHistoryResult._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchHistoryResult &&
    other.runtimeType == runtimeType &&
    _CSearchHistoryResult_cg_objectIdentifier(this._self) == _CSearchHistoryResult_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchHistoryResult_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SearchHistoryResult <-> CSearchHistoryResult

final class _CSearchHistoryResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchHistoryResultBasicFunctions on _CSearchHistoryResult {
  void _releaseIntermediate() {
    _CSearchHistoryResult_release(_impl);
  }

  _CSearchHistoryResult _retain() {
    return _CSearchHistoryResult_retain(_impl);
  }
}

extension _CSearchHistoryResultToDart on _CSearchHistoryResult {
  SearchHistoryResult _toDart() {
    return SearchHistoryResult._create(_retain()._impl);
  }
}


extension _DartToCSearchHistoryResult on SearchHistoryResult {
  _CSearchHistoryResult _copyFromDartTo_CSearchHistoryResult() {
    return (_CSearchHistoryResultMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<SearchHistoryItem> <-> _CArray_CSearchHistoryItem

final class _CArray_CSearchHistoryItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSearchHistoryItemToDart on _CArray_CSearchHistoryItem {
  List<SearchHistoryItem> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSearchHistoryItem on List<SearchHistoryItem> {
  _CArray_CSearchHistoryItem _copyFromDartTo_CArray_CSearchHistoryItem() {
    final cArray = _CArray_CSearchHistoryItemmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSearchHistoryItem();
        _CArray_CSearchHistoryItemaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CSearchHistoryItemBasicFunctions on _CArray_CSearchHistoryItem {
  void _releaseIntermediate() {
    _CArray_CSearchHistoryItem_release(this);
  }

  static final _listToFill = <SearchHistoryItem>[];

  static void _iterate(_CSearchHistoryItem item) {
    _listToFill.add(item._toDart());
  }

  List<SearchHistoryItem> _fillFromC() {
    _forEach_CArray_CSearchHistoryItem(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSearchHistoryItem)>(_iterate));
    final result = List<SearchHistoryItem>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - SearchHistoryFilter

enum SearchHistoryFilter {
  none(0),
  object(1),
  searchQuery(2),
  ;

  const SearchHistoryFilter(this.rawValue);
  final int rawValue;

  static SearchHistoryFilter getByValue(int value) {
    return SearchHistoryFilter.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSearchHistoryFilter extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSearchHistoryFilterBasicFunctions on _CSearchHistoryFilter {
  void _releaseIntermediate() {
  }
}

extension _CSearchHistoryFilterToDart on _CSearchHistoryFilter {
  SearchHistoryFilter _toDart() {
    return SearchHistoryFilter.getByValue(this.rawValue);
  }
}

extension _DartTo_CSearchHistoryFilter on SearchHistoryFilter {
  _CSearchHistoryFilter _copyFromDartTo_CSearchHistoryFilter() {
    return _CSearchHistoryFilterMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SearchHistoryFilterEnumSet

class SearchHistoryFilterEnumSet extends EnumSet<SearchHistoryFilter> {
  SearchHistoryFilterEnumSet() : super();

  factory SearchHistoryFilterEnumSet.fromRawValue(int rawValue) {
    SearchHistoryFilterEnumSet enumSet = SearchHistoryFilterEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory SearchHistoryFilterEnumSet.of(Iterable<SearchHistoryFilter> elements) {
    SearchHistoryFilterEnumSet enumSet = SearchHistoryFilterEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory SearchHistoryFilterEnumSet.all() {
    SearchHistoryFilterEnumSet enumSet = SearchHistoryFilterEnumSet();
    enumSet.addAll(SearchHistoryFilter.values);
    return enumSet;
  }

  @override
  bool contains(SearchHistoryFilter value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<SearchHistoryFilter> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(SearchHistoryFilter value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<SearchHistoryFilter> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(SearchHistoryFilter value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<SearchHistoryFilter> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<SearchHistoryFilter> intersection(EnumSet<SearchHistoryFilter> other) =>
      SearchHistoryFilterEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<SearchHistoryFilter> union(EnumSet<SearchHistoryFilter> other) =>
      SearchHistoryFilterEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<SearchHistoryFilter> difference(EnumSet<SearchHistoryFilter> other) =>
      SearchHistoryFilterEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<SearchHistoryFilter> toSet() {
    Set<SearchHistoryFilter> result = {};
    SearchHistoryFilter.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    SearchHistoryFilter.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CSearchHistoryFilter extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CSearchHistoryFilterBasicFunctions on _COptionSet_CSearchHistoryFilter {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CSearchHistoryFilterToDart on _COptionSet_CSearchHistoryFilter {
  SearchHistoryFilterEnumSet _toDart() {
    return SearchHistoryFilterEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CSearchHistoryFilter on SearchHistoryFilterEnumSet {
  _COptionSet_CSearchHistoryFilter _copyFromDartTo_COptionSet_CSearchHistoryFilter() {
    return _COptionSet_CSearchHistoryFilterMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - SearchHistoryPage

class SearchHistoryPage {
  final int limit;
  final int offset;
  final SearchHistoryFilterEnumSet filter;

  const SearchHistoryPage({
    this.limit = 100,
    this.offset = 0,
    required this.filter
  });

  SearchHistoryPage copyWith({
    int? limit,
    int? offset,
    SearchHistoryFilterEnumSet? filter
  }) {
    return SearchHistoryPage(
      limit: limit ?? this.limit,
      offset: offset ?? this.offset,
      filter: filter ?? this.filter
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchHistoryPage &&
    other.runtimeType == runtimeType &&
    other.limit == limit &&
    other.offset == offset &&
    other.filter == filter;

  @override
  int get hashCode {
    return Object.hash(limit, offset, filter);
  }

}
final class _CSearchHistoryPage extends ffi.Struct {
  @ffi.Uint64()
  external int limit;

  @ffi.Uint64()
  external int offset;

  external _COptionSet_CSearchHistoryFilter filter;

}
// MARK: - SearchHistoryPage <-> _CSearchHistoryPage

extension _CSearchHistoryPageToDart on _CSearchHistoryPage {
  SearchHistoryPage _toDart() {
    return SearchHistoryPage(
      limit: this.limit,
      offset: this.offset,
      filter: this.filter._toDart()
    );
  }
}

extension _DartTo_CSearchHistoryPage on SearchHistoryPage {
  _CSearchHistoryPage _copyFromDartTo_CSearchHistoryPage() {
    final res = _CSearchHistoryPageMakeDefault();
    res.limit = this.limit;
    res.offset = this.offset;
    res.filter = this.filter._copyFromDartTo_COptionSet_CSearchHistoryFilter();
    return res;
  }
}
extension _CSearchHistoryPageRelease on _CSearchHistoryPage {
  void _releaseIntermediate() {
  }
}

// MARK: - SearchHistory

class SearchHistory implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Получает максимальный размер истории поиска. */
  int get capacity {
    int res = _CSearchHistory_capacity(_CSearchHistoryMakeDefault().._impl=_self);
    return res;
  }
  Channel<ChangeType> get onHistoryChanged {
    _CChannel_CChangeType res = _CSearchHistory_onHistoryChanged(_CSearchHistoryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSearchHistory_releasePtr);

  SearchHistory._raw(this._self);
  factory SearchHistory._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchHistory._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory SearchHistory(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CSearchHistory res = _CSearchHistory_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return SearchHistory._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchHistory &&
    other.runtimeType == runtimeType &&
    _CSearchHistory_cg_objectIdentifier(this._self) == _CSearchHistory_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchHistory_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: SearchHistory: Methods

  /**
   Возвращает страницу истории поиска. Элементы возвращаются в упорядоченном
   виде по времени добавления (от самых свежих до самых поздних).
  */
  CancelableOperation<SearchHistoryResult> items(
    SearchHistoryPage page
  )  {
    var _a1 = page._copyFromDartTo_CSearchHistoryPage();
    _CFuture_CSearchHistoryResult res = _CSearchHistory_items_CSearchHistoryPage(_CSearchHistoryMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Добавляет элемент в историю поиска. В случае, если уже существовал
   такой же элемент, ранний дубликат удаляется.
  */
  void addItem(
    SearchHistoryItem item
  )  {
    var _a1 = item._copyFromDartTo_CSearchHistoryItem();
    void res = _CSearchHistory_addItem_CSearchHistoryItem(_CSearchHistoryMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Добавляет список элементов в историю поиска. Считается, что
   порядок в списке хронологический. Все дубликаты будут убраны.
  */
  void addItems(
    List<SearchHistoryItem> items
  )  {
    var _a1 = items._copyFromDartTo_CArray_CSearchHistoryItem();
    void res = _CSearchHistory_addItems_CArray_CSearchHistoryItem(_CSearchHistoryMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаляет элемент из истории поиска. */
  void removeItem(
    SearchHistoryItem item
  )  {
    var _a1 = item._copyFromDartTo_CSearchHistoryItem();
    void res = _CSearchHistory_removeItem_CSearchHistoryItem(_CSearchHistoryMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаляет список элементов из истории поиска. */
  void removeItems(
    List<SearchHistoryItem> items
  )  {
    var _a1 = items._copyFromDartTo_CArray_CSearchHistoryItem();
    void res = _CSearchHistory_removeItems_CArray_CSearchHistoryItem(_CSearchHistoryMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Очищает историю поиска. */
  void clear()  {
    void res = _CSearchHistory_clear(_CSearchHistoryMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - SearchHistory <-> CSearchHistory

final class _CSearchHistory extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchHistoryBasicFunctions on _CSearchHistory {
  void _releaseIntermediate() {
    _CSearchHistory_release(_impl);
  }

  _CSearchHistory _retain() {
    return _CSearchHistory_retain(_impl);
  }
}

extension _CSearchHistoryToDart on _CSearchHistory {
  SearchHistory _toDart() {
    return SearchHistory._create(_retain()._impl);
  }
}


extension _DartToCSearchHistory on SearchHistory {
  _CSearchHistory _copyFromDartTo_CSearchHistory() {
    return (_CSearchHistoryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<SearchHistoryResult> <-> _CFuture_CSearchHistoryResult

final class _CFuture_CSearchHistoryResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CSearchHistoryResult_Cancellable {
  final Completer<SearchHistoryResult> completer;
  final _CFuture_CSearchHistoryResult _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CSearchHistoryResult, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CSearchHistoryResult_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CSearchHistoryResultBasicFunctions on _CFuture_CSearchHistoryResult {
  void _releaseIntermediate() {
    _CFuture_CSearchHistoryResult_release(this);
  }

  _CFuture_CSearchHistoryResult _retain() {
    return _CFuture_CSearchHistoryResult_retain(this);
  }
}

extension _CFuture_CSearchHistoryResultToDart on _CFuture_CSearchHistoryResult {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CSearchHistoryResult_Cancellable>{};

  static void valueFunction(_CSearchHistoryResult cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<SearchHistoryResult> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<SearchHistoryResult>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CSearchHistoryResult, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CSearchHistoryResultReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CSearchHistoryResult_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CSearchHistoryResult on CancelableOperation<SearchHistoryResult> {
  _CFuture_CSearchHistoryResult _copyFromDartTo_CFuture_CSearchHistoryResult() {
    return _CFuture_CSearchHistoryResultMakeDefault();
  }
}
	
// MARK: - Channel<ChangeType> <-> _CChannel_CChangeType

class _CChannel_CChangeTypeImpl extends Channel<ChangeType> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<ChangeType>>{};

  final _CChannel_CChangeType _channel;

  _CChannel_CChangeTypeImpl(this._channel);

  static void valueFunction(_CChangeType cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<ChangeType> listen(void onData(ChangeType event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CChangeType, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<ChangeType>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CChannel_CChangeType extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CChannel_CChangeTypeBasicFunctions on _CChannel_CChangeType {
  void _releaseIntermediate() {
    _CChannel_CChangeType_release(this);
  }

  _CChannel_CChangeType _retain() {
    return _CChannel_CChangeType_retain(this);
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CChangeType, ffi.Int64)> callback) {
    return _CChannel_CChangeTypeConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CChannel_CChangeTypeToDart on _CChannel_CChangeType {
  Channel<ChangeType> _toDart() {
    return _CChannel_CChangeTypeImpl(this._retain());
  }
}

extension _DartTo_CChannel_CChangeType on Channel<ChangeType> {
  _CChannel_CChangeType _copyFromDartTo_CChannel_CChangeType() {
    return _CChannel_CChangeTypeMakeDefault();
  }
}
	
// MARK: - PackedSearchQuery

/** Вспомогательный объект для сериализации и десериализации поискового запроса. */
class PackedSearchQuery implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Текст запроса.
   Для некоторых запросов (например, раскрытие рубрики из suggest'а) текст отсутствует,
   т.к. в запросе хранятся идентификаторы, и поведение отличается от поиска по тексту элемента suggest'а.
  */
  String get queryText {
    _CString res = _CPackedSearchQuery_queryText(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Геометрия, ограничивающая область поиска. */
  List<GeoPoint>? get spatialRestriction {
    _COptional_CArray_CGeoPoint res = _CPackedSearchQuery_spatialRestriction(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Прямоугольная область интереса. */
  GeoRect? get areaOfInterest {
    _COptional_CGeoRect res = _CPackedSearchQuery_areaOfInterest(_CPackedSearchQueryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Ограничение по возвращаемым поиском типам объектов. */
  List<ObjectType> get allowedResultTypes {
    _CArray_CObjectType res = _CPackedSearchQuery_allowedResultTypes(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Размер страницы выдачи. */
  int get pageSize {
    int res = _CPackedSearchQuery_pageSize(_CPackedSearchQueryMakeDefault().._impl=_self);
    return res;
  }
  /** Информация об активных фильтрах. */
  DirectoryFilter get directoryFilter {
    _CDirectoryFilter res = _CPackedSearchQuery_directoryFilter(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Тип сортировки результатов. */
  SortingType get sortingType {
    _CSortingType res = _CPackedSearchQuery_sortingType(_CPackedSearchQueryMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CPackedSearchQuery_releasePtr);

  PackedSearchQuery._raw(this._self);
  factory PackedSearchQuery._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PackedSearchQuery._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PackedSearchQuery &&
    other.runtimeType == runtimeType &&
    _CPackedSearchQuery_cg_objectIdentifier(this._self) == _CPackedSearchQuery_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPackedSearchQuery_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CPackedSearchQuery: Static Methods

  /**
   Десериализация запроса поиска.
  
   - Throws: Exception десериализуется неподдерживаемая версия или битые данные.
  */
  static PackedSearchQuery fromBytes(
    ByteData data
  )  {
    var _a0 = data._copyFromDartTo_CData();
    _CResult_CPackedSearchQuery res = _CPackedSearchQuery_S_fromBytes_CData(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static PackedSearchQuery fromSearchQuery(
    SearchQuery searchQuery
  )  {
    var _a0 = searchQuery._copyFromDartTo_CSearchQuery();
    _CPackedSearchQuery res = _CPackedSearchQuery_S_fromSearchQuery_CSearchQuery(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: PackedSearchQuery: Methods

  ByteData toBytes()  {
    _CData res = _CPackedSearchQuery_toBytes(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  SearchQuery toSearchQuery()  {
    _CSearchQuery res = _CPackedSearchQuery_toSearchQuery(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - PackedSearchQuery <-> CPackedSearchQuery

final class _CPackedSearchQuery extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPackedSearchQueryBasicFunctions on _CPackedSearchQuery {
  void _releaseIntermediate() {
    _CPackedSearchQuery_release(_impl);
  }

  _CPackedSearchQuery _retain() {
    return _CPackedSearchQuery_retain(_impl);
  }
}

extension _CPackedSearchQueryToDart on _CPackedSearchQuery {
  PackedSearchQuery _toDart() {
    return PackedSearchQuery._create(_retain()._impl);
  }
}


extension _DartToCPackedSearchQuery on PackedSearchQuery {
  _CPackedSearchQuery _copyFromDartTo_CPackedSearchQuery() {
    return (_CPackedSearchQueryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PackedSearchQuery <-> _CResult_CPackedSearchQuery

final class _CResult_CPackedSearchQueryImpl extends ffi.Union {
  
  external _CPackedSearchQuery _value;
  external _CError _error;
}

final class _CResult_CPackedSearchQuery extends ffi.Struct {
  external _CResult_CPackedSearchQueryImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CPackedSearchQueryBasicFunctions on _CResult_CPackedSearchQuery {
  void _releaseIntermediate() {
    _CResult_CPackedSearchQuery_release(this);
  }
}

extension _CResult_CPackedSearchQueryToDart on _CResult_CPackedSearchQuery {
  PackedSearchQuery _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CPackedSearchQuery _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - ByteData <-> _CData

final class _CData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDataBasicFunctions on _CData {
  int _getSize() {
    return _GetSizeWith_CData(this);
  }

  ffi.Pointer<ffi.Uint8> _getData() {
    return _GetDataWith_CData(this);
  }

  void _releaseIntermediate() {
    _CData_release(this);
  }
}

extension _CDataToDart on _CData {
  ByteData _toDart() {
    final size = this._getSize();
    final data = this._getData();
    final bytes = Uint8List.fromList(data.asTypedList(size));
    return ByteData.view(bytes.buffer);
  }
}

extension _DartTo_CData on ByteData {
  _CData _copyFromDartTo_CData() {
    final bytes = this.buffer.asUint8List(this.offsetInBytes, this.lengthInBytes);
    final frameData = ffi_package.malloc<ffi.Uint8>(bytes.length);
    final pointerList = frameData.asTypedList(bytes.length);
    pointerList.setAll(0, bytes);
    final res = _CDataCreateWithData(bytes.length, frameData);
    ffi_package.malloc.free(frameData);
    return res;
  }
}
	
// MARK: - PointGeometryData

/** Данные геометрии точечного объекта. */
final class PointGeometryData {
  final Object? _value;
  final int _index;

  PointGeometryData._raw(this._value, this._index);

  PointGeometryData.geoPoint(GeoPoint value) : this._raw(value, 0);
  PointGeometryData.geoPointWithElevation(GeoPointWithElevation value) : this._raw(value, 1);

  bool get isGeoPoint => this._index == 0;
  GeoPoint? get asGeoPoint => this.isGeoPoint ? this._value as GeoPoint : null;

  bool get isGeoPointWithElevation => this._index == 1;
  GeoPointWithElevation? get asGeoPointWithElevation => this.isGeoPointWithElevation ? this._value as GeoPointWithElevation : null;

  T match<T>({
    required T Function(GeoPoint value) geoPoint,
    required T Function(GeoPointWithElevation value) geoPointWithElevation,
  }) {
    return switch (this._index) {
      0 => geoPoint(this._value as GeoPoint),
      1 => geoPointWithElevation(this._value as GeoPointWithElevation),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "PointGeometryData(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PointGeometryData &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CPointGeometryDataImpl extends ffi.Union {
  external _CGeoPoint _geoPoint;
  external _CGeoPointWithElevation _geoPointWithElevation;
}

final class _CPointGeometryData extends ffi.Struct {
  external _CPointGeometryDataImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CPointGeometryDataBasicFunctions on _CPointGeometryData {
  void _releaseIntermediate() {
    _CPointGeometryData_release(this);
  }
}
	
// MARK: - PointGeometryData <-> CPointGeometryData

extension _CPointGeometryDataToDart on _CPointGeometryData {
  PointGeometryData _toDart() {
    return switch (this._index) {
      0 => PointGeometryData.geoPoint(this._impl._geoPoint._toDart()),
      1 => PointGeometryData.geoPointWithElevation(this._impl._geoPointWithElevation._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CPointGeometryData on PointGeometryData {
  _CPointGeometryData _copyFromDartTo_CPointGeometryData() {
    var res = _CPointGeometryDataMakeDefault();
    this.match<void>(
      geoPoint: (GeoPoint value) {
        res._impl._geoPoint = value._copyFromDartTo_CGeoPoint();
        res._index = 0;
      },
      geoPointWithElevation: (GeoPointWithElevation value) {
        res._impl._geoPointWithElevation = value._copyFromDartTo_CGeoPointWithElevation();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - PointGeometry

/** Точка. */
class PointGeometry extends Geometry implements ffi.Finalizable {
  PointGeometryData get point {
    _CPointGeometryData res = _CPointGeometry_point(_CPointGeometryMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CPointGeometry_releasePtr);

  PointGeometry._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory PointGeometry._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PointGeometry._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory PointGeometry(
    GeoPoint point
  ) {
    var _a0 = point._copyFromDartTo_CGeoPoint();
    _CPointGeometry res = _CPointGeometry_C_createWith_CGeoPoint(_a0);
    return PointGeometry._create(res._impl);
  }

  factory PointGeometry.fromGeoPointWithElevation(
    GeoPointWithElevation point
  ) {
    var _a0 = point._copyFromDartTo_CGeoPointWithElevation();
    _CPointGeometry res = _CPointGeometry_C_createWith_CGeoPointWithElevation(_a0);
    return PointGeometry._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PointGeometry &&
    other.runtimeType == runtimeType &&
    _CPointGeometry_cg_objectIdentifier(this._self) == _CPointGeometry_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPointGeometry_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - PointGeometry <-> CPointGeometry

final class _CPointGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPointGeometryBasicFunctions on _CPointGeometry {
  void _releaseIntermediate() {
    _CPointGeometry_release(_impl);
  }

  _CPointGeometry _retain() {
    return _CPointGeometry_retain(_impl);
  }
}

extension _CPointGeometryToDart on _CPointGeometry {
  PointGeometry _toDart() {
    return PointGeometry._create(_retain()._impl);
  }
}


extension _DartToCPointGeometry on PointGeometry {
  _CPointGeometry _copyFromDartTo_CPointGeometry() {
    return (_CPointGeometryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PolygonGeometry

/** Полигон. */
class PolygonGeometry extends Geometry implements ffi.Finalizable {
  List<List<GeoPoint>> get contours {
    _CArray_CArray_CGeoPoint res = _CPolygonGeometry_contours(_CPolygonGeometryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPolygonGeometry_releasePtr);

  PolygonGeometry._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory PolygonGeometry._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PolygonGeometry._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory PolygonGeometry(
    List<List<GeoPoint>> contours
  ) {
    var _a0 = contours._copyFromDartTo_CArray_CArray_CGeoPoint();
    _CPolygonGeometry res = _CPolygonGeometry_C_createWith_CArray_CArray_CGeoPoint(_a0);
    _a0._releaseIntermediate();
    return PolygonGeometry._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PolygonGeometry &&
    other.runtimeType == runtimeType &&
    _CPolygonGeometry_cg_objectIdentifier(this._self) == _CPolygonGeometry_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPolygonGeometry_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - PolygonGeometry <-> CPolygonGeometry

final class _CPolygonGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPolygonGeometryBasicFunctions on _CPolygonGeometry {
  void _releaseIntermediate() {
    _CPolygonGeometry_release(_impl);
  }

  _CPolygonGeometry _retain() {
    return _CPolygonGeometry_retain(_impl);
  }
}

extension _CPolygonGeometryToDart on _CPolygonGeometry {
  PolygonGeometry _toDart() {
    return PolygonGeometry._create(_retain()._impl);
  }
}


extension _DartToCPolygonGeometry on PolygonGeometry {
  _CPolygonGeometry _copyFromDartTo_CPolygonGeometry() {
    return (_CPolygonGeometryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PolylineGeometry

/** Ломаная линия. */
class PolylineGeometry extends Geometry implements ffi.Finalizable {
  List<GeoPoint> get points {
    _CArray_CGeoPoint res = _CPolylineGeometry_points(_CPolylineGeometryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPolylineGeometry_releasePtr);

  PolylineGeometry._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory PolylineGeometry._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PolylineGeometry._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory PolylineGeometry(
    List<GeoPoint> points
  ) {
    var _a0 = points._copyFromDartTo_CArray_CGeoPoint();
    _CPolylineGeometry res = _CPolylineGeometry_C_createWith_CArray_CGeoPoint(_a0);
    _a0._releaseIntermediate();
    return PolylineGeometry._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PolylineGeometry &&
    other.runtimeType == runtimeType &&
    _CPolylineGeometry_cg_objectIdentifier(this._self) == _CPolylineGeometry_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPolylineGeometry_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - PolylineGeometry <-> CPolylineGeometry

final class _CPolylineGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPolylineGeometryBasicFunctions on _CPolylineGeometry {
  void _releaseIntermediate() {
    _CPolylineGeometry_release(_impl);
  }

  _CPolylineGeometry _retain() {
    return _CPolylineGeometry_retain(_impl);
  }
}

extension _CPolylineGeometryToDart on _CPolylineGeometry {
  PolylineGeometry _toDart() {
    return PolylineGeometry._create(_retain()._impl);
  }
}


extension _DartToCPolylineGeometry on PolylineGeometry {
  _CPolylineGeometry _copyFromDartTo_CPolylineGeometry() {
    return (_CPolylineGeometryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ComplexGeometry

/**
 Составная геометрия, состоит из набора простых или составных геометрий.

 Поддерживается произвольный уровень вложенности составных геометрий в наборе.
*/
class ComplexGeometry extends Geometry implements ffi.Finalizable {
  List<Geometry> get elements {
    _CArray_CGeometry res = _CComplexGeometry_elements(_CComplexGeometryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CComplexGeometry_releasePtr);

  ComplexGeometry._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory ComplexGeometry._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ComplexGeometry._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory ComplexGeometry(
    List<Geometry> geometries
  ) {
    var _a0 = geometries._copyFromDartTo_CArray_CGeometry();
    _CComplexGeometry res = _CComplexGeometry_C_createWith_CArray_CGeometry(_a0);
    _a0._releaseIntermediate();
    return ComplexGeometry._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ComplexGeometry &&
    other.runtimeType == runtimeType &&
    _CComplexGeometry_cg_objectIdentifier(this._self) == _CComplexGeometry_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CComplexGeometry_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ComplexGeometry <-> CComplexGeometry

final class _CComplexGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CComplexGeometryBasicFunctions on _CComplexGeometry {
  void _releaseIntermediate() {
    _CComplexGeometry_release(_impl);
  }

  _CComplexGeometry _retain() {
    return _CComplexGeometry_retain(_impl);
  }
}

extension _CComplexGeometryToDart on _CComplexGeometry {
  ComplexGeometry _toDart() {
    return ComplexGeometry._create(_retain()._impl);
  }
}


extension _DartToCComplexGeometry on ComplexGeometry {
  _CComplexGeometry _copyFromDartTo_CComplexGeometry() {
    return (_CComplexGeometryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<Geometry> <-> _CArray_CGeometry

final class _CArray_CGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CGeometryToDart on _CArray_CGeometry {
  List<Geometry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CGeometry on List<Geometry> {
  _CArray_CGeometry _copyFromDartTo_CArray_CGeometry() {
    final cArray = _CArray_CGeometrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CGeometry();
        _CArray_CGeometryaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CGeometryBasicFunctions on _CArray_CGeometry {
  void _releaseIntermediate() {
    _CArray_CGeometry_release(this);
  }

  static final _listToFill = <Geometry>[];

  static void _iterate(_CGeometry item) {
    _listToFill.add(item._toDart());
  }

  List<Geometry> _fillFromC() {
    _forEach_CArray_CGeometry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CGeometry)>(_iterate));
    final result = List<Geometry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - downloadData

@internal
CancelableOperation<ByteData> downloadData(
  Context context,
  String url
){
  var _a0 = context._copyFromDartTo_CContext();
  var _a1 = url._copyFromDartTo_CString();
  _CFuture_CData res = _CFunction_G_downloadData_With_CContext_CString(_a0, _a1);
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - CancelableOperation<ByteData> <-> _CFuture_CData

final class _CFuture_CData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CData_Cancellable {
  final Completer<ByteData> completer;
  final _CFuture_CData _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CData, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CData_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CDataBasicFunctions on _CFuture_CData {
  void _releaseIntermediate() {
    _CFuture_CData_release(this);
  }

  _CFuture_CData _retain() {
    return _CFuture_CData_retain(this);
  }
}

extension _CFuture_CDataToDart on _CFuture_CData {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CData_Cancellable>{};

  static void valueFunction(_CData cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<ByteData> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<ByteData>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CData, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CDataReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CData_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CData on CancelableOperation<ByteData> {
  _CFuture_CData _copyFromDartTo_CFuture_CData() {
    return _CFuture_CDataMakeDefault();
  }
}
	
// MARK: - Anchor

/**
 Точка привязки изображения
 (0, 0) - левый верхний угол, (1, 1) - правый нижний
*/
class Anchor {
  final double x;
  final double y;

  const Anchor({
    this.x = 0.5,
    this.y = 0.5
  });

  Anchor copyWith({
    double? x,
    double? y
  }) {
    return Anchor(
      x: x ?? this.x,
      y: y ?? this.y
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Anchor &&
    other.runtimeType == runtimeType &&
    other.x == x &&
    other.y == y;

  @override
  int get hashCode {
    return Object.hash(x, y);
  }

}
final class _CAnchor extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

}
// MARK: - Anchor <-> _CAnchor

extension _CAnchorToDart on _CAnchor {
  Anchor _toDart() {
    return Anchor(
      x: this.x,
      y: this.y
    );
  }
}

extension _DartTo_CAnchor on Anchor {
  _CAnchor _copyFromDartTo_CAnchor() {
    final res = _CAnchorMakeDefault();
    res.x = this.x;
    res.y = this.y;
    return res;
  }
}
extension _CAnchorRelease on _CAnchor {
  void _releaseIntermediate() {
  }
}

// MARK: - List<AttributeValue> <-> _CArray_CAttributeValue

final class _CArray_CAttributeValue extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CAttributeValueToDart on _CArray_CAttributeValue {
  List<AttributeValue> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CAttributeValue on List<AttributeValue> {
  _CArray_CAttributeValue _copyFromDartTo_CArray_CAttributeValue() {
    final cArray = _CArray_CAttributeValuemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CAttributeValue();
        _CArray_CAttributeValueaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CAttributeValueBasicFunctions on _CArray_CAttributeValue {
  void _releaseIntermediate() {
    _CArray_CAttributeValue_release(this);
  }

  static final _listToFill = <AttributeValue>[];

  static void _iterate(_CAttributeValue item) {
    _listToFill.add(item._toDart());
  }

  List<AttributeValue> _fillFromC() {
    _forEach_CArray_CAttributeValue(this, ffi.Pointer.fromFunction<ffi.Void Function(_CAttributeValue)>(_iterate));
    final result = List<AttributeValue>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - core.Map<String, AttributeValue> <-> _CDictionary_CString_CAttributeValue

final class _CDictionary_CString_CAttributeValue extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDictionary_CString_CAttributeValueToDart on _CDictionary_CString_CAttributeValue {
  core.Map<String, AttributeValue> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CDictionary_CString_CAttributeValue on core.Map<String, AttributeValue> {
  _CDictionary_CString_CAttributeValue _copyFromDartTo_CDictionary_CString_CAttributeValue() {
    final cDict = _CDictionary_CString_CAttributeValuemakeEmpty();
    forEach((k, v) {
        final cKey = k._copyFromDartTo_CString();
        final cValue = v._copyFromDartTo_CAttributeValue();
        _CDictionary_CString_CAttributeValueaddElement(cDict, cKey, cValue);
        cKey._releaseIntermediate();
        cValue._releaseIntermediate();
    });
    return cDict;
  }
}

extension _CDictionary_CString_CAttributeValueBasicFunctions on _CDictionary_CString_CAttributeValue {
  void _releaseIntermediate() {
    _CDictionary_CString_CAttributeValue_release(this);
  }

  static final _mapToFill = <String, AttributeValue>{};

  static void _iterate(_CString key, _CAttributeValue value) {
    _mapToFill.putIfAbsent(key._toDart(), () => value._toDart());
  }

  core.Map<String, AttributeValue> _fillFromC() {
    _forEach_CDictionary_CString_CAttributeValue(this, ffi.Pointer.fromFunction<ffi.Void Function(_CString, _CAttributeValue value)>(_iterate));
    final result = core.Map<String, AttributeValue>.from(_mapToFill);
    _mapToFill.clear();
    return result;
  }
}
	
// MARK: - AttributeValue

/** Свойства объектов карты. */
final class AttributeValue {
  final Object? _value;
  final int _index;

  AttributeValue._raw(this._value, this._index);

  AttributeValue.empty() : this._raw(null, 0);
  AttributeValue.boolean(bool value) : this._raw(value, 1);
  AttributeValue.number(double value) : this._raw(value, 2);
  AttributeValue.integer(int value) : this._raw(value, 3);
  AttributeValue.string(String value) : this._raw(value, 4);
  AttributeValue.data(ByteData value) : this._raw(value, 5);
  AttributeValue.array(List<AttributeValue> value) : this._raw(value, 6);
  AttributeValue.object(core.Map<String, AttributeValue> value) : this._raw(value, 7);

  bool get isEmpty => this._index == 0;
  Object? get asEmpty => this.isEmpty ? this._value as Object : null;

  bool get isBoolean => this._index == 1;
  bool? get asBoolean => this.isBoolean ? this._value as bool : null;

  bool get isNumber => this._index == 2;
  double? get asNumber => this.isNumber ? this._value as double : null;

  bool get isInteger => this._index == 3;
  int? get asInteger => this.isInteger ? this._value as int : null;

  bool get isString => this._index == 4;
  String? get asString => this.isString ? this._value as String : null;

  bool get isData => this._index == 5;
  ByteData? get asData => this.isData ? this._value as ByteData : null;

  bool get isArray => this._index == 6;
  List<AttributeValue>? get asArray => this.isArray ? this._value as List<AttributeValue> : null;

  bool get isObject => this._index == 7;
  core.Map<String, AttributeValue>? get asObject => this.isObject ? this._value as core.Map<String, AttributeValue> : null;

  T match<T>({
    required T Function() empty,
    required T Function(bool value) boolean,
    required T Function(double value) number,
    required T Function(int value) integer,
    required T Function(String value) string,
    required T Function(ByteData value) data,
    required T Function(List<AttributeValue> value) array,
    required T Function(core.Map<String, AttributeValue> value) object,
  }) {
    return switch (this._index) {
      0 => empty(),
      1 => boolean(this._value as bool),
      2 => number(this._value as double),
      3 => integer(this._value as int),
      4 => string(this._value as String),
      5 => data(this._value as ByteData),
      6 => array(this._value as List<AttributeValue>),
      7 => object(this._value as core.Map<String, AttributeValue>),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "AttributeValue(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AttributeValue &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CAttributeValueImpl extends ffi.Union {
  external _CEmpty _empty;
  @ffi.Bool()
  external bool _boolean;
  @ffi.Double()
  external double _number;
  @ffi.Int64()
  external int _integer;
  external _CString _string;
  external _CData _data;
  external _CArray_CAttributeValue _array;
  external _CDictionary_CString_CAttributeValue _object;
}

final class _CAttributeValue extends ffi.Struct {
  external _CAttributeValueImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CAttributeValueBasicFunctions on _CAttributeValue {
  void _releaseIntermediate() {
    _CAttributeValue_release(this);
  }
}
	
// MARK: - AttributeValue <-> CAttributeValue

extension _CAttributeValueToDart on _CAttributeValue {
  AttributeValue _toDart() {
    return switch (this._index) {
      0 => AttributeValue.empty(),
      1 => AttributeValue.boolean(this._impl._boolean),
      2 => AttributeValue.number(this._impl._number),
      3 => AttributeValue.integer(this._impl._integer),
      4 => AttributeValue.string(this._impl._string._toDart()),
      5 => AttributeValue.data(this._impl._data._toDart()),
      6 => AttributeValue.array(this._impl._array._toDart()),
      7 => AttributeValue.object(this._impl._object._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CAttributeValue on AttributeValue {
  _CAttributeValue _copyFromDartTo_CAttributeValue() {
    var res = _CAttributeValueMakeDefault();
    this.match<void>(
      empty: () {
        res._index = 0;
      },
      boolean: (bool value) {
        res._impl._boolean = value;
        res._index = 1;
      },
      number: (double value) {
        res._impl._number = value;
        res._index = 2;
      },
      integer: (int value) {
        res._impl._integer = value;
        res._index = 3;
      },
      string: (String value) {
        res._impl._string = value._copyFromDartTo_CString();
        res._index = 4;
      },
      data: (ByteData value) {
        res._impl._data = value._copyFromDartTo_CData();
        res._index = 5;
      },
      array: (List<AttributeValue> value) {
        res._impl._array = value._copyFromDartTo_CArray_CAttributeValue();
        res._index = 6;
      },
      object: (core.Map<String, AttributeValue> value) {
        res._impl._object = value._copyFromDartTo_CDictionary_CString_CAttributeValue();
        res._index = 7;
      },
    );
    return res;
  }
}

// MARK: - BearingSource

/** Источник направления. */
enum BearingSource {
  /** Автоматический выбор источника направления в зависимости от параметров геопозиции. */
  auto(0),
  /** Ориентировать карту по направлению, полученному от GNSS. */
  satellite(1),
  /** Ориентировать карту по компасу. */
  magnetic(2),
  ;

  const BearingSource(this.rawValue);
  final int rawValue;

  static BearingSource getByValue(int value) {
    return BearingSource.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CBearingSource extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CBearingSourceBasicFunctions on _CBearingSource {
  void _releaseIntermediate() {
  }
}

extension _CBearingSourceToDart on _CBearingSource {
  BearingSource _toDart() {
    return BearingSource.getByValue(this.rawValue);
  }
}

extension _DartTo_CBearingSource on BearingSource {
  _CBearingSource _copyFromDartTo_CBearingSource() {
    return _CBearingSourceMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraAnimatedMoveReason

/** Причина анимированного перемещения камеры. */
enum CameraAnimatedMoveReason {
  /** Явный вызов ICamera::move() */
  application(0),
  /**
   Анимированное перемещение вызвано обработкой событий (кинематика после перемещения карты, поворот на север
   и другие).
  */
  event(1),
  /** Внутренние причины, например, из-за активного слежения за позицией пользователя. */
  internal(2),
  ;

  const CameraAnimatedMoveReason(this.rawValue);
  final int rawValue;

  static CameraAnimatedMoveReason getByValue(int value) {
    return CameraAnimatedMoveReason.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraAnimatedMoveReason extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraAnimatedMoveReasonBasicFunctions on _CCameraAnimatedMoveReason {
  void _releaseIntermediate() {
  }
}

extension _CCameraAnimatedMoveReasonToDart on _CCameraAnimatedMoveReason {
  CameraAnimatedMoveReason _toDart() {
    return CameraAnimatedMoveReason.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraAnimatedMoveReason on CameraAnimatedMoveReason {
  _CCameraAnimatedMoveReason _copyFromDartTo_CCameraAnimatedMoveReason() {
    return _CCameraAnimatedMoveReasonMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraAnimatedMoveResult

/** Результат перемещения камеры. */
enum CameraAnimatedMoveResult {
  /** Перемещение позиции камеры завершено по достижении конечной точки. */
  finished(0),
  /** Перемещение позиции камеры отменено событием карты (сдвиг, изменение масштаба, и т.д.). */
  cancelledByEvent(1),
  /**
   Запущен новый перелёт, изменена позиция
   (явно или косвенно через ICamera::set_position_point() или ICamera::set_padding())
   или изменён режим слежения.
  */
  cancelledByApplication(2),
  ;

  const CameraAnimatedMoveResult(this.rawValue);
  final int rawValue;

  static CameraAnimatedMoveResult getByValue(int value) {
    return CameraAnimatedMoveResult.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraAnimatedMoveResult extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraAnimatedMoveResultBasicFunctions on _CCameraAnimatedMoveResult {
  void _releaseIntermediate() {
  }
}

extension _CCameraAnimatedMoveResultToDart on _CCameraAnimatedMoveResult {
  CameraAnimatedMoveResult _toDart() {
    return CameraAnimatedMoveResult.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraAnimatedMoveResult on CameraAnimatedMoveResult {
  _CCameraAnimatedMoveResult _copyFromDartTo_CCameraAnimatedMoveResult() {
    return _CCameraAnimatedMoveResultMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraAnimationType

/** Тип перелёта */
enum CameraAnimationType {
  /** Тип перелёта выбирается в зависимости от расстояния между начальной и конечной позициями. */
  default_(0),
  /** Линейное изменение параметров позиции камеры. */
  linear(1),
  /**
   Zoom изменяется таким образом, чтобы постараться в какой-то момент перелёта
   отобразить начальную и конечную позиции. Позиции могут быть не отображены,
   если текущие ограничения (см. ICamera::zoom_restrictions()) не позволяют установить столь малый zoom.
  */
  showBothPositions(2),
  ;

  const CameraAnimationType(this.rawValue);
  final int rawValue;

  static CameraAnimationType getByValue(int value) {
    return CameraAnimationType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraAnimationType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraAnimationTypeBasicFunctions on _CCameraAnimationType {
  void _releaseIntermediate() {
  }
}

extension _CCameraAnimationTypeToDart on _CCameraAnimationType {
  CameraAnimationType _toDart() {
    return CameraAnimationType.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraAnimationType on CameraAnimationType {
  _CCameraAnimationType _copyFromDartTo_CCameraAnimationType() {
    return _CCameraAnimationTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraBehaviourChangeReason

/** Причина изменения режима слежения камеры. */
enum CameraBehaviourChangeReason {
  /**
   Смена режима приложением, установка позиции (явно или косвенно через ICamera::set_position_point()),
   запуск перелёта.
  */
  application(0),
  /**
   Режим слежения изменился из-за события карты.
   В зависимости от события может сброситься режим слежения за позицией, углом поворота,
   углом наклона или масштабом, см. CameraBehaviour.
  */
  event(1),
  ;

  const CameraBehaviourChangeReason(this.rawValue);
  final int rawValue;

  static CameraBehaviourChangeReason getByValue(int value) {
    return CameraBehaviourChangeReason.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraBehaviourChangeReason extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraBehaviourChangeReasonBasicFunctions on _CCameraBehaviourChangeReason {
  void _releaseIntermediate() {
  }
}

extension _CCameraBehaviourChangeReasonToDart on _CCameraBehaviourChangeReason {
  CameraBehaviourChangeReason _toDart() {
    return CameraBehaviourChangeReason.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraBehaviourChangeReason on CameraBehaviourChangeReason {
  _CCameraBehaviourChangeReason _copyFromDartTo_CCameraBehaviourChangeReason() {
    return _CCameraBehaviourChangeReasonMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraPositionPoint

/**
 Относительная экранная позиция точки, к которой привязана камера.

 Область экрана задаётся padding'ами.
 x - отступ от левого края области экрана, y - отступ от верхнего края
 Допустимый интервал значений отступов (0.0f, 1.0f)
 0,0 - левый верхний угол области экрана, 1,1 - правый нижний
*/
class CameraPositionPoint {
  final double x;
  final double y;

  const CameraPositionPoint({
    this.x = 0.5,
    this.y = 0.5
  });

  CameraPositionPoint copyWith({
    double? x,
    double? y
  }) {
    return CameraPositionPoint(
      x: x ?? this.x,
      y: y ?? this.y
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraPositionPoint &&
    other.runtimeType == runtimeType &&
    other.x == x &&
    other.y == y;

  @override
  int get hashCode {
    return Object.hash(x, y);
  }

}
final class _CCameraPositionPoint extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

}
// MARK: - CameraPositionPoint <-> _CCameraPositionPoint

extension _CCameraPositionPointToDart on _CCameraPositionPoint {
  CameraPositionPoint _toDart() {
    return CameraPositionPoint(
      x: this.x,
      y: this.y
    );
  }
}

extension _DartTo_CCameraPositionPoint on CameraPositionPoint {
  _CCameraPositionPoint _copyFromDartTo_CCameraPositionPoint() {
    final res = _CCameraPositionPointMakeDefault();
    res.x = this.x;
    res.y = this.y;
    return res;
  }
}
extension _CCameraPositionPointRelease on _CCameraPositionPoint {
  void _releaseIntermediate() {
  }
}

// MARK: - CameraState

/** Состояние камеры. */
enum CameraState {
  /** Камера управляется пользователем. */
  busy(0),
  /** Eсть активный перелёт, запущенный в результате обработки событий или пользователем явно. */
  fly(1),
  /**
   Камера не управляется пользователем и нет активных перелётов.
   Либо с камерой ничего не происходит, либо она следит за позицией и/или наклоном.
  */
  free(2),
  ;

  const CameraState(this.rawValue);
  final int rawValue;

  static CameraState getByValue(int value) {
    return CameraState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraStateBasicFunctions on _CCameraState {
  void _releaseIntermediate() {
  }
}

extension _CCameraStateToDart on _CCameraState {
  CameraState _toDart() {
    return CameraState.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraState on CameraState {
  _CCameraState _copyFromDartTo_CCameraState() {
    return _CCameraStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraViewPoint

/**
 Относительная экранная позиция точки, в которую направлен взгляд камеры.

 Допустимый интервал значений отступов (0.0f, 1.0f)
 0,0 - левый верхний угол вьюпорта, 1,1 - правый нижний
*/
class CameraViewPoint {
  final double x;
  final double y;

  const CameraViewPoint({
    this.x = 0.5,
    this.y = 0.5
  });

  CameraViewPoint copyWith({
    double? x,
    double? y
  }) {
    return CameraViewPoint(
      x: x ?? this.x,
      y: y ?? this.y
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraViewPoint &&
    other.runtimeType == runtimeType &&
    other.x == x &&
    other.y == y;

  @override
  int get hashCode {
    return Object.hash(x, y);
  }

}
final class _CCameraViewPoint extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

}
// MARK: - CameraViewPoint <-> _CCameraViewPoint

extension _CCameraViewPointToDart on _CCameraViewPoint {
  CameraViewPoint _toDart() {
    return CameraViewPoint(
      x: this.x,
      y: this.y
    );
  }
}

extension _DartTo_CCameraViewPoint on CameraViewPoint {
  _CCameraViewPoint _copyFromDartTo_CCameraViewPoint() {
    final res = _CCameraViewPointMakeDefault();
    res.x = this.x;
    res.y = this.y;
    return res;
  }
}
extension _CCameraViewPointRelease on _CCameraViewPoint {
  void _releaseIntermediate() {
  }
}

// MARK: - Color

/** Цвет */
class Color {
  final int argb;

  const Color([this.argb = 4278190080]);

  Color copyWith({
    int? argb
  }) {
    return Color(
      argb ?? this.argb
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Color &&
    other.runtimeType == runtimeType &&
    other.argb == argb;

  @override
  int get hashCode {
    return argb.hashCode;
  }

}
final class _CColor extends ffi.Struct {
  @ffi.Uint32()
  external int argb;

}
// MARK: - Color <-> _CColor

extension _CColorToDart on _CColor {
  Color _toDart() {
    return Color(
      this.argb
    );
  }
}

extension _DartTo_CColor on Color {
  _CColor _copyFromDartTo_CColor() {
    final res = _CColorMakeDefault();
    res.argb = this.argb;
    return res;
  }
}
extension _CColorRelease on _CColor {
  void _releaseIntermediate() {
  }
}

// MARK: - DeviceDensity

/**
 Множитель, который вычисляется как отношение DPI к базовому DPI устройства.

 В Android соответствует resources.displayMetrics.density
 В iOS соответствует nativeScale

 - Note: должен быть положительным.
*/
class DeviceDensity {
  final double value;

  const DeviceDensity([this.value = 0]);

  DeviceDensity copyWith({
    double? value
  }) {
    return DeviceDensity(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DeviceDensity &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CDeviceDensity extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - DeviceDensity <-> _CDeviceDensity

extension _CDeviceDensityToDart on _CDeviceDensity {
  DeviceDensity _toDart() {
    return DeviceDensity(
      this.value
    );
  }
}

extension _DartTo_CDeviceDensity on DeviceDensity {
  _CDeviceDensity _copyFromDartTo_CDeviceDensity() {
    final res = _CDeviceDensityMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CDeviceDensityRelease on _CDeviceDensity {
  void _releaseIntermediate() {
  }
}

// MARK: - DevicePpi

/**
 Разрешающая способность дисплея устройства, в пикселях на дюйм.

 - Note: должна быть положительной.
*/
class DevicePpi {
  final double value;

  const DevicePpi([this.value = 0]);

  DevicePpi copyWith({
    double? value
  }) {
    return DevicePpi(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DevicePpi &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CDevicePpi extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - DevicePpi <-> _CDevicePpi

extension _CDevicePpiToDart on _CDevicePpi {
  DevicePpi _toDart() {
    return DevicePpi(
      this.value
    );
  }
}

extension _DartTo_CDevicePpi on DevicePpi {
  _CDevicePpi _copyFromDartTo_CDevicePpi() {
    final res = _CDevicePpiMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CDevicePpiRelease on _CDevicePpi {
  void _releaseIntermediate() {
  }
}

// MARK: - GraphicsPreset

/** Перечисление доступных режимов графики. */
enum GraphicsPreset {
  /** Упрощенный режим отрисовки, по возможности отключаются тяжелые графические эффекты. */
  lite(0),
  /** Стандартный режим отрисовки, соблюдается баланс между визуальным качеством картинки и потребляемыми ресурсами. */
  normal(1),
  /**
   Иммерсивный режим, включаются все самые "тяжелые" графические эффекты.
  
   - Warning: : Может приводить к значительной деградации производительности на слабых устройствах.
  */
  immersive(2),
  ;

  const GraphicsPreset(this.rawValue);
  final int rawValue;

  static GraphicsPreset getByValue(int value) {
    return GraphicsPreset.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CGraphicsPreset extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CGraphicsPresetBasicFunctions on _CGraphicsPreset {
  void _releaseIntermediate() {
  }
}

extension _CGraphicsPresetToDart on _CGraphicsPreset {
  GraphicsPreset _toDart() {
    return GraphicsPreset.getByValue(this.rawValue);
  }
}

extension _DartTo_CGraphicsPreset on GraphicsPreset {
  _CGraphicsPreset _copyFromDartTo_CGraphicsPreset() {
    return _CGraphicsPresetMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ZIndex

/** Индекс, задающий порядок отрисовки объектов в рамках слоя. */
class ZIndex {
  final int value;

  const ZIndex([this.value = 0]);

  ZIndex copyWith({
    int? value
  }) {
    return ZIndex(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ZIndex &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CZIndex extends ffi.Struct {
  @ffi.Uint32()
  external int value;

}
// MARK: - ZIndex <-> _CZIndex

extension _CZIndexToDart on _CZIndex {
  ZIndex _toDart() {
    return ZIndex(
      this.value
    );
  }
}

extension _DartTo_CZIndex on ZIndex {
  _CZIndex _copyFromDartTo_CZIndex() {
    final res = _CZIndexMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CZIndexRelease on _CZIndex {
  void _releaseIntermediate() {
  }
}

// MARK: - Zoom

/**
 Уровень масштабирования.

 Zoom = 0 это такой масштаб, при котором весь мир вписан в квадрат 256x256 логических пикселей (см. LogicalPixel)
 Zoom = 1 это такой масштаб, при котором весь мир вписан в квадрат 512x512 логических пикселей
 Масштаб пропорционален величине 2^Zoom.

 - Note: Zoom не может быть отрицательным.
*/
class Zoom {
  final double value;

  const Zoom([this.value = 0]);

  Zoom copyWith({
    double? value
  }) {
    return Zoom(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Zoom &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CZoom extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - Zoom <-> _CZoom

extension _CZoomToDart on _CZoom {
  Zoom _toDart() {
    return Zoom(
      this.value
    );
  }
}

extension _DartTo_CZoom on Zoom {
  _CZoom _copyFromDartTo_CZoom() {
    final res = _CZoomMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CZoomRelease on _CZoom {
  void _releaseIntermediate() {
  }
}

// MARK: - Tilt

/**
 Угол наклона в градусах, где 0 - надир (смотрим вертикально вниз), 90 - горизонт спереди.

 Допустимыми считаются значения в интервале от 0 до 70 градусов.
 В случаях, когда точка позиции камеры расположена ближе к нижнему краю экрана,
 значение может быть дополнительно уменьшено.
*/
class Tilt {
  final double value;

  const Tilt([this.value = 0]);

  Tilt copyWith({
    double? value
  }) {
    return Tilt(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Tilt &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CTilt extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - Tilt <-> _CTilt

extension _CTiltToDart on _CTilt {
  Tilt _toDart() {
    return Tilt(
      this.value
    );
  }
}

extension _DartTo_CTilt on Tilt {
  _CTilt _copyFromDartTo_CTilt() {
    final res = _CTiltMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CTiltRelease on _CTilt {
  void _releaseIntermediate() {
  }
}

// MARK: - CameraPosition

/** Позиция камеры. */
class CameraPosition {
  /** Точка местности, которая находится в точке позиции камеры (см. ICamera::position_point()). */
  final GeoPoint point;
  /**
   Уровень масштабирования.
   0 - это весь мир, вписанный в квадрат 256x256 логических пикселей (см. LogicalPixel)
  */
  final Zoom zoom;
  /**
   Угол наклона направления взгляда по вертикали.
  
   - Note: 0 - надир (смотрим вертикально вниз), максимальное значение - 60 градусов.
  */
  final Tilt tilt;
  /**
   Угол поворота направления взгляда по горизонтали относительно направления на север.
   Отсчитывается по часовой стрелке, в градусах.
  */
  final Bearing bearing;

  const CameraPosition({
    required this.point,
    required this.zoom,
    this.tilt = const Tilt(0),
    this.bearing = const Bearing(0)
  });

  CameraPosition copyWith({
    GeoPoint? point,
    Zoom? zoom,
    Tilt? tilt,
    Bearing? bearing
  }) {
    return CameraPosition(
      point: point ?? this.point,
      zoom: zoom ?? this.zoom,
      tilt: tilt ?? this.tilt,
      bearing: bearing ?? this.bearing
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraPosition &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.zoom == zoom &&
    other.tilt == tilt &&
    other.bearing == bearing;

  @override
  int get hashCode {
    return Object.hash(point, zoom, tilt, bearing);
  }

}
final class _CCameraPosition extends ffi.Struct {
  external _CGeoPoint point;

  external _CZoom zoom;

  external _CTilt tilt;

  external _CBearing bearing;

}
// MARK: - CameraPosition <-> _CCameraPosition

extension _CCameraPositionToDart on _CCameraPosition {
  CameraPosition _toDart() {
    return CameraPosition(
      point: this.point._toDart(),
      zoom: this.zoom._toDart(),
      tilt: this.tilt._toDart(),
      bearing: this.bearing._toDart()
    );
  }
}

extension _DartTo_CCameraPosition on CameraPosition {
  _CCameraPosition _copyFromDartTo_CCameraPosition() {
    final res = _CCameraPositionMakeDefault();
    res.point = this.point._copyFromDartTo_CGeoPoint();
    res.zoom = this.zoom._copyFromDartTo_CZoom();
    res.tilt = this.tilt._copyFromDartTo_CTilt();
    res.bearing = this.bearing._copyFromDartTo_CBearing();
    return res;
  }
}
extension _CCameraPositionRelease on _CCameraPosition {
  void _releaseIntermediate() {
  }
}

// MARK: - _CameraMoveControllerCpp

/**
 Класс, позволяющий управлять положением камеры для нужд анимации

 - Warning: Класс должен быть потокобезопасным.
*/
class _CameraMoveControllerCpp extends CameraMoveController implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CCameraMoveControllerCpp_releasePtr);

  _CameraMoveControllerCpp._raw(this._self);
  factory _CameraMoveControllerCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _CameraMoveControllerCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _CameraMoveControllerCpp &&
    other.runtimeType == runtimeType &&
    _CCameraMoveControllerCpp_cg_objectIdentifier(this._self) == _CCameraMoveControllerCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCameraMoveControllerCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _CameraMoveControllerCpp: Methods

  /**
   Позиция области просмотра в конкретный момент времени.
   Контроллер должен быть готов к тому, что время анимации будет передаваться в любом порядке,
   не обязательно в неубывающем.
  
   - Parameter time: Время от начала анимации в миллисекундах.
   - Returns: Положение области просмотра в указанный момент времени.
  */
  CameraPosition position(
    Duration time
  )  {
    var _a1 = time._copyFromDartTo_CTimeInterval();
    _CCameraPosition res = _CCameraMoveControllerCpp_position_CTimeInterval(_CCameraMoveControllerCppMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Продолжительность анимации в миллисекундах.
  
   - Returns: Продолжительность анимации в миллисекундах.
  */
  Duration animationTime()  {
    _CTimeInterval res = _CCameraMoveControllerCpp_animationTime(_CCameraMoveControllerCppMakeDefault().._impl=_self);
    return res._toDart();
  }

}

// MARK: - _CameraMoveControllerCpp <-> CCameraMoveControllerCpp

final class _CCameraMoveControllerCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCameraMoveControllerCppBasicFunctions on _CCameraMoveControllerCpp {
  void _releaseIntermediate() {
    _CCameraMoveControllerCpp_release(_impl);
  }

  _CCameraMoveControllerCpp _retain() {
    return _CCameraMoveControllerCpp_retain(_impl);
  }
}

extension _CCameraMoveControllerCppToDart on _CCameraMoveControllerCpp {
  _CameraMoveControllerCpp _toDart() {
    return _CameraMoveControllerCpp._create(_retain()._impl);
  }
}


extension _DartToCCameraMoveControllerCpp on _CameraMoveControllerCpp {
  _CCameraMoveControllerCpp _copyFromDartTo_CCameraMoveControllerCpp() {
    return (_CCameraMoveControllerCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CameraMoveController

/**
 Класс, позволяющий управлять положением камеры для нужд анимации

 - Warning: Класс должен быть потокобезопасным.
*/
abstract class CameraMoveController {
  CameraPosition position(
    Duration time
  );
  Duration animationTime();
}

class _CameraMoveController {
  final CameraMoveController object;
  int refCounter = 1;

  _CameraMoveController(this.object);
}

final class _CCameraMoveController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CCameraPosition)>>, _CTimeInterval)>> _position_CTimeInterval;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CTimeInterval)>>)>> _animationTime;
}

extension _CCameraMoveControllerBasicFunctions on _CCameraMoveController {
  void _releaseIntermediate() {
    _CCameraMoveController_release(this);
  }
}

int _CCameraMoveControllerInstanceCounter = 1;
final _CCameraMoveControllerInstanceMap = <int, _CameraMoveController>{};

extension _CCameraMoveControllerToDart on _CCameraMoveController {
  CameraMoveController _toDart() {
    late CameraMoveController? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CCameraMoveControllerInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CCameraMoveControllerCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CCameraMoveController");
    }
    return result;
  }
}

extension _DartTo_CCameraMoveController on CameraMoveController {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CCameraMoveControllerInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CCameraMoveControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CCameraMoveControllerInstanceMap.remove(platformValue.address);
  }

  _CCameraMoveController _copyFromDartTo_CCameraMoveController() {
    var res = _CCameraMoveControllerMakeDefault();
    if (this is _CameraMoveControllerCpp) {
      final cppValue = this as _CameraMoveControllerCpp;
      res._cppValue = cppValue._copyFromDartTo_CCameraMoveControllerCpp()._impl;
      return res;
    }
    final instanceId = _CCameraMoveControllerInstanceCounter;
    _CCameraMoveControllerInstanceCounter += 1;
    _CCameraMoveControllerInstanceMap[instanceId] = _CameraMoveController(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final position_CTimeIntervalFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CCameraPosition)>>, _CTimeInterval)>.listener(position_CTimeIntervalFunction);
    res._position_CTimeInterval = position_CTimeIntervalFunctionCallable.nativeFunction;
    final animationTimeFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CTimeInterval)>>)>.listener(animationTimeFunction);
    res._animationTime = animationTimeFunctionCallable.nativeFunction;
    return res;
  }

  static void position_CTimeIntervalFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CCameraPosition)>> resultValueCallback, _CTimeInterval time) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCameraMoveController");
    }
    final platformObject = _CCameraMoveControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCameraMoveController");
    }

    final timeDart = time._toDart();
    final res = platformObject.object.position(timeDart);
    time._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CCameraPosition)>();
    callbackFunction(context, res._copyFromDartTo_CCameraPosition());
  }

  static void animationTimeFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CTimeInterval)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCameraMoveController");
    }
    final platformObject = _CCameraMoveControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCameraMoveController");
    }

    final res = platformObject.object.animationTime();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CTimeInterval)>();
    callbackFunction(context, res._copyFromDartTo_CTimeInterval());
  }


}

// MARK: - NewValuesNotifier

/** Интерфейс объекта, который сообщает о том, что есть изменения в каком-либо из параметров. */
class NewValuesNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CNewValuesNotifier_releasePtr);

  NewValuesNotifier._raw(this._self);
  factory NewValuesNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = NewValuesNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is NewValuesNotifier &&
    other.runtimeType == runtimeType &&
    _CNewValuesNotifier_cg_objectIdentifier(this._self) == _CNewValuesNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CNewValuesNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: NewValuesNotifier: Methods

  /** Необходимо вызывать, чтобы сообщить об обновлении параметров. */
  void sendNotification()  {
    void res = _CNewValuesNotifier_sendNotification(_CNewValuesNotifierMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - NewValuesNotifier <-> CNewValuesNotifier

final class _CNewValuesNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CNewValuesNotifierBasicFunctions on _CNewValuesNotifier {
  void _releaseIntermediate() {
    _CNewValuesNotifier_release(_impl);
  }

  _CNewValuesNotifier _retain() {
    return _CNewValuesNotifier_retain(_impl);
  }
}

extension _CNewValuesNotifierToDart on _CNewValuesNotifier {
  NewValuesNotifier _toDart() {
    return NewValuesNotifier._create(_retain()._impl);
  }
}


extension _DartToCNewValuesNotifier on NewValuesNotifier {
  _CNewValuesNotifier _copyFromDartTo_CNewValuesNotifier() {
    return (_CNewValuesNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - FollowValue

enum FollowValue {
  coordinates(1),
  bearing(2),
  tilt(4),
  styleZoom(8),
  ;

  const FollowValue(this.rawValue);
  final int rawValue;

  static FollowValue getByValue(int value) {
    return FollowValue.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CFollowValue extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CFollowValueBasicFunctions on _CFollowValue {
  void _releaseIntermediate() {
  }
}

extension _CFollowValueToDart on _CFollowValue {
  FollowValue _toDart() {
    return FollowValue.getByValue(this.rawValue);
  }
}

extension _DartTo_CFollowValue on FollowValue {
  _CFollowValue _copyFromDartTo_CFollowValue() {
    return _CFollowValueMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - StyleZoom

/**
 Стилевой уровень масштабирования.

 Задаётся в редакторе стилей и отличается от обычного уровня масштабирования тем, что для одного StyleZoom
 масштаб карты одинаков независимо от широты.
 Однако, при Zoom
 <
 9 или при latitude > 60 градусов StyleZoom == Zoom и масштаб карты на разных широтах отличается.

 - Note: StyleZoom не может быть отрицательным.
*/
class StyleZoom {
  final double value;

  const StyleZoom([this.value = 0]);

  StyleZoom copyWith({
    double? value
  }) {
    return StyleZoom(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is StyleZoom &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CStyleZoom extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - StyleZoom <-> _CStyleZoom

extension _CStyleZoomToDart on _CStyleZoom {
  StyleZoom _toDart() {
    return StyleZoom(
      this.value
    );
  }
}

extension _DartTo_CStyleZoom on StyleZoom {
  _CStyleZoom _copyFromDartTo_CStyleZoom() {
    final res = _CStyleZoomMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CStyleZoomRelease on _CStyleZoom {
  void _releaseIntermediate() {
  }
}

// MARK: - _CustomFollowControllerCpp

/**
 Интерфейс, который можно реализовать на платформе для создания собственного контроллера слежения за параметрами
 Для добавления контроллера в камеру, нужно реализовать этот интерфейс и создать объект FollowController'а передав
 в качестве аргумента объект, реализующий данные интерфейс.
*/
class _CustomFollowControllerCpp extends CustomFollowController implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CCustomFollowControllerCpp_releasePtr);

  _CustomFollowControllerCpp._raw(this._self);
  factory _CustomFollowControllerCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _CustomFollowControllerCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _CustomFollowControllerCpp &&
    other.runtimeType == runtimeType &&
    _CCustomFollowControllerCpp_cg_objectIdentifier(this._self) == _CCustomFollowControllerCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCustomFollowControllerCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _CustomFollowControllerCpp: Methods

  /** Набор видов значений, которыми умеет управлять данный контроллер. */
  FollowValueEnumSet availableValues()  {
    _COptionSet_CFollowValue res = _CCustomFollowControllerCpp_availableValues(_CCustomFollowControllerCppMakeDefault().._impl=_self);
    return res._toDart();
  }

  /**
   С помощью этого метода в контроллер сообщается, какие из
   предоставляемых им значений используются. Это позволяет освободить
   ресурсы, связанные с вычислением неиспользуемых значений. Метод может
   вызываться многократно с разными значениями, в этом случае актуальным
   является последнее из них.
  */
  void requestValues(
    FollowValueEnumSet values
  )  {
    var _a1 = values._copyFromDartTo_COptionSet_CFollowValue();
    void res = _CCustomFollowControllerCpp_requestValues_COptionSet_CFollowValue(_CCustomFollowControllerCppMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Установка нотифаера, который оповещает о новых значениях.
   Нотифаер нужно сохранить в реализуемом контроллере
  */
  void setNewValuesNotifier(
    NewValuesNotifier? notifier
  )  {
    var _a1 = notifier._copyFromDartTo_COptional_CNewValuesNotifier();
    void res = _CCustomFollowControllerCpp_setNewValuesNotifier_COptional_CNewValuesNotifier(_CCustomFollowControllerCppMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Географические координаты.
   Метод вызывается только после вызова request_values с соответствующими параметрами.
  */
  GeoPoint? coordinates()  {
    _COptional_CGeoPoint res = _CCustomFollowControllerCpp_coordinates(_CCustomFollowControllerCppMakeDefault().._impl=_self);
    return res._toDart();
  }

  /**
   Направление.
   Метод вызывается только после вызова request_values с соответствующими параметрами.
  */
  Bearing? bearing()  {
    _COptional_CBearing res = _CCustomFollowControllerCpp_bearing(_CCustomFollowControllerCppMakeDefault().._impl=_self);
    return res._toDart();
  }

  /**
   Наклон карты.
   Метод вызывается только после вызова request_values с соответствующими параметрами.
  */
  Tilt? tilt()  {
    _COptional_CTilt res = _CCustomFollowControllerCpp_tilt(_CCustomFollowControllerCppMakeDefault().._impl=_self);
    return res._toDart();
  }

  /**
   Стилевой уровень масштабирования карты.
   Метод вызывается только после вызова request_values с соответствующими параметрами.
  */
  StyleZoom? styleZoom()  {
    _COptional_CStyleZoom res = _CCustomFollowControllerCpp_styleZoom(_CCustomFollowControllerCppMakeDefault().._impl=_self);
    return res._toDart();
  }

}

// MARK: - _CustomFollowControllerCpp <-> CCustomFollowControllerCpp

final class _CCustomFollowControllerCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCustomFollowControllerCppBasicFunctions on _CCustomFollowControllerCpp {
  void _releaseIntermediate() {
    _CCustomFollowControllerCpp_release(_impl);
  }

  _CCustomFollowControllerCpp _retain() {
    return _CCustomFollowControllerCpp_retain(_impl);
  }
}

extension _CCustomFollowControllerCppToDart on _CCustomFollowControllerCpp {
  _CustomFollowControllerCpp _toDart() {
    return _CustomFollowControllerCpp._create(_retain()._impl);
  }
}


extension _DartToCCustomFollowControllerCpp on _CustomFollowControllerCpp {
  _CCustomFollowControllerCpp _copyFromDartTo_CCustomFollowControllerCpp() {
    return (_CCustomFollowControllerCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - FollowValueEnumSet

class FollowValueEnumSet extends EnumSet<FollowValue> {
  FollowValueEnumSet() : super();

  factory FollowValueEnumSet.fromRawValue(int rawValue) {
    FollowValueEnumSet enumSet = FollowValueEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory FollowValueEnumSet.of(Iterable<FollowValue> elements) {
    FollowValueEnumSet enumSet = FollowValueEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory FollowValueEnumSet.all() {
    FollowValueEnumSet enumSet = FollowValueEnumSet();
    enumSet.addAll(FollowValue.values);
    return enumSet;
  }

  @override
  bool contains(FollowValue value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<FollowValue> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(FollowValue value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<FollowValue> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(FollowValue value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<FollowValue> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<FollowValue> intersection(EnumSet<FollowValue> other) =>
      FollowValueEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<FollowValue> union(EnumSet<FollowValue> other) =>
      FollowValueEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<FollowValue> difference(EnumSet<FollowValue> other) =>
      FollowValueEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<FollowValue> toSet() {
    Set<FollowValue> result = {};
    FollowValue.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    FollowValue.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CFollowValue extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CFollowValueBasicFunctions on _COptionSet_CFollowValue {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CFollowValueToDart on _COptionSet_CFollowValue {
  FollowValueEnumSet _toDart() {
    return FollowValueEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CFollowValue on FollowValueEnumSet {
  _COptionSet_CFollowValue _copyFromDartTo_COptionSet_CFollowValue() {
    return _COptionSet_CFollowValueMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - NewValuesNotifier? <-> _COptional_CNewValuesNotifier

final class _COptional_CNewValuesNotifier extends ffi.Struct {
  
  external _CNewValuesNotifier value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CNewValuesNotifierBasicFunctions on _COptional_CNewValuesNotifier {
  void _releaseIntermediate() {
    _COptional_CNewValuesNotifier_release(this);
  }
}

extension _COptional_CNewValuesNotifierToDart on _COptional_CNewValuesNotifier {
  NewValuesNotifier? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CNewValuesNotifier on NewValuesNotifier? {
  _COptional_CNewValuesNotifier _copyFromDartTo_COptional_CNewValuesNotifier() {
    final cOptional = _COptional_CNewValuesNotifierMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CNewValuesNotifier();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - GeoPoint? <-> _COptional_CGeoPoint

final class _COptional_CGeoPoint extends ffi.Struct {
  
  external _CGeoPoint value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGeoPointBasicFunctions on _COptional_CGeoPoint {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CGeoPointToDart on _COptional_CGeoPoint {
  GeoPoint? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGeoPoint on GeoPoint? {
  _COptional_CGeoPoint _copyFromDartTo_COptional_CGeoPoint() {
    final cOptional = _COptional_CGeoPointMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGeoPoint();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Tilt? <-> _COptional_CTilt

final class _COptional_CTilt extends ffi.Struct {
  
  external _CTilt value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CTiltBasicFunctions on _COptional_CTilt {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CTiltToDart on _COptional_CTilt {
  Tilt? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CTilt on Tilt? {
  _COptional_CTilt _copyFromDartTo_COptional_CTilt() {
    final cOptional = _COptional_CTiltMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CTilt();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - StyleZoom? <-> _COptional_CStyleZoom

final class _COptional_CStyleZoom extends ffi.Struct {
  
  external _CStyleZoom value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CStyleZoomBasicFunctions on _COptional_CStyleZoom {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CStyleZoomToDart on _COptional_CStyleZoom {
  StyleZoom? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CStyleZoom on StyleZoom? {
  _COptional_CStyleZoom _copyFromDartTo_COptional_CStyleZoom() {
    final cOptional = _COptional_CStyleZoomMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CStyleZoom();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CustomFollowController

/**
 Интерфейс, который можно реализовать на платформе для создания собственного контроллера слежения за параметрами
 Для добавления контроллера в камеру, нужно реализовать этот интерфейс и создать объект FollowController'а передав
 в качестве аргумента объект, реализующий данные интерфейс.
*/
abstract class CustomFollowController {
  FollowValueEnumSet availableValues();
  void requestValues(
    FollowValueEnumSet values
  );
  void setNewValuesNotifier(
    NewValuesNotifier? notifier
  );
  GeoPoint? coordinates();
  Bearing? bearing();
  Tilt? tilt();
  StyleZoom? styleZoom();
}

class _CustomFollowController {
  final CustomFollowController object;
  int refCounter = 1;

  _CustomFollowController(this.object);
}

final class _CCustomFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptionSet_CFollowValue)>>)>> _availableValues;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptionSet_CFollowValue)>> _requestValues_COptionSet_CFollowValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptional_CNewValuesNotifier)>> _setNewValuesNotifier_COptional_CNewValuesNotifier;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CGeoPoint)>>)>> _coordinates;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CBearing)>>)>> _bearing;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CTilt)>>)>> _tilt;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CStyleZoom)>>)>> _styleZoom;
}

extension _CCustomFollowControllerBasicFunctions on _CCustomFollowController {
  void _releaseIntermediate() {
    _CCustomFollowController_release(this);
  }
}

int _CCustomFollowControllerInstanceCounter = 1;
final _CCustomFollowControllerInstanceMap = <int, _CustomFollowController>{};

extension _CCustomFollowControllerToDart on _CCustomFollowController {
  CustomFollowController _toDart() {
    late CustomFollowController? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CCustomFollowControllerInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CCustomFollowControllerCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CCustomFollowController");
    }
    return result;
  }
}

extension _DartTo_CCustomFollowController on CustomFollowController {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CCustomFollowControllerInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CCustomFollowControllerInstanceMap.remove(platformValue.address);
  }

  _CCustomFollowController _copyFromDartTo_CCustomFollowController() {
    var res = _CCustomFollowControllerMakeDefault();
    if (this is _CustomFollowControllerCpp) {
      final cppValue = this as _CustomFollowControllerCpp;
      res._cppValue = cppValue._copyFromDartTo_CCustomFollowControllerCpp()._impl;
      return res;
    }
    final instanceId = _CCustomFollowControllerInstanceCounter;
    _CCustomFollowControllerInstanceCounter += 1;
    _CCustomFollowControllerInstanceMap[instanceId] = _CustomFollowController(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final availableValuesFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptionSet_CFollowValue)>>)>.listener(availableValuesFunction);
    res._availableValues = availableValuesFunctionCallable.nativeFunction;
    final requestValues_COptionSet_CFollowValueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptionSet_CFollowValue)>.listener(requestValues_COptionSet_CFollowValueFunction);
    res._requestValues_COptionSet_CFollowValue = requestValues_COptionSet_CFollowValueFunctionCallable.nativeFunction;
    final setNewValuesNotifier_COptional_CNewValuesNotifierFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptional_CNewValuesNotifier)>.listener(setNewValuesNotifier_COptional_CNewValuesNotifierFunction);
    res._setNewValuesNotifier_COptional_CNewValuesNotifier = setNewValuesNotifier_COptional_CNewValuesNotifierFunctionCallable.nativeFunction;
    final coordinatesFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CGeoPoint)>>)>.listener(coordinatesFunction);
    res._coordinates = coordinatesFunctionCallable.nativeFunction;
    final bearingFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CBearing)>>)>.listener(bearingFunction);
    res._bearing = bearingFunctionCallable.nativeFunction;
    final tiltFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CTilt)>>)>.listener(tiltFunction);
    res._tilt = tiltFunctionCallable.nativeFunction;
    final styleZoomFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CStyleZoom)>>)>.listener(styleZoomFunction);
    res._styleZoom = styleZoomFunctionCallable.nativeFunction;
    return res;
  }

  static void availableValuesFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptionSet_CFollowValue)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final res = platformObject.object.availableValues();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _COptionSet_CFollowValue)>();
    callbackFunction(context, res._copyFromDartTo_COptionSet_CFollowValue());
  }

  static void requestValues_COptionSet_CFollowValueFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _COptionSet_CFollowValue values) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final valuesDart = values._toDart();
    platformObject.object.requestValues(valuesDart);
    values._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }

  static void setNewValuesNotifier_COptional_CNewValuesNotifierFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _COptional_CNewValuesNotifier notifier) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final notifierDart = notifier._toDart();
    platformObject.object.setNewValuesNotifier(notifierDart);
    notifier._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }

  static void coordinatesFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CGeoPoint)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final res = platformObject.object.coordinates();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _COptional_CGeoPoint)>();
    callbackFunction(context, res._copyFromDartTo_COptional_CGeoPoint());
  }

  static void bearingFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CBearing)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final res = platformObject.object.bearing();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _COptional_CBearing)>();
    callbackFunction(context, res._copyFromDartTo_COptional_CBearing());
  }

  static void tiltFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CTilt)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final res = platformObject.object.tilt();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _COptional_CTilt)>();
    callbackFunction(context, res._copyFromDartTo_COptional_CTilt());
  }

  static void styleZoomFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CStyleZoom)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final res = platformObject.object.styleZoom();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _COptional_CStyleZoom)>();
    callbackFunction(context, res._copyFromDartTo_COptional_CStyleZoom());
  }


}

// MARK: - Event

/** Базовый класс для всех обрабатываемых событий. */
class Event implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CEvent_releasePtr);

  Event._raw(this._self);
  factory Event._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Event._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Event &&
    other.runtimeType == runtimeType &&
    _CEvent_cg_objectIdentifier(this._self) == _CEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Event <-> CEvent

final class _CEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CEventBasicFunctions on _CEvent {
  void _releaseIntermediate() {
    _CEvent_release(_impl);
  }

  _CEvent _retain() {
    return _CEvent_retain(_impl);
  }
}

extension _CEventToDart on _CEvent {
  Event _toDart() {
    final selector = _CEvent_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = Event._create(_retain()._impl);
        return res;
      case 1:
        final res = InputEvent._create(_retain()._impl);
        return res;
      case 2:
        final res = CancelEvent._create(_retain()._impl);
        return res;
      case 3:
        final res = DirectMapControlBeginEvent._create(_retain()._impl);
        return res;
      case 4:
        final res = MapRotationBeginEvent._create(_retain()._impl);
        return res;
      case 5:
        final res = MapRotationEndEvent._create(_retain()._impl);
        return res;
      case 6:
        final res = MapScalingBeginEvent._create(_retain()._impl);
        return res;
      case 7:
        final res = MapScalingEndEvent._create(_retain()._impl);
        return res;
      case 8:
        final res = MapShiftBeginEvent._create(_retain()._impl);
        return res;
      case 9:
        final res = MapShiftEndEvent._create(_retain()._impl);
        return res;
      case 10:
        final res = RotateMapToNorthEvent._create(_retain()._impl);
        return res;
      case 11:
        final res = ScaleMapEvent._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCEvent on Event {
  _CEvent _copyFromDartTo_CEvent() {
    return (_CEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - InputEvent

/** Событие пользовательского ввода. */
class InputEvent extends Event implements ffi.Finalizable {
  /**
   Получение времени регистрации события ввода.
  
   - Returns: время регистрации события, в мс
  */
  Duration get timestamp {
    _CTimeInterval res = _CInputEvent_timestamp(_CInputEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CInputEvent_releasePtr);

  InputEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory InputEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = InputEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is InputEvent &&
    other.runtimeType == runtimeType &&
    _CInputEvent_cg_objectIdentifier(this._self) == _CInputEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CInputEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - InputEvent <-> CInputEvent

final class _CInputEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CInputEventBasicFunctions on _CInputEvent {
  void _releaseIntermediate() {
    _CInputEvent_release(_impl);
  }

  _CInputEvent _retain() {
    return _CInputEvent_retain(_impl);
  }
}

extension _CInputEventToDart on _CInputEvent {
  InputEvent _toDart() {
    final selector = _CInputEvent_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = InputEvent._create(_retain()._impl);
        return res;
      case 1:
        final res = DirectMapControlEndEvent._create(_retain()._impl);
        return res;
      case 2:
        final res = DirectMapRotationEvent._create(_retain()._impl);
        return res;
      case 3:
        final res = DirectMapScalingEvent._create(_retain()._impl);
        return res;
      case 4:
        final res = DirectMapShiftEvent._create(_retain()._impl);
        return res;
      case 5:
        final res = DirectMapTiltEvent._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCInputEvent on InputEvent {
  _CInputEvent _copyFromDartTo_CInputEvent() {
    return (_CInputEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelEvent

/**
 Событие отмены текущего действия.

 Вызывается, например, при отмене жеста, потере фокуса окна или при потере захвата мыши.
 Также может быть вызван изнутри карты при смене ограничений уровня масштабирования, некоторых изменениях режима
 слежения и установке интерактивного режима карты.
*/
class CancelEvent extends Event implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CCancelEvent_releasePtr);

  CancelEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory CancelEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CancelEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory CancelEvent() {
    _CCancelEvent res = _CCancelEvent_C_create();
    return CancelEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CancelEvent &&
    other.runtimeType == runtimeType &&
    _CCancelEvent_cg_objectIdentifier(this._self) == _CCancelEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCancelEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - CancelEvent <-> CCancelEvent

final class _CCancelEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCancelEventBasicFunctions on _CCancelEvent {
  void _releaseIntermediate() {
    _CCancelEvent_release(_impl);
  }

  _CCancelEvent _retain() {
    return _CCancelEvent_retain(_impl);
  }
}

extension _CCancelEventToDart on _CCancelEvent {
  CancelEvent _toDart() {
    return CancelEvent._create(_retain()._impl);
  }
}


extension _DartToCCancelEvent on CancelEvent {
  _CCancelEvent _copyFromDartTo_CCancelEvent() {
    return (_CCancelEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DgisSourceWorkingMode

/** Установка режима работы источника данных IDgisSource. */
enum DgisSourceWorkingMode {
  /** Получение данных с серверов 2ГИС. */
  online(0),
  /** Использование в работе предварительно загруженных данных. */
  offline(1),
  /**
   Гибридный режим, при котором приоритетно получение данных с серверов 2ГИС.
   Предварительно загруженные данные используются,
   если по каким-либо причинам не удалось получить данные с серверов или
   предварительно загруженные данные совпадают с данными на сервере.
  */
  hybridOnlineFirst(2),
  /**
   Гибридный режим, при котором приоритетно использование предварительно загруженных данных.
   Данные с серверов 2ГИС используются, если отсутствуют предварительно загруженные данные.
  */
  hybridOfflineFirst(3),
  ;

  const DgisSourceWorkingMode(this.rawValue);
  final int rawValue;

  static DgisSourceWorkingMode getByValue(int value) {
    return DgisSourceWorkingMode.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CDgisSourceWorkingMode extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CDgisSourceWorkingModeBasicFunctions on _CDgisSourceWorkingMode {
  void _releaseIntermediate() {
  }
}

extension _CDgisSourceWorkingModeToDart on _CDgisSourceWorkingMode {
  DgisSourceWorkingMode _toDart() {
    return DgisSourceWorkingMode.getByValue(this.rawValue);
  }
}

extension _DartTo_CDgisSourceWorkingMode on DgisSourceWorkingMode {
  _CDgisSourceWorkingMode _copyFromDartTo_CDgisSourceWorkingMode() {
    return _CDgisSourceWorkingModeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - DirectMapControlBeginEvent

/**
 Событие начала прямого управления картой.
 Сообщает карте, что необходимо обрабатывать события прямого управления картой.
 События прямого управления работают только от DirectMapControlBeginEvent до DirectMapControlEndEvent.
 После завершения последовательности событий прямого управления может запуститься кинематика.
 Кинематика использует время возникновения события, поэтому лучше использовать время, полученное от системы,
 а не заполнять значение при обработке.
 Пока кинематика работает только для перемещения карты, но не для вращения и масштабирования.
*/
class DirectMapControlBeginEvent extends Event implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CDirectMapControlBeginEvent_releasePtr);

  DirectMapControlBeginEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DirectMapControlBeginEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectMapControlBeginEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory DirectMapControlBeginEvent() {
    _CDirectMapControlBeginEvent res = _CDirectMapControlBeginEvent_C_create();
    return DirectMapControlBeginEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectMapControlBeginEvent &&
    other.runtimeType == runtimeType &&
    _CDirectMapControlBeginEvent_cg_objectIdentifier(this._self) == _CDirectMapControlBeginEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectMapControlBeginEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DirectMapControlBeginEvent <-> CDirectMapControlBeginEvent

final class _CDirectMapControlBeginEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectMapControlBeginEventBasicFunctions on _CDirectMapControlBeginEvent {
  void _releaseIntermediate() {
    _CDirectMapControlBeginEvent_release(_impl);
  }

  _CDirectMapControlBeginEvent _retain() {
    return _CDirectMapControlBeginEvent_retain(_impl);
  }
}

extension _CDirectMapControlBeginEventToDart on _CDirectMapControlBeginEvent {
  DirectMapControlBeginEvent _toDart() {
    return DirectMapControlBeginEvent._create(_retain()._impl);
  }
}


extension _DartToCDirectMapControlBeginEvent on DirectMapControlBeginEvent {
  _CDirectMapControlBeginEvent _copyFromDartTo_CDirectMapControlBeginEvent() {
    return (_CDirectMapControlBeginEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DirectMapControlEndEvent

/**
 Событие окончания прямого управления картой.
 Завершает прямое управление картой, начатое после получения события DirectMapControlBeginEvent.
 О событиях прямого управления картой описано в DirectMapControlBeginEvent.
*/
class DirectMapControlEndEvent extends InputEvent implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CDirectMapControlEndEvent_releasePtr);

  DirectMapControlEndEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DirectMapControlEndEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectMapControlEndEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory DirectMapControlEndEvent(
    Duration timestamp
  ) {
    var _a0 = timestamp._copyFromDartTo_CTimeInterval();
    _CDirectMapControlEndEvent res = _CDirectMapControlEndEvent_C_createWith_CTimeInterval(_a0);
    return DirectMapControlEndEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectMapControlEndEvent &&
    other.runtimeType == runtimeType &&
    _CDirectMapControlEndEvent_cg_objectIdentifier(this._self) == _CDirectMapControlEndEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectMapControlEndEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DirectMapControlEndEvent <-> CDirectMapControlEndEvent

final class _CDirectMapControlEndEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectMapControlEndEventBasicFunctions on _CDirectMapControlEndEvent {
  void _releaseIntermediate() {
    _CDirectMapControlEndEvent_release(_impl);
  }

  _CDirectMapControlEndEvent _retain() {
    return _CDirectMapControlEndEvent_retain(_impl);
  }
}

extension _CDirectMapControlEndEventToDart on _CDirectMapControlEndEvent {
  DirectMapControlEndEvent _toDart() {
    return DirectMapControlEndEvent._create(_retain()._impl);
  }
}


extension _DartToCDirectMapControlEndEvent on DirectMapControlEndEvent {
  _CDirectMapControlEndEvent _copyFromDartTo_CDirectMapControlEndEvent() {
    return (_CDirectMapControlEndEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ScreenPoint

/**
 Точка в экранных координатах.

 Направления осей: x - вправо, y - вниз.
 (0.0, 0.0) - левый верхний угол левого верхнего пикселя.
 Целая часть координаты - номер пикселя, дробная - относительное местоположение в пикселе.
*/
class ScreenPoint {
  final double x;
  final double y;

  const ScreenPoint({
    this.x = 0,
    this.y = 0
  });

  ScreenPoint copyWith({
    double? x,
    double? y
  }) {
    return ScreenPoint(
      x: x ?? this.x,
      y: y ?? this.y
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScreenPoint &&
    other.runtimeType == runtimeType &&
    other.x == x &&
    other.y == y;

  @override
  int get hashCode {
    return Object.hash(x, y);
  }

}
final class _CScreenPoint extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

}
// MARK: - ScreenPoint <-> _CScreenPoint

extension _CScreenPointToDart on _CScreenPoint {
  ScreenPoint _toDart() {
    return ScreenPoint(
      x: this.x,
      y: this.y
    );
  }
}

extension _DartTo_CScreenPoint on ScreenPoint {
  _CScreenPoint _copyFromDartTo_CScreenPoint() {
    final res = _CScreenPointMakeDefault();
    res.x = this.x;
    res.y = this.y;
    return res;
  }
}
extension _CScreenPointRelease on _CScreenPoint {
  void _releaseIntermediate() {
  }
}

// MARK: - DirectMapRotationEvent

/** Событие прямого вращения карты. О событиях прямого управления картой описано в DirectMapControlBeginEvent. */
class DirectMapRotationEvent extends InputEvent implements ffi.Finalizable {
  /** Изменение угла поворота карты. */
  Bearing get bearingDelta {
    _CBearing res = _CDirectMapRotationEvent_bearingDelta(_CDirectMapRotationEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Точка на экране, вокруг которой вращается карта. */
  ScreenPoint? get rotationCenter {
    _COptional_CScreenPoint res = _CDirectMapRotationEvent_rotationCenter(_CDirectMapRotationEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CDirectMapRotationEvent_releasePtr);

  DirectMapRotationEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DirectMapRotationEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectMapRotationEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   - Parameter bearingDelta: изменение угла поворота карты, в градусах.
   Положительные значения соответствуют направлению вращения против часовой стрелки
   - Parameter timestamp: Время генерации системного события.
   - Parameter rotationCenter: Точка на экране, вокруг которой вращается карта. Если точка не задана,
   то вращение происходит относительно точки позиции карты.
  */
  factory DirectMapRotationEvent(
    Bearing bearingDelta,
    Duration timestamp,
    [ScreenPoint? rotationCenter = null
    ]) {
    var _a0 = bearingDelta._copyFromDartTo_CBearing();
    var _a1 = timestamp._copyFromDartTo_CTimeInterval();
    var _a2 = rotationCenter._copyFromDartTo_COptional_CScreenPoint();
    _CDirectMapRotationEvent res = _CDirectMapRotationEvent_C_createWith_CBearing_CTimeInterval_COptional_CScreenPoint(_a0, _a1, _a2);
    return DirectMapRotationEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectMapRotationEvent &&
    other.runtimeType == runtimeType &&
    _CDirectMapRotationEvent_cg_objectIdentifier(this._self) == _CDirectMapRotationEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectMapRotationEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DirectMapRotationEvent <-> CDirectMapRotationEvent

final class _CDirectMapRotationEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectMapRotationEventBasicFunctions on _CDirectMapRotationEvent {
  void _releaseIntermediate() {
    _CDirectMapRotationEvent_release(_impl);
  }

  _CDirectMapRotationEvent _retain() {
    return _CDirectMapRotationEvent_retain(_impl);
  }
}

extension _CDirectMapRotationEventToDart on _CDirectMapRotationEvent {
  DirectMapRotationEvent _toDart() {
    return DirectMapRotationEvent._create(_retain()._impl);
  }
}


extension _DartToCDirectMapRotationEvent on DirectMapRotationEvent {
  _CDirectMapRotationEvent _copyFromDartTo_CDirectMapRotationEvent() {
    return (_CDirectMapRotationEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ScreenPoint? <-> _COptional_CScreenPoint

final class _COptional_CScreenPoint extends ffi.Struct {
  
  external _CScreenPoint value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CScreenPointBasicFunctions on _COptional_CScreenPoint {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CScreenPointToDart on _COptional_CScreenPoint {
  ScreenPoint? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CScreenPoint on ScreenPoint? {
  _COptional_CScreenPoint _copyFromDartTo_COptional_CScreenPoint() {
    final cOptional = _COptional_CScreenPointMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CScreenPoint();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - DirectMapScalingEvent

/** Событие прямого масштабирования карты. События прямого управления картой описаны в DirectMapControlBeginEvent. */
class DirectMapScalingEvent extends InputEvent implements ffi.Finalizable {
  /** Величина, на которую изменится текущее значение масштаба. */
  double get zoomDelta {
    double res = _CDirectMapScalingEvent_zoomDelta(_CDirectMapScalingEventMakeDefault().._impl=_self);
    return res;
  }
  /** Точка на экране, относительно которой масштабируется карта. */
  ScreenPoint? get scalingCenter {
    _COptional_CScreenPoint res = _CDirectMapScalingEvent_scalingCenter(_CDirectMapScalingEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CDirectMapScalingEvent_releasePtr);

  DirectMapScalingEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DirectMapScalingEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectMapScalingEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   - Parameter zoomDelta: Величина, на которую изменится текущее значение масштаба.
   - Parameter timestamp: Время генерации системного события.
   - Parameter scalingCenter: Точка на экране, относительно которой масштабируется карта. Если точка не задана,
   то масштабирование происходит относительно точки позиции карты.
  */
  factory DirectMapScalingEvent(
    double zoomDelta,
    Duration timestamp,
    [ScreenPoint? scalingCenter = null
    ]) {
    var _a1 = timestamp._copyFromDartTo_CTimeInterval();
    var _a2 = scalingCenter._copyFromDartTo_COptional_CScreenPoint();
    _CDirectMapScalingEvent res = _CDirectMapScalingEvent_C_createWith_float_CTimeInterval_COptional_CScreenPoint(zoomDelta, _a1, _a2);
    return DirectMapScalingEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectMapScalingEvent &&
    other.runtimeType == runtimeType &&
    _CDirectMapScalingEvent_cg_objectIdentifier(this._self) == _CDirectMapScalingEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectMapScalingEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DirectMapScalingEvent <-> CDirectMapScalingEvent

final class _CDirectMapScalingEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectMapScalingEventBasicFunctions on _CDirectMapScalingEvent {
  void _releaseIntermediate() {
    _CDirectMapScalingEvent_release(_impl);
  }

  _CDirectMapScalingEvent _retain() {
    return _CDirectMapScalingEvent_retain(_impl);
  }
}

extension _CDirectMapScalingEventToDart on _CDirectMapScalingEvent {
  DirectMapScalingEvent _toDart() {
    return DirectMapScalingEvent._create(_retain()._impl);
  }
}


extension _DartToCDirectMapScalingEvent on DirectMapScalingEvent {
  _CDirectMapScalingEvent _copyFromDartTo_CDirectMapScalingEvent() {
    return (_CDirectMapScalingEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ScreenShift

/**
 Смещение карты по горизонтали и вертикали в координатном пространстве экрана.

 Положительное направление смещения: dx - вправо, dy - вниз.
*/
class ScreenShift {
  final double dx;
  final double dy;

  const ScreenShift({
    this.dx = 0,
    this.dy = 0
  });

  ScreenShift copyWith({
    double? dx,
    double? dy
  }) {
    return ScreenShift(
      dx: dx ?? this.dx,
      dy: dy ?? this.dy
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScreenShift &&
    other.runtimeType == runtimeType &&
    other.dx == dx &&
    other.dy == dy;

  @override
  int get hashCode {
    return Object.hash(dx, dy);
  }

}
final class _CScreenShift extends ffi.Struct {
  @ffi.Float()
  external double dx;

  @ffi.Float()
  external double dy;

}
// MARK: - ScreenShift <-> _CScreenShift

extension _CScreenShiftToDart on _CScreenShift {
  ScreenShift _toDart() {
    return ScreenShift(
      dx: this.dx,
      dy: this.dy
    );
  }
}

extension _DartTo_CScreenShift on ScreenShift {
  _CScreenShift _copyFromDartTo_CScreenShift() {
    final res = _CScreenShiftMakeDefault();
    res.dx = this.dx;
    res.dy = this.dy;
    return res;
  }
}
extension _CScreenShiftRelease on _CScreenShift {
  void _releaseIntermediate() {
  }
}

// MARK: - DirectMapShiftEvent

/** Событие прямого сдвига карты. События прямого управления картой описаны в DirectMapControlBeginEvent. */
class DirectMapShiftEvent extends InputEvent implements ffi.Finalizable {
  /** Изменение экранной позиции карты. */
  ScreenShift get screenShift {
    _CScreenShift res = _CDirectMapShiftEvent_screenShift(_CDirectMapShiftEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Центральная точка, от которой производится смещение карты. */
  ScreenPoint get shiftedPoint {
    _CScreenPoint res = _CDirectMapShiftEvent_shiftedPoint(_CDirectMapShiftEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CDirectMapShiftEvent_releasePtr);

  DirectMapShiftEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DirectMapShiftEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectMapShiftEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   - Parameter screenShift: Изменение экранной позиции карты относительно предыдущей, в пикселях.
   - Parameter shiftedPoint: Центральная точка, от которой производится смещение карты.
   - Parameter timestamp: Время генерации системного события.
  */
  factory DirectMapShiftEvent(
    ScreenShift screenShift,
    ScreenPoint shiftedPoint,
    Duration timestamp
  ) {
    var _a0 = screenShift._copyFromDartTo_CScreenShift();
    var _a1 = shiftedPoint._copyFromDartTo_CScreenPoint();
    var _a2 = timestamp._copyFromDartTo_CTimeInterval();
    _CDirectMapShiftEvent res = _CDirectMapShiftEvent_C_createWith_CScreenShift_CScreenPoint_CTimeInterval(_a0, _a1, _a2);
    return DirectMapShiftEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectMapShiftEvent &&
    other.runtimeType == runtimeType &&
    _CDirectMapShiftEvent_cg_objectIdentifier(this._self) == _CDirectMapShiftEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectMapShiftEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DirectMapShiftEvent <-> CDirectMapShiftEvent

final class _CDirectMapShiftEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectMapShiftEventBasicFunctions on _CDirectMapShiftEvent {
  void _releaseIntermediate() {
    _CDirectMapShiftEvent_release(_impl);
  }

  _CDirectMapShiftEvent _retain() {
    return _CDirectMapShiftEvent_retain(_impl);
  }
}

extension _CDirectMapShiftEventToDart on _CDirectMapShiftEvent {
  DirectMapShiftEvent _toDart() {
    return DirectMapShiftEvent._create(_retain()._impl);
  }
}


extension _DartToCDirectMapShiftEvent on DirectMapShiftEvent {
  _CDirectMapShiftEvent _copyFromDartTo_CDirectMapShiftEvent() {
    return (_CDirectMapShiftEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DirectMapTiltEvent

/** Событие прямого наклона камеры. События прямого управления картой описаны в DirectMapControlBeginEvent. */
class DirectMapTiltEvent extends InputEvent implements ffi.Finalizable {
  /** Изменение угла наклона в градусах. */
  double get delta {
    double res = _CDirectMapTiltEvent_delta(_CDirectMapTiltEventMakeDefault().._impl=_self);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CDirectMapTiltEvent_releasePtr);

  DirectMapTiltEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DirectMapTiltEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectMapTiltEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   - Parameter delta: Изменение угла наклона в градусах.
   - Parameter timestamp: Время генерации системного события.
  */
  factory DirectMapTiltEvent(
    double delta,
    Duration timestamp
  ) {
    var _a1 = timestamp._copyFromDartTo_CTimeInterval();
    _CDirectMapTiltEvent res = _CDirectMapTiltEvent_C_createWith_float_CTimeInterval(delta, _a1);
    return DirectMapTiltEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectMapTiltEvent &&
    other.runtimeType == runtimeType &&
    _CDirectMapTiltEvent_cg_objectIdentifier(this._self) == _CDirectMapTiltEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectMapTiltEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DirectMapTiltEvent <-> CDirectMapTiltEvent

final class _CDirectMapTiltEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectMapTiltEventBasicFunctions on _CDirectMapTiltEvent {
  void _releaseIntermediate() {
    _CDirectMapTiltEvent_release(_impl);
  }

  _CDirectMapTiltEvent _retain() {
    return _CDirectMapTiltEvent_retain(_impl);
  }
}

extension _CDirectMapTiltEventToDart on _CDirectMapTiltEvent {
  DirectMapTiltEvent _toDart() {
    return DirectMapTiltEvent._create(_retain()._impl);
  }
}


extension _DartToCDirectMapTiltEvent on DirectMapTiltEvent {
  _CDirectMapTiltEvent _copyFromDartTo_CDirectMapTiltEvent() {
    return (_CDirectMapTiltEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapRotationDirection

/** Направление вращения карты. */
enum MapRotationDirection {
  /** Вращение карты по часовой стрелке. */
  clockwise(0),
  /** Вращение карты против часовой стрелки. */
  counterclockwise(1),
  ;

  const MapRotationDirection(this.rawValue);
  final int rawValue;

  static MapRotationDirection getByValue(int value) {
    return MapRotationDirection.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CMapRotationDirection extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CMapRotationDirectionBasicFunctions on _CMapRotationDirection {
  void _releaseIntermediate() {
  }
}

extension _CMapRotationDirectionToDart on _CMapRotationDirection {
  MapRotationDirection _toDart() {
    return MapRotationDirection.getByValue(this.rawValue);
  }
}

extension _DartTo_CMapRotationDirection on MapRotationDirection {
  _CMapRotationDirection _copyFromDartTo_CMapRotationDirection() {
    return _CMapRotationDirectionMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - MapRotationBeginEvent

/** Событие начала вращения карты вокруг точки. */
class MapRotationBeginEvent extends Event implements ffi.Finalizable {
  MapRotationDirection get direction {
    _CMapRotationDirection res = _CMapRotationBeginEvent_direction(_CMapRotationBeginEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapRotationBeginEvent_releasePtr);

  MapRotationBeginEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MapRotationBeginEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapRotationBeginEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapRotationBeginEvent(
    MapRotationDirection inDirection
  ) {
    var _a0 = inDirection._copyFromDartTo_CMapRotationDirection();
    _CMapRotationBeginEvent res = _CMapRotationBeginEvent_C_createWith_CMapRotationDirection(_a0);
    return MapRotationBeginEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapRotationBeginEvent &&
    other.runtimeType == runtimeType &&
    _CMapRotationBeginEvent_cg_objectIdentifier(this._self) == _CMapRotationBeginEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapRotationBeginEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapRotationBeginEvent <-> CMapRotationBeginEvent

final class _CMapRotationBeginEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapRotationBeginEventBasicFunctions on _CMapRotationBeginEvent {
  void _releaseIntermediate() {
    _CMapRotationBeginEvent_release(_impl);
  }

  _CMapRotationBeginEvent _retain() {
    return _CMapRotationBeginEvent_retain(_impl);
  }
}

extension _CMapRotationBeginEventToDart on _CMapRotationBeginEvent {
  MapRotationBeginEvent _toDart() {
    return MapRotationBeginEvent._create(_retain()._impl);
  }
}


extension _DartToCMapRotationBeginEvent on MapRotationBeginEvent {
  _CMapRotationBeginEvent _copyFromDartTo_CMapRotationBeginEvent() {
    return (_CMapRotationBeginEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapRotationEndEvent

/** Событие окончания вращения карты вокруг точки. */
class MapRotationEndEvent extends Event implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CMapRotationEndEvent_releasePtr);

  MapRotationEndEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MapRotationEndEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapRotationEndEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapRotationEndEvent() {
    _CMapRotationEndEvent res = _CMapRotationEndEvent_C_create();
    return MapRotationEndEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapRotationEndEvent &&
    other.runtimeType == runtimeType &&
    _CMapRotationEndEvent_cg_objectIdentifier(this._self) == _CMapRotationEndEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapRotationEndEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapRotationEndEvent <-> CMapRotationEndEvent

final class _CMapRotationEndEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapRotationEndEventBasicFunctions on _CMapRotationEndEvent {
  void _releaseIntermediate() {
    _CMapRotationEndEvent_release(_impl);
  }

  _CMapRotationEndEvent _retain() {
    return _CMapRotationEndEvent_retain(_impl);
  }
}

extension _CMapRotationEndEventToDart on _CMapRotationEndEvent {
  MapRotationEndEvent _toDart() {
    return MapRotationEndEvent._create(_retain()._impl);
  }
}


extension _DartToCMapRotationEndEvent on MapRotationEndEvent {
  _CMapRotationEndEvent _copyFromDartTo_CMapRotationEndEvent() {
    return (_CMapRotationEndEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapScalingDirection

/** Направление изменения масштаба карты. */
enum MapScalingDirection {
  /** Увеличение уровня масштабирования, т.е. увеличение объектов. */
  zoomIn(0),
  /** Уменьшение уровня масштабирования, т.е. уменьшение объектов. */
  zoomOut(1),
  ;

  const MapScalingDirection(this.rawValue);
  final int rawValue;

  static MapScalingDirection getByValue(int value) {
    return MapScalingDirection.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CMapScalingDirection extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CMapScalingDirectionBasicFunctions on _CMapScalingDirection {
  void _releaseIntermediate() {
  }
}

extension _CMapScalingDirectionToDart on _CMapScalingDirection {
  MapScalingDirection _toDart() {
    return MapScalingDirection.getByValue(this.rawValue);
  }
}

extension _DartTo_CMapScalingDirection on MapScalingDirection {
  _CMapScalingDirection _copyFromDartTo_CMapScalingDirection() {
    return _CMapScalingDirectionMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - MapScalingBeginEvent

/** Событие начала изменения масштаба. */
class MapScalingBeginEvent extends Event implements ffi.Finalizable {
  MapScalingDirection get direction {
    _CMapScalingDirection res = _CMapScalingBeginEvent_direction(_CMapScalingBeginEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapScalingBeginEvent_releasePtr);

  MapScalingBeginEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MapScalingBeginEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapScalingBeginEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapScalingBeginEvent(
    MapScalingDirection inDirection
  ) {
    var _a0 = inDirection._copyFromDartTo_CMapScalingDirection();
    _CMapScalingBeginEvent res = _CMapScalingBeginEvent_C_createWith_CMapScalingDirection(_a0);
    return MapScalingBeginEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapScalingBeginEvent &&
    other.runtimeType == runtimeType &&
    _CMapScalingBeginEvent_cg_objectIdentifier(this._self) == _CMapScalingBeginEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapScalingBeginEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapScalingBeginEvent <-> CMapScalingBeginEvent

final class _CMapScalingBeginEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapScalingBeginEventBasicFunctions on _CMapScalingBeginEvent {
  void _releaseIntermediate() {
    _CMapScalingBeginEvent_release(_impl);
  }

  _CMapScalingBeginEvent _retain() {
    return _CMapScalingBeginEvent_retain(_impl);
  }
}

extension _CMapScalingBeginEventToDart on _CMapScalingBeginEvent {
  MapScalingBeginEvent _toDart() {
    return MapScalingBeginEvent._create(_retain()._impl);
  }
}


extension _DartToCMapScalingBeginEvent on MapScalingBeginEvent {
  _CMapScalingBeginEvent _copyFromDartTo_CMapScalingBeginEvent() {
    return (_CMapScalingBeginEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapScalingEndEvent

/** Событие окончания изменения масштаба. */
class MapScalingEndEvent extends Event implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CMapScalingEndEvent_releasePtr);

  MapScalingEndEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MapScalingEndEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapScalingEndEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapScalingEndEvent() {
    _CMapScalingEndEvent res = _CMapScalingEndEvent_C_create();
    return MapScalingEndEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapScalingEndEvent &&
    other.runtimeType == runtimeType &&
    _CMapScalingEndEvent_cg_objectIdentifier(this._self) == _CMapScalingEndEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapScalingEndEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapScalingEndEvent <-> CMapScalingEndEvent

final class _CMapScalingEndEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapScalingEndEventBasicFunctions on _CMapScalingEndEvent {
  void _releaseIntermediate() {
    _CMapScalingEndEvent_release(_impl);
  }

  _CMapScalingEndEvent _retain() {
    return _CMapScalingEndEvent_retain(_impl);
  }
}

extension _CMapScalingEndEventToDart on _CMapScalingEndEvent {
  MapScalingEndEvent _toDart() {
    return MapScalingEndEvent._create(_retain()._impl);
  }
}


extension _DartToCMapScalingEndEvent on MapScalingEndEvent {
  _CMapScalingEndEvent _copyFromDartTo_CMapScalingEndEvent() {
    return (_CMapScalingEndEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapShiftDirection

/** Направление смещения карты. */
enum MapShiftDirection {
  left(0),
  right(1),
  up(2),
  down(3),
  leftUp(4),
  leftDown(5),
  rightUp(6),
  rightDown(7),
  ;

  const MapShiftDirection(this.rawValue);
  final int rawValue;

  static MapShiftDirection getByValue(int value) {
    return MapShiftDirection.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CMapShiftDirection extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CMapShiftDirectionBasicFunctions on _CMapShiftDirection {
  void _releaseIntermediate() {
  }
}

extension _CMapShiftDirectionToDart on _CMapShiftDirection {
  MapShiftDirection _toDart() {
    return MapShiftDirection.getByValue(this.rawValue);
  }
}

extension _DartTo_CMapShiftDirection on MapShiftDirection {
  _CMapShiftDirection _copyFromDartTo_CMapShiftDirection() {
    return _CMapShiftDirectionMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - MapShiftBeginEvent

/** Событие начала сдвига карты. */
class MapShiftBeginEvent extends Event implements ffi.Finalizable {
  MapShiftDirection get direction {
    _CMapShiftDirection res = _CMapShiftBeginEvent_direction(_CMapShiftBeginEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapShiftBeginEvent_releasePtr);

  MapShiftBeginEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MapShiftBeginEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapShiftBeginEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapShiftBeginEvent(
    MapShiftDirection inDirection
  ) {
    var _a0 = inDirection._copyFromDartTo_CMapShiftDirection();
    _CMapShiftBeginEvent res = _CMapShiftBeginEvent_C_createWith_CMapShiftDirection(_a0);
    return MapShiftBeginEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapShiftBeginEvent &&
    other.runtimeType == runtimeType &&
    _CMapShiftBeginEvent_cg_objectIdentifier(this._self) == _CMapShiftBeginEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapShiftBeginEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapShiftBeginEvent <-> CMapShiftBeginEvent

final class _CMapShiftBeginEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapShiftBeginEventBasicFunctions on _CMapShiftBeginEvent {
  void _releaseIntermediate() {
    _CMapShiftBeginEvent_release(_impl);
  }

  _CMapShiftBeginEvent _retain() {
    return _CMapShiftBeginEvent_retain(_impl);
  }
}

extension _CMapShiftBeginEventToDart on _CMapShiftBeginEvent {
  MapShiftBeginEvent _toDart() {
    return MapShiftBeginEvent._create(_retain()._impl);
  }
}


extension _DartToCMapShiftBeginEvent on MapShiftBeginEvent {
  _CMapShiftBeginEvent _copyFromDartTo_CMapShiftBeginEvent() {
    return (_CMapShiftBeginEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapShiftEndEvent

/** Событие окончания смещения карты. */
class MapShiftEndEvent extends Event implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CMapShiftEndEvent_releasePtr);

  MapShiftEndEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MapShiftEndEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapShiftEndEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapShiftEndEvent() {
    _CMapShiftEndEvent res = _CMapShiftEndEvent_C_create();
    return MapShiftEndEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapShiftEndEvent &&
    other.runtimeType == runtimeType &&
    _CMapShiftEndEvent_cg_objectIdentifier(this._self) == _CMapShiftEndEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapShiftEndEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapShiftEndEvent <-> CMapShiftEndEvent

final class _CMapShiftEndEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapShiftEndEventBasicFunctions on _CMapShiftEndEvent {
  void _releaseIntermediate() {
    _CMapShiftEndEvent_release(_impl);
  }

  _CMapShiftEndEvent _retain() {
    return _CMapShiftEndEvent_retain(_impl);
  }
}

extension _CMapShiftEndEventToDart on _CMapShiftEndEvent {
  MapShiftEndEvent _toDart() {
    return MapShiftEndEvent._create(_retain()._impl);
  }
}


extension _DartToCMapShiftEndEvent on MapShiftEndEvent {
  _CMapShiftEndEvent _copyFromDartTo_CMapShiftEndEvent() {
    return (_CMapShiftEndEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RotateMapToNorthEvent

/** Событие поворота карты на север. */
class RotateMapToNorthEvent extends Event implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CRotateMapToNorthEvent_releasePtr);

  RotateMapToNorthEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RotateMapToNorthEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RotateMapToNorthEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory RotateMapToNorthEvent() {
    _CRotateMapToNorthEvent res = _CRotateMapToNorthEvent_C_create();
    return RotateMapToNorthEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RotateMapToNorthEvent &&
    other.runtimeType == runtimeType &&
    _CRotateMapToNorthEvent_cg_objectIdentifier(this._self) == _CRotateMapToNorthEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRotateMapToNorthEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - RotateMapToNorthEvent <-> CRotateMapToNorthEvent

final class _CRotateMapToNorthEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRotateMapToNorthEventBasicFunctions on _CRotateMapToNorthEvent {
  void _releaseIntermediate() {
    _CRotateMapToNorthEvent_release(_impl);
  }

  _CRotateMapToNorthEvent _retain() {
    return _CRotateMapToNorthEvent_retain(_impl);
  }
}

extension _CRotateMapToNorthEventToDart on _CRotateMapToNorthEvent {
  RotateMapToNorthEvent _toDart() {
    return RotateMapToNorthEvent._create(_retain()._impl);
  }
}


extension _DartToCRotateMapToNorthEvent on RotateMapToNorthEvent {
  _CRotateMapToNorthEvent _copyFromDartTo_CRotateMapToNorthEvent() {
    return (_CRotateMapToNorthEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ScaleMapEvent

/** Событие изменения масштаба карты. */
class ScaleMapEvent extends Event implements ffi.Finalizable {
  /** Величина, на которую изменится текущее значение масштаба. */
  double get zoomDelta {
    double res = _CScaleMapEvent_zoomDelta(_CScaleMapEventMakeDefault().._impl=_self);
    return res;
  }
  /** Точка на экране, относительно которой масштабируется карта. */
  ScreenPoint? get scalingCenter {
    _COptional_CScreenPoint res = _CScaleMapEvent_scalingCenter(_CScaleMapEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CScaleMapEvent_releasePtr);

  ScaleMapEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory ScaleMapEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ScaleMapEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Конструктор события изменения масштаба.
  
   - Parameter zoomDelta: Величина, на которую изменится текущее значение масштаба.
   - Parameter scalingCenter: Точка на экране, относительно которой масштабируется карта. Если точка не задана,
   то масштабирование происходит относительно точки позиции карты.
  */
  factory ScaleMapEvent(
    double zoomDelta,
    [ScreenPoint? scalingCenter = null
    ]) {
    var _a1 = scalingCenter._copyFromDartTo_COptional_CScreenPoint();
    _CScaleMapEvent res = _CScaleMapEvent_C_createWith_float_COptional_CScreenPoint(zoomDelta, _a1);
    return ScaleMapEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScaleMapEvent &&
    other.runtimeType == runtimeType &&
    _CScaleMapEvent_cg_objectIdentifier(this._self) == _CScaleMapEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CScaleMapEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ScaleMapEvent <-> CScaleMapEvent

final class _CScaleMapEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CScaleMapEventBasicFunctions on _CScaleMapEvent {
  void _releaseIntermediate() {
    _CScaleMapEvent_release(_impl);
  }

  _CScaleMapEvent _retain() {
    return _CScaleMapEvent_retain(_impl);
  }
}

extension _CScaleMapEventToDart on _CScaleMapEvent {
  ScaleMapEvent _toDart() {
    return ScaleMapEvent._create(_retain()._impl);
  }
}


extension _DartToCScaleMapEvent on ScaleMapEvent {
  _CScaleMapEvent _copyFromDartTo_CScaleMapEvent() {
    return (_CScaleMapEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Object? <-> _CAny

class _Any {
  final Object object;
  int refCounter = 1;

  _Any(this.object);
}

final class _CAny extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;
}

extension _CAnyBasicFunctions on _CAny {
  void _releaseIntermediate() {
    _CAny_release(this);
  }
}

int _CAnyInstanceCounter = 1;
final _CAnyInstanceMap = <int, _Any>{};

extension _CAnyToDart on _CAny {
  Object? _toDart() {
    final anyValue = this._value.cast<ffi.Int64>();
    if (anyValue.address == 0) {
      return null;
    }
    return _CAnyInstanceMap[anyValue.address]?.object;
  }
}

extension _DartTo_CAny on Object? {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final anyValue = value.cast<ffi.Int64>();
    if (anyValue.address == 0) {
      return;
    }
    _CAnyInstanceMap[anyValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final anyValue = value.cast<ffi.Int64>();
    if (anyValue.address == 0) {
      return;
    }
    final anyObject = _CAnyInstanceMap[anyValue.address];
    if (anyObject == null) {
      return;
    }
    anyObject.refCounter -= 1;
    if (anyObject.refCounter > 0) {
      return;
    }
    _CAnyInstanceMap.remove(anyValue.address);
  }

  _CAny _copyFromDartTo_CAny() {
    var res = _CAnyMakeDefault();
    if (this == null) {
      return res;
    }
    final instanceId = _CAnyInstanceCounter;
    _CAnyInstanceCounter += 1;
    _CAnyInstanceMap[instanceId] = _Any(this!);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;
    return res;
  }
}
	
// MARK: - ClusterOptions

/** Параметры маркера кластера. */
class ClusterOptions {
  /** Атрибуты кластера. */
  final core.Map<String, AttributeValue> attributes;
  /** Пользовательские данные. Возвращаются в IClusterObject. */
  final Object? userData;

  const ClusterOptions({
    required this.attributes,
    this.userData = const {}
  });

  ClusterOptions copyWith({
    core.Map<String, AttributeValue>? attributes,
    Optional<Object?>? userData
  }) {
    return ClusterOptions(
      attributes: attributes ?? this.attributes,
      userData: userData != null ? userData.value : this.userData
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ClusterOptions &&
    other.runtimeType == runtimeType &&
    other.attributes == attributes &&
    other.userData == userData;

  @override
  int get hashCode {
    return Object.hash(attributes, userData);
  }

}
final class _CClusterOptions extends ffi.Struct {
  external _CDictionary_CString_CAttributeValue attributes;

  external _CAny userData;

}
// MARK: - ClusterOptions <-> _CClusterOptions

extension _CClusterOptionsToDart on _CClusterOptions {
  ClusterOptions _toDart() {
    return ClusterOptions(
      attributes: this.attributes._toDart(),
      userData: this.userData._toDart()
    );
  }
}

extension _DartTo_CClusterOptions on ClusterOptions {
  _CClusterOptions _copyFromDartTo_CClusterOptions() {
    final res = _CClusterOptionsMakeDefault();
    res.attributes = this.attributes._copyFromDartTo_CDictionary_CString_CAttributeValue();
    res.userData = this.userData._copyFromDartTo_CAny();
    return res;
  }
}
extension _CClusterOptionsRelease on _CClusterOptions {
  void _releaseIntermediate() {
    attributes._releaseIntermediate();
    userData._releaseIntermediate();
  }
}

// MARK: - FollowBearing

enum FollowBearing {
  off(0),
  on_(1),
  ;

  const FollowBearing(this.rawValue);
  final int rawValue;

  static FollowBearing getByValue(int value) {
    return FollowBearing.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CFollowBearing extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CFollowBearingBasicFunctions on _CFollowBearing {
  void _releaseIntermediate() {
  }
}

extension _CFollowBearingToDart on _CFollowBearing {
  FollowBearing _toDart() {
    return FollowBearing.getByValue(this.rawValue);
  }
}

extension _DartTo_CFollowBearing on FollowBearing {
  _CFollowBearing _copyFromDartTo_CFollowBearing() {
    return _CFollowBearingMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - FollowStyleZoom

enum FollowStyleZoom {
  off(0),
  on_(1),
  ;

  const FollowStyleZoom(this.rawValue);
  final int rawValue;

  static FollowStyleZoom getByValue(int value) {
    return FollowStyleZoom.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CFollowStyleZoom extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CFollowStyleZoomBasicFunctions on _CFollowStyleZoom {
  void _releaseIntermediate() {
  }
}

extension _CFollowStyleZoomToDart on _CFollowStyleZoom {
  FollowStyleZoom _toDart() {
    return FollowStyleZoom.getByValue(this.rawValue);
  }
}

extension _DartTo_CFollowStyleZoom on FollowStyleZoom {
  _CFollowStyleZoom _copyFromDartTo_CFollowStyleZoom() {
    return _CFollowStyleZoomMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - FollowPosition

/** Настройки слежения за позицией. */
class FollowPosition {
  final FollowBearing bearing;
  final FollowStyleZoom styleZoom;

  const FollowPosition({
    this.bearing = FollowBearing.off,
    this.styleZoom = FollowStyleZoom.off
  });

  FollowPosition copyWith({
    FollowBearing? bearing,
    FollowStyleZoom? styleZoom
  }) {
    return FollowPosition(
      bearing: bearing ?? this.bearing,
      styleZoom: styleZoom ?? this.styleZoom
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FollowPosition &&
    other.runtimeType == runtimeType &&
    other.bearing == bearing &&
    other.styleZoom == styleZoom;

  @override
  int get hashCode {
    return Object.hash(bearing, styleZoom);
  }

}
final class _CFollowPosition extends ffi.Struct {
  external _CFollowBearing bearing;

  external _CFollowStyleZoom styleZoom;

}
// MARK: - FollowPosition <-> _CFollowPosition

extension _CFollowPositionToDart on _CFollowPosition {
  FollowPosition _toDart() {
    return FollowPosition(
      bearing: this.bearing._toDart(),
      styleZoom: this.styleZoom._toDart()
    );
  }
}

extension _DartTo_CFollowPosition on FollowPosition {
  _CFollowPosition _copyFromDartTo_CFollowPosition() {
    final res = _CFollowPositionMakeDefault();
    res.bearing = this.bearing._copyFromDartTo_CFollowBearing();
    res.styleZoom = this.styleZoom._copyFromDartTo_CFollowStyleZoom();
    return res;
  }
}
extension _CFollowPositionRelease on _CFollowPosition {
  void _releaseIntermediate() {
  }
}

// MARK: - FollowTilt

enum FollowTilt {
  off(0),
  on_(1),
  ;

  const FollowTilt(this.rawValue);
  final int rawValue;

  static FollowTilt getByValue(int value) {
    return FollowTilt.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CFollowTilt extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CFollowTiltBasicFunctions on _CFollowTilt {
  void _releaseIntermediate() {
  }
}

extension _CFollowTiltToDart on _CFollowTilt {
  FollowTilt _toDart() {
    return FollowTilt.getByValue(this.rawValue);
  }
}

extension _DartTo_CFollowTilt on FollowTilt {
  _CFollowTilt _copyFromDartTo_CFollowTilt() {
    return _CFollowTiltMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Attributes

/**
 Интерфейс для управления свойствами объекта карты.

 Свойства есть только у объектов карты, но можно задавать свойства по умолчанию для всей карты,
 для стиля и для источника (подробнее см. ISource).
*/
class Attributes implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Получение списка свойств. */
  List<String> get attributeNames {
    _CArray_CString res = _CAttributes_attributeNames(_CAttributesMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение канала, уведомляющего об изменении свойств. */
  Channel<List<String>> get changed {
    _CChannel_CArray_CString res = _CAttributes_changed(_CAttributesMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CAttributes_releasePtr);

  Attributes._raw(this._self);
  factory Attributes._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Attributes._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Attributes &&
    other.runtimeType == runtimeType &&
    _CAttributes_cg_objectIdentifier(this._self) == _CAttributes_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CAttributes_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Attributes: Methods

  /**
   Установка свойства.
  
   - Parameter name: Название свойства.
   - Parameter value: Значение.
  */
  void setAttributeValue(
    String name,
    AttributeValue value
  )  {
    var _a1 = name._copyFromDartTo_CString();
    var _a2 = value._copyFromDartTo_CAttributeValue();
    void res = _CAttributes_setAttributeValue_CString_CAttributeValue(_CAttributesMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Установка набора свойств.
   Сначала удаляются свойства attributes_to_remove, затем добавляются свойства values.
   Если свойство с таким названием уже было добавлено, то оно заменяется.
  
   - Parameter values: Набор пар "имя":"значение" для добавляемых свойства.
   - Parameter attributesToRemove: Список имён свойств, которые нужно удалить.
  */
  void setAttributeValues(
    core.Map<String, AttributeValue> values,
    [List<String> attributesToRemove = const []
    ])  {
    var _a1 = values._copyFromDartTo_CDictionary_CString_CAttributeValue();
    var _a2 = attributesToRemove._copyFromDartTo_CArray_CString();
    void res = _CAttributes_setAttributeValues_CDictionary_CString_CAttributeValue_CArray_CString(_CAttributesMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Удаление свойства.
  
   - Parameter name: Имя свойства для удаления.
  */
  void removeAttribute(
    String name
  )  {
    var _a1 = name._copyFromDartTo_CString();
    void res = _CAttributes_removeAttribute_CString(_CAttributesMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Получение свойства.
  
   - Parameter name: Имя свойства для получения.
  */
  AttributeValue getAttributeValue(
    String name
  )  {
    var _a1 = name._copyFromDartTo_CString();
    _CAttributeValue res = _CAttributes_getAttributeValue_CString(_CAttributesMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - Attributes <-> CAttributes

final class _CAttributes extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CAttributesBasicFunctions on _CAttributes {
  void _releaseIntermediate() {
    _CAttributes_release(_impl);
  }

  _CAttributes _retain() {
    return _CAttributes_retain(_impl);
  }
}

extension _CAttributesToDart on _CAttributes {
  Attributes _toDart() {
    return Attributes._create(_retain()._impl);
  }
}


extension _DartToCAttributes on Attributes {
  _CAttributes _copyFromDartTo_CAttributes() {
    return (_CAttributesMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Channel<List<String>> <-> _CChannel_CArray_CString

class _CChannel_CArray_CStringImpl extends Channel<List<String>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<String>>>{};

  final _CChannel_CArray_CString _channel;

  _CChannel_CArray_CStringImpl(this._channel);

  static void valueFunction(_CArray_CString cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<String>> listen(void onData(List<String> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CString, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<String>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CChannel_CArray_CString extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CChannel_CArray_CStringBasicFunctions on _CChannel_CArray_CString {
  void _releaseIntermediate() {
    _CChannel_CArray_CString_release(this);
  }

  _CChannel_CArray_CString _retain() {
    return _CChannel_CArray_CString_retain(this);
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CString, ffi.Int64)> callback) {
    return _CChannel_CArray_CStringConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CChannel_CArray_CStringToDart on _CChannel_CArray_CString {
  Channel<List<String>> _toDart() {
    return _CChannel_CArray_CStringImpl(this._retain());
  }
}

extension _DartTo_CChannel_CArray_CString on Channel<List<String>> {
  _CChannel_CArray_CString _copyFromDartTo_CChannel_CArray_CString() {
    return _CChannel_CArray_CStringMakeDefault();
  }
}
	
// MARK: - AnimationSettings

/**
 Настройки анимаций объектов карты.
 Применяются для слоев стилей, в которых указан источник модели.
 Например, такими слоями являются слои с типами "3D model" и "Directional model".
 Индекс анимации должен быть обязательно указан для анимированной модели.
*/
class AnimationSettings implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Индекс текущей анимации модели.
   Если null, то используется значение из стилей.
   Если в стилях значение не задано или задано отрицательное, никакая анимация не проигрывается.
  */
  int? get animationIndex {
    _COptional_int32_t res = _CAnimationSettings_animationIndex(_CAnimationSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set animationIndex(int? index) {
    var _a1 = index._copyFromDartTo_COptional_int32_t();
    void res = _CAnimationSettings_setAnimationIndex_COptional_int32_t(_CAnimationSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Название текущей анимации модели.
   Если null, то используется значение из стилей.
   Если в стилях значение не задано, никакая анимация не проигрывается.
  */
  String? get animationName {
    _COptional_CString res = _CAnimationSettings_animationName(_CAnimationSettingsMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set animationName(String? name) {
    var _a1 = name._copyFromDartTo_COptional_CString();
    void res = _CAnimationSettings_setAnimationName_COptional_CString(_CAnimationSettingsMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /**
   Индекс текущей сцены модели.
   Если null, то используется значение из стилей.
   Если в стилях значение не задано или задано отрицательное,
   используется сцена по умолчанию, которая определена в самой модели.
  */
  int? get sceneIndex {
    _COptional_int32_t res = _CAnimationSettings_sceneIndex(_CAnimationSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set sceneIndex(int? index) {
    var _a1 = index._copyFromDartTo_COptional_int32_t();
    void res = _CAnimationSettings_setSceneIndex_COptional_int32_t(_CAnimationSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Название текущей сцены модели.
   Если null, то используется значение из стилей.
   Если в стилях значение не задано, используется сцена по умолчанию, которая определена в самой модели.
  */
  String? get sceneName {
    _COptional_CString res = _CAnimationSettings_sceneName(_CAnimationSettingsMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set sceneName(String? name) {
    var _a1 = name._copyFromDartTo_COptional_CString();
    void res = _CAnimationSettings_setSceneName_COptional_CString(_CAnimationSettingsMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /**
   Количество повторений анимации модели.
   Если null, то используется значение из стилей.
   Если в стилях значение не задано или задано отрицательное, анимация будет проигрываться бесконечно.
  */
  int? get animationRepeatCount {
    _COptional_int32_t res = _CAnimationSettings_animationRepeatCount(_CAnimationSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set animationRepeatCount(int? count) {
    var _a1 = count._copyFromDartTo_COptional_int32_t();
    void res = _CAnimationSettings_setAnimationRepeatCount_COptional_int32_t(_CAnimationSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Скорость проигрывания анимации модели.
   Если null, то используется значение из стилей.
   Значения больше единицы ускоряют проигрывание, меньше замедляют.
   Если в стилях значение не задано, используется скорость по умолчанию.
  */
  double? get animationSpeed {
    _COptional_float res = _CAnimationSettings_animationSpeed(_CAnimationSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set animationSpeed(double? speed) {
    var _a1 = speed._copyFromDartTo_COptional_float();
    void res = _CAnimationSettings_setAnimationSpeed_COptional_float(_CAnimationSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CAnimationSettings_releasePtr);

  AnimationSettings._raw(this._self);
  factory AnimationSettings._create(ffi.Pointer<ffi.Void> self) {
    final classObject = AnimationSettings._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AnimationSettings &&
    other.runtimeType == runtimeType &&
    _CAnimationSettings_cg_objectIdentifier(this._self) == _CAnimationSettings_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CAnimationSettings_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - AnimationSettings <-> CAnimationSettings

final class _CAnimationSettings extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CAnimationSettingsBasicFunctions on _CAnimationSettings {
  void _releaseIntermediate() {
    _CAnimationSettings_release(_impl);
  }

  _CAnimationSettings _retain() {
    return _CAnimationSettings_retain(_impl);
  }
}

extension _CAnimationSettingsToDart on _CAnimationSettings {
  AnimationSettings _toDart() {
    return AnimationSettings._create(_retain()._impl);
  }
}


extension _DartToCAnimationSettings on AnimationSettings {
  _CAnimationSettings _copyFromDartTo_CAnimationSettings() {
    return (_CAnimationSettingsMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - int? <-> _COptional_int32_t

final class _COptional_int32_t extends ffi.Struct {
  @ffi.Int32()
  external int value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_int32_tBasicFunctions on _COptional_int32_t {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_int32_tToDart on _COptional_int32_t {
  int? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_int32_t on int? {
  _COptional_int32_t _copyFromDartTo_COptional_int32_t() {
    final cOptional = _COptional_int32_tMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - double? <-> _COptional_float

final class _COptional_float extends ffi.Struct {
  @ffi.Float()
  external double value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_floatBasicFunctions on _COptional_float {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_floatToDart on _COptional_float {
  double? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_float on double? {
  _COptional_float _copyFromDartTo_COptional_float() {
    final cOptional = _COptional_floatMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - MapObject

/** Объект на карте. */
class MapObject implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Произвольные пользовательские данные, прикрепленные к объекту. */
  Object? get userData {
    _CAny res = _CMapObject_userData(_CMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set userData(Object? userData) {
    var _a1 = userData._copyFromDartTo_CAny();
    void res = _CMapObject_setUserData_CAny(_CMapObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapObject_releasePtr);

  MapObject._raw(this._self);
  factory MapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapObject &&
    other.runtimeType == runtimeType &&
    _CMapObject_cg_objectIdentifier(this._self) == _CMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapObject <-> CMapObject

final class _CMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapObjectBasicFunctions on _CMapObject {
  void _releaseIntermediate() {
    _CMapObject_release(_impl);
  }

  _CMapObject _retain() {
    return _CMapObject_retain(_impl);
  }
}

extension _CMapObjectToDart on _CMapObject {
  MapObject _toDart() {
    final selector = _CMapObject_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = MapObject._create(_retain()._impl);
        return res;
      case 1:
        final res = GeometryMapObject._create(_retain()._impl);
        return res;
      case 2:
        final res = ClusterObject._create(_retain()._impl);
        return res;
      case 3:
        final res = DgisMapObject._create(_retain()._impl);
        return res;
      case 4:
        final res = MyLocationMapObject._create(_retain()._impl);
        return res;
      case 5:
        final res = RoadEventMapObject._create(_retain()._impl);
        return res;
      case 6:
        final res = SimpleMapObject._create(_retain()._impl);
        return res;
      case 7:
        final res = SimpleClusterObject._create(_retain()._impl);
        return res;
      case 8:
        final res = RouteMapObject._create(_retain()._impl);
        return res;
      case 9:
        final res = RouteInfoCalloutMapObject._create(_retain()._impl);
        return res;
      case 10:
        final res = RoutePointMapObject._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCMapObject on MapObject {
  _CMapObject _copyFromDartTo_CMapObject() {
    return (_CMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GeometryMapObject

/**
 Геометрический объект карты.

 - Note: методы потокобезопасны
 - Note: объект будет отображаться на карте при выполнении следующих условий:
 - объект видимый;
 - объект добавлен в источник данных;
 - источник данных, содержащий объект, добавлен в карту;
 - в стилях, установленных в карту, есть параметры отображения, применимые к этому объекту.
 Подробнее про отображение на карте - см. ISource.
*/
class GeometryMapObject extends MapObject implements ffi.Finalizable {
  /** Геометрия объекта. */
  StatefulChannel<Geometry> get geometryChannel {
    _CStatefulChannel_CGeometry res = _CGeometryMapObject_geometryChannel(_CGeometryMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Геометрия объекта. */
  Geometry get geometry {
    _CGeometry res = _CGeometryMapObject_geometry(_CGeometryMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set geometry(Geometry geometry) {
    var _a1 = geometry._copyFromDartTo_CGeometry();
    void res = _CGeometryMapObject_setGeometry_CGeometry(_CGeometryMapObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Получение свойств объекта карты для чтения и изменения. */
  Attributes get objectAttributes {
    _CAttributes res = _CGeometryMapObject_objectAttributes(_CGeometryMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Текущий флаг видимости объекта. */
  StatefulChannel<bool> get isVisibleChannel {
    _CStatefulChannel_bool res = _CGeometryMapObject_isVisibleChannel(_CGeometryMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Текущий флаг видимости объекта. */
  bool get isVisible {
    bool res = _CGeometryMapObject_isVisible(_CGeometryMapObjectMakeDefault().._impl=_self);
    return res;
  }
  set isVisible(bool visible) {
    void res = _CGeometryMapObject_setVisible_bool(_CGeometryMapObjectMakeDefault().._impl=_self, visible);
    return res;
  }
  /** Текущий флаг перемещаемости объекта. */
  StatefulChannel<bool> get isDraggableChannel {
    _CStatefulChannel_bool res = _CGeometryMapObject_isDraggableChannel(_CGeometryMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Текущий флаг перемещаемости объекта. */
  bool get isDraggable {
    bool res = _CGeometryMapObject_isDraggable(_CGeometryMapObjectMakeDefault().._impl=_self);
    return res;
  }
  set isDraggable(bool draggable) {
    void res = _CGeometryMapObject_setDraggable_bool(_CGeometryMapObjectMakeDefault().._impl=_self, draggable);
    return res;
  }
  /**
   Получение настроек анимации.
   Применяется для объектов с типом "3D model" или "Directional model".
  */
  AnimationSettings get animationSettings {
    _CAnimationSettings res = _CGeometryMapObject_animationSettings(_CGeometryMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Прямоугольник минимального размера, содержащий геометрию. */
  GeoRect get bounds {
    _CGeoRect res = _CGeometryMapObject_bounds(_CGeometryMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CGeometryMapObject_releasePtr);

  GeometryMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory GeometryMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GeometryMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeometryMapObject &&
    other.runtimeType == runtimeType &&
    _CGeometryMapObject_cg_objectIdentifier(this._self) == _CGeometryMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGeometryMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - GeometryMapObject <-> CGeometryMapObject

final class _CGeometryMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGeometryMapObjectBasicFunctions on _CGeometryMapObject {
  void _releaseIntermediate() {
    _CGeometryMapObject_release(_impl);
  }

  _CGeometryMapObject _retain() {
    return _CGeometryMapObject_retain(_impl);
  }
}

extension _CGeometryMapObjectToDart on _CGeometryMapObject {
  GeometryMapObject _toDart() {
    return GeometryMapObject._create(_retain()._impl);
  }
}


extension _DartToCGeometryMapObject on GeometryMapObject {
  _CGeometryMapObject _copyFromDartTo_CGeometryMapObject() {
    return (_CGeometryMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<Geometry> <-> _CStatefulChannel_CGeometry

class _CStatefulChannel_CGeometryImpl extends StatefulChannel<Geometry> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Geometry>>{};

  final _CStatefulChannel_CGeometry _channel;

  _CStatefulChannel_CGeometryImpl(this._channel);

  @override
  Geometry get value {
    return this._channel._getter();
  }

  static void valueFunction(_CGeometry cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<Geometry> listen(void onData(Geometry event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CGeometry, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Geometry>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CGeometryBasicFunctions on _CStatefulChannel_CGeometry {
  void _releaseIntermediate() {
    _CStatefulChannel_CGeometry_release(this);
  }

  _CStatefulChannel_CGeometry _retain() {
    return _CStatefulChannel_CGeometry_retain(this);
  }

  Geometry _getter() {
    final cValue = _CStatefulChannel_CGeometryGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CGeometry, ffi.Int64)> callback) {
    return _CStatefulChannel_CGeometryConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CGeometryToDart on _CStatefulChannel_CGeometry {
  StatefulChannel<Geometry> _toDart() {
    return _CStatefulChannel_CGeometryImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CGeometry on StatefulChannel<Geometry> {
  _CStatefulChannel_CGeometry _copyFromDartTo_CStatefulChannel_CGeometry() {
    return _CStatefulChannel_CGeometryMakeDefault();
  }
}
	
// MARK: - StatefulChannel<bool> <-> _CStatefulChannel_bool

class _CStatefulChannel_boolImpl extends StatefulChannel<bool> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<bool>>{};

  final _CStatefulChannel_bool _channel;

  _CStatefulChannel_boolImpl(this._channel);

  @override
  bool get value {
    return this._channel._getter();
  }

  static void valueFunction(bool cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue);
    }
    
  }

  @override
  StreamSubscription<bool> listen(void onData(bool event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Bool, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<bool>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_bool extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_boolBasicFunctions on _CStatefulChannel_bool {
  void _releaseIntermediate() {
    _CStatefulChannel_bool_release(this);
  }

  _CStatefulChannel_bool _retain() {
    return _CStatefulChannel_bool_retain(this);
  }

  bool _getter() {
    final cValue = _CStatefulChannel_boolGetCurrentValue(this);
    final res = cValue;
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(ffi.Bool, ffi.Int64)> callback) {
    return _CStatefulChannel_boolConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_boolToDart on _CStatefulChannel_bool {
  StatefulChannel<bool> _toDart() {
    return _CStatefulChannel_boolImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_bool on StatefulChannel<bool> {
  _CStatefulChannel_bool _copyFromDartTo_CStatefulChannel_bool() {
    return _CStatefulChannel_boolMakeDefault();
  }
}
	
// MARK: - ClusterObject

/** Кластер объектов. */
class ClusterObject extends MapObject implements ffi.Finalizable {
  /** Получение позиции кластера на карте. */
  GeoPointWithElevation get position {
    _CGeoPointWithElevation res = _CClusterObject_position(_CClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение количества маркеров в кластере. */
  int get objectCount {
    int res = _CClusterObject_objectCount(_CClusterObjectMakeDefault().._impl=_self);
    return res;
  }
  /** Получение списка маркеров в кластере. */
  List<GeometryMapObject> get objects {
    _CArray_CGeometryMapObject res = _CClusterObject_objects(_CClusterObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение геометрического объекта кластера. */
  GeometryMapObject? get geometryObject {
    _COptional_CGeometryMapObject res = _CClusterObject_geometryObject(_CClusterObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CClusterObject_releasePtr);

  ClusterObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory ClusterObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ClusterObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ClusterObject &&
    other.runtimeType == runtimeType &&
    _CClusterObject_cg_objectIdentifier(this._self) == _CClusterObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CClusterObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ClusterObject <-> CClusterObject

final class _CClusterObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CClusterObjectBasicFunctions on _CClusterObject {
  void _releaseIntermediate() {
    _CClusterObject_release(_impl);
  }

  _CClusterObject _retain() {
    return _CClusterObject_retain(_impl);
  }
}

extension _CClusterObjectToDart on _CClusterObject {
  ClusterObject _toDart() {
    return ClusterObject._create(_retain()._impl);
  }
}


extension _DartToCClusterObject on ClusterObject {
  _CClusterObject _copyFromDartTo_CClusterObject() {
    return (_CClusterObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<GeometryMapObject> <-> _CArray_CGeometryMapObject

final class _CArray_CGeometryMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CGeometryMapObjectToDart on _CArray_CGeometryMapObject {
  List<GeometryMapObject> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CGeometryMapObject on List<GeometryMapObject> {
  _CArray_CGeometryMapObject _copyFromDartTo_CArray_CGeometryMapObject() {
    final cArray = _CArray_CGeometryMapObjectmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CGeometryMapObject();
        _CArray_CGeometryMapObjectaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CGeometryMapObjectBasicFunctions on _CArray_CGeometryMapObject {
  void _releaseIntermediate() {
    _CArray_CGeometryMapObject_release(this);
  }

  static final _listToFill = <GeometryMapObject>[];

  static void _iterate(_CGeometryMapObject item) {
    _listToFill.add(item._toDart());
  }

  List<GeometryMapObject> _fillFromC() {
    _forEach_CArray_CGeometryMapObject(this, ffi.Pointer.fromFunction<ffi.Void Function(_CGeometryMapObject)>(_iterate));
    final result = List<GeometryMapObject>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - GeometryMapObject? <-> _COptional_CGeometryMapObject

final class _COptional_CGeometryMapObject extends ffi.Struct {
  
  external _CGeometryMapObject value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGeometryMapObjectBasicFunctions on _COptional_CGeometryMapObject {
  void _releaseIntermediate() {
    _COptional_CGeometryMapObject_release(this);
  }
}

extension _COptional_CGeometryMapObjectToDart on _COptional_CGeometryMapObject {
  GeometryMapObject? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGeometryMapObject on GeometryMapObject? {
  _COptional_CGeometryMapObject _copyFromDartTo_COptional_CGeometryMapObject() {
    final cOptional = _COptional_CGeometryMapObjectMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGeometryMapObject();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - DgisMapObject

/**
 Объект карты 2GIS.

 - Note: информацию об объекте можно получить через справочник (directory)
*/
class DgisMapObject extends MapObject implements ffi.Finalizable {
  /** Стабильный числовой идентификатор объекта. */
  DgisObjectId get id {
    _CDgisObjectId res = _CDgisMapObject_id(_CDgisMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CDgisMapObject_releasePtr);

  DgisMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DgisMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DgisMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DgisMapObject &&
    other.runtimeType == runtimeType &&
    _CDgisMapObject_cg_objectIdentifier(this._self) == _CDgisMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDgisMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DgisMapObject <-> CDgisMapObject

final class _CDgisMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDgisMapObjectBasicFunctions on _CDgisMapObject {
  void _releaseIntermediate() {
    _CDgisMapObject_release(_impl);
  }

  _CDgisMapObject _retain() {
    return _CDgisMapObject_retain(_impl);
  }
}

extension _CDgisMapObjectToDart on _CDgisMapObject {
  DgisMapObject _toDart() {
    return DgisMapObject._create(_retain()._impl);
  }
}


extension _DartToCDgisMapObject on DgisMapObject {
  _CDgisMapObject _copyFromDartTo_CDgisMapObject() {
    return (_CDgisMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Source

/**
 Источник данных на карте.

 Это может быть источник пробочных данных, маршрутов, маркеров, произвольных геометрических или других объектов карты.
 У любого объекта карты могут быть свои свойства.
 Свойства объекта влияют на то, какие к нему применяются правила и параметры отображения, описаные в стилях карты.
 Стиль - набор параметров и правил отображения объектов карты, получаемый через редактор стилей и использующийся для
 отрисовки карты.

 Свойства объекта могут быть заданы:
 - непосредственно для объекта;
 - источнику данных (все объекты, добавленные в источник, получают эти свойства);
 - карте (все объекты, добавленные на карту, получают эти свойства);
 - стилю (все объекты, к которым применён стиль, получают эти свойства).
 Список приведён в порядке понижения приоритета применения свойств.
 Даже если на карту не добавлен ни один источник данных, свойства стиля и карты всё равно повлияют на карту,
 т.к. есть специальные отображаемые объекты, например - фон.
*/
class Source implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSource_releasePtr);

  Source._raw(this._self);
  factory Source._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Source._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Source &&
    other.runtimeType == runtimeType &&
    _CSource_cg_objectIdentifier(this._self) == _CSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Source <-> CSource

final class _CSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSourceBasicFunctions on _CSource {
  void _releaseIntermediate() {
    _CSource_release(_impl);
  }

  _CSource _retain() {
    return _CSource_retain(_impl);
  }
}

extension _CSourceToDart on _CSource {
  Source _toDart() {
    final selector = _CSource_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = Source._create(_retain()._impl);
        return res;
      case 1:
        final res = DgisSource._create(_retain()._impl);
        return res;
      case 2:
        final res = GeometryMapObjectSource._create(_retain()._impl);
        return res;
      case 3:
        final res = MyLocationMapObjectSource._create(_retain()._impl);
        return res;
      case 4:
        final res = TrafficSource._create(_retain()._impl);
        return res;
      case 5:
        final res = RoadEventSource._create(_retain()._impl);
        return res;
      case 6:
        final res = RasterTileSource._create(_retain()._impl);
        return res;
      case 7:
        final res = RouteEditorSource._create(_retain()._impl);
        return res;
      case 8:
        final res = RouteMapObjectSource._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCSource on Source {
  _CSource _copyFromDartTo_CSource() {
    return (_CSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DgisSource

/** Основной интерфейс источников данных 2ГИС. */
class DgisSource extends Source implements ffi.Finalizable {
  /** Получение списка идентификаторов выделенных объектов. */
  StatefulChannel<List<DgisObjectId>> get highlightedObjectsChannel {
    _CStatefulChannel_CArray_CDgisObjectId res = _CDgisSource_highlightedObjectsChannel(_CDgisSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение списка идентификаторов выделенных объектов. */
  List<DgisObjectId> get highlightedObjects {
    _CArray_CDgisObjectId res = _CDgisSource_highlightedObjects(_CDgisSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CDgisSource_releasePtr);

  DgisSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DgisSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DgisSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DgisSource &&
    other.runtimeType == runtimeType &&
    _CDgisSource_cg_objectIdentifier(this._self) == _CDgisSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDgisSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CDgisSource: Static Methods

  /**
   Создание источника, получающего данные с серверов 2ГИС
   или использующего в работе предварительно загруженные данные.
  */
  static Source createDgisSource(
    Context context,
    [DgisSourceWorkingMode workingMode = DgisSourceWorkingMode.hybridOnlineFirst
    ])  {
    var _a0 = context._copyFromDartTo_CContext();
    var _a1 = workingMode._copyFromDartTo_CDgisSourceWorkingMode();
    _CSource res = _CDgisSource_S_createDgisSource_CContext_CDgisSourceWorkingMode(_a0, _a1);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: DgisSource: Methods

  /**
   Установка или снятие выделения объектов.
  
   - Note: добавляет объекту атрибут "selected", который можно использовать в стилях.
   - Parameter directoryObjectIds: Идентификаторы изменяемых объектов.
   - Parameter highlighted: Установка или снятие выделения.
  */
  void setHighlighted(
    List<DgisObjectId> directoryObjectIds,
    bool highlighted
  )  {
    var _a1 = directoryObjectIds._copyFromDartTo_CArray_CDgisObjectId();
    void res = _CDgisSource_setHighlighted_CArray_CDgisObjectId_bool(_CDgisSourceMakeDefault().._impl=_self, _a1, highlighted);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - DgisSource <-> CDgisSource

final class _CDgisSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDgisSourceBasicFunctions on _CDgisSource {
  void _releaseIntermediate() {
    _CDgisSource_release(_impl);
  }

  _CDgisSource _retain() {
    return _CDgisSource_retain(_impl);
  }
}

extension _CDgisSourceToDart on _CDgisSource {
  DgisSource _toDart() {
    return DgisSource._create(_retain()._impl);
  }
}


extension _DartToCDgisSource on DgisSource {
  _CDgisSource _copyFromDartTo_CDgisSource() {
    return (_CDgisSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<List<DgisObjectId>> <-> _CStatefulChannel_CArray_CDgisObjectId

class _CStatefulChannel_CArray_CDgisObjectIdImpl extends StatefulChannel<List<DgisObjectId>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<DgisObjectId>>>{};

  final _CStatefulChannel_CArray_CDgisObjectId _channel;

  _CStatefulChannel_CArray_CDgisObjectIdImpl(this._channel);

  @override
  List<DgisObjectId> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CArray_CDgisObjectId cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<DgisObjectId>> listen(void onData(List<DgisObjectId> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CDgisObjectId, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<DgisObjectId>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CArray_CDgisObjectId extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CArray_CDgisObjectIdBasicFunctions on _CStatefulChannel_CArray_CDgisObjectId {
  void _releaseIntermediate() {
    _CStatefulChannel_CArray_CDgisObjectId_release(this);
  }

  _CStatefulChannel_CArray_CDgisObjectId _retain() {
    return _CStatefulChannel_CArray_CDgisObjectId_retain(this);
  }

  List<DgisObjectId> _getter() {
    final cValue = _CStatefulChannel_CArray_CDgisObjectIdGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CDgisObjectId, ffi.Int64)> callback) {
    return _CStatefulChannel_CArray_CDgisObjectIdConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CArray_CDgisObjectIdToDart on _CStatefulChannel_CArray_CDgisObjectId {
  StatefulChannel<List<DgisObjectId>> _toDart() {
    return _CStatefulChannel_CArray_CDgisObjectIdImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CArray_CDgisObjectId on StatefulChannel<List<DgisObjectId>> {
  _CStatefulChannel_CArray_CDgisObjectId _copyFromDartTo_CStatefulChannel_CArray_CDgisObjectId() {
    return _CStatefulChannel_CArray_CDgisObjectIdMakeDefault();
  }
}
	
// MARK: - FollowController

/**
 Класс, позволяющий управлять положением камеры.
 Реализации всех его методов должны быть потокобезопасны. У большинства
 методов есть тривиальные реализации по умолчанию (таким образом
 FollowController, отвечающий за масштаб, не обязан переопределять методы
 coordinates() и т.п.).
 Один контроллер может быть единомоментно добавлен только в одну карту.
*/
class FollowController implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CFollowController_releasePtr);

  FollowController._raw(this._self);
  factory FollowController._create(ffi.Pointer<ffi.Void> self) {
    final classObject = FollowController._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FollowController &&
    other.runtimeType == runtimeType &&
    _CFollowController_cg_objectIdentifier(this._self) == _CFollowController_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CFollowController_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - FollowController <-> CFollowController

final class _CFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CFollowControllerBasicFunctions on _CFollowController {
  void _releaseIntermediate() {
    _CFollowController_release(_impl);
  }

  _CFollowController _retain() {
    return _CFollowController_retain(_impl);
  }
}

extension _CFollowControllerToDart on _CFollowController {
  FollowController _toDart() {
    final selector = _CFollowController_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = FollowController._create(_retain()._impl);
        return res;
      case 1:
        final res = BearingFollowController._create(_retain()._impl);
        return res;
      case 2:
        final res = CoordinatesFollowController._create(_retain()._impl);
        return res;
      case 3:
        final res = StyleZoomFollowController._create(_retain()._impl);
        return res;
      case 4:
        final res = TiltFollowController._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCFollowController on FollowController {
  _CFollowController _copyFromDartTo_CFollowController() {
    return (_CFollowControllerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GeometryMapObjectSource

/** Источник геометрических объектов карты. */
class GeometryMapObjectSource extends Source implements ffi.Finalizable {
  /** Получить все объекты, добавленные в источник. */
  List<GeometryMapObject> get objects {
    _CArray_CGeometryMapObject res = _CGeometryMapObjectSource_objects(_CGeometryMapObjectSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение значений свойств по умолчанию для всех объектов, добавленных в источник (см. IAttributes). */
  Attributes get sourceAttributes {
    _CAttributes res = _CGeometryMapObjectSource_sourceAttributes(_CGeometryMapObjectSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CGeometryMapObjectSource_releasePtr);

  GeometryMapObjectSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory GeometryMapObjectSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GeometryMapObjectSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeometryMapObjectSource &&
    other.runtimeType == runtimeType &&
    _CGeometryMapObjectSource_cg_objectIdentifier(this._self) == _CGeometryMapObjectSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGeometryMapObjectSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: GeometryMapObjectSource: Methods

  /**
   Получить список объектов, участвующих в кластеризации при переданной позиции камеры.
   В списке будут присутствовать как кластеры, так и геометрические объекты.
  */
  List<MapObject> clusteringObjects(
    CameraPosition position
  )  {
    var _a1 = position._copyFromDartTo_CCameraPosition();
    _CArray_CMapObject res = _CGeometryMapObjectSource_clusteringObjects_CCameraPosition(_CGeometryMapObjectSourceMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Добавление объекта в источник.
  
   - Note: Добавление объектов по группой эффективнее, чем добавление по одному, особенно в случае,
   когда источник уже добавлен в одну или несколько карт.
   - Note: Добавление асинхронное, потокобезопасное, метод можно использовать из любого потока.
   - Note: Для источника с кластеризацией добавление пока не реализовано, будет выброшено исключение.
  */
  void addObject(
    GeometryMapObject item
  )  {
    var _a1 = item._copyFromDartTo_CGeometryMapObject();
    void res = _CGeometryMapObjectSource_addObject_CGeometryMapObject(_CGeometryMapObjectSourceMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Добавление нескольких объектов в источник.
  
   - Note: Добавление объектов по группой эффективнее, чем добавление по одному, особенно в случае,
   когда источник уже добавлен в одну или несколько карт.
   - Note: Добавление асинхронное, потокобезопасное, метод можно использовать из любого потока.
   - Note: Для источника с кластеризацией добавление пока не реализовано, будет выброшено исключение.
  */
  void addObjects(
    List<GeometryMapObject> objects
  )  {
    var _a1 = objects._copyFromDartTo_CArray_CGeometryMapObject();
    void res = _CGeometryMapObjectSource_addObjects_CArray_CGeometryMapObject(_CGeometryMapObjectSourceMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Удаление объекта из источника.
  
   - Note: Удаление асинхронное, потокобезопасное, метод можно использовать из любого потока.
  */
  void removeObject(
    GeometryMapObject item
  )  {
    var _a1 = item._copyFromDartTo_CGeometryMapObject();
    void res = _CGeometryMapObjectSource_removeObject_CGeometryMapObject(_CGeometryMapObjectSourceMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаление объектов из источника. */
  void removeObjects(
    List<GeometryMapObject> objects
  )  {
    var _a1 = objects._copyFromDartTo_CArray_CGeometryMapObject();
    void res = _CGeometryMapObjectSource_removeObjects_CArray_CGeometryMapObject(_CGeometryMapObjectSourceMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаление и добавление объектов в источник. */
  void removeAndAddObjects(
    List<GeometryMapObject> objectsToRemove,
    List<GeometryMapObject> objectsToAdd
  )  {
    var _a1 = objectsToRemove._copyFromDartTo_CArray_CGeometryMapObject();
    var _a2 = objectsToAdd._copyFromDartTo_CArray_CGeometryMapObject();
    void res = _CGeometryMapObjectSource_removeAndAddObjects_CArray_CGeometryMapObject_CArray_CGeometryMapObject(_CGeometryMapObjectSourceMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаление всех объектов из источника. */
  void clear()  {
    void res = _CGeometryMapObjectSource_clear(_CGeometryMapObjectSourceMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - GeometryMapObjectSource <-> CGeometryMapObjectSource

final class _CGeometryMapObjectSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGeometryMapObjectSourceBasicFunctions on _CGeometryMapObjectSource {
  void _releaseIntermediate() {
    _CGeometryMapObjectSource_release(_impl);
  }

  _CGeometryMapObjectSource _retain() {
    return _CGeometryMapObjectSource_retain(_impl);
  }
}

extension _CGeometryMapObjectSourceToDart on _CGeometryMapObjectSource {
  GeometryMapObjectSource _toDart() {
    return GeometryMapObjectSource._create(_retain()._impl);
  }
}


extension _DartToCGeometryMapObjectSource on GeometryMapObjectSource {
  _CGeometryMapObjectSource _copyFromDartTo_CGeometryMapObjectSource() {
    return (_CGeometryMapObjectSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<MapObject> <-> _CArray_CMapObject

final class _CArray_CMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CMapObjectToDart on _CArray_CMapObject {
  List<MapObject> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CMapObject on List<MapObject> {
  _CArray_CMapObject _copyFromDartTo_CArray_CMapObject() {
    final cArray = _CArray_CMapObjectmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CMapObject();
        _CArray_CMapObjectaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CMapObjectBasicFunctions on _CArray_CMapObject {
  void _releaseIntermediate() {
    _CArray_CMapObject_release(this);
  }

  static final _listToFill = <MapObject>[];

  static void _iterate(_CMapObject item) {
    _listToFill.add(item._toDart());
  }

  List<MapObject> _fillFromC() {
    _forEach_CArray_CMapObject(this, ffi.Pointer.fromFunction<ffi.Void Function(_CMapObject)>(_iterate));
    final result = List<MapObject>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - Image

/** Изображение. */
class Image implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CImage_releasePtr);

  Image._raw(this._self);
  factory Image._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Image._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Image &&
    other.runtimeType == runtimeType &&
    _CImage_cg_objectIdentifier(this._self) == _CImage_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CImage_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Image <-> CImage

final class _CImage extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CImageBasicFunctions on _CImage {
  void _releaseIntermediate() {
    _CImage_release(_impl);
  }

  _CImage _retain() {
    return _CImage_retain(_impl);
  }
}

extension _CImageToDart on _CImage {
  Image _toDart() {
    return Image._create(_retain()._impl);
  }
}


extension _DartToCImage on Image {
  _CImage _copyFromDartTo_CImage() {
    return (_CImageMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ImageFormat

enum ImageFormat {
  /** Изображение PNG формата. */
  png(0),
  /** Изображение SVG формата. */
  svg(1),
  /** Битмап. */
  rgba8888(2),
  /** JSON файл с Lottie анимацией. */
  lottieJson(3),
  ;

  const ImageFormat(this.rawValue);
  final int rawValue;

  static ImageFormat getByValue(int value) {
    return ImageFormat.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CImageFormat extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CImageFormatBasicFunctions on _CImageFormat {
  void _releaseIntermediate() {
  }
}

extension _CImageFormatToDart on _CImageFormat {
  ImageFormat _toDart() {
    return ImageFormat.getByValue(this.rawValue);
  }
}

extension _DartTo_CImageFormat on ImageFormat {
  _CImageFormat _copyFromDartTo_CImageFormat() {
    return _CImageFormatMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ImageData

/** Данные изображения: размер, формат и бинарные данные. */
class ImageData {
  final ScreenSize size;
  final ImageFormat format;
  final ByteData data;

  const ImageData({
    required this.size,
    required this.format,
    required this.data
  });

  ImageData copyWith({
    ScreenSize? size,
    ImageFormat? format,
    ByteData? data
  }) {
    return ImageData(
      size: size ?? this.size,
      format: format ?? this.format,
      data: data ?? this.data
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ImageData &&
    other.runtimeType == runtimeType &&
    other.size == size &&
    other.format == format &&
    other.data == data;

  @override
  int get hashCode {
    return Object.hash(size, format, data);
  }

}
final class _CImageData extends ffi.Struct {
  external _CScreenSize size;

  external _CImageFormat format;

  external _CData data;

}
// MARK: - ImageData <-> _CImageData

extension _CImageDataToDart on _CImageData {
  ImageData _toDart() {
    return ImageData(
      size: this.size._toDart(),
      format: this.format._toDart(),
      data: this.data._toDart()
    );
  }
}

extension _DartTo_CImageData on ImageData {
  _CImageData _copyFromDartTo_CImageData() {
    final res = _CImageDataMakeDefault();
    res.size = this.size._copyFromDartTo_CScreenSize();
    res.format = this.format._copyFromDartTo_CImageFormat();
    res.data = this.data._copyFromDartTo_CData();
    return res;
  }
}
extension _CImageDataRelease on _CImageData {
  void _releaseIntermediate() {
    data._releaseIntermediate();
  }
}

// MARK: - _ImageLoaderCpp

class _ImageLoaderCpp extends ImageLoader implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CImageLoaderCpp_releasePtr);

  _ImageLoaderCpp._raw(this._self);
  factory _ImageLoaderCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _ImageLoaderCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _ImageLoaderCpp &&
    other.runtimeType == runtimeType &&
    _CImageLoaderCpp_cg_objectIdentifier(this._self) == _CImageLoaderCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CImageLoaderCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _ImageLoaderCpp: Methods

  ImageData load()  {
    _CImageData res = _CImageLoaderCpp_load(_CImageLoaderCppMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - _ImageLoaderCpp <-> CImageLoaderCpp

final class _CImageLoaderCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CImageLoaderCppBasicFunctions on _CImageLoaderCpp {
  void _releaseIntermediate() {
    _CImageLoaderCpp_release(_impl);
  }

  _CImageLoaderCpp _retain() {
    return _CImageLoaderCpp_retain(_impl);
  }
}

extension _CImageLoaderCppToDart on _CImageLoaderCpp {
  _ImageLoaderCpp _toDart() {
    return _ImageLoaderCpp._create(_retain()._impl);
  }
}


extension _DartToCImageLoaderCpp on _ImageLoaderCpp {
  _CImageLoaderCpp _copyFromDartTo_CImageLoaderCpp() {
    return (_CImageLoaderCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ImageLoader

@internal
abstract class ImageLoader {
  ImageData load();
}

class _ImageLoader {
  final ImageLoader object;
  int refCounter = 1;

  _ImageLoader(this.object);
}

final class _CImageLoader extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CImageData)>>)>> _load;
}

extension _CImageLoaderBasicFunctions on _CImageLoader {
  void _releaseIntermediate() {
    _CImageLoader_release(this);
  }
}

int _CImageLoaderInstanceCounter = 1;
final _CImageLoaderInstanceMap = <int, _ImageLoader>{};

extension _CImageLoaderToDart on _CImageLoader {
  ImageLoader _toDart() {
    late ImageLoader? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CImageLoaderInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CImageLoaderCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CImageLoader");
    }
    return result;
  }
}

extension _DartTo_CImageLoader on ImageLoader {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CImageLoaderInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CImageLoaderInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CImageLoaderInstanceMap.remove(platformValue.address);
  }

  _CImageLoader _copyFromDartTo_CImageLoader() {
    var res = _CImageLoaderMakeDefault();
    if (this is _ImageLoaderCpp) {
      final cppValue = this as _ImageLoaderCpp;
      res._cppValue = cppValue._copyFromDartTo_CImageLoaderCpp()._impl;
      return res;
    }
    final instanceId = _CImageLoaderInstanceCounter;
    _CImageLoaderInstanceCounter += 1;
    _CImageLoaderInstanceMap[instanceId] = _ImageLoader(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final loadFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CImageData)>>)>.listener(loadFunction);
    res._load = loadFunctionCallable.nativeFunction;
    return res;
  }

  static void loadFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CImageData)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CImageLoader");
    }
    final platformObject = _CImageLoaderInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CImageLoader");
    }

    final res = platformObject.object.load();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CImageData)>();
    callbackFunction(context, res._copyFromDartTo_CImageData());
  }


}

// MARK: - BearingFollowController

/** Контроллер слежения за направлением карты. */
class BearingFollowController extends FollowController implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CBearingFollowController_releasePtr);

  BearingFollowController._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory BearingFollowController._create(ffi.Pointer<ffi.Void> self) {
    final classObject = BearingFollowController._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Создание контроллера слежения за направлением карты.
  
   - Parameter bearingSource: источник информации о направлении.
   - Parameter animationDuration: неотрицательная длительность изменения реального направления.
   - Parameter valueThreshold: неотрицательное пороговое значение учитываемого изменения реального направления.
  */
  factory BearingFollowController(
    BearingSource bearingSource,
    [Duration animationDuration = const Duration(milliseconds: 1000),
    Bearing valueThreshold = const Bearing(1)
    ]) {
    var _a0 = bearingSource._copyFromDartTo_CBearingSource();
    var _a1 = animationDuration._copyFromDartTo_CTimeInterval();
    var _a2 = valueThreshold._copyFromDartTo_CBearing();
    _CBearingFollowController res = _CBearingFollowController_C_createWith_CBearingSource_CTimeInterval_CBearing(_a0, _a1, _a2);
    return BearingFollowController._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BearingFollowController &&
    other.runtimeType == runtimeType &&
    _CBearingFollowController_cg_objectIdentifier(this._self) == _CBearingFollowController_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CBearingFollowController_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - BearingFollowController <-> CBearingFollowController

final class _CBearingFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CBearingFollowControllerBasicFunctions on _CBearingFollowController {
  void _releaseIntermediate() {
    _CBearingFollowController_release(_impl);
  }

  _CBearingFollowController _retain() {
    return _CBearingFollowController_retain(_impl);
  }
}

extension _CBearingFollowControllerToDart on _CBearingFollowController {
  BearingFollowController _toDart() {
    return BearingFollowController._create(_retain()._impl);
  }
}


extension _DartToCBearingFollowController on BearingFollowController {
  _CBearingFollowController _copyFromDartTo_CBearingFollowController() {
    return (_CBearingFollowControllerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CoordinatesFollowController

/** Контроллер слежения за координатами позиции карты. */
class CoordinatesFollowController extends FollowController implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CCoordinatesFollowController_releasePtr);

  CoordinatesFollowController._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory CoordinatesFollowController._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CoordinatesFollowController._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Создание контроллера слежения за координатами позиции карты.
  
   - Parameter animationDuration: длительность изменения реальной позиции.
   - Parameter valueThreshold: неотрицательное пороговое значение учитываемого изменения реальной позиции.
  */
  factory CoordinatesFollowController(
    [Duration animationDuration = const Duration(milliseconds: 1000),
    Meter valueThreshold = const Meter(0.10000000149011612)
    ]) {
    var _a0 = animationDuration._copyFromDartTo_CTimeInterval();
    var _a1 = valueThreshold._copyFromDartTo_CMeter();
    _CCoordinatesFollowController res = _CCoordinatesFollowController_C_createWith_CTimeInterval_CMeter(_a0, _a1);
    return CoordinatesFollowController._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CoordinatesFollowController &&
    other.runtimeType == runtimeType &&
    _CCoordinatesFollowController_cg_objectIdentifier(this._self) == _CCoordinatesFollowController_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCoordinatesFollowController_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - CoordinatesFollowController <-> CCoordinatesFollowController

final class _CCoordinatesFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCoordinatesFollowControllerBasicFunctions on _CCoordinatesFollowController {
  void _releaseIntermediate() {
    _CCoordinatesFollowController_release(_impl);
  }

  _CCoordinatesFollowController _retain() {
    return _CCoordinatesFollowController_retain(_impl);
  }
}

extension _CCoordinatesFollowControllerToDart on _CCoordinatesFollowController {
  CoordinatesFollowController _toDart() {
    return CoordinatesFollowController._create(_retain()._impl);
  }
}


extension _DartToCCoordinatesFollowController on CoordinatesFollowController {
  _CCoordinatesFollowController _copyFromDartTo_CCoordinatesFollowController() {
    return (_CCoordinatesFollowControllerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - BearingSource? <-> _COptional_CBearingSource

final class _COptional_CBearingSource extends ffi.Struct {
  
  external _CBearingSource value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CBearingSourceBasicFunctions on _COptional_CBearingSource {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CBearingSourceToDart on _COptional_CBearingSource {
  BearingSource? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CBearingSource on BearingSource? {
  _COptional_CBearingSource _copyFromDartTo_COptional_CBearingSource() {
    final cOptional = _COptional_CBearingSourceMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CBearingSource();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - MyLocationControllerSettings

/** Настройки контроллера перемещения маркера геопозиции. */
class MyLocationControllerSettings {
  /** Источник направления. Если отсутствует, будет отображаться маркер без направления. */
  final BearingSource? bearingSource;
  /** Неотрицательная длительность изменения реального направления. */
  final Duration animationDuration;
  /** Неотрицательное пороговое значение учитываемого изменения реальной позиции и её точности. */
  final Meter coordinatesThreshold;
  /** Неотрицательное пороговое значение учитываемого изменения реального направления. */
  final Bearing bearingThreshold;

  const MyLocationControllerSettings({
    this.bearingSource = BearingSource.auto,
    this.animationDuration = const Duration(milliseconds: 1000),
    this.coordinatesThreshold = const Meter(0.10000000149011612),
    this.bearingThreshold = const Bearing(1)
  });

  MyLocationControllerSettings copyWith({
    Optional<BearingSource?>? bearingSource,
    Duration? animationDuration,
    Meter? coordinatesThreshold,
    Bearing? bearingThreshold
  }) {
    return MyLocationControllerSettings(
      bearingSource: bearingSource != null ? bearingSource.value : this.bearingSource,
      animationDuration: animationDuration ?? this.animationDuration,
      coordinatesThreshold: coordinatesThreshold ?? this.coordinatesThreshold,
      bearingThreshold: bearingThreshold ?? this.bearingThreshold
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MyLocationControllerSettings &&
    other.runtimeType == runtimeType &&
    other.bearingSource == bearingSource &&
    other.animationDuration == animationDuration &&
    other.coordinatesThreshold == coordinatesThreshold &&
    other.bearingThreshold == bearingThreshold;

  @override
  int get hashCode {
    return Object.hash(bearingSource, animationDuration, coordinatesThreshold, bearingThreshold);
  }

}
final class _CMyLocationControllerSettings extends ffi.Struct {
  external _COptional_CBearingSource bearingSource;

  external _CTimeInterval animationDuration;

  external _CMeter coordinatesThreshold;

  external _CBearing bearingThreshold;

}
// MARK: - MyLocationControllerSettings <-> _CMyLocationControllerSettings

extension _CMyLocationControllerSettingsToDart on _CMyLocationControllerSettings {
  MyLocationControllerSettings _toDart() {
    return MyLocationControllerSettings(
      bearingSource: this.bearingSource._toDart(),
      animationDuration: this.animationDuration._toDart(),
      coordinatesThreshold: this.coordinatesThreshold._toDart(),
      bearingThreshold: this.bearingThreshold._toDart()
    );
  }
}

extension _DartTo_CMyLocationControllerSettings on MyLocationControllerSettings {
  _CMyLocationControllerSettings _copyFromDartTo_CMyLocationControllerSettings() {
    final res = _CMyLocationControllerSettingsMakeDefault();
    res.bearingSource = this.bearingSource._copyFromDartTo_COptional_CBearingSource();
    res.animationDuration = this.animationDuration._copyFromDartTo_CTimeInterval();
    res.coordinatesThreshold = this.coordinatesThreshold._copyFromDartTo_CMeter();
    res.bearingThreshold = this.bearingThreshold._copyFromDartTo_CBearing();
    return res;
  }
}
extension _CMyLocationControllerSettingsRelease on _CMyLocationControllerSettings {
  void _releaseIntermediate() {
  }
}

// MARK: - MyLocationMapObjectMarkerType

/** Тип маркера геопозиции. */
enum MyLocationMapObjectMarkerType {
  /**
   Использовать стандартные модели из стилей. Есть возможность менять модель через редактор стилей.
   Соответствующие слои: s_dvg_vehicle_gps_marker, s_dvg_vehicle_gps_marker_degraded,
   s_dvg_foot_gps_model, s_dvg_foot_gps_model_degraded, s_dvg_foot_gps_direction_model
  */
  model(0),
  /**
   Использовать SVG иконки. Есть возможность менять иконку через редактор стилей. Соответствующие слои:
   s_dvg_foot_gps_marker_with_direction, s_dvg_foot_gps_marker2, s_dvg_foot_gps_marker_degraded2
  */
  svgIcon(1),
  ;

  const MyLocationMapObjectMarkerType(this.rawValue);
  final int rawValue;

  static MyLocationMapObjectMarkerType getByValue(int value) {
    return MyLocationMapObjectMarkerType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CMyLocationMapObjectMarkerType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CMyLocationMapObjectMarkerTypeBasicFunctions on _CMyLocationMapObjectMarkerType {
  void _releaseIntermediate() {
  }
}

extension _CMyLocationMapObjectMarkerTypeToDart on _CMyLocationMapObjectMarkerType {
  MyLocationMapObjectMarkerType _toDart() {
    return MyLocationMapObjectMarkerType.getByValue(this.rawValue);
  }
}

extension _DartTo_CMyLocationMapObjectMarkerType on MyLocationMapObjectMarkerType {
  _CMyLocationMapObjectMarkerType _copyFromDartTo_CMyLocationMapObjectMarkerType() {
    return _CMyLocationMapObjectMarkerTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ModelData

/** Данные модели. */
class ModelData implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CModelData_releasePtr);

  ModelData._raw(this._self);
  factory ModelData._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ModelData._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ModelData &&
    other.runtimeType == runtimeType &&
    _CModelData_cg_objectIdentifier(this._self) == _CModelData_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CModelData_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ModelData <-> CModelData

final class _CModelData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CModelDataBasicFunctions on _CModelData {
  void _releaseIntermediate() {
    _CModelData_release(_impl);
  }

  _CModelData _retain() {
    return _CModelData_retain(_impl);
  }
}

extension _CModelDataToDart on _CModelData {
  ModelData _toDart() {
    return ModelData._create(_retain()._impl);
  }
}


extension _DartToCModelData on ModelData {
  _CModelData _copyFromDartTo_CModelData() {
    return (_CModelDataMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MyLocationMapObject

/** Маркер геопозиции. */
class MyLocationMapObject extends MapObject implements ffi.Finalizable {
  /** Получение настроек анимации для чтения и изменения. */
  AnimationSettings get animationSettings {
    _CAnimationSettings res = _CMyLocationMapObject_animationSettings(_CMyLocationMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение свойств объекта карты для чтения и изменения. */
  Attributes get objectAttributes {
    _CAttributes res = _CMyLocationMapObject_objectAttributes(_CMyLocationMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMyLocationMapObject_releasePtr);

  MyLocationMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MyLocationMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MyLocationMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MyLocationMapObject &&
    other.runtimeType == runtimeType &&
    _CMyLocationMapObject_cg_objectIdentifier(this._self) == _CMyLocationMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMyLocationMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: MyLocationMapObject: Methods

  /** Установить данные модели. */
  void setModelData(
    ModelData? data
  )  {
    var _a1 = data._copyFromDartTo_COptional_CModelData();
    void res = _CMyLocationMapObject_setModelData_COptional_CModelData(_CMyLocationMapObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - MyLocationMapObject <-> CMyLocationMapObject

final class _CMyLocationMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMyLocationMapObjectBasicFunctions on _CMyLocationMapObject {
  void _releaseIntermediate() {
    _CMyLocationMapObject_release(_impl);
  }

  _CMyLocationMapObject _retain() {
    return _CMyLocationMapObject_retain(_impl);
  }
}

extension _CMyLocationMapObjectToDart on _CMyLocationMapObject {
  MyLocationMapObject _toDart() {
    return MyLocationMapObject._create(_retain()._impl);
  }
}


extension _DartToCMyLocationMapObject on MyLocationMapObject {
  _CMyLocationMapObject _copyFromDartTo_CMyLocationMapObject() {
    return (_CMyLocationMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ModelData? <-> _COptional_CModelData

final class _COptional_CModelData extends ffi.Struct {
  
  external _CModelData value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CModelDataBasicFunctions on _COptional_CModelData {
  void _releaseIntermediate() {
    _COptional_CModelData_release(this);
  }
}

extension _COptional_CModelDataToDart on _COptional_CModelData {
  ModelData? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CModelData on ModelData? {
  _COptional_CModelData _copyFromDartTo_COptional_CModelData() {
    final cOptional = _COptional_CModelDataMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CModelData();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - MyLocationMapObjectSource

/** Источник, содержащий маркер геопозиции. */
class MyLocationMapObjectSource extends Source implements ffi.Finalizable {
  /** Получить маркер геопозиции. */
  MyLocationMapObject get item {
    _CMyLocationMapObject res = _CMyLocationMapObjectSource_item(_CMyLocationMapObjectSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMyLocationMapObjectSource_releasePtr);

  MyLocationMapObjectSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MyLocationMapObjectSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MyLocationMapObjectSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /** Создать источник маркера геопозиции. */
  factory MyLocationMapObjectSource(
    Context context,
    [MyLocationControllerSettings controllerSettings = const MyLocationControllerSettings(),
    MyLocationMapObjectMarkerType markerType = MyLocationMapObjectMarkerType.model
    ]) {
    var _a0 = context._copyFromDartTo_CContext();
    var _a1 = controllerSettings._copyFromDartTo_CMyLocationControllerSettings();
    var _a2 = markerType._copyFromDartTo_CMyLocationMapObjectMarkerType();
    _CMyLocationMapObjectSource res = _CMyLocationMapObjectSource_C_createWith_CContext_CMyLocationControllerSettings_CMyLocationMapObjectMarkerType(_a0, _a1, _a2);
    _a0._releaseIntermediate();
    return MyLocationMapObjectSource._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MyLocationMapObjectSource &&
    other.runtimeType == runtimeType &&
    _CMyLocationMapObjectSource_cg_objectIdentifier(this._self) == _CMyLocationMapObjectSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMyLocationMapObjectSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MyLocationMapObjectSource <-> CMyLocationMapObjectSource

final class _CMyLocationMapObjectSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMyLocationMapObjectSourceBasicFunctions on _CMyLocationMapObjectSource {
  void _releaseIntermediate() {
    _CMyLocationMapObjectSource_release(_impl);
  }

  _CMyLocationMapObjectSource _retain() {
    return _CMyLocationMapObjectSource_retain(_impl);
  }
}

extension _CMyLocationMapObjectSourceToDart on _CMyLocationMapObjectSource {
  MyLocationMapObjectSource _toDart() {
    return MyLocationMapObjectSource._create(_retain()._impl);
  }
}


extension _DartToCMyLocationMapObjectSource on MyLocationMapObjectSource {
  _CMyLocationMapObjectSource _copyFromDartTo_CMyLocationMapObjectSource() {
    return (_CMyLocationMapObjectSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadEventMapObject

/** Объект карты "Дорожное событие". */
class RoadEventMapObject extends MapObject implements ffi.Finalizable {
  DgisObjectId get id {
    _CDgisObjectId res = _CRoadEventMapObject_id(_CRoadEventMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение дорожного события. */
  RoadEvent get event {
    _CRoadEvent res = _CRoadEventMapObject_event(_CRoadEventMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение настроек анимации дорожных событий для чтения и изменения. */
  AnimationSettings get animationSettings {
    _CAnimationSettings res = _CRoadEventMapObject_animationSettings(_CRoadEventMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadEventMapObject_releasePtr);

  RoadEventMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RoadEventMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEventMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventMapObject &&
    other.runtimeType == runtimeType &&
    _CRoadEventMapObject_cg_objectIdentifier(this._self) == _CRoadEventMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEventMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - RoadEventMapObject <-> CRoadEventMapObject

final class _CRoadEventMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventMapObjectBasicFunctions on _CRoadEventMapObject {
  void _releaseIntermediate() {
    _CRoadEventMapObject_release(_impl);
  }

  _CRoadEventMapObject _retain() {
    return _CRoadEventMapObject_retain(_impl);
  }
}

extension _CRoadEventMapObjectToDart on _CRoadEventMapObject {
  RoadEventMapObject _toDart() {
    return RoadEventMapObject._create(_retain()._impl);
  }
}


extension _DartToCRoadEventMapObject on RoadEventMapObject {
  _CRoadEventMapObject _copyFromDartTo_CRoadEventMapObject() {
    return (_CRoadEventMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadEventType

/** Тип события. */
enum RoadEventType {
  /** ДТП. */
  accident(0),
  /** Дорожные работы. */
  roadWorks(1),
  /** Камера. */
  camera(2),
  /** Комментарий. */
  comment(3),
  /** Перекрытие дорожного движения. */
  roadRestriction(4),
  /** Событие "Другое". */
  other(5),
  ;

  const RoadEventType(this.rawValue);
  final int rawValue;

  static RoadEventType getByValue(int value) {
    return RoadEventType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoadEventType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoadEventTypeBasicFunctions on _CRoadEventType {
  void _releaseIntermediate() {
  }
}

extension _CRoadEventTypeToDart on _CRoadEventType {
  RoadEventType _toDart() {
    return RoadEventType.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoadEventType on RoadEventType {
  _CRoadEventType _copyFromDartTo_CRoadEventType() {
    return _CRoadEventTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RoadEvent

/** Дорожное событие. */
class RoadEvent implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Тип события. */
  RoadEventType get type {
    _CRoadEventType res = _CRoadEvent_type(_CRoadEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Идентификатор события. */
  String get id {
    _CString res = _CRoadEvent_id(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Локализованное название события. */
  String get name {
    _CString res = _CRoadEvent_name(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о пользователе, добавившем событие. */
  AuthorInfo get author {
    _CAuthorInfo res = _CRoadEvent_author(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Временная метка создания события. */
  DateTime? get timestamp {
    _COptional_CDate res = _CRoadEvent_timestamp(_CRoadEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Координаты события. */
  GeoPoint get location {
    _CGeoPoint res = _CRoadEvent_location(_CRoadEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Пользовательское описание дорожного события. */
  String get description {
    _CString res = _CRoadEvent_description(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Информация о камере.
  
   - Note: Доступна только для событий типа "Camera".
  */
  RoadCameraInfo? get cameraInfo {
    _COptional_CRoadCameraInfo res = _CRoadEvent_cameraInfo(_CRoadEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Расписание.
  
   - Note: На текущий момент доступно только для перекрытий, и даже для них может отсутствовать.
  */
  Schedule? get schedule {
    _COptional_CSchedule res = _CRoadEvent_schedule(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Затронутые событием полосы.
  
   - Note: На текущий момент могут быть проставлены только у пользовательских событий.
  */
  LaneEnumSet get lanes {
    _COptionSet_CLane res = _CRoadEvent_lanes(_CRoadEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Список доступных действий с событием. */
  List<RoadEventAction> get availableActions {
    _CArray_CRoadEventAction res = _CRoadEvent_availableActions(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение объекта для удаления события.
  
   - Returns: объект для удаления события.
   В случае, если событие создано другим пользователем, вернётся пустой объект.
  */
  Remover? get remover {
    _COptional_CRemover res = _CRoadEvent_remover(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadEvent_releasePtr);

  RoadEvent._raw(this._self);
  factory RoadEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEvent &&
    other.runtimeType == runtimeType &&
    _CRoadEvent_cg_objectIdentifier(this._self) == _CRoadEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadEvent: Methods

  /** Фотографии события. */
  CancelableOperation<List<RoadEventPhoto>> photos()  {
    _CFuture_CArray_CRoadEventPhoto res = _CRoadEvent_photos(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadEvent <-> CRoadEvent

final class _CRoadEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventBasicFunctions on _CRoadEvent {
  void _releaseIntermediate() {
    _CRoadEvent_release(_impl);
  }

  _CRoadEvent _retain() {
    return _CRoadEvent_retain(_impl);
  }
}

extension _CRoadEventToDart on _CRoadEvent {
  RoadEvent _toDart() {
    return RoadEvent._create(_retain()._impl);
  }
}


extension _DartToCRoadEvent on RoadEvent {
  _CRoadEvent _copyFromDartTo_CRoadEvent() {
    return (_CRoadEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - AuthorType

/** Категория автора контента. */
enum AuthorType {
  /** Анонимный пользователь. */
  anonymous(0),
  /** Компания 2ГИС. */
  doubleGis(1),
  /** Авторизированный пользователь. */
  user(2),
  /** Текущий пользователь приложения. */
  me(3),
  ;

  const AuthorType(this.rawValue);
  final int rawValue;

  static AuthorType getByValue(int value) {
    return AuthorType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CAuthorType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CAuthorTypeBasicFunctions on _CAuthorType {
  void _releaseIntermediate() {
  }
}

extension _CAuthorTypeToDart on _CAuthorType {
  AuthorType _toDart() {
    return AuthorType.getByValue(this.rawValue);
  }
}

extension _DartTo_CAuthorType on AuthorType {
  _CAuthorType _copyFromDartTo_CAuthorType() {
    return _CAuthorTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - AuthorInfo

/** Информация об авторе события или фотографии. */
class AuthorInfo {
  /** Категория автора контента. */
  final AuthorType type;
  /**
   Строка, содержащая имя пользователя, добавившего событие или фотографию.
  
   - Имя пользователя в случае, если автор является авторизированным пользователем
   и согласился на отображение своего имени.
   - Пустая строка для анонимного пользователя или пользователя, отказавшегося от отображения своего имени.
  */
  final String name;

  const AuthorInfo({
    required this.type,
    required this.name
  });

  AuthorInfo copyWith({
    AuthorType? type,
    String? name
  }) {
    return AuthorInfo(
      type: type ?? this.type,
      name: name ?? this.name
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AuthorInfo &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.name == name;

  @override
  int get hashCode {
    return Object.hash(type, name);
  }

}
final class _CAuthorInfo extends ffi.Struct {
  external _CAuthorType type;

  external _CString name;

}
// MARK: - AuthorInfo <-> _CAuthorInfo

extension _CAuthorInfoToDart on _CAuthorInfo {
  AuthorInfo _toDart() {
    return AuthorInfo(
      type: this.type._toDart(),
      name: this.name._toDart()
    );
  }
}

extension _DartTo_CAuthorInfo on AuthorInfo {
  _CAuthorInfo _copyFromDartTo_CAuthorInfo() {
    final res = _CAuthorInfoMakeDefault();
    res.type = this.type._copyFromDartTo_CAuthorType();
    res.name = this.name._copyFromDartTo_CString();
    return res;
  }
}
extension _CAuthorInfoRelease on _CAuthorInfo {
  void _releaseIntermediate() {
    name._releaseIntermediate();
  }
}

// MARK: - DateTime <-> _CDate

final class _CDate extends ffi.Struct {
  @ffi.Double()
  external double secondsSinceEpoch;
}

extension _CDateToDart on _CDate {
  DateTime _toDart() {
    final msSinceEpoch = secondsSinceEpoch * 1000;
    return DateTime.fromMillisecondsSinceEpoch(msSinceEpoch.ceil(), isUtc: true);
  }
}

extension _DartTo_CDate on DateTime {
  _CDate _copyFromDartTo_CDate() {
    return _CDateMakeDefault()..secondsSinceEpoch = millisecondsSinceEpoch / 1000;
  }
}
	
// MARK: - DateTime? <-> _COptional_CDate

final class _COptional_CDate extends ffi.Struct {
  
  external _CDate value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CDateBasicFunctions on _COptional_CDate {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CDateToDart on _COptional_CDate {
  DateTime? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CDate on DateTime? {
  _COptional_CDate _copyFromDartTo_COptional_CDate() {
    final cOptional = _COptional_CDateMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CDate();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CameraPurpose

/** Назначение камеры. */
enum CameraPurpose {
  /** Фиксация превышения скорости. */
  speedControl(1),
  /** Фиксация превышения средней скорости на участке. */
  averageSpeedControl(2),
  /** Фиксация движения по выделенной полосе для общественного транспорта. */
  publicTransportLaneMovementControl(4),
  /** Фиксация пересечения сплошной линии разметки, движения по обочине. */
  roadMarkingsCrossingControl(8),
  /** Фиксация проезда на запрещающий сигнал светофора. */
  trafficLightsViolationControl(16),
  /** Фиксация выезда за стоп-линию, проезда без остановки знака "Стоп", выезда на перекрёсток во время затора. */
  stopLineCrossingControl(32),
  /** Фиксация движения по встречной полосе. */
  oncomingTrafficLaneMovementControl(64),
  /** Фиксация непредоставления приоритета пешеходам. */
  pedestrianAdvantageViolationControl(128),
  /** Фиксация нарушения рядности поворота на перекрёстке. */
  laneDisciplineControl(256),
  /** Фиксация нарушения запрета остановки. */
  noStoppingViolationControl(512),
  /** Муляж. */
  dummy(1024),
  /** Камера системы "Платон", камера контроля ограничений для грузовых автомобилей */
  truck(2048),
  ;

  const CameraPurpose(this.rawValue);
  final int rawValue;

  static CameraPurpose getByValue(int value) {
    return CameraPurpose.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraPurpose extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraPurposeBasicFunctions on _CCameraPurpose {
  void _releaseIntermediate() {
  }
}

extension _CCameraPurposeToDart on _CCameraPurpose {
  CameraPurpose _toDart() {
    return CameraPurpose.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraPurpose on CameraPurpose {
  _CCameraPurpose _copyFromDartTo_CCameraPurpose() {
    return _CCameraPurposeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraPurposeEnumSet

class CameraPurposeEnumSet extends EnumSet<CameraPurpose> {
  CameraPurposeEnumSet() : super();

  factory CameraPurposeEnumSet.fromRawValue(int rawValue) {
    CameraPurposeEnumSet enumSet = CameraPurposeEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory CameraPurposeEnumSet.of(Iterable<CameraPurpose> elements) {
    CameraPurposeEnumSet enumSet = CameraPurposeEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory CameraPurposeEnumSet.all() {
    CameraPurposeEnumSet enumSet = CameraPurposeEnumSet();
    enumSet.addAll(CameraPurpose.values);
    return enumSet;
  }

  @override
  bool contains(CameraPurpose value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<CameraPurpose> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(CameraPurpose value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<CameraPurpose> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(CameraPurpose value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<CameraPurpose> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<CameraPurpose> intersection(EnumSet<CameraPurpose> other) =>
      CameraPurposeEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<CameraPurpose> union(EnumSet<CameraPurpose> other) =>
      CameraPurposeEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<CameraPurpose> difference(EnumSet<CameraPurpose> other) =>
      CameraPurposeEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<CameraPurpose> toSet() {
    Set<CameraPurpose> result = {};
    CameraPurpose.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    CameraPurpose.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CCameraPurpose extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CCameraPurposeBasicFunctions on _COptionSet_CCameraPurpose {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CCameraPurposeToDart on _COptionSet_CCameraPurpose {
  CameraPurposeEnumSet _toDart() {
    return CameraPurposeEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CCameraPurpose on CameraPurposeEnumSet {
  _COptionSet_CCameraPurpose _copyFromDartTo_COptionSet_CCameraPurpose() {
    return _COptionSet_CCameraPurposeMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - RoadCameraInfo

/** Информация о камере. */
class RoadCameraInfo {
  /**
   Назначения камеры.
  
   - Note: Могут отсутствовать, если нет информации, или если камеру добавил пользователь.
  */
  final CameraPurposeEnumSet purposes;
  /**
   Ограничение скорости в км/ч.
  
   - Note: На текущий момент доступно только для камер, контролирующих скорость и среднюю скорость на участке.
   - Note: Может отсутствовать и для камер контроля скорости, если значение неизвестно.
  */
  final int? speedLimit;

  const RoadCameraInfo({
    required this.purposes,
    required this.speedLimit
  });

  RoadCameraInfo copyWith({
    CameraPurposeEnumSet? purposes,
    Optional<int?>? speedLimit
  }) {
    return RoadCameraInfo(
      purposes: purposes ?? this.purposes,
      speedLimit: speedLimit != null ? speedLimit.value : this.speedLimit
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadCameraInfo &&
    other.runtimeType == runtimeType &&
    other.purposes == purposes &&
    other.speedLimit == speedLimit;

  @override
  int get hashCode {
    return Object.hash(purposes, speedLimit);
  }

}
final class _CRoadCameraInfo extends ffi.Struct {
  external _COptionSet_CCameraPurpose purposes;

  external _COptional_uint16_t speedLimit;

}
// MARK: - RoadCameraInfo <-> _CRoadCameraInfo

extension _CRoadCameraInfoToDart on _CRoadCameraInfo {
  RoadCameraInfo _toDart() {
    return RoadCameraInfo(
      purposes: this.purposes._toDart(),
      speedLimit: this.speedLimit._toDart()
    );
  }
}

extension _DartTo_CRoadCameraInfo on RoadCameraInfo {
  _CRoadCameraInfo _copyFromDartTo_CRoadCameraInfo() {
    final res = _CRoadCameraInfoMakeDefault();
    res.purposes = this.purposes._copyFromDartTo_COptionSet_CCameraPurpose();
    res.speedLimit = this.speedLimit._copyFromDartTo_COptional_uint16_t();
    return res;
  }
}
extension _CRoadCameraInfoRelease on _CRoadCameraInfo {
  void _releaseIntermediate() {
  }
}

// MARK: - RoadCameraInfo? <-> _COptional_CRoadCameraInfo

final class _COptional_CRoadCameraInfo extends ffi.Struct {
  
  external _CRoadCameraInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRoadCameraInfoBasicFunctions on _COptional_CRoadCameraInfo {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CRoadCameraInfoToDart on _COptional_CRoadCameraInfo {
  RoadCameraInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRoadCameraInfo on RoadCameraInfo? {
  _COptional_CRoadCameraInfo _copyFromDartTo_COptional_CRoadCameraInfo() {
    final cOptional = _COptional_CRoadCameraInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRoadCameraInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Schedule

/** Расписание действия дорожного события. */
class Schedule {
  /** Время начала действия. Отсутствует, если неизвестно. */
  final DateTime? startTime;
  /** Время начала действия. Отсутствует, если неизвестно. */
  final DateTime? finishTime;
  /**
   Интервалы работы внутри недели.
  
   - Note: Интервалы упорядочены по времени.
   - Note: Первый интервал может начинаться с прошлой недели.
  */
  final List<WeekTimeInterval> weekTimeIntervals;

  const Schedule({
    required this.startTime,
    required this.finishTime,
    required this.weekTimeIntervals
  });

  Schedule copyWith({
    Optional<DateTime?>? startTime,
    Optional<DateTime?>? finishTime,
    List<WeekTimeInterval>? weekTimeIntervals
  }) {
    return Schedule(
      startTime: startTime != null ? startTime.value : this.startTime,
      finishTime: finishTime != null ? finishTime.value : this.finishTime,
      weekTimeIntervals: weekTimeIntervals ?? this.weekTimeIntervals
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Schedule &&
    other.runtimeType == runtimeType &&
    other.startTime == startTime &&
    other.finishTime == finishTime &&
    other.weekTimeIntervals == weekTimeIntervals;

  @override
  int get hashCode {
    return Object.hash(startTime, finishTime, weekTimeIntervals);
  }

}
final class _CSchedule extends ffi.Struct {
  external _COptional_CDate startTime;

  external _COptional_CDate finishTime;

  external _CArray_CWeekTimeInterval weekTimeIntervals;

}
// MARK: - Schedule <-> _CSchedule

extension _CScheduleToDart on _CSchedule {
  Schedule _toDart() {
    return Schedule(
      startTime: this.startTime._toDart(),
      finishTime: this.finishTime._toDart(),
      weekTimeIntervals: this.weekTimeIntervals._toDart()
    );
  }
}

extension _DartTo_CSchedule on Schedule {
  _CSchedule _copyFromDartTo_CSchedule() {
    final res = _CScheduleMakeDefault();
    res.startTime = this.startTime._copyFromDartTo_COptional_CDate();
    res.finishTime = this.finishTime._copyFromDartTo_COptional_CDate();
    res.weekTimeIntervals = this.weekTimeIntervals._copyFromDartTo_CArray_CWeekTimeInterval();
    return res;
  }
}
extension _CScheduleRelease on _CSchedule {
  void _releaseIntermediate() {
    weekTimeIntervals._releaseIntermediate();
  }
}

// MARK: - Schedule? <-> _COptional_CSchedule

final class _COptional_CSchedule extends ffi.Struct {
  
  external _CSchedule value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CScheduleBasicFunctions on _COptional_CSchedule {
  void _releaseIntermediate() {
    _COptional_CSchedule_release(this);
  }
}

extension _COptional_CScheduleToDart on _COptional_CSchedule {
  Schedule? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CSchedule on Schedule? {
  _COptional_CSchedule _copyFromDartTo_COptional_CSchedule() {
    final cOptional = _COptional_CScheduleMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CSchedule();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Lane

/** Полоса, которую затрагивает дорожное событие. */
enum Lane {
  /** Левая полоса. */
  left(1),
  /** Средняя полоса. */
  center(2),
  /** Правая полоса. */
  right(4),
  ;

  const Lane(this.rawValue);
  final int rawValue;

  static Lane getByValue(int value) {
    return Lane.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CLane extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CLaneBasicFunctions on _CLane {
  void _releaseIntermediate() {
  }
}

extension _CLaneToDart on _CLane {
  Lane _toDart() {
    return Lane.getByValue(this.rawValue);
  }
}

extension _DartTo_CLane on Lane {
  _CLane _copyFromDartTo_CLane() {
    return _CLaneMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - LaneEnumSet

class LaneEnumSet extends EnumSet<Lane> {
  LaneEnumSet() : super();

  factory LaneEnumSet.fromRawValue(int rawValue) {
    LaneEnumSet enumSet = LaneEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory LaneEnumSet.of(Iterable<Lane> elements) {
    LaneEnumSet enumSet = LaneEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory LaneEnumSet.all() {
    LaneEnumSet enumSet = LaneEnumSet();
    enumSet.addAll(Lane.values);
    return enumSet;
  }

  @override
  bool contains(Lane value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<Lane> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(Lane value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<Lane> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(Lane value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<Lane> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<Lane> intersection(EnumSet<Lane> other) =>
      LaneEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<Lane> union(EnumSet<Lane> other) =>
      LaneEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<Lane> difference(EnumSet<Lane> other) =>
      LaneEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<Lane> toSet() {
    Set<Lane> result = {};
    Lane.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    Lane.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CLane extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CLaneBasicFunctions on _COptionSet_CLane {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CLaneToDart on _COptionSet_CLane {
  LaneEnumSet _toDart() {
    return LaneEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CLane on LaneEnumSet {
  _COptionSet_CLane _copyFromDartTo_COptionSet_CLane() {
    return _COptionSet_CLaneMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - CancelableOperation<List<RoadEventPhoto>> <-> _CFuture_CArray_CRoadEventPhoto

final class _CFuture_CArray_CRoadEventPhoto extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CArray_CRoadEventPhoto_Cancellable {
  final Completer<List<RoadEventPhoto>> completer;
  final _CFuture_CArray_CRoadEventPhoto _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CArray_CRoadEventPhoto, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CArray_CRoadEventPhoto_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CArray_CRoadEventPhotoBasicFunctions on _CFuture_CArray_CRoadEventPhoto {
  void _releaseIntermediate() {
    _CFuture_CArray_CRoadEventPhoto_release(this);
  }

  _CFuture_CArray_CRoadEventPhoto _retain() {
    return _CFuture_CArray_CRoadEventPhoto_retain(this);
  }
}

extension _CFuture_CArray_CRoadEventPhotoToDart on _CFuture_CArray_CRoadEventPhoto {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CArray_CRoadEventPhoto_Cancellable>{};

  static void valueFunction(_CArray_CRoadEventPhoto cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<List<RoadEventPhoto>> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<List<RoadEventPhoto>>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CRoadEventPhoto, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CArray_CRoadEventPhotoReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CArray_CRoadEventPhoto_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CArray_CRoadEventPhoto on CancelableOperation<List<RoadEventPhoto>> {
  _CFuture_CArray_CRoadEventPhoto _copyFromDartTo_CFuture_CArray_CRoadEventPhoto() {
    return _CFuture_CArray_CRoadEventPhotoMakeDefault();
  }
}
	
// MARK: - List<RoadEventPhoto> <-> _CArray_CRoadEventPhoto

final class _CArray_CRoadEventPhoto extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRoadEventPhotoToDart on _CArray_CRoadEventPhoto {
  List<RoadEventPhoto> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRoadEventPhoto on List<RoadEventPhoto> {
  _CArray_CRoadEventPhoto _copyFromDartTo_CArray_CRoadEventPhoto() {
    final cArray = _CArray_CRoadEventPhotomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRoadEventPhoto();
        _CArray_CRoadEventPhotoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CRoadEventPhotoBasicFunctions on _CArray_CRoadEventPhoto {
  void _releaseIntermediate() {
    _CArray_CRoadEventPhoto_release(this);
  }

  static final _listToFill = <RoadEventPhoto>[];

  static void _iterate(_CRoadEventPhoto item) {
    _listToFill.add(item._toDart());
  }

  List<RoadEventPhoto> _fillFromC() {
    _forEach_CArray_CRoadEventPhoto(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRoadEventPhoto)>(_iterate));
    final result = List<RoadEventPhoto>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RoadEventPhoto

/** Фотография дорожного события. */
class RoadEventPhoto implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** URL полноразмерной фотографии. */
  String get photoUrl {
    _CString res = _CRoadEventPhoto_photoUrl(_CRoadEventPhotoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о пользователе, добавившем фотографию. */
  AuthorInfo get author {
    _CAuthorInfo res = _CRoadEventPhoto_author(_CRoadEventPhotoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Временная метка. */
  DateTime get timestamp {
    _CDate res = _CRoadEventPhoto_timestamp(_CRoadEventPhotoMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Получение объекта для удаления фотографии.
  
   - Returns: объект для удаления фотографии.
   В случае, если фотография добавлена другим пользователем, вернётся пустой объект.
  */
  Remover? get remover {
    _COptional_CRemover res = _CRoadEventPhoto_remover(_CRoadEventPhotoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadEventPhoto_releasePtr);

  RoadEventPhoto._raw(this._self);
  factory RoadEventPhoto._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEventPhoto._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventPhoto &&
    other.runtimeType == runtimeType &&
    _CRoadEventPhoto_cg_objectIdentifier(this._self) == _CRoadEventPhoto_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEventPhoto_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadEventPhoto: Methods

  /** URL превью фотографии. */
  String previewUrl(
    ScreenSize desiredSize
  )  {
    var _a1 = desiredSize._copyFromDartTo_CScreenSize();
    _CString res = _CRoadEventPhoto_previewUrl_CScreenSize(_CRoadEventPhotoMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Отправка жалобы на фотографию.
  
   - Note: жалоба на свою фотографию ни к чему не приведёт.
  */
  CancelableOperation<ActionResult> report()  {
    _CFuture_CActionResult res = _CRoadEventPhoto_report(_CRoadEventPhotoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadEventPhoto <-> CRoadEventPhoto

final class _CRoadEventPhoto extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventPhotoBasicFunctions on _CRoadEventPhoto {
  void _releaseIntermediate() {
    _CRoadEventPhoto_release(_impl);
  }

  _CRoadEventPhoto _retain() {
    return _CRoadEventPhoto_retain(_impl);
  }
}

extension _CRoadEventPhotoToDart on _CRoadEventPhoto {
  RoadEventPhoto _toDart() {
    return RoadEventPhoto._create(_retain()._impl);
  }
}


extension _DartToCRoadEventPhoto on RoadEventPhoto {
  _CRoadEventPhoto _copyFromDartTo_CRoadEventPhoto() {
    return (_CRoadEventPhotoMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ActionResult

/** Тип результата действия. */
enum ActionResult {
  /** Действие успешно выполнено. */
  ok(0),
  /** Сетевая ошибка. */
  networkError(1),
  ;

  const ActionResult(this.rawValue);
  final int rawValue;

  static ActionResult getByValue(int value) {
    return ActionResult.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CActionResult extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CActionResultBasicFunctions on _CActionResult {
  void _releaseIntermediate() {
  }
}

extension _CActionResultToDart on _CActionResult {
  ActionResult _toDart() {
    return ActionResult.getByValue(this.rawValue);
  }
}

extension _DartTo_CActionResult on ActionResult {
  _CActionResult _copyFromDartTo_CActionResult() {
    return _CActionResultMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CancelableOperation<ActionResult> <-> _CFuture_CActionResult

final class _CFuture_CActionResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CActionResult_Cancellable {
  final Completer<ActionResult> completer;
  final _CFuture_CActionResult _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CActionResult, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CActionResult_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CActionResultBasicFunctions on _CFuture_CActionResult {
  void _releaseIntermediate() {
    _CFuture_CActionResult_release(this);
  }

  _CFuture_CActionResult _retain() {
    return _CFuture_CActionResult_retain(this);
  }
}

extension _CFuture_CActionResultToDart on _CFuture_CActionResult {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CActionResult_Cancellable>{};

  static void valueFunction(_CActionResult cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<ActionResult> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<ActionResult>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CActionResult, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CActionResultReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CActionResult_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CActionResult on CancelableOperation<ActionResult> {
  _CFuture_CActionResult _copyFromDartTo_CFuture_CActionResult() {
    return _CFuture_CActionResultMakeDefault();
  }
}
	
// MARK: - Remover

/** Объект для удаления пользовательского контента. */
class Remover implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CRemover_releasePtr);

  Remover._raw(this._self);
  factory Remover._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Remover._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Remover &&
    other.runtimeType == runtimeType &&
    _CRemover_cg_objectIdentifier(this._self) == _CRemover_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRemover_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Remover: Methods

  /**
   Удаление контента.
  
   - Note: действие доступно для контента, автором которого является пользователь.
  */
  CancelableOperation<ActionResult> remove()  {
    _CFuture_CActionResult res = _CRemover_remove(_CRemoverMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - Remover <-> CRemover

final class _CRemover extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRemoverBasicFunctions on _CRemover {
  void _releaseIntermediate() {
    _CRemover_release(_impl);
  }

  _CRemover _retain() {
    return _CRemover_retain(_impl);
  }
}

extension _CRemoverToDart on _CRemover {
  Remover _toDart() {
    return Remover._create(_retain()._impl);
  }
}


extension _DartToCRemover on Remover {
  _CRemover _copyFromDartTo_CRemover() {
    return (_CRemoverMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Remover? <-> _COptional_CRemover

final class _COptional_CRemover extends ffi.Struct {
  
  external _CRemover value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRemoverBasicFunctions on _COptional_CRemover {
  void _releaseIntermediate() {
    _COptional_CRemover_release(this);
  }
}

extension _COptional_CRemoverToDart on _COptional_CRemover {
  Remover? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRemover on Remover? {
  _COptional_CRemover _copyFromDartTo_COptional_CRemover() {
    final cOptional = _COptional_CRemoverMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRemover();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<RoadEventAction> <-> _CArray_CRoadEventAction

final class _CArray_CRoadEventAction extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRoadEventActionToDart on _CArray_CRoadEventAction {
  List<RoadEventAction> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRoadEventAction on List<RoadEventAction> {
  _CArray_CRoadEventAction _copyFromDartTo_CArray_CRoadEventAction() {
    final cArray = _CArray_CRoadEventActionmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRoadEventAction();
        _CArray_CRoadEventActionaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CRoadEventActionBasicFunctions on _CArray_CRoadEventAction {
  void _releaseIntermediate() {
    _CArray_CRoadEventAction_release(this);
  }

  static final _listToFill = <RoadEventAction>[];

  static void _iterate(_CRoadEventAction item) {
    _listToFill.add(item._toDart());
  }

  List<RoadEventAction> _fillFromC() {
    _forEach_CArray_CRoadEventAction(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRoadEventAction)>(_iterate));
    final result = List<RoadEventAction>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RoadEventActionType

/** Тип действия дорожного события. */
enum RoadEventActionType {
  /** Добавление отметки "нравится". */
  like(0),
  /** Добавление отметки "не нравится". */
  dislike(1),
  /** Подтверждение события. */
  confirmation(2),
  /** Опровержение события. */
  disproof(3),
  ;

  const RoadEventActionType(this.rawValue);
  final int rawValue;

  static RoadEventActionType getByValue(int value) {
    return RoadEventActionType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoadEventActionType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoadEventActionTypeBasicFunctions on _CRoadEventActionType {
  void _releaseIntermediate() {
  }
}

extension _CRoadEventActionTypeToDart on _CRoadEventActionType {
  RoadEventActionType _toDart() {
    return RoadEventActionType.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoadEventActionType on RoadEventActionType {
  _CRoadEventActionType _copyFromDartTo_CRoadEventActionType() {
    return _CRoadEventActionTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RoadEventAction

/** Действие события. */
class RoadEventAction implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Тип действия. */
  RoadEventActionType get type {
    _CRoadEventActionType res = _CRoadEventAction_type(_CRoadEventActionMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Локализованное название действия. */
  String get name {
    _CString res = _CRoadEventAction_name(_CRoadEventActionMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о действии. */
  StatefulChannel<RoadEventActionInfo> get infoChannel {
    _CStatefulChannel_CRoadEventActionInfo res = _CRoadEventAction_infoChannel(_CRoadEventActionMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о действии. */
  RoadEventActionInfo get info {
    _CRoadEventActionInfo res = _CRoadEventAction_info(_CRoadEventActionMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadEventAction_releasePtr);

  RoadEventAction._raw(this._self);
  factory RoadEventAction._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEventAction._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventAction &&
    other.runtimeType == runtimeType &&
    _CRoadEventAction_cg_objectIdentifier(this._self) == _CRoadEventAction_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEventAction_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadEventAction: Methods

  /**
   Применение действия (например, добавление отметки "нравится", подтверждение события).
  
   - Note: Есть действия, противоположные друг другу, например, "нравится" и "не нравится".
   Если для события доступны оба действия, вызов метода сбрасывает применение противоположного -
   невозможно одновременно поставить "нравится" и "не нравится".
  */
  CancelableOperation<ActionResult> set()  {
    _CFuture_CActionResult res = _CRoadEventAction_set(_CRoadEventActionMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Отмена действия (например, сброс отметки "нравится", сброс подтверждения события).
  
   - Note: Есть действия, противоположные друг другу, например, "нравится" и "не нравится".
   Если для события доступны оба действия, вызов метода не вызывает применение противоположного действия.
  */
  CancelableOperation<ActionResult> reset()  {
    _CFuture_CActionResult res = _CRoadEventAction_reset(_CRoadEventActionMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadEventAction <-> CRoadEventAction

final class _CRoadEventAction extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventActionBasicFunctions on _CRoadEventAction {
  void _releaseIntermediate() {
    _CRoadEventAction_release(_impl);
  }

  _CRoadEventAction _retain() {
    return _CRoadEventAction_retain(_impl);
  }
}

extension _CRoadEventActionToDart on _CRoadEventAction {
  RoadEventAction _toDart() {
    return RoadEventAction._create(_retain()._impl);
  }
}


extension _DartToCRoadEventAction on RoadEventAction {
  _CRoadEventAction _copyFromDartTo_CRoadEventAction() {
    return (_CRoadEventActionMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<RoadEventActionInfo> <-> _CStatefulChannel_CRoadEventActionInfo

class _CStatefulChannel_CRoadEventActionInfoImpl extends StatefulChannel<RoadEventActionInfo> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RoadEventActionInfo>>{};

  final _CStatefulChannel_CRoadEventActionInfo _channel;

  _CStatefulChannel_CRoadEventActionInfoImpl(this._channel);

  @override
  RoadEventActionInfo get value {
    return this._channel._getter();
  }

  static void valueFunction(_CRoadEventActionInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<RoadEventActionInfo> listen(void onData(RoadEventActionInfo event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CRoadEventActionInfo, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RoadEventActionInfo>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CRoadEventActionInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CRoadEventActionInfoBasicFunctions on _CStatefulChannel_CRoadEventActionInfo {
  void _releaseIntermediate() {
    _CStatefulChannel_CRoadEventActionInfo_release(this);
  }

  _CStatefulChannel_CRoadEventActionInfo _retain() {
    return _CStatefulChannel_CRoadEventActionInfo_retain(this);
  }

  RoadEventActionInfo _getter() {
    final cValue = _CStatefulChannel_CRoadEventActionInfoGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CRoadEventActionInfo, ffi.Int64)> callback) {
    return _CStatefulChannel_CRoadEventActionInfoConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CRoadEventActionInfoToDart on _CStatefulChannel_CRoadEventActionInfo {
  StatefulChannel<RoadEventActionInfo> _toDart() {
    return _CStatefulChannel_CRoadEventActionInfoImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CRoadEventActionInfo on StatefulChannel<RoadEventActionInfo> {
  _CStatefulChannel_CRoadEventActionInfo _copyFromDartTo_CStatefulChannel_CRoadEventActionInfo() {
    return _CStatefulChannel_CRoadEventActionInfoMakeDefault();
  }
}
	
// MARK: - RoadEventActionState

/** Состояние действия. */
enum RoadEventActionState {
  /** Применено. */
  set_(0),
  /** Не применено. */
  notSet(1),
  ;

  const RoadEventActionState(this.rawValue);
  final int rawValue;

  static RoadEventActionState getByValue(int value) {
    return RoadEventActionState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoadEventActionState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoadEventActionStateBasicFunctions on _CRoadEventActionState {
  void _releaseIntermediate() {
  }
}

extension _CRoadEventActionStateToDart on _CRoadEventActionState {
  RoadEventActionState _toDart() {
    return RoadEventActionState.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoadEventActionState on RoadEventActionState {
  _CRoadEventActionState _copyFromDartTo_CRoadEventActionState() {
    return _CRoadEventActionStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - int? <-> _COptional_uint32_t

final class _COptional_uint32_t extends ffi.Struct {
  @ffi.Uint32()
  external int value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_uint32_tBasicFunctions on _COptional_uint32_t {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_uint32_tToDart on _COptional_uint32_t {
  int? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_uint32_t on int? {
  _COptional_uint32_t _copyFromDartTo_COptional_uint32_t() {
    final cOptional = _COptional_uint32_tMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - RoadEventActionInfo

/** Информация о действии. */
class RoadEventActionInfo {
  /** Состояние действия. */
  final RoadEventActionState state;
  /** Количество действий, применённых к событию всеми пользователями (только для пользовательских событий). */
  final int? count;

  const RoadEventActionInfo({
    required this.state,
    required this.count
  });

  RoadEventActionInfo copyWith({
    RoadEventActionState? state,
    Optional<int?>? count
  }) {
    return RoadEventActionInfo(
      state: state ?? this.state,
      count: count != null ? count.value : this.count
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventActionInfo &&
    other.runtimeType == runtimeType &&
    other.state == state &&
    other.count == count;

  @override
  int get hashCode {
    return Object.hash(state, count);
  }

}
final class _CRoadEventActionInfo extends ffi.Struct {
  external _CRoadEventActionState state;

  external _COptional_uint32_t count;

}
// MARK: - RoadEventActionInfo <-> _CRoadEventActionInfo

extension _CRoadEventActionInfoToDart on _CRoadEventActionInfo {
  RoadEventActionInfo _toDart() {
    return RoadEventActionInfo(
      state: this.state._toDart(),
      count: this.count._toDart()
    );
  }
}

extension _DartTo_CRoadEventActionInfo on RoadEventActionInfo {
  _CRoadEventActionInfo _copyFromDartTo_CRoadEventActionInfo() {
    final res = _CRoadEventActionInfoMakeDefault();
    res.state = this.state._copyFromDartTo_CRoadEventActionState();
    res.count = this.count._copyFromDartTo_COptional_uint32_t();
    return res;
  }
}
extension _CRoadEventActionInfoRelease on _CRoadEventActionInfo {
  void _releaseIntermediate() {
  }
}

// MARK: - Style

/** Стиль с набором свойств объектов карты (cм. ISource). */
class Style implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Получение свойств по умолчанию для объектов, к которым применён указанный слой. */
  Attributes get styleAttributes {
    _CAttributes res = _CStyle_styleAttributes(_CStyleMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CStyle_releasePtr);

  Style._raw(this._self);
  factory Style._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Style._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Style &&
    other.runtimeType == runtimeType &&
    _CStyle_cg_objectIdentifier(this._self) == _CStyle_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CStyle_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Style <-> CStyle

final class _CStyle extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStyleBasicFunctions on _CStyle {
  void _releaseIntermediate() {
    _CStyle_release(_impl);
  }

  _CStyle _retain() {
    return _CStyle_retain(_impl);
  }
}

extension _CStyleToDart on _CStyle {
  Style _toDart() {
    return Style._create(_retain()._impl);
  }
}


extension _DartToCStyle on Style {
  _CStyle _copyFromDartTo_CStyle() {
    return (_CStyleMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StyleZoomFollowController

/** Контроллер слежения за стилевым уровнем масштабирования карты. */
class StyleZoomFollowController extends FollowController implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CStyleZoomFollowController_releasePtr);

  StyleZoomFollowController._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory StyleZoomFollowController._create(ffi.Pointer<ffi.Void> self) {
    final classObject = StyleZoomFollowController._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /** Создание контроллера слежения за стилевым уровнем масштабирования карты. */
  factory StyleZoomFollowController(
    [Duration animationDuration = const Duration(milliseconds: 300)
    ]) {
    var _a0 = animationDuration._copyFromDartTo_CTimeInterval();
    _CStyleZoomFollowController res = _CStyleZoomFollowController_C_createWith_CTimeInterval(_a0);
    return StyleZoomFollowController._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is StyleZoomFollowController &&
    other.runtimeType == runtimeType &&
    _CStyleZoomFollowController_cg_objectIdentifier(this._self) == _CStyleZoomFollowController_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CStyleZoomFollowController_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: StyleZoomFollowController: Methods

  /** Установка нового значения стилевого уровня масштабирования. */
  void setStyleZoom(
    StyleZoom styleZoom
  )  {
    var _a1 = styleZoom._copyFromDartTo_CStyleZoom();
    void res = _CStyleZoomFollowController_setStyleZoom_CStyleZoom(_CStyleZoomFollowControllerMakeDefault().._impl=_self, _a1);
    return res;
  }

  /** Установка интервала допустимых значений стилевого уровня масштабирования. */
  void setStyleZoomRange(
    StyleZoom minStyleZoom,
    StyleZoom maxStyleZoom
  )  {
    var _a1 = minStyleZoom._copyFromDartTo_CStyleZoom();
    var _a2 = maxStyleZoom._copyFromDartTo_CStyleZoom();
    void res = _CStyleZoomFollowController_setStyleZoomRange_CStyleZoom_CStyleZoom(_CStyleZoomFollowControllerMakeDefault().._impl=_self, _a1, _a2);
    return res;
  }

}

// MARK: - StyleZoomFollowController <-> CStyleZoomFollowController

final class _CStyleZoomFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStyleZoomFollowControllerBasicFunctions on _CStyleZoomFollowController {
  void _releaseIntermediate() {
    _CStyleZoomFollowController_release(_impl);
  }

  _CStyleZoomFollowController _retain() {
    return _CStyleZoomFollowController_retain(_impl);
  }
}

extension _CStyleZoomFollowControllerToDart on _CStyleZoomFollowController {
  StyleZoomFollowController _toDart() {
    return StyleZoomFollowController._create(_retain()._impl);
  }
}


extension _DartToCStyleZoomFollowController on StyleZoomFollowController {
  _CStyleZoomFollowController _copyFromDartTo_CStyleZoomFollowController() {
    return (_CStyleZoomFollowControllerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - _StyleZoomToTiltRelationCpp

/** Объект для описания зависимости угла наклона камеры от стилевого уровня масштабирования. */
class _StyleZoomToTiltRelationCpp extends StyleZoomToTiltRelation implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CStyleZoomToTiltRelationCpp_releasePtr);

  _StyleZoomToTiltRelationCpp._raw(this._self);
  factory _StyleZoomToTiltRelationCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _StyleZoomToTiltRelationCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _StyleZoomToTiltRelationCpp &&
    other.runtimeType == runtimeType &&
    _CStyleZoomToTiltRelationCpp_cg_objectIdentifier(this._self) == _CStyleZoomToTiltRelationCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CStyleZoomToTiltRelationCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _StyleZoomToTiltRelationCpp: Methods

  /**
   Получение наклона камеры по стилевому уровню масштабирования.
  
   - Parameter styleZoom: Стилевой уровень масштабирования.
   - Returns: угол наклона камеры
   - Note: Функция должна быть непрерывной и монотонной.
   - Note: Функция должна быть потокобезопасной.
  */
  Tilt styleZoomToTilt(
    StyleZoom styleZoom
  )  {
    var _a1 = styleZoom._copyFromDartTo_CStyleZoom();
    _CTilt res = _CStyleZoomToTiltRelationCpp_styleZoomToTilt_CStyleZoom(_CStyleZoomToTiltRelationCppMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

}

// MARK: - _StyleZoomToTiltRelationCpp <-> CStyleZoomToTiltRelationCpp

final class _CStyleZoomToTiltRelationCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStyleZoomToTiltRelationCppBasicFunctions on _CStyleZoomToTiltRelationCpp {
  void _releaseIntermediate() {
    _CStyleZoomToTiltRelationCpp_release(_impl);
  }

  _CStyleZoomToTiltRelationCpp _retain() {
    return _CStyleZoomToTiltRelationCpp_retain(_impl);
  }
}

extension _CStyleZoomToTiltRelationCppToDart on _CStyleZoomToTiltRelationCpp {
  _StyleZoomToTiltRelationCpp _toDart() {
    return _StyleZoomToTiltRelationCpp._create(_retain()._impl);
  }
}


extension _DartToCStyleZoomToTiltRelationCpp on _StyleZoomToTiltRelationCpp {
  _CStyleZoomToTiltRelationCpp _copyFromDartTo_CStyleZoomToTiltRelationCpp() {
    return (_CStyleZoomToTiltRelationCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StyleZoomToTiltRelation

/** Объект для описания зависимости угла наклона камеры от стилевого уровня масштабирования. */
abstract class StyleZoomToTiltRelation {
  Tilt styleZoomToTilt(
    StyleZoom styleZoom
  );
}

class _StyleZoomToTiltRelation {
  final StyleZoomToTiltRelation object;
  int refCounter = 1;

  _StyleZoomToTiltRelation(this.object);
}

final class _CStyleZoomToTiltRelation extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CTilt)>>, _CStyleZoom)>> _styleZoomToTilt_CStyleZoom;
}

extension _CStyleZoomToTiltRelationBasicFunctions on _CStyleZoomToTiltRelation {
  void _releaseIntermediate() {
    _CStyleZoomToTiltRelation_release(this);
  }
}

int _CStyleZoomToTiltRelationInstanceCounter = 1;
final _CStyleZoomToTiltRelationInstanceMap = <int, _StyleZoomToTiltRelation>{};

extension _CStyleZoomToTiltRelationToDart on _CStyleZoomToTiltRelation {
  StyleZoomToTiltRelation _toDart() {
    late StyleZoomToTiltRelation? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CStyleZoomToTiltRelationInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CStyleZoomToTiltRelationCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CStyleZoomToTiltRelation");
    }
    return result;
  }
}

extension _DartTo_CStyleZoomToTiltRelation on StyleZoomToTiltRelation {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CStyleZoomToTiltRelationInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CStyleZoomToTiltRelationInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CStyleZoomToTiltRelationInstanceMap.remove(platformValue.address);
  }

  _CStyleZoomToTiltRelation _copyFromDartTo_CStyleZoomToTiltRelation() {
    var res = _CStyleZoomToTiltRelationMakeDefault();
    if (this is _StyleZoomToTiltRelationCpp) {
      final cppValue = this as _StyleZoomToTiltRelationCpp;
      res._cppValue = cppValue._copyFromDartTo_CStyleZoomToTiltRelationCpp()._impl;
      return res;
    }
    final instanceId = _CStyleZoomToTiltRelationInstanceCounter;
    _CStyleZoomToTiltRelationInstanceCounter += 1;
    _CStyleZoomToTiltRelationInstanceMap[instanceId] = _StyleZoomToTiltRelation(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final styleZoomToTilt_CStyleZoomFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CTilt)>>, _CStyleZoom)>.listener(styleZoomToTilt_CStyleZoomFunction);
    res._styleZoomToTilt_CStyleZoom = styleZoomToTilt_CStyleZoomFunctionCallable.nativeFunction;
    return res;
  }

  static void styleZoomToTilt_CStyleZoomFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CTilt)>> resultValueCallback, _CStyleZoom styleZoom) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CStyleZoomToTiltRelation");
    }
    final platformObject = _CStyleZoomToTiltRelationInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CStyleZoomToTiltRelation");
    }

    final styleZoomDart = styleZoom._toDart();
    final res = platformObject.object.styleZoomToTilt(styleZoomDart);
    styleZoom._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CTilt)>();
    callbackFunction(context, res._copyFromDartTo_CTilt());
  }


}

// MARK: - TiltFollowController

/** Контроллер слежения за углом наклона карты. */
class TiltFollowController extends FollowController implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CTiltFollowController_releasePtr);

  TiltFollowController._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory TiltFollowController._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TiltFollowController._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Создание контроллера слежения за углом наклона карты.
  
   - Parameter styleZoomToTilt: зависимость угла наклона камеры от стилевого уровня масштабирования.
  */
  factory TiltFollowController(
    StyleZoomToTiltRelation styleZoomToTilt
  ) {
    var _a0 = styleZoomToTilt._copyFromDartTo_CStyleZoomToTiltRelation();
    _CTiltFollowController res = _CTiltFollowController_C_createWith_CStyleZoomToTiltRelation(_a0);
    _a0._releaseIntermediate();
    return TiltFollowController._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TiltFollowController &&
    other.runtimeType == runtimeType &&
    _CTiltFollowController_cg_objectIdentifier(this._self) == _CTiltFollowController_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTiltFollowController_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - TiltFollowController <-> CTiltFollowController

final class _CTiltFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTiltFollowControllerBasicFunctions on _CTiltFollowController {
  void _releaseIntermediate() {
    _CTiltFollowController_release(_impl);
  }

  _CTiltFollowController _retain() {
    return _CTiltFollowController_retain(_impl);
  }
}

extension _CTiltFollowControllerToDart on _CTiltFollowController {
  TiltFollowController _toDart() {
    return TiltFollowController._create(_retain()._impl);
  }
}


extension _DartToCTiltFollowController on TiltFollowController {
  _CTiltFollowController _copyFromDartTo_CTiltFollowController() {
    return (_CTiltFollowControllerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - TrafficSource

/** Интерфейс класса, управляющего отображением пробок на карте. */
class TrafficSource extends Source implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CTrafficSource_releasePtr);

  TrafficSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory TrafficSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TrafficSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory TrafficSource(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CTrafficSource res = _CTrafficSource_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return TrafficSource._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficSource &&
    other.runtimeType == runtimeType &&
    _CTrafficSource_cg_objectIdentifier(this._self) == _CTrafficSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTrafficSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - TrafficSource <-> CTrafficSource

final class _CTrafficSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTrafficSourceBasicFunctions on _CTrafficSource {
  void _releaseIntermediate() {
    _CTrafficSource_release(_impl);
  }

  _CTrafficSource _retain() {
    return _CTrafficSource_retain(_impl);
  }
}

extension _CTrafficSourceToDart on _CTrafficSource {
  TrafficSource _toDart() {
    return TrafficSource._create(_retain()._impl);
  }
}


extension _DartToCTrafficSource on TrafficSource {
  _CTrafficSource _copyFromDartTo_CTrafficSource() {
    return (_CTrafficSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadEventDisplayCategory

/** Категория дорожного события для отображения на карте. */
enum RoadEventDisplayCategory {
  /** Камеры всех типов, в том числе и добавленные пользователем. */
  camera(1),
  /** Комментарии на дорогах. */
  comment(2),
  /** ДТП. */
  accident(4),
  /** Перекрытия дорог. */
  roadRestriction(8),
  /** Дорожные работы. */
  roadWorks(16),
  /** События категории "Другое". */
  other(32),
  /** Всегда отображать события, созданные текущим пользователем, вне зависимости от их категории. */
  user(64),
  ;

  const RoadEventDisplayCategory(this.rawValue);
  final int rawValue;

  static RoadEventDisplayCategory getByValue(int value) {
    return RoadEventDisplayCategory.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoadEventDisplayCategory extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoadEventDisplayCategoryBasicFunctions on _CRoadEventDisplayCategory {
  void _releaseIntermediate() {
  }
}

extension _CRoadEventDisplayCategoryToDart on _CRoadEventDisplayCategory {
  RoadEventDisplayCategory _toDart() {
    return RoadEventDisplayCategory.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoadEventDisplayCategory on RoadEventDisplayCategory {
  _CRoadEventDisplayCategory _copyFromDartTo_CRoadEventDisplayCategory() {
    return _CRoadEventDisplayCategoryMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RoadEventSource

/** Интерфейс класса, управляющего отображением дорожных событий (tUGC) на карте. */
class RoadEventSource extends Source implements ffi.Finalizable {
  /** Получение текущих категорий событий, предоставляемых данным источником. */
  RoadEventDisplayCategoryEnumSet get visibleEvents {
    _COptionSet_CRoadEventDisplayCategory res = _CRoadEventSource_getVisibleEvents(_CRoadEventSourceMakeDefault().._impl=_self);
    return res._toDart();
  }
  set visibleEvents(RoadEventDisplayCategoryEnumSet types) {
    var _a1 = types._copyFromDartTo_COptionSet_CRoadEventDisplayCategory();
    void res = _CRoadEventSource_setVisibleEvents_COptionSet_CRoadEventDisplayCategory(_CRoadEventSourceMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение списка идентификаторов выделенных дорожных событий. */
  StatefulChannel<List<DgisObjectId>> get highlightedObjectsChannel {
    _CStatefulChannel_CArray_CDgisObjectId res = _CRoadEventSource_highlightedObjectsChannel(_CRoadEventSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение списка идентификаторов выделенных дорожных событий. */
  List<DgisObjectId> get highlightedObjects {
    _CArray_CDgisObjectId res = _CRoadEventSource_highlightedObjects(_CRoadEventSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadEventSource_releasePtr);

  RoadEventSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RoadEventSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEventSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /** Создание источника, отображающего дорожные события на карте. */
  factory RoadEventSource(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CRoadEventSource res = _CRoadEventSource_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return RoadEventSource._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventSource &&
    other.runtimeType == runtimeType &&
    _CRoadEventSource_cg_objectIdentifier(this._self) == _CRoadEventSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEventSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadEventSource: Methods

  /**
   Установка или снятие выделения дорожных событий.
  
   - Note: добавляет событию атрибут "selected", который можно использовать в стилях.
   - Parameter directoryObjectIds: Идентификаторы изменяемых событий. Можно получить из RoadEventMapObject.
   - Parameter highlighted: Установка или снятие выделения.
  */
  void setHighlighted(
    List<DgisObjectId> directoryObjectIds,
    bool highlighted
  )  {
    var _a1 = directoryObjectIds._copyFromDartTo_CArray_CDgisObjectId();
    void res = _CRoadEventSource_setHighlighted_CArray_CDgisObjectId_bool(_CRoadEventSourceMakeDefault().._impl=_self, _a1, highlighted);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - RoadEventSource <-> CRoadEventSource

final class _CRoadEventSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventSourceBasicFunctions on _CRoadEventSource {
  void _releaseIntermediate() {
    _CRoadEventSource_release(_impl);
  }

  _CRoadEventSource _retain() {
    return _CRoadEventSource_retain(_impl);
  }
}

extension _CRoadEventSourceToDart on _CRoadEventSource {
  RoadEventSource _toDart() {
    return RoadEventSource._create(_retain()._impl);
  }
}


extension _DartToCRoadEventSource on RoadEventSource {
  _CRoadEventSource _copyFromDartTo_CRoadEventSource() {
    return (_CRoadEventSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadEventDisplayCategoryEnumSet

class RoadEventDisplayCategoryEnumSet extends EnumSet<RoadEventDisplayCategory> {
  RoadEventDisplayCategoryEnumSet() : super();

  factory RoadEventDisplayCategoryEnumSet.fromRawValue(int rawValue) {
    RoadEventDisplayCategoryEnumSet enumSet = RoadEventDisplayCategoryEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory RoadEventDisplayCategoryEnumSet.of(Iterable<RoadEventDisplayCategory> elements) {
    RoadEventDisplayCategoryEnumSet enumSet = RoadEventDisplayCategoryEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory RoadEventDisplayCategoryEnumSet.all() {
    RoadEventDisplayCategoryEnumSet enumSet = RoadEventDisplayCategoryEnumSet();
    enumSet.addAll(RoadEventDisplayCategory.values);
    return enumSet;
  }

  @override
  bool contains(RoadEventDisplayCategory value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<RoadEventDisplayCategory> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(RoadEventDisplayCategory value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<RoadEventDisplayCategory> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(RoadEventDisplayCategory value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<RoadEventDisplayCategory> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<RoadEventDisplayCategory> intersection(EnumSet<RoadEventDisplayCategory> other) =>
      RoadEventDisplayCategoryEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<RoadEventDisplayCategory> union(EnumSet<RoadEventDisplayCategory> other) =>
      RoadEventDisplayCategoryEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<RoadEventDisplayCategory> difference(EnumSet<RoadEventDisplayCategory> other) =>
      RoadEventDisplayCategoryEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<RoadEventDisplayCategory> toSet() {
    Set<RoadEventDisplayCategory> result = {};
    RoadEventDisplayCategory.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    RoadEventDisplayCategory.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CRoadEventDisplayCategory extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CRoadEventDisplayCategoryBasicFunctions on _COptionSet_CRoadEventDisplayCategory {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CRoadEventDisplayCategoryToDart on _COptionSet_CRoadEventDisplayCategory {
  RoadEventDisplayCategoryEnumSet _toDart() {
    return RoadEventDisplayCategoryEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CRoadEventDisplayCategory on RoadEventDisplayCategoryEnumSet {
  _COptionSet_CRoadEventDisplayCategory _copyFromDartTo_COptionSet_CRoadEventDisplayCategory() {
    return _COptionSet_CRoadEventDisplayCategoryMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - Alignment

enum Alignment {
  topLeft(0),
  topRight(1),
  bottomLeft(2),
  bottomRight(3),
  ;

  const Alignment(this.rawValue);
  final int rawValue;

  static Alignment getByValue(int value) {
    return Alignment.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CAlignment extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CAlignmentBasicFunctions on _CAlignment {
  void _releaseIntermediate() {
  }
}

extension _CAlignmentToDart on _CAlignment {
  Alignment _toDart() {
    return Alignment.getByValue(this.rawValue);
  }
}

extension _DartTo_CAlignment on Alignment {
  _CAlignment _copyFromDartTo_CAlignment() {
    return _CAlignmentMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - AnimationMode

/** Режим анимации. */
enum AnimationMode {
  /** Обычная. Анимация объекта отображается один раз. */
  normal(0),
  /** Зацикленная. Анимация объекта отображается циклически. */
  loop(1),
  ;

  const AnimationMode(this.rawValue);
  final int rawValue;

  static AnimationMode getByValue(int value) {
    return AnimationMode.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CAnimationMode extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CAnimationModeBasicFunctions on _CAnimationMode {
  void _releaseIntermediate() {
  }
}

extension _CAnimationModeToDart on _CAnimationMode {
  AnimationMode _toDart() {
    return AnimationMode.getByValue(this.rawValue);
  }
}

extension _DartTo_CAnimationMode on AnimationMode {
  _CAnimationMode _copyFromDartTo_CAnimationMode() {
    return _CAnimationModeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - LogicalPixel

/**
 Пиксель, размер которого не зависит от плотности экрана.

 1 логический пиксель соответствует  1 / (базовый ppi) дюйма.
 Базовый PPI зависит от устройства и вычисляется из отношения DevicePpi/DeviceDensity.
 DevicePpi и DeviceDensity, в свою очередь, задаются с ОС через интерфейс карты.
 Для Android LogicalPixel соответствует dp, для iOS - point'у.
*/
class LogicalPixel {
  final double value;

  const LogicalPixel([this.value = 0]);

  LogicalPixel copyWith({
    double? value
  }) {
    return LogicalPixel(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LogicalPixel &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CLogicalPixel extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - LogicalPixel <-> _CLogicalPixel

extension _CLogicalPixelToDart on _CLogicalPixel {
  LogicalPixel _toDart() {
    return LogicalPixel(
      this.value
    );
  }
}

extension _DartTo_CLogicalPixel on LogicalPixel {
  _CLogicalPixel _copyFromDartTo_CLogicalPixel() {
    final res = _CLogicalPixelMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CLogicalPixelRelease on _CLogicalPixel {
  void _releaseIntermediate() {
  }
}

// MARK: - MapDataLoadingState

enum MapDataLoadingState {
  /** Данные загружаются и, возможно, будут добавлены позже. */
  loading(0),
  /** Данные загружены. */
  loaded(1),
  ;

  const MapDataLoadingState(this.rawValue);
  final int rawValue;

  static MapDataLoadingState getByValue(int value) {
    return MapDataLoadingState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CMapDataLoadingState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CMapDataLoadingStateBasicFunctions on _CMapDataLoadingState {
  void _releaseIntermediate() {
  }
}

extension _CMapDataLoadingStateToDart on _CMapDataLoadingState {
  MapDataLoadingState _toDart() {
    return MapDataLoadingState.getByValue(this.rawValue);
  }
}

extension _DartTo_CMapDataLoadingState on MapDataLoadingState {
  _CMapDataLoadingState _copyFromDartTo_CMapDataLoadingState() {
    return _CMapDataLoadingStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - MapDirection

/** Угол поворота объекта относительно направления на север, в градусах, отсчитывается по часовой стрелке. */
class MapDirection {
  final double value;

  const MapDirection([this.value = 0]);

  MapDirection copyWith({
    double? value
  }) {
    return MapDirection(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapDirection &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CMapDirection extends ffi.Struct {
  @ffi.Double()
  external double value;

}
// MARK: - MapDirection <-> _CMapDirection

extension _CMapDirectionToDart on _CMapDirection {
  MapDirection _toDart() {
    return MapDirection(
      this.value
    );
  }
}

extension _DartTo_CMapDirection on MapDirection {
  _CMapDirection _copyFromDartTo_CMapDirection() {
    final res = _CMapDirectionMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CMapDirectionRelease on _CMapDirection {
  void _releaseIntermediate() {
  }
}

// MARK: - MapId

/** Идентификатор экземпляра карты, уникальный в рамках процесса. */
class MapId {
  final int value;

  const MapId([this.value = 0]);

  MapId copyWith({
    int? value
  }) {
    return MapId(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapId &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CMapId extends ffi.Struct {
  @ffi.Int32()
  external int value;

}
// MARK: - MapId <-> _CMapId

extension _CMapIdToDart on _CMapId {
  MapId _toDart() {
    return MapId(
      this.value
    );
  }
}

extension _DartTo_CMapId on MapId {
  _CMapId _copyFromDartTo_CMapId() {
    final res = _CMapIdMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CMapIdRelease on _CMapId {
  void _releaseIntermediate() {
  }
}

// MARK: - MapVisibilityState

/** Статус видимости карты */
enum MapVisibilityState {
  /** Карту полностью видно */
  visible(0),
  /** Карта полностью скрыта от пользователя */
  hidden(1),
  ;

  const MapVisibilityState(this.rawValue);
  final int rawValue;

  static MapVisibilityState getByValue(int value) {
    return MapVisibilityState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CMapVisibilityState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CMapVisibilityStateBasicFunctions on _CMapVisibilityState {
  void _releaseIntermediate() {
  }
}

extension _CMapVisibilityStateToDart on _CMapVisibilityState {
  MapVisibilityState _toDart() {
    return MapVisibilityState.getByValue(this.rawValue);
  }
}

extension _DartTo_CMapVisibilityState on MapVisibilityState {
  _CMapVisibilityState _copyFromDartTo_CMapVisibilityState() {
    return _CMapVisibilityStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Opacity

/** Непрозрачность - от 0.0 (полная прозрачность) до 1.0 (полная непрозрачность). */
class Opacity {
  final double value;

  const Opacity([this.value = 0]);

  Opacity copyWith({
    double? value
  }) {
    return Opacity(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Opacity &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _COpacity extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - Opacity <-> _COpacity

extension _COpacityToDart on _COpacity {
  Opacity _toDart() {
    return Opacity(
      this.value
    );
  }
}

extension _DartTo_COpacity on Opacity {
  _COpacity _copyFromDartTo_COpacity() {
    final res = _COpacityMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _COpacityRelease on _COpacity {
  void _releaseIntermediate() {
  }
}

// MARK: - Padding

/**
 Отступы от краёв камеры.

 Задаётся от краёв внутрь, в физических пикселях.
 Отступы влияют на:
 - точку позиции;
 - анимированное перемещение карты;
 - расположение динамических объектов карты (например баблы маршрутов).
*/
class Padding {
  /** Отступ слева внутрь. */
  final int left;
  /** Отступ сверху внутрь. */
  final int top;
  /** Отступ справа внутрь. */
  final int right;
  /** Отступ снизу внутрь. */
  final int bottom;

  const Padding({
    this.left = 0,
    this.top = 0,
    this.right = 0,
    this.bottom = 0
  });

  Padding copyWith({
    int? left,
    int? top,
    int? right,
    int? bottom
  }) {
    return Padding(
      left: left ?? this.left,
      top: top ?? this.top,
      right: right ?? this.right,
      bottom: bottom ?? this.bottom
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Padding &&
    other.runtimeType == runtimeType &&
    other.left == left &&
    other.top == top &&
    other.right == right &&
    other.bottom == bottom;

  @override
  int get hashCode {
    return Object.hash(left, top, right, bottom);
  }

}
final class _CPadding extends ffi.Struct {
  @ffi.Uint32()
  external int left;

  @ffi.Uint32()
  external int top;

  @ffi.Uint32()
  external int right;

  @ffi.Uint32()
  external int bottom;

}
// MARK: - Padding <-> _CPadding

extension _CPaddingToDart on _CPadding {
  Padding _toDart() {
    return Padding(
      left: this.left,
      top: this.top,
      right: this.right,
      bottom: this.bottom
    );
  }
}

extension _DartTo_CPadding on Padding {
  _CPadding _copyFromDartTo_CPadding() {
    final res = _CPaddingMakeDefault();
    res.left = this.left;
    res.top = this.top;
    res.right = this.right;
    res.bottom = this.bottom;
    return res;
  }
}
extension _CPaddingRelease on _CPadding {
  void _releaseIntermediate() {
  }
}

// MARK: - ProductType

@internal
enum ProductType {
  dgis(0),
  urbi(1),
  ;

  const ProductType(this.rawValue);
  final int rawValue;

  static ProductType getByValue(int value) {
    return ProductType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CProductType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CProductTypeBasicFunctions on _CProductType {
  void _releaseIntermediate() {
  }
}

extension _CProductTypeToDart on _CProductType {
  ProductType _toDart() {
    return ProductType.getByValue(this.rawValue);
  }
}

extension _DartTo_CProductType on ProductType {
  _CProductType _copyFromDartTo_CProductType() {
    return _CProductTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ModelScale

/** Коэффициент масштабирования модели. Подбирается вручную. Значение варьируется от 0.0 до 64.0. */
class ModelScale {
  final double value;

  const ModelScale([this.value = 0]);

  ModelScale copyWith({
    double? value
  }) {
    return ModelScale(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ModelScale &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CModelScale extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - ModelScale <-> _CModelScale

extension _CModelScaleToDart on _CModelScale {
  ModelScale _toDart() {
    return ModelScale(
      this.value
    );
  }
}

extension _DartTo_CModelScale on ModelScale {
  _CModelScale _copyFromDartTo_CModelScale() {
    final res = _CModelScaleMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CModelScaleRelease on _CModelScale {
  void _releaseIntermediate() {
  }
}

// MARK: - RenderedObject

/** Отображаемый объект карты. */
class RenderedObject {
  /** Объект карты. */
  final MapObject item;
  /** Источник данных, содержащий объект карты. */
  final Source source;
  /** Идентификатор этажного плана здания, на котором расположен объект. */
  final LevelId? levelId;

  const RenderedObject({
    required this.item,
    required this.source,
    this.levelId = null
  });

  RenderedObject copyWith({
    MapObject? item,
    Source? source,
    Optional<LevelId?>? levelId
  }) {
    return RenderedObject(
      item: item ?? this.item,
      source: source ?? this.source,
      levelId: levelId != null ? levelId.value : this.levelId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RenderedObject &&
    other.runtimeType == runtimeType &&
    other.item == item &&
    other.source == source &&
    other.levelId == levelId;

  @override
  int get hashCode {
    return Object.hash(item, source, levelId);
  }

}
final class _CRenderedObject extends ffi.Struct {
  external _CMapObject item;

  external _CSource source;

  external _COptional_CLevelId levelId;

}
// MARK: - RenderedObject <-> _CRenderedObject

extension _CRenderedObjectToDart on _CRenderedObject {
  RenderedObject _toDart() {
    return RenderedObject(
      item: this.item._toDart(),
      source: this.source._toDart(),
      levelId: this.levelId._toDart()
    );
  }
}

extension _DartTo_CRenderedObject on RenderedObject {
  _CRenderedObject _copyFromDartTo_CRenderedObject() {
    final res = _CRenderedObjectMakeDefault();
    res.item = this.item._copyFromDartTo_CMapObject();
    res.source = this.source._copyFromDartTo_CSource();
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    return res;
  }
}
extension _CRenderedObjectRelease on _CRenderedObject {
  void _releaseIntermediate() {
    item._releaseIntermediate();
    source._releaseIntermediate();
  }
}

// MARK: - ScreenDistance

/**
 Расстояние между объектами на экране в миллиметрах.

 - Note: не может быть отрицательным
*/
class ScreenDistance {
  final double value;

  const ScreenDistance([this.value = 0]);

  ScreenDistance copyWith({
    double? value
  }) {
    return ScreenDistance(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScreenDistance &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CScreenDistance extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - ScreenDistance <-> _CScreenDistance

extension _CScreenDistanceToDart on _CScreenDistance {
  ScreenDistance _toDart() {
    return ScreenDistance(
      this.value
    );
  }
}

extension _DartTo_CScreenDistance on ScreenDistance {
  _CScreenDistance _copyFromDartTo_CScreenDistance() {
    final res = _CScreenDistanceMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CScreenDistanceRelease on _CScreenDistance {
  void _releaseIntermediate() {
  }
}

// MARK: - StyleLayerId

/** Идентификатор слоя стиля. */
class StyleLayerId {
  final String id;

  const StyleLayerId(this.id);

  StyleLayerId copyWith({
    String? id
  }) {
    return StyleLayerId(
      id ?? this.id
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is StyleLayerId &&
    other.runtimeType == runtimeType &&
    other.id == id;

  @override
  int get hashCode {
    return id.hashCode;
  }

}
final class _CStyleLayerId extends ffi.Struct {
  external _CString id;

}
// MARK: - StyleLayerId <-> _CStyleLayerId

extension _CStyleLayerIdToDart on _CStyleLayerId {
  StyleLayerId _toDart() {
    return StyleLayerId(
      this.id._toDart()
    );
  }
}

extension _DartTo_CStyleLayerId on StyleLayerId {
  _CStyleLayerId _copyFromDartTo_CStyleLayerId() {
    final res = _CStyleLayerIdMakeDefault();
    res.id = this.id._copyFromDartTo_CString();
    return res;
  }
}
extension _CStyleLayerIdRelease on _CStyleLayerId {
  void _releaseIntermediate() {
    id._releaseIntermediate();
  }
}

// MARK: - TextHorizontalAlignment

/** Выравнивание надписи по горизонтали. */
enum TextHorizontalAlignment {
  /** Автоматическое выравнивание. */
  auto(0),
  /** Выравнивание по центру. */
  center(1),
  /** Выравнивание по левому краю. */
  left(2),
  /** Выравнивание по правому краю. */
  right(3),
  ;

  const TextHorizontalAlignment(this.rawValue);
  final int rawValue;

  static TextHorizontalAlignment getByValue(int value) {
    return TextHorizontalAlignment.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CTextHorizontalAlignment extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CTextHorizontalAlignmentBasicFunctions on _CTextHorizontalAlignment {
  void _releaseIntermediate() {
  }
}

extension _CTextHorizontalAlignmentToDart on _CTextHorizontalAlignment {
  TextHorizontalAlignment _toDart() {
    return TextHorizontalAlignment.getByValue(this.rawValue);
  }
}

extension _DartTo_CTextHorizontalAlignment on TextHorizontalAlignment {
  _CTextHorizontalAlignment _copyFromDartTo_CTextHorizontalAlignment() {
    return _CTextHorizontalAlignmentMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - TextPlacement

/**
 Варианты положения подписи относительно иконки.
 Само положение определяется следующим образом:
 1. Первая часть enum обозначает область, относительно которой определяется зона положения подписи:
 A. "Circle" - значит рассматривается окружность вокруг маркера.
 B. Пустая строка - значит рассматривается квадрат.
 2. Вторая часть enum определяет зону относительно области вокруг маркера.
 3. Третья часть enum определяет расположение подписи внутри зоны.
*/
enum TextPlacement {
  /** Нет подписи. */
  noLabel(0),
  /** В центре области ниже квадрата вокруг маркера. */
  bottomCenter(1),
  /** С правой стороны области ниже квадрата вокруг маркера. */
  bottomRight(2),
  /** С левой стороны области ниже квадрата вокруг маркера. */
  bottomLeft(3),
  /** В нижней правой области относительно окружности вокруг маркера. */
  circleBottomRight(4),
  /** Снизу области правее квадрата вокруг маркера. */
  rightBottom(5),
  /** В центре области правее квадрата вокруг маркера. */
  rightCenter(6),
  /** Сверху области правее квадрата вокруг маркера. */
  rightTop(7),
  /** В верхней правой области относительно окружности вокруг маркера. */
  circleTopRight(8),
  /** В центре области выше квадрата вокруг маркера. */
  topCenter(9),
  /** С правой стороны области выше квадрата вокруг маркера. */
  topRight(10),
  /** С левой стороны области выше квадрата вокруг маркера. */
  topLeft(11),
  /** В верхней левой области относительно окружности вокруг маркера. */
  circleTopLeft(12),
  /** Сверху области левее квадрата вокруг маркера. */
  leftTop(13),
  /** В центре области левее квадрата вокруг маркера. */
  leftCenter(14),
  /** Снизу области левее квадрата вокруг маркера. */
  leftBottom(15),
  /** В нижней левой области относительно окружности вокруг маркера. */
  circleBottomLeft(16),
  /** По центру квадрата вокруг маркера. */
  centerCenter(17),
  ;

  const TextPlacement(this.rawValue);
  final int rawValue;

  static TextPlacement getByValue(int value) {
    return TextPlacement.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CTextPlacement extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CTextPlacementBasicFunctions on _CTextPlacement {
  void _releaseIntermediate() {
  }
}

extension _CTextPlacementToDart on _CTextPlacement {
  TextPlacement _toDart() {
    return TextPlacement.getByValue(this.rawValue);
  }
}

extension _DartTo_CTextPlacement on TextPlacement {
  _CTextPlacement _copyFromDartTo_CTextPlacement() {
    return _CTextPlacementMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - TextStyle

/** Настройки внешнего вида текста. */
class TextStyle {
  final LogicalPixel fontSize;
  final Color color;
  final LogicalPixel strokeWidth;
  final Color strokeColor;
  final TextHorizontalAlignment textHorizontalAlignment;
  final TextPlacement textPlacement;
  final LogicalPixel textOffset;
  final String? fontName;

  const TextStyle({
    this.fontSize = const LogicalPixel(8),
    this.color = const Color(),
    this.strokeWidth = const LogicalPixel(0.3499999940395355),
    this.strokeColor = const Color(4294967295),
    this.textHorizontalAlignment = TextHorizontalAlignment.auto,
    this.textPlacement = TextPlacement.bottomCenter,
    this.textOffset = const LogicalPixel(0),
    this.fontName = null
  });

  TextStyle copyWith({
    LogicalPixel? fontSize,
    Color? color,
    LogicalPixel? strokeWidth,
    Color? strokeColor,
    TextHorizontalAlignment? textHorizontalAlignment,
    TextPlacement? textPlacement,
    LogicalPixel? textOffset,
    Optional<String?>? fontName
  }) {
    return TextStyle(
      fontSize: fontSize ?? this.fontSize,
      color: color ?? this.color,
      strokeWidth: strokeWidth ?? this.strokeWidth,
      strokeColor: strokeColor ?? this.strokeColor,
      textHorizontalAlignment: textHorizontalAlignment ?? this.textHorizontalAlignment,
      textPlacement: textPlacement ?? this.textPlacement,
      textOffset: textOffset ?? this.textOffset,
      fontName: fontName != null ? fontName.value : this.fontName
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TextStyle &&
    other.runtimeType == runtimeType &&
    other.fontSize == fontSize &&
    other.color == color &&
    other.strokeWidth == strokeWidth &&
    other.strokeColor == strokeColor &&
    other.textHorizontalAlignment == textHorizontalAlignment &&
    other.textPlacement == textPlacement &&
    other.textOffset == textOffset &&
    other.fontName == fontName;

  @override
  int get hashCode {
    return Object.hash(fontSize, color, strokeWidth, strokeColor, textHorizontalAlignment, textPlacement, textOffset, fontName);
  }

}
final class _CTextStyle extends ffi.Struct {
  external _CLogicalPixel fontSize;

  external _CColor color;

  external _CLogicalPixel strokeWidth;

  external _CColor strokeColor;

  external _CTextHorizontalAlignment textHorizontalAlignment;

  external _CTextPlacement textPlacement;

  external _CLogicalPixel textOffset;

  external _COptional_CString fontName;

}
// MARK: - TextStyle <-> _CTextStyle

extension _CTextStyleToDart on _CTextStyle {
  TextStyle _toDart() {
    return TextStyle(
      fontSize: this.fontSize._toDart(),
      color: this.color._toDart(),
      strokeWidth: this.strokeWidth._toDart(),
      strokeColor: this.strokeColor._toDart(),
      textHorizontalAlignment: this.textHorizontalAlignment._toDart(),
      textPlacement: this.textPlacement._toDart(),
      textOffset: this.textOffset._toDart(),
      fontName: this.fontName._toDart()
    );
  }
}

extension _DartTo_CTextStyle on TextStyle {
  _CTextStyle _copyFromDartTo_CTextStyle() {
    final res = _CTextStyleMakeDefault();
    res.fontSize = this.fontSize._copyFromDartTo_CLogicalPixel();
    res.color = this.color._copyFromDartTo_CColor();
    res.strokeWidth = this.strokeWidth._copyFromDartTo_CLogicalPixel();
    res.strokeColor = this.strokeColor._copyFromDartTo_CColor();
    res.textHorizontalAlignment = this.textHorizontalAlignment._copyFromDartTo_CTextHorizontalAlignment();
    res.textPlacement = this.textPlacement._copyFromDartTo_CTextPlacement();
    res.textOffset = this.textOffset._copyFromDartTo_CLogicalPixel();
    res.fontName = this.fontName._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CTextStyleRelease on _CTextStyle {
  void _releaseIntermediate() {
    fontName._releaseIntermediate();
  }
}

// MARK: - FollowPosition? <-> _COptional_CFollowPosition

final class _COptional_CFollowPosition extends ffi.Struct {
  
  external _CFollowPosition value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CFollowPositionBasicFunctions on _COptional_CFollowPosition {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CFollowPositionToDart on _COptional_CFollowPosition {
  FollowPosition? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CFollowPosition on FollowPosition? {
  _COptional_CFollowPosition _copyFromDartTo_COptional_CFollowPosition() {
    final cOptional = _COptional_CFollowPositionMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CFollowPosition();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CameraBehaviour

/**
 Режим слежения камеры.

 Режимы камеры деградируются по следующим правилам:
 * смещение карты сбрасывает слежение за позицией (включая слежение за направлением и стилевым уровнем
 масштабирования)
 события: DirectMapShiftEvent, MapShiftBeginEvent, DirectMapRotationEvent с указанием центра события,
 DirectMapScalingEvent с указанием центра события, ScaleMapEvent с указанием центра события
 * поворот карты относительно точки позиции отбрасывает Bearing
 события: MapRotationBeginEvent, RotateMapToNorthEvent, DirectMapRotationEvent без центра события
 * изменение масштаба относительно точки позиции отбрасывает StyleZoom
 события: MapScalingBeginEvent, DirectMapScalingEvent без центра события, ScaleMapEvent без центра события
 * наклон отбрасывает Tilt
 события: DirectMapTiltEvent
*/
class CameraBehaviour {
  final FollowPosition? position;
  final FollowTilt tilt;

  const CameraBehaviour({
    required this.position,
    this.tilt = FollowTilt.off
  });

  CameraBehaviour copyWith({
    Optional<FollowPosition?>? position,
    FollowTilt? tilt
  }) {
    return CameraBehaviour(
      position: position != null ? position.value : this.position,
      tilt: tilt ?? this.tilt
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraBehaviour &&
    other.runtimeType == runtimeType &&
    other.position == position &&
    other.tilt == tilt;

  @override
  int get hashCode {
    return Object.hash(position, tilt);
  }

}
final class _CCameraBehaviour extends ffi.Struct {
  external _COptional_CFollowPosition position;

  external _CFollowTilt tilt;

}
// MARK: - CameraBehaviour <-> _CCameraBehaviour

extension _CCameraBehaviourToDart on _CCameraBehaviour {
  CameraBehaviour _toDart() {
    return CameraBehaviour(
      position: this.position._toDart(),
      tilt: this.tilt._toDart()
    );
  }
}

extension _DartTo_CCameraBehaviour on CameraBehaviour {
  _CCameraBehaviour _copyFromDartTo_CCameraBehaviour() {
    final res = _CCameraBehaviourMakeDefault();
    res.position = this.position._copyFromDartTo_COptional_CFollowPosition();
    res.tilt = this.tilt._copyFromDartTo_CFollowTilt();
    return res;
  }
}
extension _CCameraBehaviourRelease on _CCameraBehaviour {
  void _releaseIntermediate() {
  }
}

// MARK: - CameraBehaviourChange

/** Изменение режима слежения. */
class CameraBehaviourChange {
  /** Новый режим слежения. */
  final CameraBehaviour newBehaviour;
  /** Причина изменения режима слежения. */
  final CameraBehaviourChangeReason changeReason;

  const CameraBehaviourChange({
    required this.newBehaviour,
    this.changeReason = CameraBehaviourChangeReason.application
  });

  CameraBehaviourChange copyWith({
    CameraBehaviour? newBehaviour,
    CameraBehaviourChangeReason? changeReason
  }) {
    return CameraBehaviourChange(
      newBehaviour: newBehaviour ?? this.newBehaviour,
      changeReason: changeReason ?? this.changeReason
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraBehaviourChange &&
    other.runtimeType == runtimeType &&
    other.newBehaviour == newBehaviour &&
    other.changeReason == changeReason;

  @override
  int get hashCode {
    return Object.hash(newBehaviour, changeReason);
  }

}
final class _CCameraBehaviourChange extends ffi.Struct {
  external _CCameraBehaviour newBehaviour;

  external _CCameraBehaviourChangeReason changeReason;

}
// MARK: - CameraBehaviourChange <-> _CCameraBehaviourChange

extension _CCameraBehaviourChangeToDart on _CCameraBehaviourChange {
  CameraBehaviourChange _toDart() {
    return CameraBehaviourChange(
      newBehaviour: this.newBehaviour._toDart(),
      changeReason: this.changeReason._toDart()
    );
  }
}

extension _DartTo_CCameraBehaviourChange on CameraBehaviourChange {
  _CCameraBehaviourChange _copyFromDartTo_CCameraBehaviourChange() {
    final res = _CCameraBehaviourChangeMakeDefault();
    res.newBehaviour = this.newBehaviour._copyFromDartTo_CCameraBehaviour();
    res.changeReason = this.changeReason._copyFromDartTo_CCameraBehaviourChangeReason();
    return res;
  }
}
extension _CCameraBehaviourChangeRelease on _CCameraBehaviourChange {
  void _releaseIntermediate() {
  }
}

// MARK: - Zoom? <-> _COptional_CZoom

final class _COptional_CZoom extends ffi.Struct {
  
  external _CZoom value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CZoomBasicFunctions on _COptional_CZoom {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CZoomToDart on _COptional_CZoom {
  Zoom? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CZoom on Zoom? {
  _COptional_CZoom _copyFromDartTo_COptional_CZoom() {
    final cOptional = _COptional_CZoomMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CZoom();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CameraPositionChange

/** Описание изменения части параметров позиции камеры. */
class CameraPositionChange {
  final GeoPoint? point;
  final Zoom? zoom;
  final Tilt? tilt;
  final Bearing? bearing;

  const CameraPositionChange({
    this.point = null,
    this.zoom = null,
    this.tilt = null,
    this.bearing = null
  });

  CameraPositionChange copyWith({
    Optional<GeoPoint?>? point,
    Optional<Zoom?>? zoom,
    Optional<Tilt?>? tilt,
    Optional<Bearing?>? bearing
  }) {
    return CameraPositionChange(
      point: point != null ? point.value : this.point,
      zoom: zoom != null ? zoom.value : this.zoom,
      tilt: tilt != null ? tilt.value : this.tilt,
      bearing: bearing != null ? bearing.value : this.bearing
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraPositionChange &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.zoom == zoom &&
    other.tilt == tilt &&
    other.bearing == bearing;

  @override
  int get hashCode {
    return Object.hash(point, zoom, tilt, bearing);
  }

}
final class _CCameraPositionChange extends ffi.Struct {
  external _COptional_CGeoPoint point;

  external _COptional_CZoom zoom;

  external _COptional_CTilt tilt;

  external _COptional_CBearing bearing;

}
// MARK: - CameraPositionChange <-> _CCameraPositionChange

extension _CCameraPositionChangeToDart on _CCameraPositionChange {
  CameraPositionChange _toDart() {
    return CameraPositionChange(
      point: this.point._toDart(),
      zoom: this.zoom._toDart(),
      tilt: this.tilt._toDart(),
      bearing: this.bearing._toDart()
    );
  }
}

extension _DartTo_CCameraPositionChange on CameraPositionChange {
  _CCameraPositionChange _copyFromDartTo_CCameraPositionChange() {
    final res = _CCameraPositionChangeMakeDefault();
    res.point = this.point._copyFromDartTo_COptional_CGeoPoint();
    res.zoom = this.zoom._copyFromDartTo_COptional_CZoom();
    res.tilt = this.tilt._copyFromDartTo_COptional_CTilt();
    res.bearing = this.bearing._copyFromDartTo_COptional_CBearing();
    return res;
  }
}
extension _CCameraPositionChangeRelease on _CCameraPositionChange {
  void _releaseIntermediate() {
  }
}

// MARK: - CameraZoomRestrictions

/** Допустимый диапазон изменения уровня масштабирования. */
class CameraZoomRestrictions {
  /** Минимальный уровень масштабирования должен быть меньше максимального. */
  final Zoom minZoom;
  /** Максимальный масштаб ограничен величиной 20. */
  final Zoom maxZoom;

  const CameraZoomRestrictions({
    this.minZoom = const Zoom(0),
    this.maxZoom = const Zoom(20)
  });

  CameraZoomRestrictions copyWith({
    Zoom? minZoom,
    Zoom? maxZoom
  }) {
    return CameraZoomRestrictions(
      minZoom: minZoom ?? this.minZoom,
      maxZoom: maxZoom ?? this.maxZoom
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraZoomRestrictions &&
    other.runtimeType == runtimeType &&
    other.minZoom == minZoom &&
    other.maxZoom == maxZoom;

  @override
  int get hashCode {
    return Object.hash(minZoom, maxZoom);
  }

}
final class _CCameraZoomRestrictions extends ffi.Struct {
  external _CZoom minZoom;

  external _CZoom maxZoom;

}
// MARK: - CameraZoomRestrictions <-> _CCameraZoomRestrictions

extension _CCameraZoomRestrictionsToDart on _CCameraZoomRestrictions {
  CameraZoomRestrictions _toDart() {
    return CameraZoomRestrictions(
      minZoom: this.minZoom._toDart(),
      maxZoom: this.maxZoom._toDart()
    );
  }
}

extension _DartTo_CCameraZoomRestrictions on CameraZoomRestrictions {
  _CCameraZoomRestrictions _copyFromDartTo_CCameraZoomRestrictions() {
    final res = _CCameraZoomRestrictionsMakeDefault();
    res.minZoom = this.minZoom._copyFromDartTo_CZoom();
    res.maxZoom = this.maxZoom._copyFromDartTo_CZoom();
    return res;
  }
}
extension _CCameraZoomRestrictionsRelease on _CCameraZoomRestrictions {
  void _releaseIntermediate() {
  }
}

// MARK: - GeometryMapObjectBuilder

/** Класс для установки свойств и последующего создания геометрических объектов. */
class GeometryMapObjectBuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CGeometryMapObjectBuilder_releasePtr);

  GeometryMapObjectBuilder._raw(this._self);
  factory GeometryMapObjectBuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GeometryMapObjectBuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory GeometryMapObjectBuilder() {
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_C_create();
    return GeometryMapObjectBuilder._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeometryMapObjectBuilder &&
    other.runtimeType == runtimeType &&
    _CGeometryMapObjectBuilder_cg_objectIdentifier(this._self) == _CGeometryMapObjectBuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGeometryMapObjectBuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: GeometryMapObjectBuilder: Methods

  /**
   Установка свойства объекта карты.
  
   - Parameter name: Имя свойства объекта карты.
   - Parameter value: Значение свойства объекта карты.
  */
  GeometryMapObjectBuilder setObjectAttribute(
    String name,
    AttributeValue value
  )  {
    var _a1 = name._copyFromDartTo_CString();
    var _a2 = value._copyFromDartTo_CAttributeValue();
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_setObjectAttribute_CString_CAttributeValue(_CGeometryMapObjectBuilderMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Установка свойств объекта карты.
  
   - Parameter values: набор пар "имя":"значение" для добавляемых свойства объекта карты
   - Note: метод не заменяет весь набор свойств объекта, т.е. если свойство в values отсутствует,
   но уже добавлено в объект ранее, оно не будет изменено.
  */
  GeometryMapObjectBuilder setObjectAttributes(
    core.Map<String, AttributeValue> values
  )  {
    var _a1 = values._copyFromDartTo_CDictionary_CString_CAttributeValue();
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_setObjectAttributes_CDictionary_CString_CAttributeValue(_CGeometryMapObjectBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Установка геометрии объекта карты. */
  GeometryMapObjectBuilder setGeometry(
    Geometry geometry
  )  {
    var _a1 = geometry._copyFromDartTo_CGeometry();
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_setGeometry_CGeometry(_CGeometryMapObjectBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Установка видимости объекта карты. */
  GeometryMapObjectBuilder setVisible(
    bool visible
  )  {
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_setVisible_bool(_CGeometryMapObjectBuilderMakeDefault().._impl=_self, visible);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Установка возможности перетаскивания объекта карты. */
  GeometryMapObjectBuilder setDraggable(
    bool draggable
  )  {
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_setDraggable_bool(_CGeometryMapObjectBuilderMakeDefault().._impl=_self, draggable);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Установка пользовательских данных.
  
   - Note: пользовательские данные никак не используются в SDK и нужны только чтобы возвращать их пользователю.
  */
  GeometryMapObjectBuilder setUserData(
    Object? userData
  )  {
    var _a1 = userData._copyFromDartTo_CAny();
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_setUserData_CAny(_CGeometryMapObjectBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Конструирование объекта карты.
  
   - Note: у объекта обязательно должна быть установлена геометрия
   - Note: после вызова этой функции GeometryMapObjectBuilder непригоден для задания параметров объекта карты или
   для его создания
  */
  GeometryMapObject createObject()  {
    _CGeometryMapObject res = _CGeometryMapObjectBuilder_createObject(_CGeometryMapObjectBuilderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - GeometryMapObjectBuilder <-> CGeometryMapObjectBuilder

final class _CGeometryMapObjectBuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGeometryMapObjectBuilderBasicFunctions on _CGeometryMapObjectBuilder {
  void _releaseIntermediate() {
    _CGeometryMapObjectBuilder_release(_impl);
  }

  _CGeometryMapObjectBuilder _retain() {
    return _CGeometryMapObjectBuilder_retain(_impl);
  }
}

extension _CGeometryMapObjectBuilderToDart on _CGeometryMapObjectBuilder {
  GeometryMapObjectBuilder _toDart() {
    return GeometryMapObjectBuilder._create(_retain()._impl);
  }
}


extension _DartToCGeometryMapObjectBuilder on GeometryMapObjectBuilder {
  _CGeometryMapObjectBuilder _copyFromDartTo_CGeometryMapObjectBuilder() {
    return (_CGeometryMapObjectBuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GeometryMapObjectSourceBuilder

class GeometryMapObjectSourceBuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CGeometryMapObjectSourceBuilder_releasePtr);

  GeometryMapObjectSourceBuilder._raw(this._self);
  factory GeometryMapObjectSourceBuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GeometryMapObjectSourceBuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory GeometryMapObjectSourceBuilder(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CGeometryMapObjectSourceBuilder res = _CGeometryMapObjectSourceBuilder_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return GeometryMapObjectSourceBuilder._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeometryMapObjectSourceBuilder &&
    other.runtimeType == runtimeType &&
    _CGeometryMapObjectSourceBuilder_cg_objectIdentifier(this._self) == _CGeometryMapObjectSourceBuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGeometryMapObjectSourceBuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: GeometryMapObjectSourceBuilder: Methods

  /**
   Установка свойства объектов карты, общего для всего источника (см. ISource).
  
   - Parameter name: Имя свойства.
   - Parameter value: Значение свойства.
  */
  GeometryMapObjectSourceBuilder setSourceAttribute(
    String name,
    AttributeValue value
  )  {
    var _a1 = name._copyFromDartTo_CString();
    var _a2 = value._copyFromDartTo_CAttributeValue();
    _CGeometryMapObjectSourceBuilder res = _CGeometryMapObjectSourceBuilder_setSourceAttribute_CString_CAttributeValue(_CGeometryMapObjectSourceBuilderMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Установка свойств объектов карты, общих для всего источника.
  
   - Parameter values: набор пар "имя":"значение" свойств
  */
  GeometryMapObjectSourceBuilder setSourceAttributes(
    core.Map<String, AttributeValue> values
  )  {
    var _a1 = values._copyFromDartTo_CDictionary_CString_CAttributeValue();
    _CGeometryMapObjectSourceBuilder res = _CGeometryMapObjectSourceBuilder_setSourceAttributes_CDictionary_CString_CAttributeValue(_CGeometryMapObjectSourceBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Добавление геометрического объекта карты в источник. */
  GeometryMapObjectSourceBuilder addObject(
    GeometryMapObject item
  )  {
    var _a1 = item._copyFromDartTo_CGeometryMapObject();
    _CGeometryMapObjectSourceBuilder res = _CGeometryMapObjectSourceBuilder_addObject_CGeometryMapObject(_CGeometryMapObjectSourceBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Добавление нескольких геометрических объектов карты в источник. */
  GeometryMapObjectSourceBuilder addObjects(
    List<GeometryMapObject> objects
  )  {
    var _a1 = objects._copyFromDartTo_CArray_CGeometryMapObject();
    _CGeometryMapObjectSourceBuilder res = _CGeometryMapObjectSourceBuilder_addObjects_CArray_CGeometryMapObject(_CGeometryMapObjectSourceBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создание источника геометрических объектов.
  
   - Note: после вызова этой функции использовать GeometryMapObjectSourceBuilder для создания источника данных или
   для задания параметров источника данных нельзя
  */
  GeometryMapObjectSource createSource()  {
    _CGeometryMapObjectSource res = _CGeometryMapObjectSourceBuilder_createSource(_CGeometryMapObjectSourceBuilderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - GeometryMapObjectSourceBuilder <-> CGeometryMapObjectSourceBuilder

final class _CGeometryMapObjectSourceBuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGeometryMapObjectSourceBuilderBasicFunctions on _CGeometryMapObjectSourceBuilder {
  void _releaseIntermediate() {
    _CGeometryMapObjectSourceBuilder_release(_impl);
  }

  _CGeometryMapObjectSourceBuilder _retain() {
    return _CGeometryMapObjectSourceBuilder_retain(_impl);
  }
}

extension _CGeometryMapObjectSourceBuilderToDart on _CGeometryMapObjectSourceBuilder {
  GeometryMapObjectSourceBuilder _toDart() {
    return GeometryMapObjectSourceBuilder._create(_retain()._impl);
  }
}


extension _DartToCGeometryMapObjectSourceBuilder on GeometryMapObjectSourceBuilder {
  _CGeometryMapObjectSourceBuilder _copyFromDartTo_CGeometryMapObjectSourceBuilder() {
    return (_CGeometryMapObjectSourceBuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - IndoorBuilding

/** Здание с этажными планами. */
class IndoorBuilding implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Идентификатор здания с этажными планами. */
  DgisObjectId get id {
    _CDgisObjectId res = _CIndoorBuilding_id(_CIndoorBuildingMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Индекс этажа по умолчанию. */
  int get defaultLevelIndex {
    int res = _CIndoorBuilding_defaultLevelIndex(_CIndoorBuildingMakeDefault().._impl=_self);
    return res;
  }
  /** Информация обо всех этажах. */
  List<LevelInfo> get levels {
    _CArray_CLevelInfo res = _CIndoorBuilding_levels(_CIndoorBuildingMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Порядковый индекс активного этажа в levels. */
  StatefulChannel<int> get activeLevelIndexChannel {
    _CStatefulChannel_uint64_t res = _CIndoorBuilding_activeLevelIndexChannel(_CIndoorBuildingMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Порядковый индекс активного этажа в levels. */
  int get activeLevelIndex {
    int res = _CIndoorBuilding_activeLevelIndex(_CIndoorBuildingMakeDefault().._impl=_self);
    return res;
  }
  set activeLevelIndex(int levelIndex) {
    void res = _CIndoorBuilding_setActiveLevelIndex_uint64_t(_CIndoorBuildingMakeDefault().._impl=_self, levelIndex);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CIndoorBuilding_releasePtr);

  IndoorBuilding._raw(this._self);
  factory IndoorBuilding._create(ffi.Pointer<ffi.Void> self) {
    final classObject = IndoorBuilding._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IndoorBuilding &&
    other.runtimeType == runtimeType &&
    _CIndoorBuilding_cg_objectIdentifier(this._self) == _CIndoorBuilding_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CIndoorBuilding_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - IndoorBuilding <-> CIndoorBuilding

final class _CIndoorBuilding extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CIndoorBuildingBasicFunctions on _CIndoorBuilding {
  void _releaseIntermediate() {
    _CIndoorBuilding_release(_impl);
  }

  _CIndoorBuilding _retain() {
    return _CIndoorBuilding_retain(_impl);
  }
}

extension _CIndoorBuildingToDart on _CIndoorBuilding {
  IndoorBuilding _toDart() {
    return IndoorBuilding._create(_retain()._impl);
  }
}


extension _DartToCIndoorBuilding on IndoorBuilding {
  _CIndoorBuilding _copyFromDartTo_CIndoorBuilding() {
    return (_CIndoorBuildingMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<int> <-> _CStatefulChannel_uint64_t

class _CStatefulChannel_uint64_tImpl extends StatefulChannel<int> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<int>>{};

  final _CStatefulChannel_uint64_t _channel;

  _CStatefulChannel_uint64_tImpl(this._channel);

  @override
  int get value {
    return this._channel._getter();
  }

  static void valueFunction(int cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue);
    }
    
  }

  @override
  StreamSubscription<int> listen(void onData(int event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Uint64, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<int>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_uint64_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_uint64_tBasicFunctions on _CStatefulChannel_uint64_t {
  void _releaseIntermediate() {
    _CStatefulChannel_uint64_t_release(this);
  }

  _CStatefulChannel_uint64_t _retain() {
    return _CStatefulChannel_uint64_t_retain(this);
  }

  int _getter() {
    final cValue = _CStatefulChannel_uint64_tGetCurrentValue(this);
    final res = cValue;
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(ffi.Uint64, ffi.Int64)> callback) {
    return _CStatefulChannel_uint64_tConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_uint64_tToDart on _CStatefulChannel_uint64_t {
  StatefulChannel<int> _toDart() {
    return _CStatefulChannel_uint64_tImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_uint64_t on StatefulChannel<int> {
  _CStatefulChannel_uint64_t _copyFromDartTo_CStatefulChannel_uint64_t() {
    return _CStatefulChannel_uint64_tMakeDefault();
  }
}
	
// MARK: - IndoorManagerState

/** Состояние отображения этажных планов. */
enum IndoorManagerState {
  /** Этажи не отображаются. */
  disabled(0),
  /** Этажи отображаются. */
  enabled(1),
  ;

  const IndoorManagerState(this.rawValue);
  final int rawValue;

  static IndoorManagerState getByValue(int value) {
    return IndoorManagerState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CIndoorManagerState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CIndoorManagerStateBasicFunctions on _CIndoorManagerState {
  void _releaseIntermediate() {
  }
}

extension _CIndoorManagerStateToDart on _CIndoorManagerState {
  IndoorManagerState _toDart() {
    return IndoorManagerState.getByValue(this.rawValue);
  }
}

extension _DartTo_CIndoorManagerState on IndoorManagerState {
  _CIndoorManagerState _copyFromDartTo_CIndoorManagerState() {
    return _CIndoorManagerStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - IndoorManager

/** Класс для получения текущего здания с этажными планами. */
class IndoorManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Получение текущего здания с этажными планами.
  
   - Returns: Текущее здание с этажными планами или нулевой указатель, если текущего здания нет
  */
  StatefulChannel<IndoorBuilding?> get focusedBuildingChannel {
    _CStatefulChannel_COptional_CIndoorBuilding res = _CIndoorManager_focusedBuildingChannel(_CIndoorManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение текущего здания с этажными планами.
  
   - Returns: Текущее здание с этажными планами или нулевой указатель, если текущего здания нет
  */
  IndoorBuilding? get focusedBuilding {
    _COptional_CIndoorBuilding res = _CIndoorManager_focusedBuilding(_CIndoorManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CIndoorManager_releasePtr);

  IndoorManager._raw(this._self);
  factory IndoorManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = IndoorManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IndoorManager &&
    other.runtimeType == runtimeType &&
    _CIndoorManager_cg_objectIdentifier(this._self) == _CIndoorManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CIndoorManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: IndoorManager: Methods

  /** Переключение включенности/выключенности менеджера этажных планов */
  void setIndoorState(
    IndoorManagerState newState
  )  {
    var _a1 = newState._copyFromDartTo_CIndoorManagerState();
    void res = _CIndoorManager_setIndoorState_CIndoorManagerState(_CIndoorManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - IndoorManager <-> CIndoorManager

final class _CIndoorManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CIndoorManagerBasicFunctions on _CIndoorManager {
  void _releaseIntermediate() {
    _CIndoorManager_release(_impl);
  }

  _CIndoorManager _retain() {
    return _CIndoorManager_retain(_impl);
  }
}

extension _CIndoorManagerToDart on _CIndoorManager {
  IndoorManager _toDart() {
    return IndoorManager._create(_retain()._impl);
  }
}


extension _DartToCIndoorManager on IndoorManager {
  _CIndoorManager _copyFromDartTo_CIndoorManager() {
    return (_CIndoorManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<IndoorBuilding?> <-> _CStatefulChannel_COptional_CIndoorBuilding

class _CStatefulChannel_COptional_CIndoorBuildingImpl extends StatefulChannel<IndoorBuilding?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<IndoorBuilding?>>{};

  final _CStatefulChannel_COptional_CIndoorBuilding _channel;

  _CStatefulChannel_COptional_CIndoorBuildingImpl(this._channel);

  @override
  IndoorBuilding? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CIndoorBuilding cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<IndoorBuilding?> listen(void onData(IndoorBuilding? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CIndoorBuilding, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<IndoorBuilding?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CIndoorBuilding extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CIndoorBuildingBasicFunctions on _CStatefulChannel_COptional_CIndoorBuilding {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CIndoorBuilding_release(this);
  }

  _CStatefulChannel_COptional_CIndoorBuilding _retain() {
    return _CStatefulChannel_COptional_CIndoorBuilding_retain(this);
  }

  IndoorBuilding? _getter() {
    final cValue = _CStatefulChannel_COptional_CIndoorBuildingGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CIndoorBuilding, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CIndoorBuildingConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CIndoorBuildingToDart on _CStatefulChannel_COptional_CIndoorBuilding {
  StatefulChannel<IndoorBuilding?> _toDart() {
    return _CStatefulChannel_COptional_CIndoorBuildingImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CIndoorBuilding on StatefulChannel<IndoorBuilding?> {
  _CStatefulChannel_COptional_CIndoorBuilding _copyFromDartTo_CStatefulChannel_COptional_CIndoorBuilding() {
    return _CStatefulChannel_COptional_CIndoorBuildingMakeDefault();
  }
}
	
// MARK: - IndoorBuilding? <-> _COptional_CIndoorBuilding

final class _COptional_CIndoorBuilding extends ffi.Struct {
  
  external _CIndoorBuilding value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CIndoorBuildingBasicFunctions on _COptional_CIndoorBuilding {
  void _releaseIntermediate() {
    _COptional_CIndoorBuilding_release(this);
  }
}

extension _COptional_CIndoorBuildingToDart on _COptional_CIndoorBuilding {
  IndoorBuilding? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CIndoorBuilding on IndoorBuilding? {
  _COptional_CIndoorBuilding _copyFromDartTo_COptional_CIndoorBuilding() {
    final cOptional = _COptional_CIndoorBuildingMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CIndoorBuilding();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - IndoorControlModel

/** Модель элемента управления этажами. */
class IndoorControlModel implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Индекс активного этажа. */
  StatefulChannel<int?> get activeLevelIndexChannel {
    _CStatefulChannel_COptional_uint64_t res = _CIndoorControlModel_activeLevelIndexChannel(_CIndoorControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Индекс активного этажа. */
  int? get activeLevelIndex {
    _COptional_uint64_t res = _CIndoorControlModel_activeLevelIndex(_CIndoorControlModelMakeDefault().._impl=_self);
    return res._toDart();
  }
  set activeLevelIndex(int? activeIndex) {
    var _a1 = activeIndex._copyFromDartTo_COptional_uint64_t();
    void res = _CIndoorControlModel_setActiveLevelIndex_COptional_uint64_t(_CIndoorControlModelMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Этажи, на которых отображаются пометки. */
  Set<LevelId> get markedLevels {
    _CSet_CLevelId res = _CIndoorControlModel_markedLevels(_CIndoorControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set markedLevels(Set<LevelId> markedLevels) {
    var _a1 = markedLevels._copyFromDartTo_CSet_CLevelId();
    void res = _CIndoorControlModel_setMarkedLevels_CSet_CLevelId(_CIndoorControlModelMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /**
   Названия этажей.
   Пусто, если на карте не отображается здание с этажными планами, или у здания всего один этаж.
  */
  StatefulChannel<List<String>> get levelNamesChannel {
    _CStatefulChannel_CArray_CString res = _CIndoorControlModel_levelNamesChannel(_CIndoorControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Названия этажей.
   Пусто, если на карте не отображается здание с этажными планами, или у здания всего один этаж.
  */
  List<String> get levelNames {
    _CArray_CString res = _CIndoorControlModel_levelNames(_CIndoorControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CIndoorControlModel_releasePtr);

  IndoorControlModel._raw(this._self);
  factory IndoorControlModel._create(ffi.Pointer<ffi.Void> self) {
    final classObject = IndoorControlModel._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory IndoorControlModel(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CIndoorControlModel res = _CIndoorControlModel_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return IndoorControlModel._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IndoorControlModel &&
    other.runtimeType == runtimeType &&
    _CIndoorControlModel_cg_objectIdentifier(this._self) == _CIndoorControlModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CIndoorControlModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: IndoorControlModel: Methods

  /** Нужно ли отображать пометку у этажа с указанным индексом. */
  bool isLevelMarked(
    int index
  )  {
    bool res = _CIndoorControlModel_isLevelMarked_uint64_t(_CIndoorControlModelMakeDefault().._impl=_self, index);
    return res;
  }

}

// MARK: - IndoorControlModel <-> CIndoorControlModel

final class _CIndoorControlModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CIndoorControlModelBasicFunctions on _CIndoorControlModel {
  void _releaseIntermediate() {
    _CIndoorControlModel_release(_impl);
  }

  _CIndoorControlModel _retain() {
    return _CIndoorControlModel_retain(_impl);
  }
}

extension _CIndoorControlModelToDart on _CIndoorControlModel {
  IndoorControlModel _toDart() {
    return IndoorControlModel._create(_retain()._impl);
  }
}


extension _DartToCIndoorControlModel on IndoorControlModel {
  _CIndoorControlModel _copyFromDartTo_CIndoorControlModel() {
    return (_CIndoorControlModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<int?> <-> _CStatefulChannel_COptional_uint64_t

class _CStatefulChannel_COptional_uint64_tImpl extends StatefulChannel<int?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<int?>>{};

  final _CStatefulChannel_COptional_uint64_t _channel;

  _CStatefulChannel_COptional_uint64_tImpl(this._channel);

  @override
  int? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_uint64_t cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<int?> listen(void onData(int? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_uint64_t, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<int?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_uint64_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_uint64_tBasicFunctions on _CStatefulChannel_COptional_uint64_t {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_uint64_t_release(this);
  }

  _CStatefulChannel_COptional_uint64_t _retain() {
    return _CStatefulChannel_COptional_uint64_t_retain(this);
  }

  int? _getter() {
    final cValue = _CStatefulChannel_COptional_uint64_tGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_uint64_t, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_uint64_tConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_uint64_tToDart on _CStatefulChannel_COptional_uint64_t {
  StatefulChannel<int?> _toDart() {
    return _CStatefulChannel_COptional_uint64_tImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_uint64_t on StatefulChannel<int?> {
  _CStatefulChannel_COptional_uint64_t _copyFromDartTo_CStatefulChannel_COptional_uint64_t() {
    return _CStatefulChannel_COptional_uint64_tMakeDefault();
  }
}
	
// MARK: - Set<LevelId> <-> _CSet_CLevelId

final class _CSet_CLevelId extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSet_CLevelIdToDart on _CSet_CLevelId {
  Set<LevelId> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CSet_CLevelId on Set<LevelId> {
  _CSet_CLevelId _copyFromDartTo_CSet_CLevelId() {
    final cSet = _CSet_CLevelIdmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CLevelId();
        _CSet_CLevelIdaddElement(cSet, cItem);
        
    });
    return cSet;
  }
}

extension _CSet_CLevelIdBasicFunctions on _CSet_CLevelId {
  void _releaseIntermediate() {
    _CSet_CLevelId_release(this);
  }

 static final _setToFill = <LevelId>{};

  static void _iterate(_CLevelId item) {
    _setToFill.add(item._toDart());
  }

  Set<LevelId> _fillFromC() {
    _forEach_CSet_CLevelId(this, ffi.Pointer.fromFunction<ffi.Void Function(_CLevelId)>(_iterate));
    final result = Set<LevelId>.from(_setToFill);
    _setToFill.clear();
    return result;
  }
}
	
// MARK: - StatefulChannel<List<String>> <-> _CStatefulChannel_CArray_CString

class _CStatefulChannel_CArray_CStringImpl extends StatefulChannel<List<String>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<String>>>{};

  final _CStatefulChannel_CArray_CString _channel;

  _CStatefulChannel_CArray_CStringImpl(this._channel);

  @override
  List<String> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CArray_CString cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<String>> listen(void onData(List<String> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CString, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<String>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CArray_CString extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CArray_CStringBasicFunctions on _CStatefulChannel_CArray_CString {
  void _releaseIntermediate() {
    _CStatefulChannel_CArray_CString_release(this);
  }

  _CStatefulChannel_CArray_CString _retain() {
    return _CStatefulChannel_CArray_CString_retain(this);
  }

  List<String> _getter() {
    final cValue = _CStatefulChannel_CArray_CStringGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CString, ffi.Int64)> callback) {
    return _CStatefulChannel_CArray_CStringConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CArray_CStringToDart on _CStatefulChannel_CArray_CString {
  StatefulChannel<List<String>> _toDart() {
    return _CStatefulChannel_CArray_CStringImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CArray_CString on StatefulChannel<List<String>> {
  _CStatefulChannel_CArray_CString _copyFromDartTo_CStatefulChannel_CArray_CString() {
    return _CStatefulChannel_CArray_CStringMakeDefault();
  }
}
	
// MARK: - Map

/** Карта. */
class Map implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Идентификатор экземпляра карты, уникальный в рамках процесса. */
  MapId get id {
    _CMapId res = _CMap_id(_CMapMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение камеры. */
  Camera get camera {
    _CCamera res = _CMap_camera(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение менеджера этажных планов. */
  IndoorManager get indoorManager {
    _CIndoorManager res = _CMap_indoorManager(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Нотификация о состоянии загружаемых в карту данных.
  
   - Note: При слежении за позицией камеры состояние карты всегда будет MapDataLoadingState::Loading.
  */
  StatefulChannel<MapDataLoadingState> get dataLoadingStateChannel {
    _CStatefulChannel_CMapDataLoadingState res = _CMap_dataLoadingStateChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Нотификация о состоянии загружаемых в карту данных.
  
   - Note: При слежении за позицией камеры состояние карты всегда будет MapDataLoadingState::Loading.
  */
  MapDataLoadingState get dataLoadingState {
    _CMapDataLoadingState res = _CMap_dataLoadingState(_CMapMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение текущих стилей карты. */
  StatefulChannel<Style> get styleChannel {
    _CStatefulChannel_CStyle res = _CMap_styleChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение текущих стилей карты. */
  Style get style {
    _CStyle res = _CMap_style(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set style(Style style) {
    var _a1 = style._copyFromDartTo_CStyle();
    void res = _CMap_setStyle_CStyle(_CMapMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /**
   Множитель размера иконок и шрифтов, полученный из приложения.
  
   Размер иконок и шрифтов задаётся в логических пикселях (см. LogicalPixel)
   и умножается на множитель размера шрифтов и иконок.
  */
  StatefulChannel<double> get fontIconSizeMultiplierChannel {
    _CStatefulChannel_float res = _CMap_fontIconSizeMultiplierChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Множитель размера иконок и шрифтов, полученный из приложения.
  
   Размер иконок и шрифтов задаётся в логических пикселях (см. LogicalPixel)
   и умножается на множитель размера шрифтов и иконок.
  */
  double get fontIconSizeMultiplier {
    double res = _CMap_fontIconSizeMultiplier(_CMapMakeDefault().._impl=_self);
    return res;
  }
  set fontIconSizeMultiplier(double multiplier) {
    _CResult_CEmpty res = _CMap_setFontIconSizeMultiplier_float(_CMapMakeDefault().._impl=_self, multiplier);
    res._toDart();
    res._releaseIntermediate();
  }
  /**
   Получение источников данных карты.
  
   - Note: Происходит асинхронно. Метод может вызываться из любого потока, потокобезопасен.
  */
  List<Source> get sources {
    _CArray_CSource res = _CMap_getSources(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  StatefulChannel<MapVisibilityState> get mapVisibilityStateChannel {
    _CStatefulChannel_CMapVisibilityState res = _CMap_mapVisibilityStateChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  MapVisibilityState get mapVisibilityState {
    _CMapVisibilityState res = _CMap_mapVisibilityState(_CMapMakeDefault().._impl=_self);
    return res._toDart();
  }
  set mapVisibilityState(MapVisibilityState state) {
    var _a1 = state._copyFromDartTo_CMapVisibilityState();
    void res = _CMap_setMapVisibilityState_CMapVisibilityState(_CMapMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Сигнал, сообщающий о необходимости отрисовки очередного кадра.
  
   - Note: Может быть вызван из метода paint(), например, если активна какая-то анимация или производится перелёт.
  */
  Channel<bool> get needRedraw {
    _CChannel_bool res = _CMap_needRedraw(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение атрибутов.
  
   - Note: должны быть указаны свойства:
   "theme"="day|night"
   "navigatorOn"="true|false"
   - Todo: стилевые свойства для пробок
  */
  Attributes get attributes {
    _CAttributes res = _CMap_attributes(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Интерактивность карты.
   Под интерактивностью понимается наличие у пользователя возможности взаимодействия с картой.
   При отключении интерактивности карта перестанет реагировать на события ввода, пришедшие от пользователя.
   Также перестанут работать контролы для работы с картой (приближения и перехода к текущему положению).
   При этом остаётся возможность работать с картой через set_position/move.
   При переходе в неинтерактивное состояние незавершённые жесты будут сброшены.
   По умолчанию карта интерактивна (interactive == true).
  
   - Note: функция может быть вызвана из любого потока.
  */
  StatefulChannel<bool> get interactiveChannel {
    _CStatefulChannel_bool res = _CMap_interactiveChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Интерактивность карты.
   Под интерактивностью понимается наличие у пользователя возможности взаимодействия с картой.
   При отключении интерактивности карта перестанет реагировать на события ввода, пришедшие от пользователя.
   Также перестанут работать контролы для работы с картой (приближения и перехода к текущему положению).
   При этом остаётся возможность работать с картой через set_position/move.
   При переходе в неинтерактивное состояние незавершённые жесты будут сброшены.
   По умолчанию карта интерактивна (interactive == true).
  
   - Note: функция может быть вызвана из любого потока.
  */
  bool get interactive {
    bool res = _CMap_interactive(_CMapMakeDefault().._impl=_self);
    return res;
  }
  set interactive(bool interactive) {
    void res = _CMap_setInteractive_bool(_CMapMakeDefault().._impl=_self, interactive);
    return res;
  }
  /**
   Необходимость скрытия копирайта на карте.
   По умолчанию копирайт отображается (hide_copyright == false).
  
   - Note: функция может быть вызвана из любого потока.
  */
  StatefulChannel<bool> get hideCopyrightChannel {
    _CStatefulChannel_bool res = _CMap_hideCopyrightChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Необходимость скрытия копирайта на карте.
   По умолчанию копирайт отображается (hide_copyright == false).
  
   - Note: функция может быть вызвана из любого потока.
  */
  bool get hideCopyright {
    bool res = _CMap_hideCopyright(_CMapMakeDefault().._impl=_self);
    return res;
  }
  /**
   Тип продукта в копирайте, который настраивается в ключе.
   По умолчанию отображается 2GIS (product_type == dgis).
  
   - Note: функция может быть вызвана из любого потока.
  */
  StatefulChannel<ProductType> get productTypeChannel {
    _CStatefulChannel_CProductType res = _CMap_productTypeChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Тип продукта в копирайте, который настраивается в ключе.
   По умолчанию отображается 2GIS (product_type == dgis).
  
   - Note: функция может быть вызвана из любого потока.
  */
  ProductType get productType {
    _CProductType res = _CMap_productType(_CMapMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение рекомендуемого режима графики для данного устройства. */
  StatefulChannel<GraphicsPreset?> get graphicsPresetHintChannel {
    _CStatefulChannel_COptional_CGraphicsPreset res = _CMap_graphicsPresetHintChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение рекомендуемого режима графики для данного устройства. */
  GraphicsPreset? get graphicsPresetHint {
    _COptional_CGraphicsPreset res = _CMap_graphicsPresetHint(_CMapMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Получение режима графики.
   В случае null используется рекомендуемый режим.
   Если определить рекомендуемый режим не удалось, то используется Normal.
  */
  StatefulChannel<GraphicsPreset?> get graphicsPresetChannel {
    _CStatefulChannel_COptional_CGraphicsPreset res = _CMap_graphicsPresetChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение режима графики.
   В случае null используется рекомендуемый режим.
   Если определить рекомендуемый режим не удалось, то используется Normal.
  */
  GraphicsPreset? get graphicsPreset {
    _COptional_CGraphicsPreset res = _CMap_graphicsPreset(_CMapMakeDefault().._impl=_self);
    return res._toDart();
  }
  set graphicsPreset(GraphicsPreset? graphicsPreset) {
    var _a1 = graphicsPreset._copyFromDartTo_COptional_CGraphicsPreset();
    void res = _CMap_setGraphicsPreset_COptional_CGraphicsPreset(_CMapMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMap_releasePtr);

  Map._raw(this._self);
  factory Map._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Map._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Map &&
    other.runtimeType == runtimeType &&
    _CMap_cg_objectIdentifier(this._self) == _CMap_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMap_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Map: Methods

  /** Сбросить множитель размера для иконок. */
  void resetFontIconSizeMultiplier()  {
    void res = _CMap_resetFontIconSizeMultiplier(_CMapMakeDefault().._impl=_self);
    return res;
  }

  /**
   Добавление источника данных на карту.
  
   - Note: Происходит асинхронно. Метод может вызываться из любого потока, потокобезопасен.
  */
  void addSource(
    Source source
  )  {
    var _a1 = source._copyFromDartTo_CSource();
    void res = _CMap_addSource_CSource(_CMapMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Удаление источника данных из карты.
  
   - Note: Происходит асинхронно. Метод может вызываться из любого потока, потокобезопасен.
  */
  void removeSource(
    Source source
  )  {
    var _a1 = source._copyFromDartTo_CSource();
    void res = _CMap_removeSource_CSource(_CMapMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Получение отображаемых объектов карты, проецирующихся на окружность на экране.
  
   - Parameter centerPoint: центр окружности.
   - Parameter radius: радиус окружности.
   - Note: Список объектов формируется в порядке отрисовки от поздних к ранним.
  */
  CancelableOperation<List<RenderedObjectInfo>> getRenderedObjects(
    ScreenPoint centerPoint,
    [ScreenDistance radius = const ScreenDistance(1)
    ])  {
    var _a1 = centerPoint._copyFromDartTo_CScreenPoint();
    var _a2 = radius._copyFromDartTo_CScreenDistance();
    _CFuture_CArray_CRenderedObjectInfo res = _CMap_getRenderedObjects_CScreenPoint_CScreenDistance(_CMapMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получение атрибутов подслоя.
  
   - Parameter sublayerName: Название подслоя.
   - Note: Полученные атрибуты содержат только добавленные туда ранее (явно).
  */
  Attributes sublayerAttributes(
    String sublayerName
  )  {
    var _a1 = sublayerName._copyFromDartTo_CString();
    _CAttributes res = _CMap_sublayerAttributes_CString(_CMapMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

@internal
extension MapInternalMethods on Map {
  /** Установка множителя размера для иконок шрифтов, получаемый из системы. */
  @internal
  void setSystemFontIconSizeMultiplier(
    double multiplier
  )  {
    _CResult_CEmpty res = _CMap_setSystemFontIconSizeMultiplier_float(_CMapMakeDefault().._impl=_self, multiplier);
    res._toDart();
    res._releaseIntermediate();
  }

  /** Обработка события управления картой. */
  @internal
  void processEvent(
    Event event
  )  {
    var _a1 = event._copyFromDartTo_CEvent();
    void res = _CMap_processEvent_CEvent(_CMapMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Получение изображения карты.
   Возможно только после отрисовки карты.
  
   - Note: функция должна вызываться из render-очереди.
  */
  @internal
  ImageData takeSnapshot(
    Alignment copyrightAlign
  )  {
    var _a1 = copyrightAlign._copyFromDartTo_CAlignment();
    _CResult_CImageData res = _CMap_takeSnapshot_CAlignment(_CMapMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  @internal
  CancelableOperation<RenderedObjectInfo?> getMapObject(
    ScreenPoint centerPoint,
    ScreenDistance radius
  )  {
    var _a1 = centerPoint._copyFromDartTo_CScreenPoint();
    var _a2 = radius._copyFromDartTo_CScreenDistance();
    _CFuture_COptional_CRenderedObjectInfo res = _CMap_getMapObject_CScreenPoint_CScreenDistance(_CMapMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - Map <-> CMap

final class _CMap extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapBasicFunctions on _CMap {
  void _releaseIntermediate() {
    _CMap_release(_impl);
  }

  _CMap _retain() {
    return _CMap_retain(_impl);
  }
}

extension _CMapToDart on _CMap {
  Map _toDart() {
    return Map._create(_retain()._impl);
  }
}


extension _DartToCMap on Map {
  _CMap _copyFromDartTo_CMap() {
    return (_CMapMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Camera

/** Камера для запуска перемещения карты и настроек слежения. */
class Camera extends BaseCamera implements ffi.Finalizable {
  /** Получение актуального состояния камеры. */
  StatefulChannel<CameraState> get stateChannel {
    _CStatefulChannel_CCameraState res = _CCamera_stateChannel(_CCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение актуального состояния камеры. */
  CameraState get state {
    _CCameraState res = _CCamera_state(_CCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Режим слежения камеры. */
  StatefulChannel<CameraBehaviourChange> get behaviourChannel {
    _CStatefulChannel_CCameraBehaviourChange res = _CCamera_behaviourChannel(_CCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Режим слежения камеры. */
  CameraBehaviourChange get behaviour {
    _CCameraBehaviourChange res = _CCamera_behaviour(_CCameraMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CCamera_releasePtr);

  Camera._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Camera._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Camera._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Camera &&
    other.runtimeType == runtimeType &&
    _CCamera_cg_objectIdentifier(this._self) == _CCamera_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCamera_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Camera: Methods

  /**
   Запуск анимированного перемещения карты с использованием встроенного контроллера перемещений карты.
  
   - Note: Сбрасывает слежение за позицией, уровнем масштабирования, наклоном и направлением и прерывает обработку жестов.
   - Parameter position: Конечная позиция камеры.
   - Parameter time: Время, выделенное на перемещение карты.
   - Parameter animationType: Тип анимации при перемещении камеры.
  */
  CancelableOperation<CameraAnimatedMoveResult> moveToCameraPosition(
    CameraPosition position,
    [Duration time = const Duration(milliseconds: 300),
    CameraAnimationType animationType = CameraAnimationType.default_
    ])  {
    var _a1 = position._copyFromDartTo_CCameraPosition();
    var _a2 = time._copyFromDartTo_CTimeInterval();
    var _a3 = animationType._copyFromDartTo_CCameraAnimationType();
    _CFuture_CCameraAnimatedMoveResult res = _CCamera_moveToCameraPosition_CCameraPosition_CTimeInterval_CCameraAnimationType(_CCameraMakeDefault().._impl=_self, _a1, _a2, _a3);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Запуск анимированного перемещения карты с использованием встроенного контроллера перемещений карты.
  
   - Note: Сбрасывает слежение за позицией, уровнем масштабирования и направлением и прерывает обработку жестов.
   - Note: Если tilt задан, то сбрасывается слежение за наклоном.
   - Note: Если tilt не задан и слежения за наклоном нет, то используется текущее значение наклона.
   - Parameter point: точка конечной позиции камеры
   - Parameter zoom: уровень масштабирования в конечной позиции камеры
   - Parameter tilt: наклон в конечной позиции камеры или пустое значение, если нужно
   в зависимости от активного режима слежения использовать значение из follow controller'а или текущее значение
   - Parameter bearing: поворот в конечной позиции камеры
   - Parameter time: время, выделенное на перемещение карты
   - Parameter animationType: тип анимации при перемещении камеры
  */
  CancelableOperation<CameraAnimatedMoveResult> move(
    GeoPoint point,
    Zoom zoom,
    Tilt? tilt,
    Bearing bearing,
    [Duration time = const Duration(milliseconds: 300),
    CameraAnimationType animationType = CameraAnimationType.default_
    ])  {
    var _a1 = point._copyFromDartTo_CGeoPoint();
    var _a2 = zoom._copyFromDartTo_CZoom();
    var _a3 = tilt._copyFromDartTo_COptional_CTilt();
    var _a4 = bearing._copyFromDartTo_CBearing();
    var _a5 = time._copyFromDartTo_CTimeInterval();
    var _a6 = animationType._copyFromDartTo_CCameraAnimationType();
    _CFuture_CCameraAnimatedMoveResult res = _CCamera_move_CGeoPoint_CZoom_COptional_CTilt_CBearing_CTimeInterval_CCameraAnimationType(_CCameraMakeDefault().._impl=_self, _a1, _a2, _a3, _a4, _a5, _a6);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Установка позиции камеры в соответствие с текущим временем и прекращение анимированного перемещения.
  
   - Note: Вызов прерывает перелёт и обработку жестов,
   а также сбрасывает слежение за позицией, уровнем масштабирования и направлением.
  */
  void processMovementAndStop()  {
    void res = _CCamera_processMovementAndStop(_CCameraMakeDefault().._impl=_self);
    return res;
  }

  /**
   Смена режима слежения камеры.
   Если новый режим более ограниченный, чем текущий, вызов прервёт перелёт и обработку жестов.
  */
  void setBehaviour(
    CameraBehaviour behaviour
  )  {
    var _a1 = behaviour._copyFromDartTo_CCameraBehaviour();
    void res = _CCamera_setBehaviour_CCameraBehaviour(_CCameraMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Добавление контроллера слежения.
  
   Их может быть несколько разных, например контроллер слежения за масштабом, за углом наклона карты,
   за геолокацией и т.д.
  */
  void addFollowController(
    FollowController followController
  )  {
    var _a1 = followController._copyFromDartTo_CFollowController();
    void res = _CCamera_addFollowController_CFollowController(_CCameraMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаление контроллера слежения. */
  void removeFollowController(
    FollowController followController
  )  {
    var _a1 = followController._copyFromDartTo_CFollowController();
    void res = _CCamera_removeFollowController_CFollowController(_CCameraMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаление контроллера слежения, реализованного на платформе. */
  void removeCustomFollowController()  {
    void res = _CCamera_removeCustomFollowController(_CCameraMakeDefault().._impl=_self);
    return res;
  }

  CancelableOperation<CameraAnimatedMoveResult> moveWithController(
    CameraMoveController moveController
  )  {
    var _a1 = moveController._copyFromDartTo_CCameraMoveController();
    _CFuture_CCameraAnimatedMoveResult res = _CCamera_moveWithController_CCameraMoveController(_CCameraMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  void setCustomFollowController(
    CustomFollowController followController
  )  {
    var _a1 = followController._copyFromDartTo_CCustomFollowController();
    void res = _CCamera_setCustomFollowController_CCustomFollowController(_CCameraMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - Camera <-> CCamera

final class _CCamera extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCameraBasicFunctions on _CCamera {
  void _releaseIntermediate() {
    _CCamera_release(_impl);
  }

  _CCamera _retain() {
    return _CCamera_retain(_impl);
  }
}

extension _CCameraToDart on _CCamera {
  Camera _toDart() {
    return Camera._create(_retain()._impl);
  }
}


extension _DartToCCamera on Camera {
  _CCamera _copyFromDartTo_CCamera() {
    return (_CCameraMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<CameraAnimatedMoveResult> <-> _CFuture_CCameraAnimatedMoveResult

final class _CFuture_CCameraAnimatedMoveResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CCameraAnimatedMoveResult_Cancellable {
  final Completer<CameraAnimatedMoveResult> completer;
  final _CFuture_CCameraAnimatedMoveResult _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CCameraAnimatedMoveResult, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CCameraAnimatedMoveResult_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CCameraAnimatedMoveResultBasicFunctions on _CFuture_CCameraAnimatedMoveResult {
  void _releaseIntermediate() {
    _CFuture_CCameraAnimatedMoveResult_release(this);
  }

  _CFuture_CCameraAnimatedMoveResult _retain() {
    return _CFuture_CCameraAnimatedMoveResult_retain(this);
  }
}

extension _CFuture_CCameraAnimatedMoveResultToDart on _CFuture_CCameraAnimatedMoveResult {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CCameraAnimatedMoveResult_Cancellable>{};

  static void valueFunction(_CCameraAnimatedMoveResult cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<CameraAnimatedMoveResult> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<CameraAnimatedMoveResult>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraAnimatedMoveResult, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CCameraAnimatedMoveResultReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CCameraAnimatedMoveResult_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CCameraAnimatedMoveResult on CancelableOperation<CameraAnimatedMoveResult> {
  _CFuture_CCameraAnimatedMoveResult _copyFromDartTo_CFuture_CCameraAnimatedMoveResult() {
    return _CFuture_CCameraAnimatedMoveResultMakeDefault();
  }
}
	
// MARK: - StatefulChannel<CameraState> <-> _CStatefulChannel_CCameraState

class _CStatefulChannel_CCameraStateImpl extends StatefulChannel<CameraState> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraState>>{};

  final _CStatefulChannel_CCameraState _channel;

  _CStatefulChannel_CCameraStateImpl(this._channel);

  @override
  CameraState get value {
    return this._channel._getter();
  }

  static void valueFunction(_CCameraState cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraState> listen(void onData(CameraState event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraState, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraState>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CCameraState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CCameraStateBasicFunctions on _CStatefulChannel_CCameraState {
  void _releaseIntermediate() {
    _CStatefulChannel_CCameraState_release(this);
  }

  _CStatefulChannel_CCameraState _retain() {
    return _CStatefulChannel_CCameraState_retain(this);
  }

  CameraState _getter() {
    final cValue = _CStatefulChannel_CCameraStateGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CCameraState, ffi.Int64)> callback) {
    return _CStatefulChannel_CCameraStateConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CCameraStateToDart on _CStatefulChannel_CCameraState {
  StatefulChannel<CameraState> _toDart() {
    return _CStatefulChannel_CCameraStateImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CCameraState on StatefulChannel<CameraState> {
  _CStatefulChannel_CCameraState _copyFromDartTo_CStatefulChannel_CCameraState() {
    return _CStatefulChannel_CCameraStateMakeDefault();
  }
}
	
// MARK: - StatefulChannel<CameraBehaviourChange> <-> _CStatefulChannel_CCameraBehaviourChange

class _CStatefulChannel_CCameraBehaviourChangeImpl extends StatefulChannel<CameraBehaviourChange> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraBehaviourChange>>{};

  final _CStatefulChannel_CCameraBehaviourChange _channel;

  _CStatefulChannel_CCameraBehaviourChangeImpl(this._channel);

  @override
  CameraBehaviourChange get value {
    return this._channel._getter();
  }

  static void valueFunction(_CCameraBehaviourChange cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraBehaviourChange> listen(void onData(CameraBehaviourChange event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraBehaviourChange, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraBehaviourChange>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CCameraBehaviourChange extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CCameraBehaviourChangeBasicFunctions on _CStatefulChannel_CCameraBehaviourChange {
  void _releaseIntermediate() {
    _CStatefulChannel_CCameraBehaviourChange_release(this);
  }

  _CStatefulChannel_CCameraBehaviourChange _retain() {
    return _CStatefulChannel_CCameraBehaviourChange_retain(this);
  }

  CameraBehaviourChange _getter() {
    final cValue = _CStatefulChannel_CCameraBehaviourChangeGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CCameraBehaviourChange, ffi.Int64)> callback) {
    return _CStatefulChannel_CCameraBehaviourChangeConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CCameraBehaviourChangeToDart on _CStatefulChannel_CCameraBehaviourChange {
  StatefulChannel<CameraBehaviourChange> _toDart() {
    return _CStatefulChannel_CCameraBehaviourChangeImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CCameraBehaviourChange on StatefulChannel<CameraBehaviourChange> {
  _CStatefulChannel_CCameraBehaviourChange _copyFromDartTo_CStatefulChannel_CCameraBehaviourChange() {
    return _CStatefulChannel_CCameraBehaviourChangeMakeDefault();
  }
}
	
// MARK: - StatefulChannel<MapDataLoadingState> <-> _CStatefulChannel_CMapDataLoadingState

class _CStatefulChannel_CMapDataLoadingStateImpl extends StatefulChannel<MapDataLoadingState> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<MapDataLoadingState>>{};

  final _CStatefulChannel_CMapDataLoadingState _channel;

  _CStatefulChannel_CMapDataLoadingStateImpl(this._channel);

  @override
  MapDataLoadingState get value {
    return this._channel._getter();
  }

  static void valueFunction(_CMapDataLoadingState cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<MapDataLoadingState> listen(void onData(MapDataLoadingState event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CMapDataLoadingState, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<MapDataLoadingState>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CMapDataLoadingState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CMapDataLoadingStateBasicFunctions on _CStatefulChannel_CMapDataLoadingState {
  void _releaseIntermediate() {
    _CStatefulChannel_CMapDataLoadingState_release(this);
  }

  _CStatefulChannel_CMapDataLoadingState _retain() {
    return _CStatefulChannel_CMapDataLoadingState_retain(this);
  }

  MapDataLoadingState _getter() {
    final cValue = _CStatefulChannel_CMapDataLoadingStateGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CMapDataLoadingState, ffi.Int64)> callback) {
    return _CStatefulChannel_CMapDataLoadingStateConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CMapDataLoadingStateToDart on _CStatefulChannel_CMapDataLoadingState {
  StatefulChannel<MapDataLoadingState> _toDart() {
    return _CStatefulChannel_CMapDataLoadingStateImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CMapDataLoadingState on StatefulChannel<MapDataLoadingState> {
  _CStatefulChannel_CMapDataLoadingState _copyFromDartTo_CStatefulChannel_CMapDataLoadingState() {
    return _CStatefulChannel_CMapDataLoadingStateMakeDefault();
  }
}
	
// MARK: - StatefulChannel<Style> <-> _CStatefulChannel_CStyle

class _CStatefulChannel_CStyleImpl extends StatefulChannel<Style> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Style>>{};

  final _CStatefulChannel_CStyle _channel;

  _CStatefulChannel_CStyleImpl(this._channel);

  @override
  Style get value {
    return this._channel._getter();
  }

  static void valueFunction(_CStyle cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<Style> listen(void onData(Style event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CStyle, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Style>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CStyle extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CStyleBasicFunctions on _CStatefulChannel_CStyle {
  void _releaseIntermediate() {
    _CStatefulChannel_CStyle_release(this);
  }

  _CStatefulChannel_CStyle _retain() {
    return _CStatefulChannel_CStyle_retain(this);
  }

  Style _getter() {
    final cValue = _CStatefulChannel_CStyleGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CStyle, ffi.Int64)> callback) {
    return _CStatefulChannel_CStyleConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CStyleToDart on _CStatefulChannel_CStyle {
  StatefulChannel<Style> _toDart() {
    return _CStatefulChannel_CStyleImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CStyle on StatefulChannel<Style> {
  _CStatefulChannel_CStyle _copyFromDartTo_CStatefulChannel_CStyle() {
    return _CStatefulChannel_CStyleMakeDefault();
  }
}
	
// MARK: - StatefulChannel<double> <-> _CStatefulChannel_float

class _CStatefulChannel_floatImpl extends StatefulChannel<double> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<double>>{};

  final _CStatefulChannel_float _channel;

  _CStatefulChannel_floatImpl(this._channel);

  @override
  double get value {
    return this._channel._getter();
  }

  static void valueFunction(double cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue);
    }
    
  }

  @override
  StreamSubscription<double> listen(void onData(double event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Float, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<double>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_float extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_floatBasicFunctions on _CStatefulChannel_float {
  void _releaseIntermediate() {
    _CStatefulChannel_float_release(this);
  }

  _CStatefulChannel_float _retain() {
    return _CStatefulChannel_float_retain(this);
  }

  double _getter() {
    final cValue = _CStatefulChannel_floatGetCurrentValue(this);
    final res = cValue;
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(ffi.Float, ffi.Int64)> callback) {
    return _CStatefulChannel_floatConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_floatToDart on _CStatefulChannel_float {
  StatefulChannel<double> _toDart() {
    return _CStatefulChannel_floatImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_float on StatefulChannel<double> {
  _CStatefulChannel_float _copyFromDartTo_CStatefulChannel_float() {
    return _CStatefulChannel_floatMakeDefault();
  }
}
	
// MARK: - void <-> _CResult_CEmpty

final class _CResult_CEmptyImpl extends ffi.Union {
  external _CEmpty _value;
  external _CError _error;
}

final class _CResult_CEmpty extends ffi.Struct {
  external _CResult_CEmptyImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CEmptyBasicFunctions on _CResult_CEmpty {
  void _releaseIntermediate() {
    _CResult_CEmpty_release(this);
  }
}

extension _CResult_CEmptyToDart on _CResult_CEmpty {
  void _toDart() {
    if (this._index == 1) {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - List<Source> <-> _CArray_CSource

final class _CArray_CSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSourceToDart on _CArray_CSource {
  List<Source> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSource on List<Source> {
  _CArray_CSource _copyFromDartTo_CArray_CSource() {
    final cArray = _CArray_CSourcemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSource();
        _CArray_CSourceaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CSourceBasicFunctions on _CArray_CSource {
  void _releaseIntermediate() {
    _CArray_CSource_release(this);
  }

  static final _listToFill = <Source>[];

  static void _iterate(_CSource item) {
    _listToFill.add(item._toDart());
  }

  List<Source> _fillFromC() {
    _forEach_CArray_CSource(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSource)>(_iterate));
    final result = List<Source>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - CancelableOperation<List<RenderedObjectInfo>> <-> _CFuture_CArray_CRenderedObjectInfo

final class _CFuture_CArray_CRenderedObjectInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CArray_CRenderedObjectInfo_Cancellable {
  final Completer<List<RenderedObjectInfo>> completer;
  final _CFuture_CArray_CRenderedObjectInfo _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CArray_CRenderedObjectInfo, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CArray_CRenderedObjectInfo_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CArray_CRenderedObjectInfoBasicFunctions on _CFuture_CArray_CRenderedObjectInfo {
  void _releaseIntermediate() {
    _CFuture_CArray_CRenderedObjectInfo_release(this);
  }

  _CFuture_CArray_CRenderedObjectInfo _retain() {
    return _CFuture_CArray_CRenderedObjectInfo_retain(this);
  }
}

extension _CFuture_CArray_CRenderedObjectInfoToDart on _CFuture_CArray_CRenderedObjectInfo {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CArray_CRenderedObjectInfo_Cancellable>{};

  static void valueFunction(_CArray_CRenderedObjectInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<List<RenderedObjectInfo>> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<List<RenderedObjectInfo>>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CRenderedObjectInfo, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CArray_CRenderedObjectInfoReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CArray_CRenderedObjectInfo_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CArray_CRenderedObjectInfo on CancelableOperation<List<RenderedObjectInfo>> {
  _CFuture_CArray_CRenderedObjectInfo _copyFromDartTo_CFuture_CArray_CRenderedObjectInfo() {
    return _CFuture_CArray_CRenderedObjectInfoMakeDefault();
  }
}
	
// MARK: - List<RenderedObjectInfo> <-> _CArray_CRenderedObjectInfo

final class _CArray_CRenderedObjectInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRenderedObjectInfoToDart on _CArray_CRenderedObjectInfo {
  List<RenderedObjectInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRenderedObjectInfo on List<RenderedObjectInfo> {
  _CArray_CRenderedObjectInfo _copyFromDartTo_CArray_CRenderedObjectInfo() {
    final cArray = _CArray_CRenderedObjectInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRenderedObjectInfo();
        _CArray_CRenderedObjectInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CRenderedObjectInfoBasicFunctions on _CArray_CRenderedObjectInfo {
  void _releaseIntermediate() {
    _CArray_CRenderedObjectInfo_release(this);
  }

  static final _listToFill = <RenderedObjectInfo>[];

  static void _iterate(_CRenderedObjectInfo item) {
    _listToFill.add(item._toDart());
  }

  List<RenderedObjectInfo> _fillFromC() {
    _forEach_CArray_CRenderedObjectInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRenderedObjectInfo)>(_iterate));
    final result = List<RenderedObjectInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RenderedObjectInfo

/** Подробная информация об отображаемом объекте карты. */
class RenderedObjectInfo {
  /** Ближайшая точка объекта в координатах экрана. */
  final ScreenPoint closestViewportPoint;
  /** Ближайшая точка объекта в координатах карты. */
  final GeoPointWithElevation closestMapPoint;
  /** Отображаемый объект карты. */
  final RenderedObject item;

  const RenderedObjectInfo({
    required this.closestViewportPoint,
    required this.closestMapPoint,
    required this.item
  });

  RenderedObjectInfo copyWith({
    ScreenPoint? closestViewportPoint,
    GeoPointWithElevation? closestMapPoint,
    RenderedObject? item
  }) {
    return RenderedObjectInfo(
      closestViewportPoint: closestViewportPoint ?? this.closestViewportPoint,
      closestMapPoint: closestMapPoint ?? this.closestMapPoint,
      item: item ?? this.item
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RenderedObjectInfo &&
    other.runtimeType == runtimeType &&
    other.closestViewportPoint == closestViewportPoint &&
    other.closestMapPoint == closestMapPoint &&
    other.item == item;

  @override
  int get hashCode {
    return Object.hash(closestViewportPoint, closestMapPoint, item);
  }

}
final class _CRenderedObjectInfo extends ffi.Struct {
  external _CScreenPoint closestViewportPoint;

  external _CGeoPointWithElevation closestMapPoint;

  external _CRenderedObject item;

}
// MARK: - RenderedObjectInfo <-> _CRenderedObjectInfo

extension _CRenderedObjectInfoToDart on _CRenderedObjectInfo {
  RenderedObjectInfo _toDart() {
    return RenderedObjectInfo(
      closestViewportPoint: this.closestViewportPoint._toDart(),
      closestMapPoint: this.closestMapPoint._toDart(),
      item: this.item._toDart()
    );
  }
}

extension _DartTo_CRenderedObjectInfo on RenderedObjectInfo {
  _CRenderedObjectInfo _copyFromDartTo_CRenderedObjectInfo() {
    final res = _CRenderedObjectInfoMakeDefault();
    res.closestViewportPoint = this.closestViewportPoint._copyFromDartTo_CScreenPoint();
    res.closestMapPoint = this.closestMapPoint._copyFromDartTo_CGeoPointWithElevation();
    res.item = this.item._copyFromDartTo_CRenderedObject();
    return res;
  }
}
extension _CRenderedObjectInfoRelease on _CRenderedObjectInfo {
  void _releaseIntermediate() {
    item._releaseIntermediate();
  }
}

// MARK: - StatefulChannel<MapVisibilityState> <-> _CStatefulChannel_CMapVisibilityState

class _CStatefulChannel_CMapVisibilityStateImpl extends StatefulChannel<MapVisibilityState> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<MapVisibilityState>>{};

  final _CStatefulChannel_CMapVisibilityState _channel;

  _CStatefulChannel_CMapVisibilityStateImpl(this._channel);

  @override
  MapVisibilityState get value {
    return this._channel._getter();
  }

  static void valueFunction(_CMapVisibilityState cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<MapVisibilityState> listen(void onData(MapVisibilityState event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CMapVisibilityState, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<MapVisibilityState>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CMapVisibilityState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CMapVisibilityStateBasicFunctions on _CStatefulChannel_CMapVisibilityState {
  void _releaseIntermediate() {
    _CStatefulChannel_CMapVisibilityState_release(this);
  }

  _CStatefulChannel_CMapVisibilityState _retain() {
    return _CStatefulChannel_CMapVisibilityState_retain(this);
  }

  MapVisibilityState _getter() {
    final cValue = _CStatefulChannel_CMapVisibilityStateGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CMapVisibilityState, ffi.Int64)> callback) {
    return _CStatefulChannel_CMapVisibilityStateConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CMapVisibilityStateToDart on _CStatefulChannel_CMapVisibilityState {
  StatefulChannel<MapVisibilityState> _toDart() {
    return _CStatefulChannel_CMapVisibilityStateImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CMapVisibilityState on StatefulChannel<MapVisibilityState> {
  _CStatefulChannel_CMapVisibilityState _copyFromDartTo_CStatefulChannel_CMapVisibilityState() {
    return _CStatefulChannel_CMapVisibilityStateMakeDefault();
  }
}
	
// MARK: - Channel<bool> <-> _CChannel_bool

class _CChannel_boolImpl extends Channel<bool> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<bool>>{};

  final _CChannel_bool _channel;

  _CChannel_boolImpl(this._channel);

  static void valueFunction(bool cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue);
    }
    
  }

  @override
  StreamSubscription<bool> listen(void onData(bool event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Bool, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<bool>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CChannel_bool extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CChannel_boolBasicFunctions on _CChannel_bool {
  void _releaseIntermediate() {
    _CChannel_bool_release(this);
  }

  _CChannel_bool _retain() {
    return _CChannel_bool_retain(this);
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(ffi.Bool, ffi.Int64)> callback) {
    return _CChannel_boolConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CChannel_boolToDart on _CChannel_bool {
  Channel<bool> _toDart() {
    return _CChannel_boolImpl(this._retain());
  }
}

extension _DartTo_CChannel_bool on Channel<bool> {
  _CChannel_bool _copyFromDartTo_CChannel_bool() {
    return _CChannel_boolMakeDefault();
  }
}
	
// MARK: - StatefulChannel<ProductType> <-> _CStatefulChannel_CProductType

class _CStatefulChannel_CProductTypeImpl extends StatefulChannel<ProductType> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<ProductType>>{};

  final _CStatefulChannel_CProductType _channel;

  _CStatefulChannel_CProductTypeImpl(this._channel);

  @override
  ProductType get value {
    return this._channel._getter();
  }

  static void valueFunction(_CProductType cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<ProductType> listen(void onData(ProductType event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CProductType, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<ProductType>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CProductType extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CProductTypeBasicFunctions on _CStatefulChannel_CProductType {
  void _releaseIntermediate() {
    _CStatefulChannel_CProductType_release(this);
  }

  _CStatefulChannel_CProductType _retain() {
    return _CStatefulChannel_CProductType_retain(this);
  }

  ProductType _getter() {
    final cValue = _CStatefulChannel_CProductTypeGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CProductType, ffi.Int64)> callback) {
    return _CStatefulChannel_CProductTypeConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CProductTypeToDart on _CStatefulChannel_CProductType {
  StatefulChannel<ProductType> _toDart() {
    return _CStatefulChannel_CProductTypeImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CProductType on StatefulChannel<ProductType> {
  _CStatefulChannel_CProductType _copyFromDartTo_CStatefulChannel_CProductType() {
    return _CStatefulChannel_CProductTypeMakeDefault();
  }
}
	
// MARK: - ImageData <-> _CResult_CImageData

final class _CResult_CImageDataImpl extends ffi.Union {
  
  external _CImageData _value;
  external _CError _error;
}

final class _CResult_CImageData extends ffi.Struct {
  external _CResult_CImageDataImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CImageDataBasicFunctions on _CResult_CImageData {
  void _releaseIntermediate() {
    _CResult_CImageData_release(this);
  }
}

extension _CResult_CImageDataToDart on _CResult_CImageData {
  ImageData _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CImageData _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - StatefulChannel<GraphicsPreset?> <-> _CStatefulChannel_COptional_CGraphicsPreset

class _CStatefulChannel_COptional_CGraphicsPresetImpl extends StatefulChannel<GraphicsPreset?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<GraphicsPreset?>>{};

  final _CStatefulChannel_COptional_CGraphicsPreset _channel;

  _CStatefulChannel_COptional_CGraphicsPresetImpl(this._channel);

  @override
  GraphicsPreset? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CGraphicsPreset cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<GraphicsPreset?> listen(void onData(GraphicsPreset? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CGraphicsPreset, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<GraphicsPreset?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CGraphicsPreset extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CGraphicsPresetBasicFunctions on _CStatefulChannel_COptional_CGraphicsPreset {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CGraphicsPreset_release(this);
  }

  _CStatefulChannel_COptional_CGraphicsPreset _retain() {
    return _CStatefulChannel_COptional_CGraphicsPreset_retain(this);
  }

  GraphicsPreset? _getter() {
    final cValue = _CStatefulChannel_COptional_CGraphicsPresetGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CGraphicsPreset, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CGraphicsPresetConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CGraphicsPresetToDart on _CStatefulChannel_COptional_CGraphicsPreset {
  StatefulChannel<GraphicsPreset?> _toDart() {
    return _CStatefulChannel_COptional_CGraphicsPresetImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CGraphicsPreset on StatefulChannel<GraphicsPreset?> {
  _CStatefulChannel_COptional_CGraphicsPreset _copyFromDartTo_CStatefulChannel_COptional_CGraphicsPreset() {
    return _CStatefulChannel_COptional_CGraphicsPresetMakeDefault();
  }
}
	
// MARK: - GraphicsPreset? <-> _COptional_CGraphicsPreset

final class _COptional_CGraphicsPreset extends ffi.Struct {
  
  external _CGraphicsPreset value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGraphicsPresetBasicFunctions on _COptional_CGraphicsPreset {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CGraphicsPresetToDart on _COptional_CGraphicsPreset {
  GraphicsPreset? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGraphicsPreset on GraphicsPreset? {
  _COptional_CGraphicsPreset _copyFromDartTo_COptional_CGraphicsPreset() {
    final cOptional = _COptional_CGraphicsPresetMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGraphicsPreset();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CancelableOperation<RenderedObjectInfo?> <-> _CFuture_COptional_CRenderedObjectInfo

final class _CFuture_COptional_CRenderedObjectInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_COptional_CRenderedObjectInfo_Cancellable {
  final Completer<RenderedObjectInfo?> completer;
  final _CFuture_COptional_CRenderedObjectInfo _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_COptional_CRenderedObjectInfo, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_COptional_CRenderedObjectInfo_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_COptional_CRenderedObjectInfoBasicFunctions on _CFuture_COptional_CRenderedObjectInfo {
  void _releaseIntermediate() {
    _CFuture_COptional_CRenderedObjectInfo_release(this);
  }

  _CFuture_COptional_CRenderedObjectInfo _retain() {
    return _CFuture_COptional_CRenderedObjectInfo_retain(this);
  }
}

extension _CFuture_COptional_CRenderedObjectInfoToDart on _CFuture_COptional_CRenderedObjectInfo {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_COptional_CRenderedObjectInfo_Cancellable>{};

  static void valueFunction(_COptional_CRenderedObjectInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<RenderedObjectInfo?> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<RenderedObjectInfo?>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CRenderedObjectInfo, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_COptional_CRenderedObjectInfoReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_COptional_CRenderedObjectInfo_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_COptional_CRenderedObjectInfo on CancelableOperation<RenderedObjectInfo?> {
  _CFuture_COptional_CRenderedObjectInfo _copyFromDartTo_CFuture_COptional_CRenderedObjectInfo() {
    return _CFuture_COptional_CRenderedObjectInfoMakeDefault();
  }
}
	
// MARK: - RenderedObjectInfo? <-> _COptional_CRenderedObjectInfo

final class _COptional_CRenderedObjectInfo extends ffi.Struct {
  
  external _CRenderedObjectInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRenderedObjectInfoBasicFunctions on _COptional_CRenderedObjectInfo {
  void _releaseIntermediate() {
    _COptional_CRenderedObjectInfo_release(this);
  }
}

extension _COptional_CRenderedObjectInfoToDart on _COptional_CRenderedObjectInfo {
  RenderedObjectInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRenderedObjectInfo on RenderedObjectInfo? {
  _COptional_CRenderedObjectInfo _copyFromDartTo_COptional_CRenderedObjectInfo() {
    final cOptional = _COptional_CRenderedObjectInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRenderedObjectInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Projection

/**
 Проекция.

 Используется сферическая проекция Меркатора (EPSG:3857), зацикленная по долготе.
 Отображаемые данные ограничены по широте от -85.06° до 85.06°.
*/
class Projection implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CProjection_releasePtr);

  Projection._raw(this._self);
  factory Projection._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Projection._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Projection &&
    other.runtimeType == runtimeType &&
    _CProjection_cg_objectIdentifier(this._self) == _CProjection_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CProjection_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Projection: Methods

  /**
   Вычисление точки карты в указанной точке экрана.
  
   - Note: Функция возвращает пустое значение, если указанная точка экрана за пределами проекции карты.
  */
  GeoPoint? screenToMap(
    ScreenPoint point
  )  {
    var _a1 = point._copyFromDartTo_CScreenPoint();
    _COptional_CGeoPoint res = _CProjection_screenToMap_CScreenPoint(_CProjectionMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Вычисление точки экрана, соответствующей указанной точке карты.
  
   - Note: Функция возвращает пустое значение:
   - point имеет невалидное значение
   (latitude лежит вне диапазона [-90; 90] или longitude лежит вне диапазона [-180; 180]).
   - если указанная точка карты находится выше плоскости проекции карты на экран.
   - если указанная точка карты находится слишком далеко за пределами экрана и возникает переполнение типа.
  */
  ScreenPoint? map_to_screen_with_geo_point(
    GeoPoint point
  )  {
    var _a1 = point._copyFromDartTo_CGeoPoint();
    _COptional_CScreenPoint res = _CProjection_map_to_screen_with_geo_point_CGeoPoint(_CProjectionMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Вычисление точки экрана, соответствующей указанной точке карты с высотой.
  
   - Note: Функция возвращает пустое значение:
   - point имеет невалидное значение
   (latitude лежит вне диапазона [-90; 90], longitude лежит вне диапазона [-180; 180] или elevation отрицателен).
   - если указанная точка карты находится выше плоскости проекции карты на экран.
   - если указанная точка карты находится слишком далеко за пределами экрана и возникает переполнение типа.
  */
  ScreenPoint? map_to_screen_with_geo_point_with_elevation(
    GeoPointWithElevation point
  )  {
    var _a1 = point._copyFromDartTo_CGeoPointWithElevation();
    _COptional_CScreenPoint res = _CProjection_map_to_screen_with_geo_point_with_elevation_CGeoPointWithElevation(_CProjectionMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Вычисление ближайшей точки карты к проекции указанной точки экрана.
  
   - Throws: Exception, если точка не может быть вычислена
   (например, значение x или y точки экрана слишком большое или слишком маленькое).
  */
  GeoPoint screenToMapClipped(
    ScreenPoint point
  )  {
    var _a1 = point._copyFromDartTo_CScreenPoint();
    _CGeoPoint res = _CProjection_screenToMapClipped_CScreenPoint(_CProjectionMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Вычисление расстояния между точками на карте, соответствующими указанным точкам на экране, в метрах.
  
   - Note: Функция возвращает пустое значение, если одна или обе указанных точки экрана находятся за пределами проекции карты.
  */
  Meter? distance_on_screen(
    ScreenPoint fromPoint,
    ScreenPoint toPoint
  )  {
    var _a1 = fromPoint._copyFromDartTo_CScreenPoint();
    var _a2 = toPoint._copyFromDartTo_CScreenPoint();
    _COptional_CMeter res = _CProjection_distance_on_screen_CScreenPoint_CScreenPoint(_CProjectionMakeDefault().._impl=_self, _a1, _a2);
    return res._toDart();
  }

  /**
   Вычисление расстояния между точками на экране, соответствующими указанным точкам на карте, в пикселях.
  
   - Note: Функция возвращает пустое значение если одна или обе точки на карте:
   - имеют невалидное значение
   (latitude лежит вне диапазона [-90; 90] или longitude лежит вне диапазона [-180; 180]).
   - находятся выше плоскости проекции карты на экран.
   - находятся слишком далеко за пределами экрана и возникает переполнение типа.
  */
  LogicalPixel? distanceOnScreen(
    GeoPoint fromGeoPoint,
    GeoPoint toGeoPoint
  )  {
    var _a1 = fromGeoPoint._copyFromDartTo_CGeoPoint();
    var _a2 = toGeoPoint._copyFromDartTo_CGeoPoint();
    _COptional_CLogicalPixel res = _CProjection_distanceOnScreen_CGeoPoint_CGeoPoint(_CProjectionMakeDefault().._impl=_self, _a1, _a2);
    return res._toDart();
  }

}

// MARK: - Projection <-> CProjection

final class _CProjection extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CProjectionBasicFunctions on _CProjection {
  void _releaseIntermediate() {
    _CProjection_release(_impl);
  }

  _CProjection _retain() {
    return _CProjection_retain(_impl);
  }
}

extension _CProjectionToDart on _CProjection {
  Projection _toDart() {
    return Projection._create(_retain()._impl);
  }
}


extension _DartToCProjection on Projection {
  _CProjection _copyFromDartTo_CProjection() {
    return (_CProjectionMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Meter? <-> _COptional_CMeter

final class _COptional_CMeter extends ffi.Struct {
  
  external _CMeter value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CMeterBasicFunctions on _COptional_CMeter {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CMeterToDart on _COptional_CMeter {
  Meter? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CMeter on Meter? {
  _COptional_CMeter _copyFromDartTo_COptional_CMeter() {
    final cOptional = _COptional_CMeterMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CMeter();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - LogicalPixel? <-> _COptional_CLogicalPixel

final class _COptional_CLogicalPixel extends ffi.Struct {
  
  external _CLogicalPixel value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLogicalPixelBasicFunctions on _COptional_CLogicalPixel {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CLogicalPixelToDart on _COptional_CLogicalPixel {
  LogicalPixel? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLogicalPixel on LogicalPixel? {
  _COptional_CLogicalPixel _copyFromDartTo_COptional_CLogicalPixel() {
    final cOptional = _COptional_CLogicalPixelMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLogicalPixel();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - BaseCamera

/**
 Камера.

 Задаёт параметры проецирования карты на экран.
*/
class BaseCamera implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Проекция.
  
   Используется для получения точки экрана по точке карты и точки карты по точке экрана.
   Параметры камеры фиксируются в момент вызова.
  */
  Projection get projection {
    _CProjection res = _CBaseCamera_projection(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение текущей позиции камеры. */
  StatefulChannel<CameraPosition> get positionChannel {
    _CStatefulChannel_CCameraPosition res = _CBaseCamera_positionChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение текущей позиции камеры. */
  CameraPosition get position {
    _CCameraPosition res = _CBaseCamera_position(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set position(CameraPosition position) {
    var _a1 = position._copyFromDartTo_CCameraPosition();
    _CResult_CEmpty res = _CBaseCamera_setPosition_CCameraPosition(_CBaseCameraMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }
  /** Получение актуальных ограничений уровня масштабирования. */
  StatefulChannel<CameraZoomRestrictions> get zoomRestrictionsChannel {
    _CStatefulChannel_CCameraZoomRestrictions res = _CBaseCamera_zoomRestrictionsChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение актуальных ограничений уровня масштабирования. */
  CameraZoomRestrictions get zoomRestrictions {
    _CCameraZoomRestrictions res = _CBaseCamera_zoomRestrictions(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set zoomRestrictions(CameraZoomRestrictions zoomRestrictions) {
    var _a1 = zoomRestrictions._copyFromDartTo_CCameraZoomRestrictions();
    _CResult_CEmpty res = _CBaseCamera_setZoomRestrictions_CCameraZoomRestrictions(_CBaseCameraMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }
  /** Получение разрешающей способности экрана (плотность пикселей на дюйм). */
  StatefulChannel<DevicePpi> get devicePpiChannel {
    _CStatefulChannel_CDevicePpi res = _CBaseCamera_devicePpiChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение разрешающей способности экрана (плотность пикселей на дюйм). */
  DevicePpi get devicePpi {
    _CDevicePpi res = _CBaseCamera_devicePpi(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение отношения DPI к базовому DPI устройства. */
  StatefulChannel<DeviceDensity> get deviceDensityChannel {
    _CStatefulChannel_CDeviceDensity res = _CBaseCamera_deviceDensityChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение отношения DPI к базовому DPI устройства. */
  DeviceDensity get deviceDensity {
    _CDeviceDensity res = _CBaseCamera_deviceDensity(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение размера области просмотра. */
  StatefulChannel<ScreenSize> get sizeChannel {
    _CStatefulChannel_CScreenSize res = _CBaseCamera_sizeChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение размера области просмотра. */
  ScreenSize get size {
    _CScreenSize res = _CBaseCamera_size(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set size(ScreenSize size) {
    var _a1 = size._copyFromDartTo_CScreenSize();
    void res = _CBaseCamera_setSize_CScreenSize(_CBaseCameraMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение текущих отступов от краёв экрана. */
  StatefulChannel<Padding> get paddingChannel {
    _CStatefulChannel_CPadding res = _CBaseCamera_paddingChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение текущих отступов от краёв экрана. */
  Padding get padding {
    _CPadding res = _CBaseCamera_padding(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set padding(Padding padding) {
    var _a1 = padding._copyFromDartTo_CPadding();
    void res = _CBaseCamera_setPadding_CPadding(_CBaseCameraMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Точка экрана, к которой привязана позиция камеры, задаётся с учётом отступов (padding). */
  StatefulChannel<CameraPositionPoint> get positionPointChannel {
    _CStatefulChannel_CCameraPositionPoint res = _CBaseCamera_positionPointChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Точка экрана, к которой привязана позиция камеры, задаётся с учётом отступов (padding). */
  CameraPositionPoint get positionPoint {
    _CCameraPositionPoint res = _CBaseCamera_positionPoint(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set positionPoint(CameraPositionPoint positionPoint) {
    var _a1 = positionPoint._copyFromDartTo_CCameraPositionPoint();
    _CResult_CEmpty res = _CBaseCamera_setPositionPoint_CCameraPositionPoint(_CBaseCameraMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }
  /**
   Точка взгляда относительно полного размера вьюпорта.
  
   - Returns: Значение, явно установленное функцией set_view_point.
   Если вернулся null, точка взгляда следует за точкой позиции.
  */
  CameraViewPoint? get viewPoint {
    _COptional_CCameraViewPoint res = _CBaseCamera_viewPoint(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set viewPoint(CameraViewPoint? viewPoint) {
    var _a1 = viewPoint._copyFromDartTo_COptional_CCameraViewPoint();
    _CResult_CEmpty res = _CBaseCamera_setViewPoint_COptional_CCameraViewPoint(_CBaseCameraMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }
  /** Область пересечения пирамиды видимости камеры и поверхности карты. */
  Geometry get visibleArea {
    _CGeometry res = _CBaseCamera_visibleArea(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Объемлющий прямоугольник видимой области карты. */
  StatefulChannel<GeoRect> get visibleRectChannel {
    _CStatefulChannel_CGeoRect res = _CBaseCamera_visibleRectChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Объемлющий прямоугольник видимой области карты. */
  GeoRect get visibleRect {
    _CGeoRect res = _CBaseCamera_visibleRect(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Получение текущей функции зависимости максимального угла наклона камеры от стилевого уровня масштабирования.
  
   - Returns: возвращает пустой объект, если функция не установлена.
  */
  StatefulChannel<StyleZoomToTiltRelation?> get maxTiltRestrictionChannel {
    _CStatefulChannel_COptional_CStyleZoomToTiltRelation res = _CBaseCamera_maxTiltRestrictionChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение текущей функции зависимости максимального угла наклона камеры от стилевого уровня масштабирования.
  
   - Returns: возвращает пустой объект, если функция не установлена.
  */
  StyleZoomToTiltRelation? get maxTiltRestriction {
    _COptional_CStyleZoomToTiltRelation res = _CBaseCamera_maxTiltRestriction(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set maxTiltRestriction(StyleZoomToTiltRelation? maxTiltRestriction) {
    var _a1 = maxTiltRestriction._copyFromDartTo_COptional_CStyleZoomToTiltRelation();
    void res = _CBaseCamera_setMaxTiltRestriction_COptional_CStyleZoomToTiltRelation(_CBaseCameraMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /**
   Получение ограничения на область видимости.
  
   - Returns: null если ограничение не задано.
  */
  StatefulChannel<GeoRect?> get viewportRestrictionChannel {
    _CStatefulChannel_COptional_CGeoRect res = _CBaseCamera_viewportRestrictionChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение ограничения на область видимости.
  
   - Returns: null если ограничение не задано.
  */
  GeoRect? get viewportRestriction {
    _COptional_CGeoRect res = _CBaseCamera_viewportRestriction(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set viewportRestriction(GeoRect? viewportRestriction) {
    var _a1 = viewportRestriction._copyFromDartTo_COptional_CGeoRect();
    void res = _CBaseCamera_setViewportRestriction_COptional_CGeoRect(_CBaseCameraMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CBaseCamera_releasePtr);

  BaseCamera._raw(this._self);
  factory BaseCamera._create(ffi.Pointer<ffi.Void> self) {
    final classObject = BaseCamera._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BaseCamera &&
    other.runtimeType == runtimeType &&
    _CBaseCamera_cg_objectIdentifier(this._self) == _CBaseCamera_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CBaseCamera_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: BaseCamera: Methods

  /** Создание копии текущей камеры. */
  BaseCamera clone()  {
    _CBaseCamera res = _CBaseCamera_clone(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Изменение только части параметров позиции камеры.
  
   - Note: Вызов прерывает перелёт и обработку жестов,
   а также сбрасывает слежение за изменёнными параметрами,
   а при изменении координат также и слежение за стилевым уровнем масштабирования и направлением.
  */
  void changePosition(
    CameraPositionChange positionChange
  )  {
    var _a1 = positionChange._copyFromDartTo_CCameraPositionChange();
    _CResult_CEmpty res = _CBaseCamera_changePosition_CCameraPositionChange(_CBaseCameraMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }

}

@internal
extension BaseCameraInternalMethods on BaseCamera {
  /** Установка разрешающей способности экрана. */
  @internal
  void setDevicePpi(
    DevicePpi devicePpi,
    DeviceDensity deviceDensity
  )  {
    var _a1 = devicePpi._copyFromDartTo_CDevicePpi();
    var _a2 = deviceDensity._copyFromDartTo_CDeviceDensity();
    void res = _CBaseCamera_setDevicePpi_CDevicePpi_CDeviceDensity(_CBaseCameraMakeDefault().._impl=_self, _a1, _a2);
    return res;
  }

}

// MARK: - BaseCamera <-> CBaseCamera

final class _CBaseCamera extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CBaseCameraBasicFunctions on _CBaseCamera {
  void _releaseIntermediate() {
    _CBaseCamera_release(_impl);
  }

  _CBaseCamera _retain() {
    return _CBaseCamera_retain(_impl);
  }
}

extension _CBaseCameraToDart on _CBaseCamera {
  BaseCamera _toDart() {
    final selector = _CBaseCamera_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = BaseCamera._create(_retain()._impl);
        return res;
      case 1:
        final res = Camera._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCBaseCamera on BaseCamera {
  _CBaseCamera _copyFromDartTo_CBaseCamera() {
    return (_CBaseCameraMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<CameraPosition> <-> _CStatefulChannel_CCameraPosition

class _CStatefulChannel_CCameraPositionImpl extends StatefulChannel<CameraPosition> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraPosition>>{};

  final _CStatefulChannel_CCameraPosition _channel;

  _CStatefulChannel_CCameraPositionImpl(this._channel);

  @override
  CameraPosition get value {
    return this._channel._getter();
  }

  static void valueFunction(_CCameraPosition cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraPosition> listen(void onData(CameraPosition event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraPosition, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraPosition>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CCameraPosition extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CCameraPositionBasicFunctions on _CStatefulChannel_CCameraPosition {
  void _releaseIntermediate() {
    _CStatefulChannel_CCameraPosition_release(this);
  }

  _CStatefulChannel_CCameraPosition _retain() {
    return _CStatefulChannel_CCameraPosition_retain(this);
  }

  CameraPosition _getter() {
    final cValue = _CStatefulChannel_CCameraPositionGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CCameraPosition, ffi.Int64)> callback) {
    return _CStatefulChannel_CCameraPositionConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CCameraPositionToDart on _CStatefulChannel_CCameraPosition {
  StatefulChannel<CameraPosition> _toDart() {
    return _CStatefulChannel_CCameraPositionImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CCameraPosition on StatefulChannel<CameraPosition> {
  _CStatefulChannel_CCameraPosition _copyFromDartTo_CStatefulChannel_CCameraPosition() {
    return _CStatefulChannel_CCameraPositionMakeDefault();
  }
}
	
// MARK: - StatefulChannel<CameraZoomRestrictions> <-> _CStatefulChannel_CCameraZoomRestrictions

class _CStatefulChannel_CCameraZoomRestrictionsImpl extends StatefulChannel<CameraZoomRestrictions> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraZoomRestrictions>>{};

  final _CStatefulChannel_CCameraZoomRestrictions _channel;

  _CStatefulChannel_CCameraZoomRestrictionsImpl(this._channel);

  @override
  CameraZoomRestrictions get value {
    return this._channel._getter();
  }

  static void valueFunction(_CCameraZoomRestrictions cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraZoomRestrictions> listen(void onData(CameraZoomRestrictions event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraZoomRestrictions, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraZoomRestrictions>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CCameraZoomRestrictions extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CCameraZoomRestrictionsBasicFunctions on _CStatefulChannel_CCameraZoomRestrictions {
  void _releaseIntermediate() {
    _CStatefulChannel_CCameraZoomRestrictions_release(this);
  }

  _CStatefulChannel_CCameraZoomRestrictions _retain() {
    return _CStatefulChannel_CCameraZoomRestrictions_retain(this);
  }

  CameraZoomRestrictions _getter() {
    final cValue = _CStatefulChannel_CCameraZoomRestrictionsGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CCameraZoomRestrictions, ffi.Int64)> callback) {
    return _CStatefulChannel_CCameraZoomRestrictionsConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CCameraZoomRestrictionsToDart on _CStatefulChannel_CCameraZoomRestrictions {
  StatefulChannel<CameraZoomRestrictions> _toDart() {
    return _CStatefulChannel_CCameraZoomRestrictionsImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CCameraZoomRestrictions on StatefulChannel<CameraZoomRestrictions> {
  _CStatefulChannel_CCameraZoomRestrictions _copyFromDartTo_CStatefulChannel_CCameraZoomRestrictions() {
    return _CStatefulChannel_CCameraZoomRestrictionsMakeDefault();
  }
}
	
// MARK: - StatefulChannel<DevicePpi> <-> _CStatefulChannel_CDevicePpi

class _CStatefulChannel_CDevicePpiImpl extends StatefulChannel<DevicePpi> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<DevicePpi>>{};

  final _CStatefulChannel_CDevicePpi _channel;

  _CStatefulChannel_CDevicePpiImpl(this._channel);

  @override
  DevicePpi get value {
    return this._channel._getter();
  }

  static void valueFunction(_CDevicePpi cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<DevicePpi> listen(void onData(DevicePpi event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CDevicePpi, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<DevicePpi>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CDevicePpi extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CDevicePpiBasicFunctions on _CStatefulChannel_CDevicePpi {
  void _releaseIntermediate() {
    _CStatefulChannel_CDevicePpi_release(this);
  }

  _CStatefulChannel_CDevicePpi _retain() {
    return _CStatefulChannel_CDevicePpi_retain(this);
  }

  DevicePpi _getter() {
    final cValue = _CStatefulChannel_CDevicePpiGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CDevicePpi, ffi.Int64)> callback) {
    return _CStatefulChannel_CDevicePpiConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CDevicePpiToDart on _CStatefulChannel_CDevicePpi {
  StatefulChannel<DevicePpi> _toDart() {
    return _CStatefulChannel_CDevicePpiImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CDevicePpi on StatefulChannel<DevicePpi> {
  _CStatefulChannel_CDevicePpi _copyFromDartTo_CStatefulChannel_CDevicePpi() {
    return _CStatefulChannel_CDevicePpiMakeDefault();
  }
}
	
// MARK: - StatefulChannel<DeviceDensity> <-> _CStatefulChannel_CDeviceDensity

class _CStatefulChannel_CDeviceDensityImpl extends StatefulChannel<DeviceDensity> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<DeviceDensity>>{};

  final _CStatefulChannel_CDeviceDensity _channel;

  _CStatefulChannel_CDeviceDensityImpl(this._channel);

  @override
  DeviceDensity get value {
    return this._channel._getter();
  }

  static void valueFunction(_CDeviceDensity cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<DeviceDensity> listen(void onData(DeviceDensity event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CDeviceDensity, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<DeviceDensity>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CDeviceDensity extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CDeviceDensityBasicFunctions on _CStatefulChannel_CDeviceDensity {
  void _releaseIntermediate() {
    _CStatefulChannel_CDeviceDensity_release(this);
  }

  _CStatefulChannel_CDeviceDensity _retain() {
    return _CStatefulChannel_CDeviceDensity_retain(this);
  }

  DeviceDensity _getter() {
    final cValue = _CStatefulChannel_CDeviceDensityGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CDeviceDensity, ffi.Int64)> callback) {
    return _CStatefulChannel_CDeviceDensityConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CDeviceDensityToDart on _CStatefulChannel_CDeviceDensity {
  StatefulChannel<DeviceDensity> _toDart() {
    return _CStatefulChannel_CDeviceDensityImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CDeviceDensity on StatefulChannel<DeviceDensity> {
  _CStatefulChannel_CDeviceDensity _copyFromDartTo_CStatefulChannel_CDeviceDensity() {
    return _CStatefulChannel_CDeviceDensityMakeDefault();
  }
}
	
// MARK: - StatefulChannel<ScreenSize> <-> _CStatefulChannel_CScreenSize

class _CStatefulChannel_CScreenSizeImpl extends StatefulChannel<ScreenSize> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<ScreenSize>>{};

  final _CStatefulChannel_CScreenSize _channel;

  _CStatefulChannel_CScreenSizeImpl(this._channel);

  @override
  ScreenSize get value {
    return this._channel._getter();
  }

  static void valueFunction(_CScreenSize cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<ScreenSize> listen(void onData(ScreenSize event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CScreenSize, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<ScreenSize>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CScreenSize extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CScreenSizeBasicFunctions on _CStatefulChannel_CScreenSize {
  void _releaseIntermediate() {
    _CStatefulChannel_CScreenSize_release(this);
  }

  _CStatefulChannel_CScreenSize _retain() {
    return _CStatefulChannel_CScreenSize_retain(this);
  }

  ScreenSize _getter() {
    final cValue = _CStatefulChannel_CScreenSizeGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CScreenSize, ffi.Int64)> callback) {
    return _CStatefulChannel_CScreenSizeConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CScreenSizeToDart on _CStatefulChannel_CScreenSize {
  StatefulChannel<ScreenSize> _toDart() {
    return _CStatefulChannel_CScreenSizeImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CScreenSize on StatefulChannel<ScreenSize> {
  _CStatefulChannel_CScreenSize _copyFromDartTo_CStatefulChannel_CScreenSize() {
    return _CStatefulChannel_CScreenSizeMakeDefault();
  }
}
	
// MARK: - StatefulChannel<Padding> <-> _CStatefulChannel_CPadding

class _CStatefulChannel_CPaddingImpl extends StatefulChannel<Padding> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Padding>>{};

  final _CStatefulChannel_CPadding _channel;

  _CStatefulChannel_CPaddingImpl(this._channel);

  @override
  Padding get value {
    return this._channel._getter();
  }

  static void valueFunction(_CPadding cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<Padding> listen(void onData(Padding event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CPadding, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Padding>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CPadding extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CPaddingBasicFunctions on _CStatefulChannel_CPadding {
  void _releaseIntermediate() {
    _CStatefulChannel_CPadding_release(this);
  }

  _CStatefulChannel_CPadding _retain() {
    return _CStatefulChannel_CPadding_retain(this);
  }

  Padding _getter() {
    final cValue = _CStatefulChannel_CPaddingGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CPadding, ffi.Int64)> callback) {
    return _CStatefulChannel_CPaddingConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CPaddingToDart on _CStatefulChannel_CPadding {
  StatefulChannel<Padding> _toDart() {
    return _CStatefulChannel_CPaddingImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CPadding on StatefulChannel<Padding> {
  _CStatefulChannel_CPadding _copyFromDartTo_CStatefulChannel_CPadding() {
    return _CStatefulChannel_CPaddingMakeDefault();
  }
}
	
// MARK: - StatefulChannel<CameraPositionPoint> <-> _CStatefulChannel_CCameraPositionPoint

class _CStatefulChannel_CCameraPositionPointImpl extends StatefulChannel<CameraPositionPoint> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraPositionPoint>>{};

  final _CStatefulChannel_CCameraPositionPoint _channel;

  _CStatefulChannel_CCameraPositionPointImpl(this._channel);

  @override
  CameraPositionPoint get value {
    return this._channel._getter();
  }

  static void valueFunction(_CCameraPositionPoint cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraPositionPoint> listen(void onData(CameraPositionPoint event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraPositionPoint, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraPositionPoint>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CCameraPositionPoint extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CCameraPositionPointBasicFunctions on _CStatefulChannel_CCameraPositionPoint {
  void _releaseIntermediate() {
    _CStatefulChannel_CCameraPositionPoint_release(this);
  }

  _CStatefulChannel_CCameraPositionPoint _retain() {
    return _CStatefulChannel_CCameraPositionPoint_retain(this);
  }

  CameraPositionPoint _getter() {
    final cValue = _CStatefulChannel_CCameraPositionPointGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CCameraPositionPoint, ffi.Int64)> callback) {
    return _CStatefulChannel_CCameraPositionPointConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CCameraPositionPointToDart on _CStatefulChannel_CCameraPositionPoint {
  StatefulChannel<CameraPositionPoint> _toDart() {
    return _CStatefulChannel_CCameraPositionPointImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CCameraPositionPoint on StatefulChannel<CameraPositionPoint> {
  _CStatefulChannel_CCameraPositionPoint _copyFromDartTo_CStatefulChannel_CCameraPositionPoint() {
    return _CStatefulChannel_CCameraPositionPointMakeDefault();
  }
}
	
// MARK: - CameraViewPoint? <-> _COptional_CCameraViewPoint

final class _COptional_CCameraViewPoint extends ffi.Struct {
  
  external _CCameraViewPoint value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CCameraViewPointBasicFunctions on _COptional_CCameraViewPoint {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CCameraViewPointToDart on _COptional_CCameraViewPoint {
  CameraViewPoint? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CCameraViewPoint on CameraViewPoint? {
  _COptional_CCameraViewPoint _copyFromDartTo_COptional_CCameraViewPoint() {
    final cOptional = _COptional_CCameraViewPointMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CCameraViewPoint();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - StatefulChannel<GeoRect> <-> _CStatefulChannel_CGeoRect

class _CStatefulChannel_CGeoRectImpl extends StatefulChannel<GeoRect> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<GeoRect>>{};

  final _CStatefulChannel_CGeoRect _channel;

  _CStatefulChannel_CGeoRectImpl(this._channel);

  @override
  GeoRect get value {
    return this._channel._getter();
  }

  static void valueFunction(_CGeoRect cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<GeoRect> listen(void onData(GeoRect event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CGeoRect, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<GeoRect>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CGeoRect extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CGeoRectBasicFunctions on _CStatefulChannel_CGeoRect {
  void _releaseIntermediate() {
    _CStatefulChannel_CGeoRect_release(this);
  }

  _CStatefulChannel_CGeoRect _retain() {
    return _CStatefulChannel_CGeoRect_retain(this);
  }

  GeoRect _getter() {
    final cValue = _CStatefulChannel_CGeoRectGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CGeoRect, ffi.Int64)> callback) {
    return _CStatefulChannel_CGeoRectConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CGeoRectToDart on _CStatefulChannel_CGeoRect {
  StatefulChannel<GeoRect> _toDart() {
    return _CStatefulChannel_CGeoRectImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CGeoRect on StatefulChannel<GeoRect> {
  _CStatefulChannel_CGeoRect _copyFromDartTo_CStatefulChannel_CGeoRect() {
    return _CStatefulChannel_CGeoRectMakeDefault();
  }
}
	
// MARK: - StatefulChannel<StyleZoomToTiltRelation?> <-> _CStatefulChannel_COptional_CStyleZoomToTiltRelation

class _CStatefulChannel_COptional_CStyleZoomToTiltRelationImpl extends StatefulChannel<StyleZoomToTiltRelation?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<StyleZoomToTiltRelation?>>{};

  final _CStatefulChannel_COptional_CStyleZoomToTiltRelation _channel;

  _CStatefulChannel_COptional_CStyleZoomToTiltRelationImpl(this._channel);

  @override
  StyleZoomToTiltRelation? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CStyleZoomToTiltRelation cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<StyleZoomToTiltRelation?> listen(void onData(StyleZoomToTiltRelation? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CStyleZoomToTiltRelation, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<StyleZoomToTiltRelation?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CStyleZoomToTiltRelation extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CStyleZoomToTiltRelationBasicFunctions on _CStatefulChannel_COptional_CStyleZoomToTiltRelation {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CStyleZoomToTiltRelation_release(this);
  }

  _CStatefulChannel_COptional_CStyleZoomToTiltRelation _retain() {
    return _CStatefulChannel_COptional_CStyleZoomToTiltRelation_retain(this);
  }

  StyleZoomToTiltRelation? _getter() {
    final cValue = _CStatefulChannel_COptional_CStyleZoomToTiltRelationGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CStyleZoomToTiltRelation, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CStyleZoomToTiltRelationConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CStyleZoomToTiltRelationToDart on _CStatefulChannel_COptional_CStyleZoomToTiltRelation {
  StatefulChannel<StyleZoomToTiltRelation?> _toDart() {
    return _CStatefulChannel_COptional_CStyleZoomToTiltRelationImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CStyleZoomToTiltRelation on StatefulChannel<StyleZoomToTiltRelation?> {
  _CStatefulChannel_COptional_CStyleZoomToTiltRelation _copyFromDartTo_CStatefulChannel_COptional_CStyleZoomToTiltRelation() {
    return _CStatefulChannel_COptional_CStyleZoomToTiltRelationMakeDefault();
  }
}
	
// MARK: - StyleZoomToTiltRelation? <-> _COptional_CStyleZoomToTiltRelation

final class _COptional_CStyleZoomToTiltRelation extends ffi.Struct {
  
  external _CStyleZoomToTiltRelation value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CStyleZoomToTiltRelationBasicFunctions on _COptional_CStyleZoomToTiltRelation {
  void _releaseIntermediate() {
    _COptional_CStyleZoomToTiltRelation_release(this);
  }
}

extension _COptional_CStyleZoomToTiltRelationToDart on _COptional_CStyleZoomToTiltRelation {
  StyleZoomToTiltRelation? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CStyleZoomToTiltRelation on StyleZoomToTiltRelation? {
  _COptional_CStyleZoomToTiltRelation _copyFromDartTo_COptional_CStyleZoomToTiltRelation() {
    final cOptional = _COptional_CStyleZoomToTiltRelationMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CStyleZoomToTiltRelation();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - StatefulChannel<GeoRect?> <-> _CStatefulChannel_COptional_CGeoRect

class _CStatefulChannel_COptional_CGeoRectImpl extends StatefulChannel<GeoRect?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<GeoRect?>>{};

  final _CStatefulChannel_COptional_CGeoRect _channel;

  _CStatefulChannel_COptional_CGeoRectImpl(this._channel);

  @override
  GeoRect? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CGeoRect cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<GeoRect?> listen(void onData(GeoRect? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CGeoRect, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<GeoRect?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CGeoRect extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CGeoRectBasicFunctions on _CStatefulChannel_COptional_CGeoRect {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CGeoRect_release(this);
  }

  _CStatefulChannel_COptional_CGeoRect _retain() {
    return _CStatefulChannel_COptional_CGeoRect_retain(this);
  }

  GeoRect? _getter() {
    final cValue = _CStatefulChannel_COptional_CGeoRectGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CGeoRect, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CGeoRectConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CGeoRectToDart on _CStatefulChannel_COptional_CGeoRect {
  StatefulChannel<GeoRect?> _toDart() {
    return _CStatefulChannel_COptional_CGeoRectImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CGeoRect on StatefulChannel<GeoRect?> {
  _CStatefulChannel_COptional_CGeoRect _copyFromDartTo_CStatefulChannel_COptional_CGeoRect() {
    return _CStatefulChannel_COptional_CGeoRectMakeDefault();
  }
}
	
// MARK: - SimpleMapObject

/** Объект на карте, для которого можно задавать видимость. */
class SimpleMapObject extends MapObject implements ffi.Finalizable {
  bool get isVisible {
    bool res = _CSimpleMapObject_isVisible(_CSimpleMapObjectMakeDefault().._impl=_self);
    return res;
  }
  set isVisible(bool visible) {
    void res = _CSimpleMapObject_setVisible_bool(_CSimpleMapObjectMakeDefault().._impl=_self, visible);
    return res;
  }
  /** Получение уровня отрисовки объекта. */
  ZIndex get zIndex {
    _CZIndex res = _CSimpleMapObject_zIndex(_CSimpleMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set zIndex(ZIndex zIndex) {
    var _a1 = zIndex._copyFromDartTo_CZIndex();
    void res = _CSimpleMapObject_setZIndex_CZIndex(_CSimpleMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Получение привязки объекта к этажу в здании.
  
   - Returns: Идентификатор этажного плана здания, либо пустое значение.
  */
  LevelId? get levelId {
    _COptional_CLevelId res = _CSimpleMapObject_levelId(_CSimpleMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set levelId(LevelId? levelId) {
    var _a1 = levelId._copyFromDartTo_COptional_CLevelId();
    void res = _CSimpleMapObject_setLevelId_COptional_CLevelId(_CSimpleMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Прямоугольник минимального размера, содержащий геометрию. */
  GeoRect get bounds {
    _CGeoRect res = _CSimpleMapObject_bounds(_CSimpleMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CSimpleMapObject_releasePtr);

  SimpleMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory SimpleMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SimpleMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SimpleMapObject &&
    other.runtimeType == runtimeType &&
    _CSimpleMapObject_cg_objectIdentifier(this._self) == _CSimpleMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSimpleMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SimpleMapObject <-> CSimpleMapObject

final class _CSimpleMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSimpleMapObjectBasicFunctions on _CSimpleMapObject {
  void _releaseIntermediate() {
    _CSimpleMapObject_release(_impl);
  }

  _CSimpleMapObject _retain() {
    return _CSimpleMapObject_retain(_impl);
  }
}

extension _CSimpleMapObjectToDart on _CSimpleMapObject {
  SimpleMapObject _toDart() {
    final selector = _CSimpleMapObject_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = SimpleMapObject._create(_retain()._impl);
        return res;
      case 1:
        final res = Marker._create(_retain()._impl);
        return res;
      case 2:
        final res = ModelMapObject._create(_retain()._impl);
        return res;
      case 3:
        final res = Circle._create(_retain()._impl);
        return res;
      case 4:
        final res = Polygon._create(_retain()._impl);
        return res;
      case 5:
        final res = Polyline._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCSimpleMapObject on SimpleMapObject {
  _CSimpleMapObject _copyFromDartTo_CSimpleMapObject() {
    return (_CSimpleMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapObjectManager

class MapObjectManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Переопределение видимости всех объектов, добавленных в экземпляр менеджера.
   Значение false здесь имеет приоритет над видимостью отдельного объекта.
  */
  bool get isVisible {
    bool res = _CMapObjectManager_isVisible(_CMapObjectManagerMakeDefault().._impl=_self);
    return res;
  }
  set isVisible(bool visible) {
    void res = _CMapObjectManager_setVisible_bool(_CMapObjectManagerMakeDefault().._impl=_self, visible);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapObjectManager_releasePtr);

  MapObjectManager._raw(this._self);
  factory MapObjectManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapObjectManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Создать IMapObjectManager.
  
   - Parameter layerId: ID слоя в стиле типа "Динамический объект".
   Создаваемые объекты будут размещены на этом слое,
   тем самым можно задать их порядок относительно других слоев.
   Если не задан, объекты размещаются поверх остальных слоев.
  */
  factory MapObjectManager(
    Map map,
    [String? layerId = null
    ]) {
    var _a0 = map._copyFromDartTo_CMap();
    var _a1 = layerId._copyFromDartTo_COptional_CString();
    _CMapObjectManager res = _CMapObjectManager_C_createWith_CMap_COptional_CString(_a0, _a1);
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    return MapObjectManager._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapObjectManager &&
    other.runtimeType == runtimeType &&
    _CMapObjectManager_cg_objectIdentifier(this._self) == _CMapObjectManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapObjectManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CMapObjectManager: Static Methods

  /**
   Создать IMapObjectManager с кластеризацией данных. Кластеризуются только IMarker объекты.
  
   - Parameter logicalPixel: Минимально возможное расстояние на экране между точками привязки маркеров на уровнях,
   где работает кластеризация.
   - Parameter maxZoom: Уровень, начиная с которого видны все маркеры.
   - Parameter clusterRenderer: Интерфейс для задания параметров отображения кластера.
   - Parameter minZoom: Уровень, начиная с которого формируются кластеры.
   - Parameter layerId: ID слоя в стиле типа "Динамический объект".
   Создаваемые объекты будут размещены на этом слое,
   тем самым можно задать их порядок относительно других слоев.
   Если не задан, объекты размещаются поверх остальных слоев.
  */
  static MapObjectManager withClustering(
    Map map,
    LogicalPixel logicalPixel,
    Zoom maxZoom,
    SimpleClusterRenderer clusterRenderer,
    [Zoom minZoom = const Zoom(0),
    String? layerId = null
    ])  {
    var _a0 = map._copyFromDartTo_CMap();
    var _a1 = logicalPixel._copyFromDartTo_CLogicalPixel();
    var _a2 = maxZoom._copyFromDartTo_CZoom();
    var _a3 = clusterRenderer._copyFromDartTo_CSimpleClusterRenderer();
    var _a4 = minZoom._copyFromDartTo_CZoom();
    var _a5 = layerId._copyFromDartTo_COptional_CString();
    _CMapObjectManager res = _CMapObjectManager_S_withClustering_CMap_CLogicalPixel_CZoom_CSimpleClusterRenderer_CZoom_COptional_CString(_a0, _a1, _a2, _a3, _a4, _a5);
    _a5._releaseIntermediate();
    _a3._releaseIntermediate();
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создать IMapObjectManager с генерализацией данных. Генерализуются только IMarker объекты.
  
   - Parameter logicalPixel: Минимально возможное расстояние на экране между точками привязки маркеров на уровнях,
   где работает генерализация.
   - Parameter maxZoom: Уровень, начиная с которого видны все маркеры.
   - Parameter minZoom: Уровень, начиная с которого работает генерализация.
   - Parameter layerId: ID слоя в стиле типа "Динамический объект".
   Создаваемые объекты будут размещены на этом слое,
   тем самым можно задать их порядок относительно других слоев.
   Если не задан, объекты размещаются поверх остальных слоев.
  */
  static MapObjectManager withGeneralization(
    Map map,
    LogicalPixel logicalPixel,
    Zoom maxZoom,
    [Zoom minZoom = const Zoom(0),
    String? layerId = null
    ])  {
    var _a0 = map._copyFromDartTo_CMap();
    var _a1 = logicalPixel._copyFromDartTo_CLogicalPixel();
    var _a2 = maxZoom._copyFromDartTo_CZoom();
    var _a3 = minZoom._copyFromDartTo_CZoom();
    var _a4 = layerId._copyFromDartTo_COptional_CString();
    _CMapObjectManager res = _CMapObjectManager_S_withGeneralization_CMap_CLogicalPixel_CZoom_CZoom_COptional_CString(_a0, _a1, _a2, _a3, _a4);
    _a4._releaseIntermediate();
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: MapObjectManager: Methods

  /** Добавить объект. */
  void addObject(
    SimpleMapObject item
  )  {
    var _a1 = item._copyFromDartTo_CSimpleMapObject();
    void res = _CMapObjectManager_addObject_CSimpleMapObject(_CMapObjectManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удалить объект. */
  void removeObject(
    SimpleMapObject item
  )  {
    var _a1 = item._copyFromDartTo_CSimpleMapObject();
    void res = _CMapObjectManager_removeObject_CSimpleMapObject(_CMapObjectManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Добавить объекты. */
  void addObjects(
    List<SimpleMapObject> objects
  )  {
    var _a1 = objects._copyFromDartTo_CArray_CSimpleMapObject();
    void res = _CMapObjectManager_addObjects_CArray_CSimpleMapObject(_CMapObjectManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удалить объекты. */
  void removeObjects(
    List<SimpleMapObject> objects
  )  {
    var _a1 = objects._copyFromDartTo_CArray_CSimpleMapObject();
    void res = _CMapObjectManager_removeObjects_CArray_CSimpleMapObject(_CMapObjectManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удалить и добавить объекты. */
  void removeAndAddObjects(
    List<SimpleMapObject> objectsToRemove,
    List<SimpleMapObject> objectsToAdd
  )  {
    var _a1 = objectsToRemove._copyFromDartTo_CArray_CSimpleMapObject();
    var _a2 = objectsToAdd._copyFromDartTo_CArray_CSimpleMapObject();
    void res = _CMapObjectManager_removeAndAddObjects_CArray_CSimpleMapObject_CArray_CSimpleMapObject(_CMapObjectManagerMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

  void removeAll()  {
    void res = _CMapObjectManager_removeAll(_CMapObjectManagerMakeDefault().._impl=_self);
    return res;
  }

  /**
   Получить список объектов, участвующих в кластеризации при переданной позиции камеры.
   В списке будут присутствовать как кластеры, так и маркеры.
  */
  List<MapObject> clusteringObjects(
    CameraPosition position
  )  {
    var _a1 = position._copyFromDartTo_CCameraPosition();
    _CArray_CMapObject res = _CMapObjectManager_clusteringObjects_CCameraPosition(_CMapObjectManagerMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - MapObjectManager <-> CMapObjectManager

final class _CMapObjectManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapObjectManagerBasicFunctions on _CMapObjectManager {
  void _releaseIntermediate() {
    _CMapObjectManager_release(_impl);
  }

  _CMapObjectManager _retain() {
    return _CMapObjectManager_retain(_impl);
  }
}

extension _CMapObjectManagerToDart on _CMapObjectManager {
  MapObjectManager _toDart() {
    return MapObjectManager._create(_retain()._impl);
  }
}


extension _DartToCMapObjectManager on MapObjectManager {
  _CMapObjectManager _copyFromDartTo_CMapObjectManager() {
    return (_CMapObjectManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<SimpleMapObject> <-> _CArray_CSimpleMapObject

final class _CArray_CSimpleMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSimpleMapObjectToDart on _CArray_CSimpleMapObject {
  List<SimpleMapObject> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSimpleMapObject on List<SimpleMapObject> {
  _CArray_CSimpleMapObject _copyFromDartTo_CArray_CSimpleMapObject() {
    final cArray = _CArray_CSimpleMapObjectmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSimpleMapObject();
        _CArray_CSimpleMapObjectaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CSimpleMapObjectBasicFunctions on _CArray_CSimpleMapObject {
  void _releaseIntermediate() {
    _CArray_CSimpleMapObject_release(this);
  }

  static final _listToFill = <SimpleMapObject>[];

  static void _iterate(_CSimpleMapObject item) {
    _listToFill.add(item._toDart());
  }

  List<SimpleMapObject> _fillFromC() {
    _forEach_CArray_CSimpleMapObject(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSimpleMapObject)>(_iterate));
    final result = List<SimpleMapObject>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - _SimpleClusterRendererCpp

/** Класс для кастомизации внешнего вида кластера в IMapObjectManager. */
class _SimpleClusterRendererCpp extends SimpleClusterRenderer implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSimpleClusterRendererCpp_releasePtr);

  _SimpleClusterRendererCpp._raw(this._self);
  factory _SimpleClusterRendererCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _SimpleClusterRendererCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _SimpleClusterRendererCpp &&
    other.runtimeType == runtimeType &&
    _CSimpleClusterRendererCpp_cg_objectIdentifier(this._self) == _CSimpleClusterRendererCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSimpleClusterRendererCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _SimpleClusterRendererCpp: Methods

  /**
   Получение маркера для кластера.
  
   - Parameter cluster: Объект кластера.
   - Returns: Объект маркера кластера.
  */
  SimpleClusterOptions renderCluster(
    SimpleClusterObject cluster
  )  {
    var _a1 = cluster._copyFromDartTo_CSimpleClusterObject();
    _CSimpleClusterOptions res = _CSimpleClusterRendererCpp_renderCluster_CSimpleClusterObject(_CSimpleClusterRendererCppMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - _SimpleClusterRendererCpp <-> CSimpleClusterRendererCpp

final class _CSimpleClusterRendererCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSimpleClusterRendererCppBasicFunctions on _CSimpleClusterRendererCpp {
  void _releaseIntermediate() {
    _CSimpleClusterRendererCpp_release(_impl);
  }

  _CSimpleClusterRendererCpp _retain() {
    return _CSimpleClusterRendererCpp_retain(_impl);
  }
}

extension _CSimpleClusterRendererCppToDart on _CSimpleClusterRendererCpp {
  _SimpleClusterRendererCpp _toDart() {
    return _SimpleClusterRendererCpp._create(_retain()._impl);
  }
}


extension _DartToCSimpleClusterRendererCpp on _SimpleClusterRendererCpp {
  _CSimpleClusterRendererCpp _copyFromDartTo_CSimpleClusterRendererCpp() {
    return (_CSimpleClusterRendererCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Image? <-> _COptional_CImage

final class _COptional_CImage extends ffi.Struct {
  
  external _CImage value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CImageBasicFunctions on _COptional_CImage {
  void _releaseIntermediate() {
    _COptional_CImage_release(this);
  }
}

extension _COptional_CImageToDart on _COptional_CImage {
  Image? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CImage on Image? {
  _COptional_CImage _copyFromDartTo_COptional_CImage() {
    final cOptional = _COptional_CImageMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CImage();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - MapDirection? <-> _COptional_CMapDirection

final class _COptional_CMapDirection extends ffi.Struct {
  
  external _CMapDirection value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CMapDirectionBasicFunctions on _COptional_CMapDirection {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CMapDirectionToDart on _COptional_CMapDirection {
  MapDirection? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CMapDirection on MapDirection? {
  _COptional_CMapDirection _copyFromDartTo_COptional_CMapDirection() {
    final cOptional = _COptional_CMapDirectionMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CMapDirection();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - TextStyle? <-> _COptional_CTextStyle

final class _COptional_CTextStyle extends ffi.Struct {
  
  external _CTextStyle value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CTextStyleBasicFunctions on _COptional_CTextStyle {
  void _releaseIntermediate() {
    _COptional_CTextStyle_release(this);
  }
}

extension _COptional_CTextStyleToDart on _COptional_CTextStyle {
  TextStyle? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CTextStyle on TextStyle? {
  _COptional_CTextStyle _copyFromDartTo_COptional_CTextStyle() {
    final cOptional = _COptional_CTextStyleMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CTextStyle();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - SimpleClusterOptions

/** Параметры маркера кластера простых (simple) объектов-маркеров. */
class SimpleClusterOptions {
  final Image? icon;
  final MapDirection? iconMapDirection;
  final Anchor anchor;
  final String? text;
  final TextStyle? textStyle;
  final Opacity iconOpacity;
  /** Целевая ширина, используемая для масштабирования. */
  final LogicalPixel iconWidth;
  final Object? userData;
  /** Уровень отрисовки объекта. */
  final ZIndex zIndex;
  /** Анимировать ли появление. */
  final bool animatedAppearance;
  /** Режим анимации. */
  final AnimationMode iconAnimationMode;

  const SimpleClusterOptions({
    required this.icon,
    this.iconMapDirection = null,
    this.anchor = const Anchor(x: 0.5, y: 0.5),
    this.text = null,
    this.textStyle = null,
    this.iconOpacity = const Opacity(1),
    this.iconWidth = const LogicalPixel(0),
    this.userData = const {},
    this.zIndex = const ZIndex(0),
    this.animatedAppearance = true,
    this.iconAnimationMode = AnimationMode.normal
  });

  SimpleClusterOptions copyWith({
    Optional<Image?>? icon,
    Optional<MapDirection?>? iconMapDirection,
    Anchor? anchor,
    Optional<String?>? text,
    Optional<TextStyle?>? textStyle,
    Opacity? iconOpacity,
    LogicalPixel? iconWidth,
    Optional<Object?>? userData,
    ZIndex? zIndex,
    bool? animatedAppearance,
    AnimationMode? iconAnimationMode
  }) {
    return SimpleClusterOptions(
      icon: icon != null ? icon.value : this.icon,
      iconMapDirection: iconMapDirection != null ? iconMapDirection.value : this.iconMapDirection,
      anchor: anchor ?? this.anchor,
      text: text != null ? text.value : this.text,
      textStyle: textStyle != null ? textStyle.value : this.textStyle,
      iconOpacity: iconOpacity ?? this.iconOpacity,
      iconWidth: iconWidth ?? this.iconWidth,
      userData: userData != null ? userData.value : this.userData,
      zIndex: zIndex ?? this.zIndex,
      animatedAppearance: animatedAppearance ?? this.animatedAppearance,
      iconAnimationMode: iconAnimationMode ?? this.iconAnimationMode
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SimpleClusterOptions &&
    other.runtimeType == runtimeType &&
    other.icon == icon &&
    other.iconMapDirection == iconMapDirection &&
    other.anchor == anchor &&
    other.text == text &&
    other.textStyle == textStyle &&
    other.iconOpacity == iconOpacity &&
    other.iconWidth == iconWidth &&
    other.userData == userData &&
    other.zIndex == zIndex &&
    other.animatedAppearance == animatedAppearance &&
    other.iconAnimationMode == iconAnimationMode;

  @override
  int get hashCode {
    return Object.hash(icon, iconMapDirection, anchor, text, textStyle, iconOpacity, iconWidth, userData, zIndex, animatedAppearance, iconAnimationMode);
  }

}
final class _CSimpleClusterOptions extends ffi.Struct {
  external _COptional_CImage icon;

  external _COptional_CMapDirection iconMapDirection;

  external _CAnchor anchor;

  external _COptional_CString text;

  external _COptional_CTextStyle textStyle;

  external _COpacity iconOpacity;

  external _CLogicalPixel iconWidth;

  external _CAny userData;

  external _CZIndex zIndex;

  @ffi.Bool()
  external bool animatedAppearance;

  external _CAnimationMode iconAnimationMode;

}
// MARK: - SimpleClusterOptions <-> _CSimpleClusterOptions

extension _CSimpleClusterOptionsToDart on _CSimpleClusterOptions {
  SimpleClusterOptions _toDart() {
    return SimpleClusterOptions(
      icon: this.icon._toDart(),
      iconMapDirection: this.iconMapDirection._toDart(),
      anchor: this.anchor._toDart(),
      text: this.text._toDart(),
      textStyle: this.textStyle._toDart(),
      iconOpacity: this.iconOpacity._toDart(),
      iconWidth: this.iconWidth._toDart(),
      userData: this.userData._toDart(),
      zIndex: this.zIndex._toDart(),
      animatedAppearance: this.animatedAppearance,
      iconAnimationMode: this.iconAnimationMode._toDart()
    );
  }
}

extension _DartTo_CSimpleClusterOptions on SimpleClusterOptions {
  _CSimpleClusterOptions _copyFromDartTo_CSimpleClusterOptions() {
    final res = _CSimpleClusterOptionsMakeDefault();
    res.icon = this.icon._copyFromDartTo_COptional_CImage();
    res.iconMapDirection = this.iconMapDirection._copyFromDartTo_COptional_CMapDirection();
    res.anchor = this.anchor._copyFromDartTo_CAnchor();
    res.text = this.text._copyFromDartTo_COptional_CString();
    res.textStyle = this.textStyle._copyFromDartTo_COptional_CTextStyle();
    res.iconOpacity = this.iconOpacity._copyFromDartTo_COpacity();
    res.iconWidth = this.iconWidth._copyFromDartTo_CLogicalPixel();
    res.userData = this.userData._copyFromDartTo_CAny();
    res.zIndex = this.zIndex._copyFromDartTo_CZIndex();
    res.animatedAppearance = this.animatedAppearance;
    res.iconAnimationMode = this.iconAnimationMode._copyFromDartTo_CAnimationMode();
    return res;
  }
}
extension _CSimpleClusterOptionsRelease on _CSimpleClusterOptions {
  void _releaseIntermediate() {
    icon._releaseIntermediate();
    text._releaseIntermediate();
    textStyle._releaseIntermediate();
    userData._releaseIntermediate();
  }
}

// MARK: - SimpleClusterObject

/** Кластер простых (simple) объектов-маркеров. */
class SimpleClusterObject extends MapObject implements ffi.Finalizable {
  /** Получение позиции кластера на карте. */
  GeoPointWithElevation get position {
    _CGeoPointWithElevation res = _CSimpleClusterObject_position(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение количества маркеров в кластере. */
  int get objectCount {
    int res = _CSimpleClusterObject_objectCount(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res;
  }
  /** Получение списка маркеров в кластере. */
  List<SimpleMapObject> get objects {
    _CArray_CSimpleMapObject res = _CSimpleClusterObject_objects(_CSimpleClusterObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение и установка точки привязки иконки кластера. */
  Anchor get anchor {
    _CAnchor res = _CSimpleClusterObject_anchor(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set anchor(Anchor anchor) {
    var _a1 = anchor._copyFromDartTo_CAnchor();
    void res = _CSimpleClusterObject_setAnchor_CAnchor(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение и установка прозрачности иконки кластера. */
  Opacity get iconOpacity {
    _COpacity res = _CSimpleClusterObject_iconOpacity(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconOpacity(Opacity opacity) {
    var _a1 = opacity._copyFromDartTo_COpacity();
    void res = _CSimpleClusterObject_setIconOpacity_COpacity(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение и установка подписи кластера. */
  String get text {
    _CString res = _CSimpleClusterObject_text(_CSimpleClusterObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set text(String text) {
    var _a1 = text._copyFromDartTo_CString();
    void res = _CSimpleClusterObject_setText_CString(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Получение и установка стиля подписи кластера. */
  TextStyle get textStyle {
    _CTextStyle res = _CSimpleClusterObject_textStyle(_CSimpleClusterObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set textStyle(TextStyle style) {
    var _a1 = style._copyFromDartTo_CTextStyle();
    void res = _CSimpleClusterObject_setTextStyle_CTextStyle(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Получение и установка целевой ширины кластера, используемой для масштабирования. */
  LogicalPixel get iconWidth {
    _CLogicalPixel res = _CSimpleClusterObject_iconWidth(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconWidth(LogicalPixel width) {
    var _a1 = width._copyFromDartTo_CLogicalPixel();
    void res = _CSimpleClusterObject_setIconWidth_CLogicalPixel(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение и установка угла поворота кластера на карте относительно направления на север, по часовой стрелке. */
  MapDirection? get iconMapDirection {
    _COptional_CMapDirection res = _CSimpleClusterObject_iconMapDirection(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconMapDirection(MapDirection? direction) {
    var _a1 = direction._copyFromDartTo_COptional_CMapDirection();
    void res = _CSimpleClusterObject_setIconMapDirection_COptional_CMapDirection(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение и установка флага анимируемости появления кластера. */
  bool get animatedAppearance {
    bool res = _CSimpleClusterObject_animatedAppearance(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res;
  }
  set animatedAppearance(bool animatedAppearance) {
    void res = _CSimpleClusterObject_setAnimatedAppearance_bool(_CSimpleClusterObjectMakeDefault().._impl=_self, animatedAppearance);
    return res;
  }
  /** Получение и установка уровня отрисовки объекта. */
  ZIndex get zIndex {
    _CZIndex res = _CSimpleClusterObject_zIndex(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set zIndex(ZIndex zIndex) {
    var _a1 = zIndex._copyFromDartTo_CZIndex();
    void res = _CSimpleClusterObject_setZIndex_CZIndex(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSimpleClusterObject_releasePtr);

  SimpleClusterObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory SimpleClusterObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SimpleClusterObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SimpleClusterObject &&
    other.runtimeType == runtimeType &&
    _CSimpleClusterObject_cg_objectIdentifier(this._self) == _CSimpleClusterObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSimpleClusterObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: SimpleClusterObject: Methods

  /** Установка иконки кластера. */
  void setIcon(
    Image? icon
  )  {
    var _a1 = icon._copyFromDartTo_COptional_CImage();
    void res = _CSimpleClusterObject_setIcon_COptional_CImage(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - SimpleClusterObject <-> CSimpleClusterObject

final class _CSimpleClusterObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSimpleClusterObjectBasicFunctions on _CSimpleClusterObject {
  void _releaseIntermediate() {
    _CSimpleClusterObject_release(_impl);
  }

  _CSimpleClusterObject _retain() {
    return _CSimpleClusterObject_retain(_impl);
  }
}

extension _CSimpleClusterObjectToDart on _CSimpleClusterObject {
  SimpleClusterObject _toDart() {
    return SimpleClusterObject._create(_retain()._impl);
  }
}


extension _DartToCSimpleClusterObject on SimpleClusterObject {
  _CSimpleClusterObject _copyFromDartTo_CSimpleClusterObject() {
    return (_CSimpleClusterObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SimpleClusterRenderer

/** Класс для кастомизации внешнего вида кластера в IMapObjectManager. */
abstract class SimpleClusterRenderer {
  SimpleClusterOptions renderCluster(
    SimpleClusterObject cluster
  );
}

class _SimpleClusterRenderer {
  final SimpleClusterRenderer object;
  int refCounter = 1;

  _SimpleClusterRenderer(this.object);
}

final class _CSimpleClusterRenderer extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CSimpleClusterOptions)>>, _CSimpleClusterObject)>> _renderCluster_CSimpleClusterObject;
}

extension _CSimpleClusterRendererBasicFunctions on _CSimpleClusterRenderer {
  void _releaseIntermediate() {
    _CSimpleClusterRenderer_release(this);
  }
}

int _CSimpleClusterRendererInstanceCounter = 1;
final _CSimpleClusterRendererInstanceMap = <int, _SimpleClusterRenderer>{};

extension _CSimpleClusterRendererToDart on _CSimpleClusterRenderer {
  SimpleClusterRenderer _toDart() {
    late SimpleClusterRenderer? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CSimpleClusterRendererInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CSimpleClusterRendererCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CSimpleClusterRenderer");
    }
    return result;
  }
}

extension _DartTo_CSimpleClusterRenderer on SimpleClusterRenderer {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CSimpleClusterRendererInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CSimpleClusterRendererInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CSimpleClusterRendererInstanceMap.remove(platformValue.address);
  }

  _CSimpleClusterRenderer _copyFromDartTo_CSimpleClusterRenderer() {
    var res = _CSimpleClusterRendererMakeDefault();
    if (this is _SimpleClusterRendererCpp) {
      final cppValue = this as _SimpleClusterRendererCpp;
      res._cppValue = cppValue._copyFromDartTo_CSimpleClusterRendererCpp()._impl;
      return res;
    }
    final instanceId = _CSimpleClusterRendererInstanceCounter;
    _CSimpleClusterRendererInstanceCounter += 1;
    _CSimpleClusterRendererInstanceMap[instanceId] = _SimpleClusterRenderer(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final renderCluster_CSimpleClusterObjectFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CSimpleClusterOptions)>>, _CSimpleClusterObject)>.listener(renderCluster_CSimpleClusterObjectFunction);
    res._renderCluster_CSimpleClusterObject = renderCluster_CSimpleClusterObjectFunctionCallable.nativeFunction;
    return res;
  }

  static void renderCluster_CSimpleClusterObjectFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CSimpleClusterOptions)>> resultValueCallback, _CSimpleClusterObject cluster) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CSimpleClusterRenderer");
    }
    final platformObject = _CSimpleClusterRendererInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CSimpleClusterRenderer");
    }

    final clusterDart = cluster._toDart();
    final res = platformObject.object.renderCluster(clusterDart);
    cluster._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CSimpleClusterOptions)>();
    callbackFunction(context, res._copyFromDartTo_CSimpleClusterOptions());
  }


}

// MARK: - Marker

/** Точечная отметка на карте, представляющая интерес для пользователя. */
class Marker extends SimpleMapObject implements ffi.Finalizable {
  /** Получение местоположения маркера. */
  GeoPointWithElevation get position {
    _CGeoPointWithElevation res = _CMarker_position(_CMarkerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set position(GeoPointWithElevation position) {
    var _a1 = position._copyFromDartTo_CGeoPointWithElevation();
    void res = _CMarker_setPosition_CGeoPointWithElevation(_CMarkerMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение иконки маркера. */
  Image? get icon {
    _COptional_CImage res = _CMarker_icon(_CMarkerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set icon(Image? icon) {
    var _a1 = icon._copyFromDartTo_COptional_CImage();
    void res = _CMarker_setIcon_COptional_CImage(_CMarkerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Получение точки привязки иконки маркера. */
  Anchor get anchor {
    _CAnchor res = _CMarker_anchor(_CMarkerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set anchor(Anchor anchor) {
    var _a1 = anchor._copyFromDartTo_CAnchor();
    void res = _CMarker_setAnchor_CAnchor(_CMarkerMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение прозрачности иконки маркера. */
  Opacity get iconOpacity {
    _COpacity res = _CMarker_iconOpacity(_CMarkerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconOpacity(Opacity opacity) {
    var _a1 = opacity._copyFromDartTo_COpacity();
    void res = _CMarker_setIconOpacity_COpacity(_CMarkerMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение подписи маркера. */
  String get text {
    _CString res = _CMarker_text(_CMarkerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set text(String text) {
    var _a1 = text._copyFromDartTo_CString();
    void res = _CMarker_setText_CString(_CMarkerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Получение стиля подписи маркера. */
  TextStyle get textStyle {
    _CTextStyle res = _CMarker_textStyle(_CMarkerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set textStyle(TextStyle style) {
    var _a1 = style._copyFromDartTo_CTextStyle();
    void res = _CMarker_setTextStyle_CTextStyle(_CMarkerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Получение флага перемещаемости маркера. */
  bool get isDraggable {
    bool res = _CMarker_isDraggable(_CMarkerMakeDefault().._impl=_self);
    return res;
  }
  set isDraggable(bool draggable) {
    void res = _CMarker_setDraggable_bool(_CMarkerMakeDefault().._impl=_self, draggable);
    return res;
  }
  /** Получение целевой ширины маркера, используемой для масштабирования. */
  LogicalPixel get iconWidth {
    _CLogicalPixel res = _CMarker_iconWidth(_CMarkerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconWidth(LogicalPixel width) {
    var _a1 = width._copyFromDartTo_CLogicalPixel();
    void res = _CMarker_setIconWidth_CLogicalPixel(_CMarkerMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Угол поворота маркера на карте относительно направления на север, по часовой стрелке. */
  MapDirection? get iconMapDirection {
    _COptional_CMapDirection res = _CMarker_iconMapDirection(_CMarkerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconMapDirection(MapDirection? direction) {
    var _a1 = direction._copyFromDartTo_COptional_CMapDirection();
    void res = _CMarker_setIconMapDirection_COptional_CMapDirection(_CMarkerMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Анимировать ли появление. */
  bool get animatedAppearance {
    bool res = _CMarker_animatedAppearance(_CMarkerMakeDefault().._impl=_self);
    return res;
  }
  set animatedAppearance(bool animatedAppearance) {
    void res = _CMarker_setAnimatedAppearance_bool(_CMarkerMakeDefault().._impl=_self, animatedAppearance);
    return res;
  }
  /** Получение режима анимации анимированного маркера. */
  AnimationMode get iconAnimationMode {
    _CAnimationMode res = _CMarker_iconAnimationMode(_CMarkerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconAnimationMode(AnimationMode iconAnimationMode) {
    var _a1 = iconAnimationMode._copyFromDartTo_CAnimationMode();
    void res = _CMarker_setIconAnimationMode_CAnimationMode(_CMarkerMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMarker_releasePtr);

  Marker._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Marker._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Marker._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory Marker(
    MarkerOptions options
  ) {
    var _a0 = options._copyFromDartTo_CMarkerOptions();
    _CResult_CMarker res = _CMarker_C_createWith_CMarkerOptions(_a0);
    _a0._releaseIntermediate();
    return Marker._create(res._toCDart()._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Marker &&
    other.runtimeType == runtimeType &&
    _CMarker_cg_objectIdentifier(this._self) == _CMarker_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMarker_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Marker <-> CMarker

final class _CMarker extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMarkerBasicFunctions on _CMarker {
  void _releaseIntermediate() {
    _CMarker_release(_impl);
  }

  _CMarker _retain() {
    return _CMarker_retain(_impl);
  }
}

extension _CMarkerToDart on _CMarker {
  Marker _toDart() {
    return Marker._create(_retain()._impl);
  }
}


extension _DartToCMarker on Marker {
  _CMarker _copyFromDartTo_CMarker() {
    return (_CMarkerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MarkerOptions

/** Параметры маркера. */
class MarkerOptions {
  final GeoPointWithElevation position;
  final Image? icon;
  final MapDirection? iconMapDirection;
  final Anchor anchor;
  final String? text;
  final TextStyle? textStyle;
  final Opacity iconOpacity;
  final bool visible;
  final bool draggable;
  /** Целевая ширина, используемая для масштабирования. */
  final LogicalPixel iconWidth;
  final Object? userData;
  /** Уровень отрисовки объекта. */
  final ZIndex zIndex;
  /** Анимировать ли появление. */
  final bool animatedAppearance;
  /** Привязка к поэтажному плану здания. */
  final LevelId? levelId;
  /** Режим анимации. */
  final AnimationMode iconAnimationMode;

  const MarkerOptions({
    required this.position,
    required this.icon,
    this.iconMapDirection = null,
    this.anchor = const Anchor(x: 0.5, y: 0.5),
    this.text = null,
    this.textStyle = null,
    this.iconOpacity = const Opacity(1),
    this.visible = true,
    this.draggable = false,
    this.iconWidth = const LogicalPixel(0),
    this.userData = const {},
    this.zIndex = const ZIndex(0),
    this.animatedAppearance = true,
    this.levelId = null,
    this.iconAnimationMode = AnimationMode.normal
  });

  MarkerOptions copyWith({
    GeoPointWithElevation? position,
    Optional<Image?>? icon,
    Optional<MapDirection?>? iconMapDirection,
    Anchor? anchor,
    Optional<String?>? text,
    Optional<TextStyle?>? textStyle,
    Opacity? iconOpacity,
    bool? visible,
    bool? draggable,
    LogicalPixel? iconWidth,
    Optional<Object?>? userData,
    ZIndex? zIndex,
    bool? animatedAppearance,
    Optional<LevelId?>? levelId,
    AnimationMode? iconAnimationMode
  }) {
    return MarkerOptions(
      position: position ?? this.position,
      icon: icon != null ? icon.value : this.icon,
      iconMapDirection: iconMapDirection != null ? iconMapDirection.value : this.iconMapDirection,
      anchor: anchor ?? this.anchor,
      text: text != null ? text.value : this.text,
      textStyle: textStyle != null ? textStyle.value : this.textStyle,
      iconOpacity: iconOpacity ?? this.iconOpacity,
      visible: visible ?? this.visible,
      draggable: draggable ?? this.draggable,
      iconWidth: iconWidth ?? this.iconWidth,
      userData: userData != null ? userData.value : this.userData,
      zIndex: zIndex ?? this.zIndex,
      animatedAppearance: animatedAppearance ?? this.animatedAppearance,
      levelId: levelId != null ? levelId.value : this.levelId,
      iconAnimationMode: iconAnimationMode ?? this.iconAnimationMode
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MarkerOptions &&
    other.runtimeType == runtimeType &&
    other.position == position &&
    other.icon == icon &&
    other.iconMapDirection == iconMapDirection &&
    other.anchor == anchor &&
    other.text == text &&
    other.textStyle == textStyle &&
    other.iconOpacity == iconOpacity &&
    other.visible == visible &&
    other.draggable == draggable &&
    other.iconWidth == iconWidth &&
    other.userData == userData &&
    other.zIndex == zIndex &&
    other.animatedAppearance == animatedAppearance &&
    other.levelId == levelId &&
    other.iconAnimationMode == iconAnimationMode;

  @override
  int get hashCode {
    return Object.hash(position, icon, iconMapDirection, anchor, text, textStyle, iconOpacity, visible, draggable, iconWidth, userData, zIndex, animatedAppearance, levelId, iconAnimationMode);
  }

}
final class _CMarkerOptions extends ffi.Struct {
  external _CGeoPointWithElevation position;

  external _COptional_CImage icon;

  external _COptional_CMapDirection iconMapDirection;

  external _CAnchor anchor;

  external _COptional_CString text;

  external _COptional_CTextStyle textStyle;

  external _COpacity iconOpacity;

  @ffi.Bool()
  external bool visible;

  @ffi.Bool()
  external bool draggable;

  external _CLogicalPixel iconWidth;

  external _CAny userData;

  external _CZIndex zIndex;

  @ffi.Bool()
  external bool animatedAppearance;

  external _COptional_CLevelId levelId;

  external _CAnimationMode iconAnimationMode;

}
// MARK: - MarkerOptions <-> _CMarkerOptions

extension _CMarkerOptionsToDart on _CMarkerOptions {
  MarkerOptions _toDart() {
    return MarkerOptions(
      position: this.position._toDart(),
      icon: this.icon._toDart(),
      iconMapDirection: this.iconMapDirection._toDart(),
      anchor: this.anchor._toDart(),
      text: this.text._toDart(),
      textStyle: this.textStyle._toDart(),
      iconOpacity: this.iconOpacity._toDart(),
      visible: this.visible,
      draggable: this.draggable,
      iconWidth: this.iconWidth._toDart(),
      userData: this.userData._toDart(),
      zIndex: this.zIndex._toDart(),
      animatedAppearance: this.animatedAppearance,
      levelId: this.levelId._toDart(),
      iconAnimationMode: this.iconAnimationMode._toDart()
    );
  }
}

extension _DartTo_CMarkerOptions on MarkerOptions {
  _CMarkerOptions _copyFromDartTo_CMarkerOptions() {
    final res = _CMarkerOptionsMakeDefault();
    res.position = this.position._copyFromDartTo_CGeoPointWithElevation();
    res.icon = this.icon._copyFromDartTo_COptional_CImage();
    res.iconMapDirection = this.iconMapDirection._copyFromDartTo_COptional_CMapDirection();
    res.anchor = this.anchor._copyFromDartTo_CAnchor();
    res.text = this.text._copyFromDartTo_COptional_CString();
    res.textStyle = this.textStyle._copyFromDartTo_COptional_CTextStyle();
    res.iconOpacity = this.iconOpacity._copyFromDartTo_COpacity();
    res.visible = this.visible;
    res.draggable = this.draggable;
    res.iconWidth = this.iconWidth._copyFromDartTo_CLogicalPixel();
    res.userData = this.userData._copyFromDartTo_CAny();
    res.zIndex = this.zIndex._copyFromDartTo_CZIndex();
    res.animatedAppearance = this.animatedAppearance;
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    res.iconAnimationMode = this.iconAnimationMode._copyFromDartTo_CAnimationMode();
    return res;
  }
}
extension _CMarkerOptionsRelease on _CMarkerOptions {
  void _releaseIntermediate() {
    icon._releaseIntermediate();
    text._releaseIntermediate();
    textStyle._releaseIntermediate();
    userData._releaseIntermediate();
  }
}

// MARK: - Marker <-> _CResult_CMarker

final class _CResult_CMarkerImpl extends ffi.Union {
  
  external _CMarker _value;
  external _CError _error;
}

final class _CResult_CMarker extends ffi.Struct {
  external _CResult_CMarkerImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CMarkerBasicFunctions on _CResult_CMarker {
  void _releaseIntermediate() {
    _CResult_CMarker_release(this);
  }
}

extension _CResult_CMarkerToDart on _CResult_CMarker {
  Marker _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CMarker _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - _ModelDataLoaderCpp

/** Загрузчик данных модели. */
class _ModelDataLoaderCpp extends ModelDataLoader implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CModelDataLoaderCpp_releasePtr);

  _ModelDataLoaderCpp._raw(this._self);
  factory _ModelDataLoaderCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _ModelDataLoaderCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _ModelDataLoaderCpp &&
    other.runtimeType == runtimeType &&
    _CModelDataLoaderCpp_cg_objectIdentifier(this._self) == _CModelDataLoaderCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CModelDataLoaderCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _ModelDataLoaderCpp: Methods

  ByteData load()  {
    _CData res = _CModelDataLoaderCpp_load(_CModelDataLoaderCppMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - _ModelDataLoaderCpp <-> CModelDataLoaderCpp

final class _CModelDataLoaderCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CModelDataLoaderCppBasicFunctions on _CModelDataLoaderCpp {
  void _releaseIntermediate() {
    _CModelDataLoaderCpp_release(_impl);
  }

  _CModelDataLoaderCpp _retain() {
    return _CModelDataLoaderCpp_retain(_impl);
  }
}

extension _CModelDataLoaderCppToDart on _CModelDataLoaderCpp {
  _ModelDataLoaderCpp _toDart() {
    return _ModelDataLoaderCpp._create(_retain()._impl);
  }
}


extension _DartToCModelDataLoaderCpp on _ModelDataLoaderCpp {
  _CModelDataLoaderCpp _copyFromDartTo_CModelDataLoaderCpp() {
    return (_CModelDataLoaderCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ModelDataLoader

/** Загрузчик данных модели. */
@internal
abstract class ModelDataLoader {
  ByteData load();
}

class _ModelDataLoader {
  final ModelDataLoader object;
  int refCounter = 1;

  _ModelDataLoader(this.object);
}

final class _CModelDataLoader extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CData)>>)>> _load;
}

extension _CModelDataLoaderBasicFunctions on _CModelDataLoader {
  void _releaseIntermediate() {
    _CModelDataLoader_release(this);
  }
}

int _CModelDataLoaderInstanceCounter = 1;
final _CModelDataLoaderInstanceMap = <int, _ModelDataLoader>{};

extension _CModelDataLoaderToDart on _CModelDataLoader {
  ModelDataLoader _toDart() {
    late ModelDataLoader? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CModelDataLoaderInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CModelDataLoaderCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CModelDataLoader");
    }
    return result;
  }
}

extension _DartTo_CModelDataLoader on ModelDataLoader {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CModelDataLoaderInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CModelDataLoaderInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CModelDataLoaderInstanceMap.remove(platformValue.address);
  }

  _CModelDataLoader _copyFromDartTo_CModelDataLoader() {
    var res = _CModelDataLoaderMakeDefault();
    if (this is _ModelDataLoaderCpp) {
      final cppValue = this as _ModelDataLoaderCpp;
      res._cppValue = cppValue._copyFromDartTo_CModelDataLoaderCpp()._impl;
      return res;
    }
    final instanceId = _CModelDataLoaderInstanceCounter;
    _CModelDataLoaderInstanceCounter += 1;
    _CModelDataLoaderInstanceMap[instanceId] = _ModelDataLoader(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final loadFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CData)>>)>.listener(loadFunction);
    res._load = loadFunctionCallable.nativeFunction;
    return res;
  }

  static void loadFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CData)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CModelDataLoader");
    }
    final platformObject = _CModelDataLoaderInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CModelDataLoader");
    }

    final res = platformObject.object.load();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CData)>();
    callbackFunction(context, res._copyFromDartTo_CData());
  }


}

// MARK: - ModelSize

/**
 Размер модели.
 Если LogicalPixel, то размер модели не будет привязан к масштабу карты и останется неизменным относительно экрана.
 Если ModelScale, то размер модели умножится на коэффициент и привяжется к масштабу карты.
*/
final class ModelSize {
  final Object? _value;
  final int _index;

  ModelSize._raw(this._value, this._index);

  ModelSize.logicalPixel(LogicalPixel value) : this._raw(value, 0);
  ModelSize.scale(ModelScale value) : this._raw(value, 1);

  bool get isLogicalPixel => this._index == 0;
  LogicalPixel? get asLogicalPixel => this.isLogicalPixel ? this._value as LogicalPixel : null;

  bool get isScale => this._index == 1;
  ModelScale? get asScale => this.isScale ? this._value as ModelScale : null;

  T match<T>({
    required T Function(LogicalPixel value) logicalPixel,
    required T Function(ModelScale value) scale,
  }) {
    return switch (this._index) {
      0 => logicalPixel(this._value as LogicalPixel),
      1 => scale(this._value as ModelScale),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "ModelSize(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ModelSize &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CModelSizeImpl extends ffi.Union {
  external _CLogicalPixel _logicalPixel;
  external _CModelScale _scale;
}

final class _CModelSize extends ffi.Struct {
  external _CModelSizeImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CModelSizeBasicFunctions on _CModelSize {
  void _releaseIntermediate() {
    _CModelSize_release(this);
  }
}
	
// MARK: - ModelSize <-> CModelSize

extension _CModelSizeToDart on _CModelSize {
  ModelSize _toDart() {
    return switch (this._index) {
      0 => ModelSize.logicalPixel(this._impl._logicalPixel._toDart()),
      1 => ModelSize.scale(this._impl._scale._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CModelSize on ModelSize {
  _CModelSize _copyFromDartTo_CModelSize() {
    var res = _CModelSizeMakeDefault();
    this.match<void>(
      logicalPixel: (LogicalPixel value) {
        res._impl._logicalPixel = value._copyFromDartTo_CLogicalPixel();
        res._index = 0;
      },
      scale: (ModelScale value) {
        res._impl._scale = value._copyFromDartTo_CModelScale();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - ModelMapObjectOptions

/** Параметры модели. */
class ModelMapObjectOptions {
  /** Местоположение. */
  final GeoPointWithElevation position;
  /** Данные. */
  final ModelData? data;
  /** Целевая ширина, используемая для масштабирования. */
  final ModelSize size;
  /** Угол поворота модели на карте относительно направления на север, по часовой стрелке. */
  final MapDirection? mapDirection;
  /** Прозрачность. */
  final Opacity opacity;
  /** Видимость. */
  final bool visible;
  /** Пользовательские данные. */
  final Object? userData;
  /** Привязка к поэтажному плану здания. */
  final LevelId? levelId;

  const ModelMapObjectOptions({
    required this.position,
    required this.data,
    required this.size,
    this.mapDirection = null,
    this.opacity = const Opacity(1),
    this.visible = true,
    this.userData = const {},
    this.levelId = null
  });

  ModelMapObjectOptions copyWith({
    GeoPointWithElevation? position,
    Optional<ModelData?>? data,
    ModelSize? size,
    Optional<MapDirection?>? mapDirection,
    Opacity? opacity,
    bool? visible,
    Optional<Object?>? userData,
    Optional<LevelId?>? levelId
  }) {
    return ModelMapObjectOptions(
      position: position ?? this.position,
      data: data != null ? data.value : this.data,
      size: size ?? this.size,
      mapDirection: mapDirection != null ? mapDirection.value : this.mapDirection,
      opacity: opacity ?? this.opacity,
      visible: visible ?? this.visible,
      userData: userData != null ? userData.value : this.userData,
      levelId: levelId != null ? levelId.value : this.levelId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ModelMapObjectOptions &&
    other.runtimeType == runtimeType &&
    other.position == position &&
    other.data == data &&
    other.size == size &&
    other.mapDirection == mapDirection &&
    other.opacity == opacity &&
    other.visible == visible &&
    other.userData == userData &&
    other.levelId == levelId;

  @override
  int get hashCode {
    return Object.hash(position, data, size, mapDirection, opacity, visible, userData, levelId);
  }

}
final class _CModelMapObjectOptions extends ffi.Struct {
  external _CGeoPointWithElevation position;

  external _COptional_CModelData data;

  external _CModelSize size;

  external _COptional_CMapDirection mapDirection;

  external _COpacity opacity;

  @ffi.Bool()
  external bool visible;

  external _CAny userData;

  external _COptional_CLevelId levelId;

}
// MARK: - ModelMapObjectOptions <-> _CModelMapObjectOptions

extension _CModelMapObjectOptionsToDart on _CModelMapObjectOptions {
  ModelMapObjectOptions _toDart() {
    return ModelMapObjectOptions(
      position: this.position._toDart(),
      data: this.data._toDart(),
      size: this.size._toDart(),
      mapDirection: this.mapDirection._toDart(),
      opacity: this.opacity._toDart(),
      visible: this.visible,
      userData: this.userData._toDart(),
      levelId: this.levelId._toDart()
    );
  }
}

extension _DartTo_CModelMapObjectOptions on ModelMapObjectOptions {
  _CModelMapObjectOptions _copyFromDartTo_CModelMapObjectOptions() {
    final res = _CModelMapObjectOptionsMakeDefault();
    res.position = this.position._copyFromDartTo_CGeoPointWithElevation();
    res.data = this.data._copyFromDartTo_COptional_CModelData();
    res.size = this.size._copyFromDartTo_CModelSize();
    res.mapDirection = this.mapDirection._copyFromDartTo_COptional_CMapDirection();
    res.opacity = this.opacity._copyFromDartTo_COpacity();
    res.visible = this.visible;
    res.userData = this.userData._copyFromDartTo_CAny();
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    return res;
  }
}
extension _CModelMapObjectOptionsRelease on _CModelMapObjectOptions {
  void _releaseIntermediate() {
    data._releaseIntermediate();
    userData._releaseIntermediate();
  }
}

// MARK: - ModelMapObject

/** Модель на карте. */
class ModelMapObject extends SimpleMapObject implements ffi.Finalizable {
  /** Местоположения модели. */
  GeoPointWithElevation get position {
    _CGeoPointWithElevation res = _CModelMapObject_position(_CModelMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set position(GeoPointWithElevation position) {
    var _a1 = position._copyFromDartTo_CGeoPointWithElevation();
    void res = _CModelMapObject_setPosition_CGeoPointWithElevation(_CModelMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Данные модели. */
  ModelData? get modelData {
    _COptional_CModelData res = _CModelMapObject_modelData(_CModelMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set modelData(ModelData? model) {
    var _a1 = model._copyFromDartTo_COptional_CModelData();
    void res = _CModelMapObject_setModelData_COptional_CModelData(_CModelMapObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Прозрачность модели. */
  Opacity get opacity {
    _COpacity res = _CModelMapObject_opacity(_CModelMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set opacity(Opacity opacity) {
    var _a1 = opacity._copyFromDartTo_COpacity();
    void res = _CModelMapObject_setOpacity_COpacity(_CModelMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Размер модели. */
  ModelSize get size {
    _CModelSize res = _CModelMapObject_size(_CModelMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set size(ModelSize width) {
    var _a1 = width._copyFromDartTo_CModelSize();
    void res = _CModelMapObject_setSize_CModelSize(_CModelMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Угол поворота модели на карте относительно направления на север, по часовой стрелке. */
  MapDirection? get mapDirection {
    _COptional_CMapDirection res = _CModelMapObject_mapDirection(_CModelMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set mapDirection(MapDirection? direction) {
    var _a1 = direction._copyFromDartTo_COptional_CMapDirection();
    void res = _CModelMapObject_setMapDirection_COptional_CMapDirection(_CModelMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Настройки анимации. */
  AnimationSettings get animationSettings {
    _CAnimationSettings res = _CModelMapObject_animationSettings(_CModelMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CModelMapObject_releasePtr);

  ModelMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory ModelMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ModelMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory ModelMapObject(
    ModelMapObjectOptions options
  ) {
    var _a0 = options._copyFromDartTo_CModelMapObjectOptions();
    _CResult_CModelMapObject res = _CModelMapObject_C_createWith_CModelMapObjectOptions(_a0);
    _a0._releaseIntermediate();
    return ModelMapObject._create(res._toCDart()._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ModelMapObject &&
    other.runtimeType == runtimeType &&
    _CModelMapObject_cg_objectIdentifier(this._self) == _CModelMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CModelMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ModelMapObject <-> CModelMapObject

final class _CModelMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CModelMapObjectBasicFunctions on _CModelMapObject {
  void _releaseIntermediate() {
    _CModelMapObject_release(_impl);
  }

  _CModelMapObject _retain() {
    return _CModelMapObject_retain(_impl);
  }
}

extension _CModelMapObjectToDart on _CModelMapObject {
  ModelMapObject _toDart() {
    return ModelMapObject._create(_retain()._impl);
  }
}


extension _DartToCModelMapObject on ModelMapObject {
  _CModelMapObject _copyFromDartTo_CModelMapObject() {
    return (_CModelMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ModelMapObject <-> _CResult_CModelMapObject

final class _CResult_CModelMapObjectImpl extends ffi.Union {
  
  external _CModelMapObject _value;
  external _CError _error;
}

final class _CResult_CModelMapObject extends ffi.Struct {
  external _CResult_CModelMapObjectImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CModelMapObjectBasicFunctions on _CResult_CModelMapObject {
  void _releaseIntermediate() {
    _CResult_CModelMapObject_release(this);
  }
}

extension _CResult_CModelMapObjectToDart on _CResult_CModelMapObject {
  ModelMapObject _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CModelMapObject _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - createModelData

@internal
ModelData createModelData(
  Context context,
  ModelDataLoader loader
){
  var _a0 = context._copyFromDartTo_CContext();
  var _a1 = loader._copyFromDartTo_CModelDataLoader();
  _CModelData res = _CFunction_G_createModelData_With_CContext_CModelDataLoader(_a0, _a1);
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - parseGeoJsonFile

List<GeometryMapObject> parseGeoJsonFile(
  String fsPath
){
  var _a0 = fsPath._copyFromDartTo_CString();
  _CArray_CGeometryMapObject res = _CFunction_G_parseGeoJsonFile_With_CString(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - parseGeoJson

List<GeometryMapObject> parseGeoJson(
  String geoJsonData
){
  var _a0 = geoJsonData._copyFromDartTo_CString();
  _CArray_CGeometryMapObject res = _CFunction_G_parseGeoJson_With_CString(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - calcPositionForGeometry

CameraPosition calcPositionForGeometry(
  BaseCamera camera,
  Geometry geometry,
  StyleZoomToTiltRelation? styleZoomToTiltRelation,
  Padding? screenArea,
  Tilt? tilt,
  Bearing? bearing,
  ScreenSize? size
){
  var _a0 = camera._copyFromDartTo_CBaseCamera();
  var _a1 = geometry._copyFromDartTo_CGeometry();
  var _a2 = styleZoomToTiltRelation._copyFromDartTo_COptional_CStyleZoomToTiltRelation();
  var _a3 = screenArea._copyFromDartTo_COptional_CPadding();
  var _a4 = tilt._copyFromDartTo_COptional_CTilt();
  var _a5 = bearing._copyFromDartTo_COptional_CBearing();
  var _a6 = size._copyFromDartTo_COptional_CScreenSize();
  _CCameraPosition res = _CFunction_G_calcPositionForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSize(_a0, _a1, _a2, _a3, _a4, _a5, _a6);
  _a2._releaseIntermediate();
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  return res._toDart();
}

// MARK: - Padding? <-> _COptional_CPadding

final class _COptional_CPadding extends ffi.Struct {
  
  external _CPadding value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CPaddingBasicFunctions on _COptional_CPadding {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CPaddingToDart on _COptional_CPadding {
  Padding? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CPadding on Padding? {
  _COptional_CPadding _copyFromDartTo_COptional_CPadding() {
    final cOptional = _COptional_CPaddingMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CPadding();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ScreenSize? <-> _COptional_CScreenSize

final class _COptional_CScreenSize extends ffi.Struct {
  
  external _CScreenSize value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CScreenSizeBasicFunctions on _COptional_CScreenSize {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CScreenSizeToDart on _COptional_CScreenSize {
  ScreenSize? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CScreenSize on ScreenSize? {
  _COptional_CScreenSize _copyFromDartTo_COptional_CScreenSize() {
    final cOptional = _COptional_CScreenSizeMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CScreenSize();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - calcPositionForObjects

CameraPosition calcPositionForObjects(
  BaseCamera camera,
  List<SimpleMapObject> objects,
  StyleZoomToTiltRelation? styleZoomToTiltRelation,
  Padding? screenArea,
  Tilt? tilt,
  Bearing? bearing,
  ScreenSize? size
){
  var _a0 = camera._copyFromDartTo_CBaseCamera();
  var _a1 = objects._copyFromDartTo_CArray_CSimpleMapObject();
  var _a2 = styleZoomToTiltRelation._copyFromDartTo_COptional_CStyleZoomToTiltRelation();
  var _a3 = screenArea._copyFromDartTo_COptional_CPadding();
  var _a4 = tilt._copyFromDartTo_COptional_CTilt();
  var _a5 = bearing._copyFromDartTo_COptional_CBearing();
  var _a6 = size._copyFromDartTo_COptional_CScreenSize();
  _CCameraPosition res = _CFunction_G_calcPositionForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSize(_a0, _a1, _a2, _a3, _a4, _a5, _a6);
  _a2._releaseIntermediate();
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  return res._toDart();
}

// MARK: - zoomOutToFitForGeometry

CameraPosition zoomOutToFitForGeometry(
  BaseCamera camera,
  Geometry geometry,
  [StyleZoomToTiltRelation? styleZoomToTiltRelation = null,
  ScreenSize? size = null
  ]){
  var _a0 = camera._copyFromDartTo_CBaseCamera();
  var _a1 = geometry._copyFromDartTo_CGeometry();
  var _a2 = styleZoomToTiltRelation._copyFromDartTo_COptional_CStyleZoomToTiltRelation();
  var _a3 = size._copyFromDartTo_COptional_CScreenSize();
  _CCameraPosition res = _CFunction_G_zoomOutToFitForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CScreenSize(_a0, _a1, _a2, _a3);
  _a2._releaseIntermediate();
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  return res._toDart();
}

// MARK: - zoomOutToFitForObjects

CameraPosition zoomOutToFitForObjects(
  BaseCamera camera,
  List<SimpleMapObject> objects,
  [StyleZoomToTiltRelation? styleZoomToTiltRelation = null,
  ScreenSize? size = null
  ]){
  var _a0 = camera._copyFromDartTo_CBaseCamera();
  var _a1 = objects._copyFromDartTo_CArray_CSimpleMapObject();
  var _a2 = styleZoomToTiltRelation._copyFromDartTo_COptional_CStyleZoomToTiltRelation();
  var _a3 = size._copyFromDartTo_COptional_CScreenSize();
  _CCameraPosition res = _CFunction_G_zoomOutToFitForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CScreenSize(_a0, _a1, _a2, _a3);
  _a2._releaseIntermediate();
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  return res._toDart();
}

// MARK: - createImage

@internal
Image createImage(
  Context context,
  ImageLoader loader
){
  var _a0 = context._copyFromDartTo_CContext();
  var _a1 = loader._copyFromDartTo_CImageLoader();
  _CImage res = _CFunction_G_createImage_With_CContext_CImageLoader(_a0, _a1);
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - createDefaultMaxTiltRestriction

/** Получаем стандартную зависимость максимального угла наклона от стилевого уровня масштабирования. */
StyleZoomToTiltRelation createDefaultMaxTiltRestriction(){
  _CStyleZoomToTiltRelation res = _CFunction_G_createDefaultMaxTiltRestriction();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - createDefaultStyleZoomToTiltRelation

/**
 Получение зависимости угла наклона камеры от стилевого уровня масштабирования
 для стандартного контроллера слежения за наклоном.
*/
StyleZoomToTiltRelation createDefaultStyleZoomToTiltRelation(){
  _CStyleZoomToTiltRelation res = _CFunction_G_createDefaultStyleZoomToTiltRelation();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - createStyleZoomToTiltRelation

/**
 Создаем зависимость угла наклона камеры от стилевого уровня масштабирования.

 - Parameter points: Точки, по которым строится зависимость.
 - Returns: зависимость угла наклона камеры от стилевого уровня масштабирования, если создать зависимость не
 удалось - бросаем исключение.
 - Note: Зависимость должна представлять собой монотонную непрерывную функцию.
 Если точками задана зависимость, не удовлетворяющая условиям, то функция бросает исключение.
 Зависимость, примерно как в 2гис, можно задать последовательностью точек [(17, 0), (19, 15), (20, 25)] в режиме карты
 и [(15, 0), (16, 34), (17, 48)] в режиме навигатора.
 Пусть нужно получить значение угла наклона камеры T для стилевого уровня масштабирования Z, такого что Z0
 <
 = Z
 <
 Z1 и
 зависимость задана точками [(Z0, T0), (Z1, T1)]. Тогда искомое значение рассчитывается по формуле
 T = T0 + k * (T1 - T0), где k = (Z - Z0) / (Z1 - Z0). Если Z
 <
 Z0, то T = T0. Если Z >= Z1, то T = T1.
*/
StyleZoomToTiltRelation createStyleZoomToTiltRelation(
  core.Map<StyleZoom, Tilt> points
){
  var _a0 = points._copyFromDartTo_CDictionary_CStyleZoom_CTilt();
  _CStyleZoomToTiltRelation res = _CFunction_G_createStyleZoomToTiltRelation_With_CDictionary_CStyleZoom_CTilt(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - core.Map<StyleZoom, Tilt> <-> _CDictionary_CStyleZoom_CTilt

final class _CDictionary_CStyleZoom_CTilt extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDictionary_CStyleZoom_CTiltToDart on _CDictionary_CStyleZoom_CTilt {
  core.Map<StyleZoom, Tilt> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CDictionary_CStyleZoom_CTilt on core.Map<StyleZoom, Tilt> {
  _CDictionary_CStyleZoom_CTilt _copyFromDartTo_CDictionary_CStyleZoom_CTilt() {
    final cDict = _CDictionary_CStyleZoom_CTiltmakeEmpty();
    forEach((k, v) {
        final cKey = k._copyFromDartTo_CStyleZoom();
        final cValue = v._copyFromDartTo_CTilt();
        _CDictionary_CStyleZoom_CTiltaddElement(cDict, cKey, cValue);
        
        
    });
    return cDict;
  }
}

extension _CDictionary_CStyleZoom_CTiltBasicFunctions on _CDictionary_CStyleZoom_CTilt {
  void _releaseIntermediate() {
    _CDictionary_CStyleZoom_CTilt_release(this);
  }

  static final _mapToFill = <StyleZoom, Tilt>{};

  static void _iterate(_CStyleZoom key, _CTilt value) {
    _mapToFill.putIfAbsent(key._toDart(), () => value._toDart());
  }

  core.Map<StyleZoom, Tilt> _fillFromC() {
    _forEach_CDictionary_CStyleZoom_CTilt(this, ffi.Pointer.fromFunction<ffi.Void Function(_CStyleZoom, _CTilt value)>(_iterate));
    final result = core.Map<StyleZoom, Tilt>.from(_mapToFill);
    _mapToFill.clear();
    return result;
  }
}
	
// MARK: - projectionZToStyleZ

StyleZoom projectionZToStyleZ(
  Zoom projectionZ,
  Latitude latitude
){
  var _a0 = projectionZ._copyFromDartTo_CZoom();
  var _a1 = latitude._copyFromDartTo_CLatitude();
  _CStyleZoom res = _CFunction_G_projectionZToStyleZ_With_CZoom_CLatitude(_a0, _a1);
  return res._toDart();
}

// MARK: - styleZToProjectionZ

Zoom styleZToProjectionZ(
  StyleZoom styleZ,
  Latitude latitude
){
  var _a0 = styleZ._copyFromDartTo_CStyleZoom();
  var _a1 = latitude._copyFromDartTo_CLatitude();
  _CZoom res = _CFunction_G_styleZToProjectionZ_With_CStyleZoom_CLatitude(_a0, _a1);
  return res._toDart();
}

// MARK: - toMapGeometry

/** Преобразовать геометрию маршрута в IGeometryPtr. */
Geometry toMapGeometry(
  GeoPointRouteAttribute geometry
){
  var _a0 = geometry._copyFromDartTo_CGeoPointRouteAttribute();
  _CGeometry res = _CFunction_G_toMapGeometry_With_CGeoPointRouteAttribute(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - GeoPointRouteAttribute

/**
 Контейнер, который описывает точечный атрибут маршрута.
 Каждый элемент хранится в виде точки на маршруте, в которой этот элемент расположен и значения самого элемента.
*/
class GeoPointRouteAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CGeoPointRouteAttribute_size(_CGeoPointRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CGeoPointRouteAttribute_isEmpty(_CGeoPointRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  GeoPointRouteEntry? get first {
    _COptional_CGeoPointRouteEntry res = _CGeoPointRouteAttribute_first(_CGeoPointRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  GeoPointRouteEntry? get last {
    _COptional_CGeoPointRouteEntry res = _CGeoPointRouteAttribute_last(_CGeoPointRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<GeoPointRouteEntry> get entries {
    _CArray_CGeoPointRouteEntry res = _CGeoPointRouteAttribute_entries(_CGeoPointRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Длина маршрута. */
  RouteDistance get length {
    _CRouteDistance res = _CGeoPointRouteAttribute_length(_CGeoPointRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CGeoPointRouteAttribute_releasePtr);

  GeoPointRouteAttribute._raw(this._self);
  factory GeoPointRouteAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GeoPointRouteAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeoPointRouteAttribute &&
    other.runtimeType == runtimeType &&
    _CGeoPointRouteAttribute_cg_objectIdentifier(this._self) == _CGeoPointRouteAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGeoPointRouteAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: GeoPointRouteAttribute: Methods

  /**
   Элементы, попадающие в отрезок [begin, end).
  
   - Throws: Exception если begin > end.
  */
  List<GeoPointRouteEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CGeoPointRouteEntry res = _CGeoPointRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CGeoPointRouteAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого
   <
   = point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  GeoPointRouteEntry? findNearBackward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CGeoPointRouteEntry res = _CGeoPointRouteAttribute_findNearBackward_CRoutePoint(_CGeoPointRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Найти ближайший элемент, позиция которого >= point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  GeoPointRouteEntry? findNearForward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CGeoPointRouteEntry res = _CGeoPointRouteAttribute_findNearForward_CRoutePoint(_CGeoPointRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Вычисляет GeoPoint по известной RoutePoint.
  
   - Returns: Вычисленные географические координаты и направление сегмента, на который указывает параметр route_point.
   Если маршрут пустой или route_point выходит за пределы маршрута, то возвращается null.
   - Note: Сложность операции O(log2(N)), где N = route_geometry.size()
  */
  SegmentGeoPoint? calculateGeoPoint(
    RoutePoint routePoint
  )  {
    var _a1 = routePoint._copyFromDartTo_CRoutePoint();
    _COptional_CSegmentGeoPoint res = _CGeoPointRouteAttribute_calculateGeoPoint_CRoutePoint(_CGeoPointRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Вычисляет ближайшую точку на маршруте к заданной в географических координатах точке.
  
   - Parameter routeGeometry: Геометрия маршрута.
   - Parameter point: Проецируемая на маршрут точка.
   - Returns: Ближайшая точка на маршруте. Если маршрут пустой, либо точки range.first и range.second одновременно
   лежат либо до маршрута, либо после, то возвращается null.
   - Note: Сложность операции O(N), где N = route_geometry.size()
  */
  RoutePoint? calculateClosestPoint(
    GeoPoint point
  )  {
    var _a1 = point._copyFromDartTo_CGeoPoint();
    _COptional_CRoutePoint res = _CGeoPointRouteAttribute_calculateClosestPoint_CGeoPoint(_CGeoPointRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

}

// MARK: - GeoPointRouteAttribute <-> CGeoPointRouteAttribute

final class _CGeoPointRouteAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGeoPointRouteAttributeBasicFunctions on _CGeoPointRouteAttribute {
  void _releaseIntermediate() {
    _CGeoPointRouteAttribute_release(_impl);
  }

  _CGeoPointRouteAttribute _retain() {
    return _CGeoPointRouteAttribute_retain(_impl);
  }
}

extension _CGeoPointRouteAttributeToDart on _CGeoPointRouteAttribute {
  GeoPointRouteAttribute _toDart() {
    return GeoPointRouteAttribute._create(_retain()._impl);
  }
}


extension _DartToCGeoPointRouteAttribute on GeoPointRouteAttribute {
  _CGeoPointRouteAttribute _copyFromDartTo_CGeoPointRouteAttribute() {
    return (_CGeoPointRouteAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RouteDistance

/** Расстояние вдоль маршрута. */
class RouteDistance {
  final int millimeters;

  const RouteDistance([this.millimeters = 0]);

  RouteDistance copyWith({
    int? millimeters
  }) {
    return RouteDistance(
      millimeters ?? this.millimeters
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteDistance &&
    other.runtimeType == runtimeType &&
    other.millimeters == millimeters;

  @override
  int get hashCode {
    return millimeters.hashCode;
  }

}
final class _CRouteDistance extends ffi.Struct {
  @ffi.Int64()
  external int millimeters;

}
// MARK: - RouteDistance <-> _CRouteDistance

extension _CRouteDistanceToDart on _CRouteDistance {
  RouteDistance _toDart() {
    return RouteDistance(
      this.millimeters
    );
  }
}

extension _DartTo_CRouteDistance on RouteDistance {
  _CRouteDistance _copyFromDartTo_CRouteDistance() {
    final res = _CRouteDistanceMakeDefault();
    res.millimeters = this.millimeters;
    return res;
  }
}
extension _CRouteDistanceRelease on _CRouteDistance {
  void _releaseIntermediate() {
  }
}

// MARK: - RoutePoint

/** Точка на маршруте, задается как расстояние вдоль маршрута относительно начала маршрута. */
class RoutePoint {
  final RouteDistance distance;

  const RoutePoint(this.distance);

  RoutePoint copyWith({
    RouteDistance? distance
  }) {
    return RoutePoint(
      distance ?? this.distance
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoutePoint &&
    other.runtimeType == runtimeType &&
    other.distance == distance;

  @override
  int get hashCode {
    return distance.hashCode;
  }

}
final class _CRoutePoint extends ffi.Struct {
  external _CRouteDistance distance;

}
// MARK: - RoutePoint <-> _CRoutePoint

extension _CRoutePointToDart on _CRoutePoint {
  RoutePoint _toDart() {
    return RoutePoint(
      this.distance._toDart()
    );
  }
}

extension _DartTo_CRoutePoint on RoutePoint {
  _CRoutePoint _copyFromDartTo_CRoutePoint() {
    final res = _CRoutePointMakeDefault();
    res.distance = this.distance._copyFromDartTo_CRouteDistance();
    return res;
  }
}
extension _CRoutePointRelease on _CRoutePoint {
  void _releaseIntermediate() {
  }
}

// MARK: - GeoPointRouteEntry

/** Элемент маршрута - точка и значение в ней. */
class GeoPointRouteEntry {
  final RoutePoint point;
  final GeoPoint value;

  const GeoPointRouteEntry({
    required this.point,
    required this.value
  });

  GeoPointRouteEntry copyWith({
    RoutePoint? point,
    GeoPoint? value
  }) {
    return GeoPointRouteEntry(
      point: point ?? this.point,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeoPointRouteEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, value);
  }

}
final class _CGeoPointRouteEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CGeoPoint value;

}
// MARK: - GeoPointRouteEntry <-> _CGeoPointRouteEntry

extension _CGeoPointRouteEntryToDart on _CGeoPointRouteEntry {
  GeoPointRouteEntry _toDart() {
    return GeoPointRouteEntry(
      point: this.point._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CGeoPointRouteEntry on GeoPointRouteEntry {
  _CGeoPointRouteEntry _copyFromDartTo_CGeoPointRouteEntry() {
    final res = _CGeoPointRouteEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.value = this.value._copyFromDartTo_CGeoPoint();
    return res;
  }
}
extension _CGeoPointRouteEntryRelease on _CGeoPointRouteEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - GeoPointRouteEntry? <-> _COptional_CGeoPointRouteEntry

final class _COptional_CGeoPointRouteEntry extends ffi.Struct {
  
  external _CGeoPointRouteEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGeoPointRouteEntryBasicFunctions on _COptional_CGeoPointRouteEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CGeoPointRouteEntryToDart on _COptional_CGeoPointRouteEntry {
  GeoPointRouteEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGeoPointRouteEntry on GeoPointRouteEntry? {
  _COptional_CGeoPointRouteEntry _copyFromDartTo_COptional_CGeoPointRouteEntry() {
    final cOptional = _COptional_CGeoPointRouteEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGeoPointRouteEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<GeoPointRouteEntry> <-> _CArray_CGeoPointRouteEntry

final class _CArray_CGeoPointRouteEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CGeoPointRouteEntryToDart on _CArray_CGeoPointRouteEntry {
  List<GeoPointRouteEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CGeoPointRouteEntry on List<GeoPointRouteEntry> {
  _CArray_CGeoPointRouteEntry _copyFromDartTo_CArray_CGeoPointRouteEntry() {
    final cArray = _CArray_CGeoPointRouteEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CGeoPointRouteEntry();
        _CArray_CGeoPointRouteEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CGeoPointRouteEntryBasicFunctions on _CArray_CGeoPointRouteEntry {
  void _releaseIntermediate() {
    _CArray_CGeoPointRouteEntry_release(this);
  }

  static final _listToFill = <GeoPointRouteEntry>[];

  static void _iterate(_CGeoPointRouteEntry item) {
    _listToFill.add(item._toDart());
  }

  List<GeoPointRouteEntry> _fillFromC() {
    _forEach_CArray_CGeoPointRouteEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CGeoPointRouteEntry)>(_iterate));
    final result = List<GeoPointRouteEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - SegmentGeoPoint

/**
 Описывает географическую точку на сегменте и направление сегмента.
 Геометрия маршрута представляет собой последовательность точек, которые попарно образуют отрезки (сегменты).
 При этом во всех функциях, работающих с геометрией маршрута считается, что первая точка из образующей отрезок пары
 входит в этот отрезок, а вторая - нет: [point_1, point_2),[point_2, point_3),...,[point_n-1, point_n)[point_last].
 Последняя точка образует сама с собой отрезок нулевой длины. Т.о. каждая точка маршрута принадлежит ровно одному
 отрезку. Направление точки point_last не определено.
*/
class SegmentGeoPoint {
  final GeoPoint point;
  final Bearing bearing;

  const SegmentGeoPoint({
    required this.point,
    required this.bearing
  });

  SegmentGeoPoint copyWith({
    GeoPoint? point,
    Bearing? bearing
  }) {
    return SegmentGeoPoint(
      point: point ?? this.point,
      bearing: bearing ?? this.bearing
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SegmentGeoPoint &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.bearing == bearing;

  @override
  int get hashCode {
    return Object.hash(point, bearing);
  }

}
final class _CSegmentGeoPoint extends ffi.Struct {
  external _CGeoPoint point;

  external _CBearing bearing;

}
// MARK: - SegmentGeoPoint <-> _CSegmentGeoPoint

extension _CSegmentGeoPointToDart on _CSegmentGeoPoint {
  SegmentGeoPoint _toDart() {
    return SegmentGeoPoint(
      point: this.point._toDart(),
      bearing: this.bearing._toDart()
    );
  }
}

extension _DartTo_CSegmentGeoPoint on SegmentGeoPoint {
  _CSegmentGeoPoint _copyFromDartTo_CSegmentGeoPoint() {
    final res = _CSegmentGeoPointMakeDefault();
    res.point = this.point._copyFromDartTo_CGeoPoint();
    res.bearing = this.bearing._copyFromDartTo_CBearing();
    return res;
  }
}
extension _CSegmentGeoPointRelease on _CSegmentGeoPoint {
  void _releaseIntermediate() {
  }
}

// MARK: - SegmentGeoPoint? <-> _COptional_CSegmentGeoPoint

final class _COptional_CSegmentGeoPoint extends ffi.Struct {
  
  external _CSegmentGeoPoint value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CSegmentGeoPointBasicFunctions on _COptional_CSegmentGeoPoint {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CSegmentGeoPointToDart on _COptional_CSegmentGeoPoint {
  SegmentGeoPoint? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CSegmentGeoPoint on SegmentGeoPoint? {
  _COptional_CSegmentGeoPoint _copyFromDartTo_COptional_CSegmentGeoPoint() {
    final cOptional = _COptional_CSegmentGeoPointMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CSegmentGeoPoint();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - RoutePoint? <-> _COptional_CRoutePoint

final class _COptional_CRoutePoint extends ffi.Struct {
  
  external _CRoutePoint value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRoutePointBasicFunctions on _COptional_CRoutePoint {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CRoutePointToDart on _COptional_CRoutePoint {
  RoutePoint? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRoutePoint on RoutePoint? {
  _COptional_CRoutePoint _copyFromDartTo_COptional_CRoutePoint() {
    final cOptional = _COptional_CRoutePointMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRoutePoint();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - DashedStrokeCircleOptions

class DashedStrokeCircleOptions {
  /** Длина пунктира. */
  final LogicalPixel dashLength;
  /** Длина межпунктирного расстояния. */
  final LogicalPixel dashSpaceLength;

  const DashedStrokeCircleOptions({
    this.dashLength = const LogicalPixel(5),
    this.dashSpaceLength = const LogicalPixel(2)
  });

  DashedStrokeCircleOptions copyWith({
    LogicalPixel? dashLength,
    LogicalPixel? dashSpaceLength
  }) {
    return DashedStrokeCircleOptions(
      dashLength: dashLength ?? this.dashLength,
      dashSpaceLength: dashSpaceLength ?? this.dashSpaceLength
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DashedStrokeCircleOptions &&
    other.runtimeType == runtimeType &&
    other.dashLength == dashLength &&
    other.dashSpaceLength == dashSpaceLength;

  @override
  int get hashCode {
    return Object.hash(dashLength, dashSpaceLength);
  }

}
final class _CDashedStrokeCircleOptions extends ffi.Struct {
  external _CLogicalPixel dashLength;

  external _CLogicalPixel dashSpaceLength;

}
// MARK: - DashedStrokeCircleOptions <-> _CDashedStrokeCircleOptions

extension _CDashedStrokeCircleOptionsToDart on _CDashedStrokeCircleOptions {
  DashedStrokeCircleOptions _toDart() {
    return DashedStrokeCircleOptions(
      dashLength: this.dashLength._toDart(),
      dashSpaceLength: this.dashSpaceLength._toDart()
    );
  }
}

extension _DartTo_CDashedStrokeCircleOptions on DashedStrokeCircleOptions {
  _CDashedStrokeCircleOptions _copyFromDartTo_CDashedStrokeCircleOptions() {
    final res = _CDashedStrokeCircleOptionsMakeDefault();
    res.dashLength = this.dashLength._copyFromDartTo_CLogicalPixel();
    res.dashSpaceLength = this.dashSpaceLength._copyFromDartTo_CLogicalPixel();
    return res;
  }
}
extension _CDashedStrokeCircleOptionsRelease on _CDashedStrokeCircleOptions {
  void _releaseIntermediate() {
  }
}

// MARK: - Circle

/** Окружность. */
class Circle extends SimpleMapObject implements ffi.Finalizable {
  /** Местоположение центра окружности. */
  GeoPoint get position {
    _CGeoPoint res = _CCircle_position(_CCircleMakeDefault().._impl=_self);
    return res._toDart();
  }
  set position(GeoPoint position) {
    var _a1 = position._copyFromDartTo_CGeoPoint();
    _CResult_CEmpty res = _CCircle_setPosition_CGeoPoint(_CCircleMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }
  /** Радиус окружности. */
  Meter get radius {
    _CMeter res = _CCircle_radius(_CCircleMakeDefault().._impl=_self);
    return res._toDart();
  }
  set radius(Meter radius) {
    var _a1 = radius._copyFromDartTo_CMeter();
    _CResult_CEmpty res = _CCircle_setRadius_CMeter(_CCircleMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }
  /** Цвет заливки окружности. */
  Color get color {
    _CColor res = _CCircle_color(_CCircleMakeDefault().._impl=_self);
    return res._toDart();
  }
  set color(Color color) {
    var _a1 = color._copyFromDartTo_CColor();
    void res = _CCircle_setColor_CColor(_CCircleMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Ширина линии границы окружности. */
  LogicalPixel get strokeWidth {
    _CLogicalPixel res = _CCircle_strokeWidth(_CCircleMakeDefault().._impl=_self);
    return res._toDart();
  }
  set strokeWidth(LogicalPixel width) {
    var _a1 = width._copyFromDartTo_CLogicalPixel();
    void res = _CCircle_setStrokeWidth_CLogicalPixel(_CCircleMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Цвет границы окружности. */
  Color get strokeColor {
    _CColor res = _CCircle_strokeColor(_CCircleMakeDefault().._impl=_self);
    return res._toDart();
  }
  set strokeColor(Color color) {
    var _a1 = color._copyFromDartTo_CColor();
    void res = _CCircle_setStrokeColor_CColor(_CCircleMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Получение параметров пунктирной обводки
  
   - Returns: параметры пунктирной обводки или null, если обводка не является пунктирной.
  */
  DashedStrokeCircleOptions? get dashedStrokeOptions {
    _COptional_CDashedStrokeCircleOptions res = _CCircle_dashedStrokeOptions(_CCircleMakeDefault().._impl=_self);
    return res._toDart();
  }
  set dashedStrokeOptions(DashedStrokeCircleOptions? options) {
    var _a1 = options._copyFromDartTo_COptional_CDashedStrokeCircleOptions();
    void res = _CCircle_setDashedStrokeOptions_COptional_CDashedStrokeCircleOptions(_CCircleMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CCircle_releasePtr);

  Circle._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Circle._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Circle._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory Circle(
    CircleOptions options
  ) {
    var _a0 = options._copyFromDartTo_CCircleOptions();
    _CResult_CCircle res = _CCircle_C_createWith_CCircleOptions(_a0);
    _a0._releaseIntermediate();
    return Circle._create(res._toCDart()._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Circle &&
    other.runtimeType == runtimeType &&
    _CCircle_cg_objectIdentifier(this._self) == _CCircle_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCircle_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Circle <-> CCircle

final class _CCircle extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCircleBasicFunctions on _CCircle {
  void _releaseIntermediate() {
    _CCircle_release(_impl);
  }

  _CCircle _retain() {
    return _CCircle_retain(_impl);
  }
}

extension _CCircleToDart on _CCircle {
  Circle _toDart() {
    return Circle._create(_retain()._impl);
  }
}


extension _DartToCCircle on Circle {
  _CCircle _copyFromDartTo_CCircle() {
    return (_CCircleMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DashedStrokeCircleOptions? <-> _COptional_CDashedStrokeCircleOptions

final class _COptional_CDashedStrokeCircleOptions extends ffi.Struct {
  
  external _CDashedStrokeCircleOptions value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CDashedStrokeCircleOptionsBasicFunctions on _COptional_CDashedStrokeCircleOptions {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CDashedStrokeCircleOptionsToDart on _COptional_CDashedStrokeCircleOptions {
  DashedStrokeCircleOptions? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CDashedStrokeCircleOptions on DashedStrokeCircleOptions? {
  _COptional_CDashedStrokeCircleOptions _copyFromDartTo_COptional_CDashedStrokeCircleOptions() {
    final cOptional = _COptional_CDashedStrokeCircleOptionsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CDashedStrokeCircleOptions();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CircleOptions

/** Параметры для создания геометрического объекта карты типа "Окружность". */
class CircleOptions {
  /** Географическая позиция. */
  final GeoPoint position;
  /** Радиус в метрах. */
  final Meter radius;
  /** Цвет заливки. */
  final Color color;
  /** Ширина линии границы окружности. */
  final LogicalPixel strokeWidth;
  /** Цвет линии границы окружности. */
  final Color strokeColor;
  /** Параметры пунктирной границы. */
  final DashedStrokeCircleOptions? dashedStrokeOptions;
  /** Флаг видимости. */
  final bool visible;
  /** Пользовательские данные (не используются внутри SDK, нужны только для пользователя API). */
  final Object? userData;
  /** Уровень отрисовки объекта. */
  final ZIndex zIndex;
  /** Привязка к поэтажному плану здания. */
  final LevelId? levelId;

  const CircleOptions({
    required this.position,
    required this.radius,
    this.color = const Color(),
    this.strokeWidth = const LogicalPixel(0),
    this.strokeColor = const Color(),
    this.dashedStrokeOptions = null,
    this.visible = true,
    this.userData = const {},
    this.zIndex = const ZIndex(0),
    this.levelId = null
  });

  CircleOptions copyWith({
    GeoPoint? position,
    Meter? radius,
    Color? color,
    LogicalPixel? strokeWidth,
    Color? strokeColor,
    Optional<DashedStrokeCircleOptions?>? dashedStrokeOptions,
    bool? visible,
    Optional<Object?>? userData,
    ZIndex? zIndex,
    Optional<LevelId?>? levelId
  }) {
    return CircleOptions(
      position: position ?? this.position,
      radius: radius ?? this.radius,
      color: color ?? this.color,
      strokeWidth: strokeWidth ?? this.strokeWidth,
      strokeColor: strokeColor ?? this.strokeColor,
      dashedStrokeOptions: dashedStrokeOptions != null ? dashedStrokeOptions.value : this.dashedStrokeOptions,
      visible: visible ?? this.visible,
      userData: userData != null ? userData.value : this.userData,
      zIndex: zIndex ?? this.zIndex,
      levelId: levelId != null ? levelId.value : this.levelId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CircleOptions &&
    other.runtimeType == runtimeType &&
    other.position == position &&
    other.radius == radius &&
    other.color == color &&
    other.strokeWidth == strokeWidth &&
    other.strokeColor == strokeColor &&
    other.dashedStrokeOptions == dashedStrokeOptions &&
    other.visible == visible &&
    other.userData == userData &&
    other.zIndex == zIndex &&
    other.levelId == levelId;

  @override
  int get hashCode {
    return Object.hash(position, radius, color, strokeWidth, strokeColor, dashedStrokeOptions, visible, userData, zIndex, levelId);
  }

}
final class _CCircleOptions extends ffi.Struct {
  external _CGeoPoint position;

  external _CMeter radius;

  external _CColor color;

  external _CLogicalPixel strokeWidth;

  external _CColor strokeColor;

  external _COptional_CDashedStrokeCircleOptions dashedStrokeOptions;

  @ffi.Bool()
  external bool visible;

  external _CAny userData;

  external _CZIndex zIndex;

  external _COptional_CLevelId levelId;

}
// MARK: - CircleOptions <-> _CCircleOptions

extension _CCircleOptionsToDart on _CCircleOptions {
  CircleOptions _toDart() {
    return CircleOptions(
      position: this.position._toDart(),
      radius: this.radius._toDart(),
      color: this.color._toDart(),
      strokeWidth: this.strokeWidth._toDart(),
      strokeColor: this.strokeColor._toDart(),
      dashedStrokeOptions: this.dashedStrokeOptions._toDart(),
      visible: this.visible,
      userData: this.userData._toDart(),
      zIndex: this.zIndex._toDart(),
      levelId: this.levelId._toDart()
    );
  }
}

extension _DartTo_CCircleOptions on CircleOptions {
  _CCircleOptions _copyFromDartTo_CCircleOptions() {
    final res = _CCircleOptionsMakeDefault();
    res.position = this.position._copyFromDartTo_CGeoPoint();
    res.radius = this.radius._copyFromDartTo_CMeter();
    res.color = this.color._copyFromDartTo_CColor();
    res.strokeWidth = this.strokeWidth._copyFromDartTo_CLogicalPixel();
    res.strokeColor = this.strokeColor._copyFromDartTo_CColor();
    res.dashedStrokeOptions = this.dashedStrokeOptions._copyFromDartTo_COptional_CDashedStrokeCircleOptions();
    res.visible = this.visible;
    res.userData = this.userData._copyFromDartTo_CAny();
    res.zIndex = this.zIndex._copyFromDartTo_CZIndex();
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    return res;
  }
}
extension _CCircleOptionsRelease on _CCircleOptions {
  void _releaseIntermediate() {
    userData._releaseIntermediate();
  }
}

// MARK: - Circle <-> _CResult_CCircle

final class _CResult_CCircleImpl extends ffi.Union {
  
  external _CCircle _value;
  external _CError _error;
}

final class _CResult_CCircle extends ffi.Struct {
  external _CResult_CCircleImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CCircleBasicFunctions on _CResult_CCircle {
  void _releaseIntermediate() {
    _CResult_CCircle_release(this);
  }
}

extension _CResult_CCircleToDart on _CResult_CCircle {
  Circle _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CCircle _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - Polygon

/** Полигон на карте. */
class Polygon extends SimpleMapObject implements ffi.Finalizable {
  List<List<GeoPoint>> get contours {
    _CArray_CArray_CGeoPoint res = _CPolygon_contours(_CPolygonMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set contours(List<List<GeoPoint>> contours) {
    var _a1 = contours._copyFromDartTo_CArray_CArray_CGeoPoint();
    void res = _CPolygon_setContours_CArray_CArray_CGeoPoint(_CPolygonMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  Color get color {
    _CColor res = _CPolygon_color(_CPolygonMakeDefault().._impl=_self);
    return res._toDart();
  }
  set color(Color color) {
    var _a1 = color._copyFromDartTo_CColor();
    void res = _CPolygon_setColor_CColor(_CPolygonMakeDefault().._impl=_self, _a1);
    return res;
  }
  LogicalPixel get strokeWidth {
    _CLogicalPixel res = _CPolygon_strokeWidth(_CPolygonMakeDefault().._impl=_self);
    return res._toDart();
  }
  set strokeWidth(LogicalPixel width) {
    var _a1 = width._copyFromDartTo_CLogicalPixel();
    void res = _CPolygon_setStrokeWidth_CLogicalPixel(_CPolygonMakeDefault().._impl=_self, _a1);
    return res;
  }
  Color get strokeColor {
    _CColor res = _CPolygon_strokeColor(_CPolygonMakeDefault().._impl=_self);
    return res._toDart();
  }
  set strokeColor(Color color) {
    var _a1 = color._copyFromDartTo_CColor();
    void res = _CPolygon_setStrokeColor_CColor(_CPolygonMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPolygon_releasePtr);

  Polygon._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Polygon._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Polygon._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Cоздание полигона на основе параметров.
  
   - Throws: Exception В случае, если один из контуров содержит меньше трех точек.
  */
  factory Polygon(
    PolygonOptions options
  ) {
    var _a0 = options._copyFromDartTo_CPolygonOptions();
    _CResult_CPolygon res = _CPolygon_C_createWith_CPolygonOptions(_a0);
    _a0._releaseIntermediate();
    return Polygon._create(res._toCDart()._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Polygon &&
    other.runtimeType == runtimeType &&
    _CPolygon_cg_objectIdentifier(this._self) == _CPolygon_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPolygon_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Polygon <-> CPolygon

final class _CPolygon extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPolygonBasicFunctions on _CPolygon {
  void _releaseIntermediate() {
    _CPolygon_release(_impl);
  }

  _CPolygon _retain() {
    return _CPolygon_retain(_impl);
  }
}

extension _CPolygonToDart on _CPolygon {
  Polygon _toDart() {
    return Polygon._create(_retain()._impl);
  }
}


extension _DartToCPolygon on Polygon {
  _CPolygon _copyFromDartTo_CPolygon() {
    return (_CPolygonMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PolygonOptions

/** Параметры полигона. */
class PolygonOptions {
  final List<List<GeoPoint>> contours;
  final Color color;
  final LogicalPixel strokeWidth;
  final Color strokeColor;
  final bool visible;
  final Object? userData;
  /** Уровень отрисовки объекта. */
  final ZIndex zIndex;
  /** Привязка к поэтажному плану здания. */
  final LevelId? levelId;

  const PolygonOptions({
    required this.contours,
    this.color = const Color(),
    this.strokeWidth = const LogicalPixel(0),
    this.strokeColor = const Color(),
    this.visible = true,
    this.userData = const {},
    this.zIndex = const ZIndex(0),
    this.levelId = null
  });

  PolygonOptions copyWith({
    List<List<GeoPoint>>? contours,
    Color? color,
    LogicalPixel? strokeWidth,
    Color? strokeColor,
    bool? visible,
    Optional<Object?>? userData,
    ZIndex? zIndex,
    Optional<LevelId?>? levelId
  }) {
    return PolygonOptions(
      contours: contours ?? this.contours,
      color: color ?? this.color,
      strokeWidth: strokeWidth ?? this.strokeWidth,
      strokeColor: strokeColor ?? this.strokeColor,
      visible: visible ?? this.visible,
      userData: userData != null ? userData.value : this.userData,
      zIndex: zIndex ?? this.zIndex,
      levelId: levelId != null ? levelId.value : this.levelId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PolygonOptions &&
    other.runtimeType == runtimeType &&
    other.contours == contours &&
    other.color == color &&
    other.strokeWidth == strokeWidth &&
    other.strokeColor == strokeColor &&
    other.visible == visible &&
    other.userData == userData &&
    other.zIndex == zIndex &&
    other.levelId == levelId;

  @override
  int get hashCode {
    return Object.hash(contours, color, strokeWidth, strokeColor, visible, userData, zIndex, levelId);
  }

}
final class _CPolygonOptions extends ffi.Struct {
  external _CArray_CArray_CGeoPoint contours;

  external _CColor color;

  external _CLogicalPixel strokeWidth;

  external _CColor strokeColor;

  @ffi.Bool()
  external bool visible;

  external _CAny userData;

  external _CZIndex zIndex;

  external _COptional_CLevelId levelId;

}
// MARK: - PolygonOptions <-> _CPolygonOptions

extension _CPolygonOptionsToDart on _CPolygonOptions {
  PolygonOptions _toDart() {
    return PolygonOptions(
      contours: this.contours._toDart(),
      color: this.color._toDart(),
      strokeWidth: this.strokeWidth._toDart(),
      strokeColor: this.strokeColor._toDart(),
      visible: this.visible,
      userData: this.userData._toDart(),
      zIndex: this.zIndex._toDart(),
      levelId: this.levelId._toDart()
    );
  }
}

extension _DartTo_CPolygonOptions on PolygonOptions {
  _CPolygonOptions _copyFromDartTo_CPolygonOptions() {
    final res = _CPolygonOptionsMakeDefault();
    res.contours = this.contours._copyFromDartTo_CArray_CArray_CGeoPoint();
    res.color = this.color._copyFromDartTo_CColor();
    res.strokeWidth = this.strokeWidth._copyFromDartTo_CLogicalPixel();
    res.strokeColor = this.strokeColor._copyFromDartTo_CColor();
    res.visible = this.visible;
    res.userData = this.userData._copyFromDartTo_CAny();
    res.zIndex = this.zIndex._copyFromDartTo_CZIndex();
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    return res;
  }
}
extension _CPolygonOptionsRelease on _CPolygonOptions {
  void _releaseIntermediate() {
    contours._releaseIntermediate();
    userData._releaseIntermediate();
  }
}

// MARK: - Polygon <-> _CResult_CPolygon

final class _CResult_CPolygonImpl extends ffi.Union {
  
  external _CPolygon _value;
  external _CError _error;
}

final class _CResult_CPolygon extends ffi.Struct {
  external _CResult_CPolygonImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CPolygonBasicFunctions on _CResult_CPolygon {
  void _releaseIntermediate() {
    _CResult_CPolygon_release(this);
  }
}

extension _CResult_CPolygonToDart on _CResult_CPolygon {
  Polygon _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CPolygon _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - DashedPolylineOptions

/** Параметры пунктирной полилинии. */
class DashedPolylineOptions {
  /** Длина пунктира. */
  final LogicalPixel dashLength;
  /** Длина межпунктирного расстояния. */
  final LogicalPixel dashSpaceLength;

  const DashedPolylineOptions({
    this.dashLength = const LogicalPixel(5),
    this.dashSpaceLength = const LogicalPixel(2)
  });

  DashedPolylineOptions copyWith({
    LogicalPixel? dashLength,
    LogicalPixel? dashSpaceLength
  }) {
    return DashedPolylineOptions(
      dashLength: dashLength ?? this.dashLength,
      dashSpaceLength: dashSpaceLength ?? this.dashSpaceLength
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DashedPolylineOptions &&
    other.runtimeType == runtimeType &&
    other.dashLength == dashLength &&
    other.dashSpaceLength == dashSpaceLength;

  @override
  int get hashCode {
    return Object.hash(dashLength, dashSpaceLength);
  }

}
final class _CDashedPolylineOptions extends ffi.Struct {
  external _CLogicalPixel dashLength;

  external _CLogicalPixel dashSpaceLength;

}
// MARK: - DashedPolylineOptions <-> _CDashedPolylineOptions

extension _CDashedPolylineOptionsToDart on _CDashedPolylineOptions {
  DashedPolylineOptions _toDart() {
    return DashedPolylineOptions(
      dashLength: this.dashLength._toDart(),
      dashSpaceLength: this.dashSpaceLength._toDart()
    );
  }
}

extension _DartTo_CDashedPolylineOptions on DashedPolylineOptions {
  _CDashedPolylineOptions _copyFromDartTo_CDashedPolylineOptions() {
    final res = _CDashedPolylineOptionsMakeDefault();
    res.dashLength = this.dashLength._copyFromDartTo_CLogicalPixel();
    res.dashSpaceLength = this.dashSpaceLength._copyFromDartTo_CLogicalPixel();
    return res;
  }
}
extension _CDashedPolylineOptionsRelease on _CDashedPolylineOptions {
  void _releaseIntermediate() {
  }
}

// MARK: - List<Color> <-> _CArray_CColor

final class _CArray_CColor extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CColorToDart on _CArray_CColor {
  List<Color> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CColor on List<Color> {
  _CArray_CColor _copyFromDartTo_CArray_CColor() {
    final cArray = _CArray_CColormakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CColor();
        _CArray_CColoraddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CColorBasicFunctions on _CArray_CColor {
  void _releaseIntermediate() {
    _CArray_CColor_release(this);
  }

  static final _listToFill = <Color>[];

  static void _iterate(_CColor item) {
    _listToFill.add(item._toDart());
  }

  List<Color> _fillFromC() {
    _forEach_CArray_CColor(this, ffi.Pointer.fromFunction<ffi.Void Function(_CColor)>(_iterate));
    final result = List<Color>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - GradientPolylineOptions

/** Параметры градиентной полилинии. */
class GradientPolylineOptions {
  /** Ширина границы линии. */
  final LogicalPixel borderWidth;
  /** Ширина второй границы линии. */
  final LogicalPixel secondBorderWidth;
  /** Длина градиентной линии. */
  final LogicalPixel gradientLength;
  /** Цвет окантовки. */
  final Color borderColor;
  /** Цвет второй окантовки. */
  final Color secondBorderColor;
  /** Палитра цветов градиентной полилинии. */
  final List<Color> colors;
  /**
   Индексы цветов градиентной полилинии. Количество индексов должно быть
   на 1 меньше количества точек полилинии.
  */
  final ByteData colorIndices;

  const GradientPolylineOptions({
    this.borderWidth = const LogicalPixel(0),
    this.secondBorderWidth = const LogicalPixel(0),
    this.gradientLength = const LogicalPixel(1),
    this.borderColor = const Color(),
    this.secondBorderColor = const Color(),
    required this.colors,
    required this.colorIndices
  });

  GradientPolylineOptions copyWith({
    LogicalPixel? borderWidth,
    LogicalPixel? secondBorderWidth,
    LogicalPixel? gradientLength,
    Color? borderColor,
    Color? secondBorderColor,
    List<Color>? colors,
    ByteData? colorIndices
  }) {
    return GradientPolylineOptions(
      borderWidth: borderWidth ?? this.borderWidth,
      secondBorderWidth: secondBorderWidth ?? this.secondBorderWidth,
      gradientLength: gradientLength ?? this.gradientLength,
      borderColor: borderColor ?? this.borderColor,
      secondBorderColor: secondBorderColor ?? this.secondBorderColor,
      colors: colors ?? this.colors,
      colorIndices: colorIndices ?? this.colorIndices
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GradientPolylineOptions &&
    other.runtimeType == runtimeType &&
    other.borderWidth == borderWidth &&
    other.secondBorderWidth == secondBorderWidth &&
    other.gradientLength == gradientLength &&
    other.borderColor == borderColor &&
    other.secondBorderColor == secondBorderColor &&
    other.colors == colors &&
    other.colorIndices == colorIndices;

  @override
  int get hashCode {
    return Object.hash(borderWidth, secondBorderWidth, gradientLength, borderColor, secondBorderColor, colors, colorIndices);
  }

}
final class _CGradientPolylineOptions extends ffi.Struct {
  external _CLogicalPixel borderWidth;

  external _CLogicalPixel secondBorderWidth;

  external _CLogicalPixel gradientLength;

  external _CColor borderColor;

  external _CColor secondBorderColor;

  external _CArray_CColor colors;

  external _CData colorIndices;

}
// MARK: - GradientPolylineOptions <-> _CGradientPolylineOptions

extension _CGradientPolylineOptionsToDart on _CGradientPolylineOptions {
  GradientPolylineOptions _toDart() {
    return GradientPolylineOptions(
      borderWidth: this.borderWidth._toDart(),
      secondBorderWidth: this.secondBorderWidth._toDart(),
      gradientLength: this.gradientLength._toDart(),
      borderColor: this.borderColor._toDart(),
      secondBorderColor: this.secondBorderColor._toDart(),
      colors: this.colors._toDart(),
      colorIndices: this.colorIndices._toDart()
    );
  }
}

extension _DartTo_CGradientPolylineOptions on GradientPolylineOptions {
  _CGradientPolylineOptions _copyFromDartTo_CGradientPolylineOptions() {
    final res = _CGradientPolylineOptionsMakeDefault();
    res.borderWidth = this.borderWidth._copyFromDartTo_CLogicalPixel();
    res.secondBorderWidth = this.secondBorderWidth._copyFromDartTo_CLogicalPixel();
    res.gradientLength = this.gradientLength._copyFromDartTo_CLogicalPixel();
    res.borderColor = this.borderColor._copyFromDartTo_CColor();
    res.secondBorderColor = this.secondBorderColor._copyFromDartTo_CColor();
    res.colors = this.colors._copyFromDartTo_CArray_CColor();
    res.colorIndices = this.colorIndices._copyFromDartTo_CData();
    return res;
  }
}
extension _CGradientPolylineOptionsRelease on _CGradientPolylineOptions {
  void _releaseIntermediate() {
    colors._releaseIntermediate();
    colorIndices._releaseIntermediate();
  }
}

// MARK: - Polyline

/** Ломаная линия на карте. */
class Polyline extends SimpleMapObject implements ffi.Finalizable {
  List<GeoPoint> get points {
    _CArray_CGeoPoint res = _CPolyline_points(_CPolylineMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set points(List<GeoPoint> points) {
    var _a1 = points._copyFromDartTo_CArray_CGeoPoint();
    void res = _CPolyline_setPoints_CArray_CGeoPoint(_CPolylineMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  LogicalPixel get width {
    _CLogicalPixel res = _CPolyline_width(_CPolylineMakeDefault().._impl=_self);
    return res._toDart();
  }
  set width(LogicalPixel width) {
    var _a1 = width._copyFromDartTo_CLogicalPixel();
    void res = _CPolyline_setWidth_CLogicalPixel(_CPolylineMakeDefault().._impl=_self, _a1);
    return res;
  }
  Color get color {
    _CColor res = _CPolyline_color(_CPolylineMakeDefault().._impl=_self);
    return res._toDart();
  }
  set color(Color color) {
    var _a1 = color._copyFromDartTo_CColor();
    void res = _CPolyline_setColor_CColor(_CPolylineMakeDefault().._impl=_self, _a1);
    return res;
  }
  double get erasedPart {
    double res = _CPolyline_erasedPart(_CPolylineMakeDefault().._impl=_self);
    return res;
  }
  set erasedPart(double part) {
    void res = _CPolyline_setErasedPart_double(_CPolylineMakeDefault().._impl=_self, part);
    return res;
  }
  /**
   Получение параметров пунктирной полилинии.
  
   - Returns: параметры пунктира или null, если линия не является пунктирной
  */
  DashedPolylineOptions? get dashedPolylineOptions {
    _COptional_CDashedPolylineOptions res = _CPolyline_dashedPolylineOptions(_CPolylineMakeDefault().._impl=_self);
    return res._toDart();
  }
  set dashedPolylineOptions(DashedPolylineOptions? options) {
    var _a1 = options._copyFromDartTo_COptional_CDashedPolylineOptions();
    void res = _CPolyline_setDashedPolylineOptions_COptional_CDashedPolylineOptions(_CPolylineMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Получение параметров градиентной полилинии.
  
   - Returns: параметры градиента или null, если линия не является градиентной
  */
  GradientPolylineOptions? get gradientPolylineOptions {
    _COptional_CGradientPolylineOptions res = _CPolyline_gradientPolylineOptions(_CPolylineMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set gradientPolylineOptions(GradientPolylineOptions? options) {
    var _a1 = options._copyFromDartTo_COptional_CGradientPolylineOptions();
    void res = _CPolyline_setGradientPolylineOptions_COptional_CGradientPolylineOptions(_CPolylineMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPolyline_releasePtr);

  Polyline._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Polyline._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Polyline._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory Polyline(
    PolylineOptions options
  ) {
    var _a0 = options._copyFromDartTo_CPolylineOptions();
    _CResult_CPolyline res = _CPolyline_C_createWith_CPolylineOptions(_a0);
    _a0._releaseIntermediate();
    return Polyline._create(res._toCDart()._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Polyline &&
    other.runtimeType == runtimeType &&
    _CPolyline_cg_objectIdentifier(this._self) == _CPolyline_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPolyline_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Polyline <-> CPolyline

final class _CPolyline extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPolylineBasicFunctions on _CPolyline {
  void _releaseIntermediate() {
    _CPolyline_release(_impl);
  }

  _CPolyline _retain() {
    return _CPolyline_retain(_impl);
  }
}

extension _CPolylineToDart on _CPolyline {
  Polyline _toDart() {
    return Polyline._create(_retain()._impl);
  }
}


extension _DartToCPolyline on Polyline {
  _CPolyline _copyFromDartTo_CPolyline() {
    return (_CPolylineMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DashedPolylineOptions? <-> _COptional_CDashedPolylineOptions

final class _COptional_CDashedPolylineOptions extends ffi.Struct {
  
  external _CDashedPolylineOptions value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CDashedPolylineOptionsBasicFunctions on _COptional_CDashedPolylineOptions {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CDashedPolylineOptionsToDart on _COptional_CDashedPolylineOptions {
  DashedPolylineOptions? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CDashedPolylineOptions on DashedPolylineOptions? {
  _COptional_CDashedPolylineOptions _copyFromDartTo_COptional_CDashedPolylineOptions() {
    final cOptional = _COptional_CDashedPolylineOptionsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CDashedPolylineOptions();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - GradientPolylineOptions? <-> _COptional_CGradientPolylineOptions

final class _COptional_CGradientPolylineOptions extends ffi.Struct {
  
  external _CGradientPolylineOptions value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGradientPolylineOptionsBasicFunctions on _COptional_CGradientPolylineOptions {
  void _releaseIntermediate() {
    _COptional_CGradientPolylineOptions_release(this);
  }
}

extension _COptional_CGradientPolylineOptionsToDart on _COptional_CGradientPolylineOptions {
  GradientPolylineOptions? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGradientPolylineOptions on GradientPolylineOptions? {
  _COptional_CGradientPolylineOptions _copyFromDartTo_COptional_CGradientPolylineOptions() {
    final cOptional = _COptional_CGradientPolylineOptionsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGradientPolylineOptions();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - PolylineOptions

/** Параметры полилинии. */
class PolylineOptions {
  /** Точки полилинии. */
  final List<GeoPoint> points;
  /** Ширина полилинии. */
  final LogicalPixel width;
  /** Основной цвет полилинии. */
  final Color color;
  /** Доля стёртой части полилинии, должна быть в диапазоне [0; 1] */
  final double erasedPart;
  /**
   Параметры пунктирной полилинии.
  
   - Note: Пунктирная градиентная линия в данный момент не поддерживается, поэтому
   если в PolylineOptions присутствуют и dashed_polyline_options, и
   gradient_polyline_options, то dashed_polyline_options будут проигнорированы
   при создании полилинии.
  */
  final DashedPolylineOptions? dashedPolylineOptions;
  /**
   Параметры градиентной полилинии.
  
   - Note: Пунктирная градиентная линия в данный момент не поддерживается, поэтому
   если в PolylineOptions присутствуют и dashed_polyline_options, и
   gradient_polyline_options, то dashed_polyline_options будут проигнорированы
   при создании полилинии.
  */
  final GradientPolylineOptions? gradientPolylineOptions;
  /** Видимость полилинии. */
  final bool visible;
  /** Пользовательские данные. */
  final Object? userData;
  /** Уровень отрисовки объекта. */
  final ZIndex zIndex;
  /** Привязка к поэтажному плану здания. */
  final LevelId? levelId;

  const PolylineOptions({
    required this.points,
    this.width = const LogicalPixel(1),
    this.color = const Color(),
    this.erasedPart = 0,
    this.dashedPolylineOptions = null,
    this.gradientPolylineOptions = null,
    this.visible = true,
    this.userData = const {},
    this.zIndex = const ZIndex(0),
    this.levelId = null
  });

  PolylineOptions copyWith({
    List<GeoPoint>? points,
    LogicalPixel? width,
    Color? color,
    double? erasedPart,
    Optional<DashedPolylineOptions?>? dashedPolylineOptions,
    Optional<GradientPolylineOptions?>? gradientPolylineOptions,
    bool? visible,
    Optional<Object?>? userData,
    ZIndex? zIndex,
    Optional<LevelId?>? levelId
  }) {
    return PolylineOptions(
      points: points ?? this.points,
      width: width ?? this.width,
      color: color ?? this.color,
      erasedPart: erasedPart ?? this.erasedPart,
      dashedPolylineOptions: dashedPolylineOptions != null ? dashedPolylineOptions.value : this.dashedPolylineOptions,
      gradientPolylineOptions: gradientPolylineOptions != null ? gradientPolylineOptions.value : this.gradientPolylineOptions,
      visible: visible ?? this.visible,
      userData: userData != null ? userData.value : this.userData,
      zIndex: zIndex ?? this.zIndex,
      levelId: levelId != null ? levelId.value : this.levelId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PolylineOptions &&
    other.runtimeType == runtimeType &&
    other.points == points &&
    other.width == width &&
    other.color == color &&
    other.erasedPart == erasedPart &&
    other.dashedPolylineOptions == dashedPolylineOptions &&
    other.gradientPolylineOptions == gradientPolylineOptions &&
    other.visible == visible &&
    other.userData == userData &&
    other.zIndex == zIndex &&
    other.levelId == levelId;

  @override
  int get hashCode {
    return Object.hash(points, width, color, erasedPart, dashedPolylineOptions, gradientPolylineOptions, visible, userData, zIndex, levelId);
  }

}
final class _CPolylineOptions extends ffi.Struct {
  external _CArray_CGeoPoint points;

  external _CLogicalPixel width;

  external _CColor color;

  @ffi.Double()
  external double erasedPart;

  external _COptional_CDashedPolylineOptions dashedPolylineOptions;

  external _COptional_CGradientPolylineOptions gradientPolylineOptions;

  @ffi.Bool()
  external bool visible;

  external _CAny userData;

  external _CZIndex zIndex;

  external _COptional_CLevelId levelId;

}
// MARK: - PolylineOptions <-> _CPolylineOptions

extension _CPolylineOptionsToDart on _CPolylineOptions {
  PolylineOptions _toDart() {
    return PolylineOptions(
      points: this.points._toDart(),
      width: this.width._toDart(),
      color: this.color._toDart(),
      erasedPart: this.erasedPart,
      dashedPolylineOptions: this.dashedPolylineOptions._toDart(),
      gradientPolylineOptions: this.gradientPolylineOptions._toDart(),
      visible: this.visible,
      userData: this.userData._toDart(),
      zIndex: this.zIndex._toDart(),
      levelId: this.levelId._toDart()
    );
  }
}

extension _DartTo_CPolylineOptions on PolylineOptions {
  _CPolylineOptions _copyFromDartTo_CPolylineOptions() {
    final res = _CPolylineOptionsMakeDefault();
    res.points = this.points._copyFromDartTo_CArray_CGeoPoint();
    res.width = this.width._copyFromDartTo_CLogicalPixel();
    res.color = this.color._copyFromDartTo_CColor();
    res.erasedPart = this.erasedPart;
    res.dashedPolylineOptions = this.dashedPolylineOptions._copyFromDartTo_COptional_CDashedPolylineOptions();
    res.gradientPolylineOptions = this.gradientPolylineOptions._copyFromDartTo_COptional_CGradientPolylineOptions();
    res.visible = this.visible;
    res.userData = this.userData._copyFromDartTo_CAny();
    res.zIndex = this.zIndex._copyFromDartTo_CZIndex();
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    return res;
  }
}
extension _CPolylineOptionsRelease on _CPolylineOptions {
  void _releaseIntermediate() {
    points._releaseIntermediate();
    gradientPolylineOptions._releaseIntermediate();
    userData._releaseIntermediate();
  }
}

// MARK: - Polyline <-> _CResult_CPolyline

final class _CResult_CPolylineImpl extends ffi.Union {
  
  external _CPolyline _value;
  external _CError _error;
}

final class _CResult_CPolyline extends ffi.Struct {
  external _CResult_CPolylineImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CPolylineBasicFunctions on _CResult_CPolyline {
  void _releaseIntermediate() {
    _CResult_CPolyline_release(this);
  }
}

extension _CResult_CPolylineToDart on _CResult_CPolyline {
  Polyline _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CPolyline _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - CameraFollowState

/** Состояние слежения камеры за текущим местоположением пользователя. */
enum CameraFollowState {
  /** Камера не находится в режиме слежения. */
  off(0),
  /** Камера в режиме слежения за позицией. */
  followPosition(1),
  /** Камера в режиме слежения за позицией и направлением. */
  followDirection(2),
  ;

  const CameraFollowState(this.rawValue);
  final int rawValue;

  static CameraFollowState getByValue(int value) {
    return CameraFollowState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraFollowState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraFollowStateBasicFunctions on _CCameraFollowState {
  void _releaseIntermediate() {
  }
}

extension _CCameraFollowStateToDart on _CCameraFollowState {
  CameraFollowState _toDart() {
    return CameraFollowState.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraFollowState on CameraFollowState {
  _CCameraFollowState _copyFromDartTo_CCameraFollowState() {
    return _CCameraFollowStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - MyLocationControlModel

/**
 Модель контрола перелета к местоположению пользователя.
 Контрол состоит из кнопки, при нажатии на которую камера перелетает к местоположению пользователя.
 Если местоположение не определено, ничего не происходит.
 Методы объекта необходимо вызывать на одном потоке.
*/
class MyLocationControlModel implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  StatefulChannel<bool> get isEnabledChannel {
    _CStatefulChannel_bool res = _CMyLocationControlModel_isEnabledChannel(_CMyLocationControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  bool get isEnabled {
    bool res = _CMyLocationControlModel_isEnabled(_CMyLocationControlModelMakeDefault().._impl=_self);
    return res;
  }
  StatefulChannel<CameraFollowState> get followStateChannel {
    _CStatefulChannel_CCameraFollowState res = _CMyLocationControlModel_followStateChannel(_CMyLocationControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  CameraFollowState get followState {
    _CCameraFollowState res = _CMyLocationControlModel_followState(_CMyLocationControlModelMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CMyLocationControlModel_releasePtr);

  MyLocationControlModel._raw(this._self);
  factory MyLocationControlModel._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MyLocationControlModel._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MyLocationControlModel(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CMyLocationControlModel res = _CMyLocationControlModel_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return MyLocationControlModel._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MyLocationControlModel &&
    other.runtimeType == runtimeType &&
    _CMyLocationControlModel_cg_objectIdentifier(this._self) == _CMyLocationControlModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMyLocationControlModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: MyLocationControlModel: Methods

  void onClicked()  {
    void res = _CMyLocationControlModel_onClicked(_CMyLocationControlModelMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - MyLocationControlModel <-> CMyLocationControlModel

final class _CMyLocationControlModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMyLocationControlModelBasicFunctions on _CMyLocationControlModel {
  void _releaseIntermediate() {
    _CMyLocationControlModel_release(_impl);
  }

  _CMyLocationControlModel _retain() {
    return _CMyLocationControlModel_retain(_impl);
  }
}

extension _CMyLocationControlModelToDart on _CMyLocationControlModel {
  MyLocationControlModel _toDart() {
    return MyLocationControlModel._create(_retain()._impl);
  }
}


extension _DartToCMyLocationControlModel on MyLocationControlModel {
  _CMyLocationControlModel _copyFromDartTo_CMyLocationControlModel() {
    return (_CMyLocationControlModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<CameraFollowState> <-> _CStatefulChannel_CCameraFollowState

class _CStatefulChannel_CCameraFollowStateImpl extends StatefulChannel<CameraFollowState> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraFollowState>>{};

  final _CStatefulChannel_CCameraFollowState _channel;

  _CStatefulChannel_CCameraFollowStateImpl(this._channel);

  @override
  CameraFollowState get value {
    return this._channel._getter();
  }

  static void valueFunction(_CCameraFollowState cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraFollowState> listen(void onData(CameraFollowState event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraFollowState, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraFollowState>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CCameraFollowState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CCameraFollowStateBasicFunctions on _CStatefulChannel_CCameraFollowState {
  void _releaseIntermediate() {
    _CStatefulChannel_CCameraFollowState_release(this);
  }

  _CStatefulChannel_CCameraFollowState _retain() {
    return _CStatefulChannel_CCameraFollowState_retain(this);
  }

  CameraFollowState _getter() {
    final cValue = _CStatefulChannel_CCameraFollowStateGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CCameraFollowState, ffi.Int64)> callback) {
    return _CStatefulChannel_CCameraFollowStateConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CCameraFollowStateToDart on _CStatefulChannel_CCameraFollowState {
  StatefulChannel<CameraFollowState> _toDart() {
    return _CStatefulChannel_CCameraFollowStateImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CCameraFollowState on StatefulChannel<CameraFollowState> {
  _CStatefulChannel_CCameraFollowState _copyFromDartTo_CStatefulChannel_CCameraFollowState() {
    return _CStatefulChannel_CCameraFollowStateMakeDefault();
  }
}
	
// MARK: - CompassControlModel

/**
 Модель контрола компаса.
 Контрол состоит из кнопки компаса, при нажатии на которую
 камера карты меняет угол в направлении севера.
 Если камера карты смотрит на сервер, то контрол необходимо скрывать.
 Потокобезопасно.
*/
class CompassControlModel implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  StatefulChannel<Bearing> get bearingChannel {
    _CStatefulChannel_CBearing res = _CCompassControlModel_bearingChannel(_CCompassControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Bearing get bearing {
    _CBearing res = _CCompassControlModel_bearing(_CCompassControlModelMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CCompassControlModel_releasePtr);

  CompassControlModel._raw(this._self);
  factory CompassControlModel._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CompassControlModel._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory CompassControlModel(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CCompassControlModel res = _CCompassControlModel_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return CompassControlModel._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CompassControlModel &&
    other.runtimeType == runtimeType &&
    _CCompassControlModel_cg_objectIdentifier(this._self) == _CCompassControlModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCompassControlModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CompassControlModel: Methods

  void onClicked()  {
    void res = _CCompassControlModel_onClicked(_CCompassControlModelMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - CompassControlModel <-> CCompassControlModel

final class _CCompassControlModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCompassControlModelBasicFunctions on _CCompassControlModel {
  void _releaseIntermediate() {
    _CCompassControlModel_release(_impl);
  }

  _CCompassControlModel _retain() {
    return _CCompassControlModel_retain(_impl);
  }
}

extension _CCompassControlModelToDart on _CCompassControlModel {
  CompassControlModel _toDart() {
    return CompassControlModel._create(_retain()._impl);
  }
}


extension _DartToCCompassControlModel on CompassControlModel {
  _CCompassControlModel _copyFromDartTo_CCompassControlModel() {
    return (_CCompassControlModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<Bearing> <-> _CStatefulChannel_CBearing

class _CStatefulChannel_CBearingImpl extends StatefulChannel<Bearing> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Bearing>>{};

  final _CStatefulChannel_CBearing _channel;

  _CStatefulChannel_CBearingImpl(this._channel);

  @override
  Bearing get value {
    return this._channel._getter();
  }

  static void valueFunction(_CBearing cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<Bearing> listen(void onData(Bearing event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CBearing, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Bearing>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CBearing extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CBearingBasicFunctions on _CStatefulChannel_CBearing {
  void _releaseIntermediate() {
    _CStatefulChannel_CBearing_release(this);
  }

  _CStatefulChannel_CBearing _retain() {
    return _CStatefulChannel_CBearing_retain(this);
  }

  Bearing _getter() {
    final cValue = _CStatefulChannel_CBearingGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CBearing, ffi.Int64)> callback) {
    return _CStatefulChannel_CBearingConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CBearingToDart on _CStatefulChannel_CBearing {
  StatefulChannel<Bearing> _toDart() {
    return _CStatefulChannel_CBearingImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CBearing on StatefulChannel<Bearing> {
  _CStatefulChannel_CBearing _copyFromDartTo_CStatefulChannel_CBearing() {
    return _CStatefulChannel_CBearingMakeDefault();
  }
}
	
// MARK: - ZoomControlButton

enum ZoomControlButton {
  zoomIn(0),
  zoomOut(1),
  ;

  const ZoomControlButton(this.rawValue);
  final int rawValue;

  static ZoomControlButton getByValue(int value) {
    return ZoomControlButton.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CZoomControlButton extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CZoomControlButtonBasicFunctions on _CZoomControlButton {
  void _releaseIntermediate() {
  }
}

extension _CZoomControlButtonToDart on _CZoomControlButton {
  ZoomControlButton _toDart() {
    return ZoomControlButton.getByValue(this.rawValue);
  }
}

extension _DartTo_CZoomControlButton on ZoomControlButton {
  _CZoomControlButton _copyFromDartTo_CZoomControlButton() {
    return _CZoomControlButtonMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ZoomControlModel

/**
 Модель контрола зумирования.
 Контрол состоит из кнопок +/-, при нажатии на которые меняется масштаб карты.
 При достижении допустимой границы масштаба кнопка масштабирования в этом направлении становится неактивной.
 Методы объекта необходимо вызывать на одном потоке.
*/
class ZoomControlModel implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CZoomControlModel_releasePtr);

  ZoomControlModel._raw(this._self);
  factory ZoomControlModel._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ZoomControlModel._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory ZoomControlModel(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CZoomControlModel res = _CZoomControlModel_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return ZoomControlModel._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ZoomControlModel &&
    other.runtimeType == runtimeType &&
    _CZoomControlModel_cg_objectIdentifier(this._self) == _CZoomControlModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CZoomControlModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: ZoomControlModel: Methods

  StatefulChannel<bool> isEnabled(
    ZoomControlButton button
  )  {
    var _a1 = button._copyFromDartTo_CZoomControlButton();
    _CStatefulChannel_bool res = _CZoomControlModel_isEnabled_CZoomControlButton(_CZoomControlModelMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  void setPressed(
    ZoomControlButton button,
    bool value
  )  {
    var _a1 = button._copyFromDartTo_CZoomControlButton();
    void res = _CZoomControlModel_setPressed_CZoomControlButton_bool(_CZoomControlModelMakeDefault().._impl=_self, _a1, value);
    return res;
  }

}

// MARK: - ZoomControlModel <-> CZoomControlModel

final class _CZoomControlModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CZoomControlModelBasicFunctions on _CZoomControlModel {
  void _releaseIntermediate() {
    _CZoomControlModel_release(_impl);
  }

  _CZoomControlModel _retain() {
    return _CZoomControlModel_retain(_impl);
  }
}

extension _CZoomControlModelToDart on _CZoomControlModel {
  ZoomControlModel _toDart() {
    return ZoomControlModel._create(_retain()._impl);
  }
}


extension _DartToCZoomControlModel on ZoomControlModel {
  _CZoomControlModel _copyFromDartTo_CZoomControlModel() {
    return (_CZoomControlModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DefaultRasterUrlTemplate

class DefaultRasterUrlTemplate {
  final String urlTemplate;

  const DefaultRasterUrlTemplate(this.urlTemplate);

  DefaultRasterUrlTemplate copyWith({
    String? urlTemplate
  }) {
    return DefaultRasterUrlTemplate(
      urlTemplate ?? this.urlTemplate
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DefaultRasterUrlTemplate &&
    other.runtimeType == runtimeType &&
    other.urlTemplate == urlTemplate;

  @override
  int get hashCode {
    return urlTemplate.hashCode;
  }

}
final class _CDefaultRasterUrlTemplate extends ffi.Struct {
  external _CString urlTemplate;

}
// MARK: - DefaultRasterUrlTemplate <-> _CDefaultRasterUrlTemplate

extension _CDefaultRasterUrlTemplateToDart on _CDefaultRasterUrlTemplate {
  DefaultRasterUrlTemplate _toDart() {
    return DefaultRasterUrlTemplate(
      this.urlTemplate._toDart()
    );
  }
}

extension _DartTo_CDefaultRasterUrlTemplate on DefaultRasterUrlTemplate {
  _CDefaultRasterUrlTemplate _copyFromDartTo_CDefaultRasterUrlTemplate() {
    final res = _CDefaultRasterUrlTemplateMakeDefault();
    res.urlTemplate = this.urlTemplate._copyFromDartTo_CString();
    return res;
  }
}
extension _CDefaultRasterUrlTemplateRelease on _CDefaultRasterUrlTemplate {
  void _releaseIntermediate() {
    urlTemplate._releaseIntermediate();
  }
}

// MARK: - WmsRasterUrlTemplate

class WmsRasterUrlTemplate {
  final String urlTemplate;

  const WmsRasterUrlTemplate(this.urlTemplate);

  WmsRasterUrlTemplate copyWith({
    String? urlTemplate
  }) {
    return WmsRasterUrlTemplate(
      urlTemplate ?? this.urlTemplate
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is WmsRasterUrlTemplate &&
    other.runtimeType == runtimeType &&
    other.urlTemplate == urlTemplate;

  @override
  int get hashCode {
    return urlTemplate.hashCode;
  }

}
final class _CWmsRasterUrlTemplate extends ffi.Struct {
  external _CString urlTemplate;

}
// MARK: - WmsRasterUrlTemplate <-> _CWmsRasterUrlTemplate

extension _CWmsRasterUrlTemplateToDart on _CWmsRasterUrlTemplate {
  WmsRasterUrlTemplate _toDart() {
    return WmsRasterUrlTemplate(
      this.urlTemplate._toDart()
    );
  }
}

extension _DartTo_CWmsRasterUrlTemplate on WmsRasterUrlTemplate {
  _CWmsRasterUrlTemplate _copyFromDartTo_CWmsRasterUrlTemplate() {
    final res = _CWmsRasterUrlTemplateMakeDefault();
    res.urlTemplate = this.urlTemplate._copyFromDartTo_CString();
    return res;
  }
}
extension _CWmsRasterUrlTemplateRelease on _CWmsRasterUrlTemplate {
  void _releaseIntermediate() {
    urlTemplate._releaseIntermediate();
  }
}

// MARK: - RasterUrlTemplate

final class RasterUrlTemplate {
  final Object? _value;
  final int _index;

  RasterUrlTemplate._raw(this._value, this._index);

  RasterUrlTemplate.defaultSource(DefaultRasterUrlTemplate value) : this._raw(value, 0);
  RasterUrlTemplate.wmsSource(WmsRasterUrlTemplate value) : this._raw(value, 1);

  bool get isDefaultSource => this._index == 0;
  DefaultRasterUrlTemplate? get asDefaultSource => this.isDefaultSource ? this._value as DefaultRasterUrlTemplate : null;

  bool get isWmsSource => this._index == 1;
  WmsRasterUrlTemplate? get asWmsSource => this.isWmsSource ? this._value as WmsRasterUrlTemplate : null;

  T match<T>({
    required T Function(DefaultRasterUrlTemplate value) defaultSource,
    required T Function(WmsRasterUrlTemplate value) wmsSource,
  }) {
    return switch (this._index) {
      0 => defaultSource(this._value as DefaultRasterUrlTemplate),
      1 => wmsSource(this._value as WmsRasterUrlTemplate),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "RasterUrlTemplate(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RasterUrlTemplate &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CRasterUrlTemplateImpl extends ffi.Union {
  external _CDefaultRasterUrlTemplate _defaultSource;
  external _CWmsRasterUrlTemplate _wmsSource;
}

final class _CRasterUrlTemplate extends ffi.Struct {
  external _CRasterUrlTemplateImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CRasterUrlTemplateBasicFunctions on _CRasterUrlTemplate {
  void _releaseIntermediate() {
    _CRasterUrlTemplate_release(this);
  }
}
	
// MARK: - RasterUrlTemplate <-> CRasterUrlTemplate

extension _CRasterUrlTemplateToDart on _CRasterUrlTemplate {
  RasterUrlTemplate _toDart() {
    return switch (this._index) {
      0 => RasterUrlTemplate.defaultSource(this._impl._defaultSource._toDart()),
      1 => RasterUrlTemplate.wmsSource(this._impl._wmsSource._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CRasterUrlTemplate on RasterUrlTemplate {
  _CRasterUrlTemplate _copyFromDartTo_CRasterUrlTemplate() {
    var res = _CRasterUrlTemplateMakeDefault();
    this.match<void>(
      defaultSource: (DefaultRasterUrlTemplate value) {
        res._impl._defaultSource = value._copyFromDartTo_CDefaultRasterUrlTemplate();
        res._index = 0;
      },
      wmsSource: (WmsRasterUrlTemplate value) {
        res._impl._wmsSource = value._copyFromDartTo_CWmsRasterUrlTemplate();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - RasterTileSource

/** Источник, получающий растровые тайлы. */
class RasterTileSource extends Source implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CRasterTileSource_releasePtr);

  RasterTileSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RasterTileSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RasterTileSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Создание источника, получающего растровые тайлы.
  
   - Parameter context: контекст.
   - Parameter sublayerName: имя, которое будет использовано при генерации объектов.
   Это имя должно быть указано в стилях в условии filter слоя типа raster для атрибута db_sublayer.
   Пример: ["match", ["get", "db_sublayer"], ["NAME"], true, false]
   Подробнее см. спецификацию: https://docs.2gis.com/ru/mapgl/stylespecification
   - Parameter sourceTemplate: Шаблон для запроса тайлов.
  */
  factory RasterTileSource(
    Context context,
    String sublayerName,
    RasterUrlTemplate sourceTemplate
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    var _a1 = sublayerName._copyFromDartTo_CString();
    var _a2 = sourceTemplate._copyFromDartTo_CRasterUrlTemplate();
    _CRasterTileSource res = _CRasterTileSource_C_createWith_CContext_CString_CRasterUrlTemplate(_a0, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    return RasterTileSource._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RasterTileSource &&
    other.runtimeType == runtimeType &&
    _CRasterTileSource_cg_objectIdentifier(this._self) == _CRasterTileSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRasterTileSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RasterTileSource: Methods

  /** Установка значения прозрачности растрового тайла. */
  void setOpacity(
    Opacity opacity
  )  {
    var _a1 = opacity._copyFromDartTo_COpacity();
    void res = _CRasterTileSource_setOpacity_COpacity(_CRasterTileSourceMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - RasterTileSource <-> CRasterTileSource

final class _CRasterTileSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRasterTileSourceBasicFunctions on _CRasterTileSource {
  void _releaseIntermediate() {
    _CRasterTileSource_release(_impl);
  }

  _CRasterTileSource _retain() {
    return _CRasterTileSource_retain(_impl);
  }
}

extension _CRasterTileSourceToDart on _CRasterTileSource {
  RasterTileSource _toDart() {
    return RasterTileSource._create(_retain()._impl);
  }
}


extension _DartToCRasterTileSource on RasterTileSource {
  _CRasterTileSource _copyFromDartTo_CRasterTileSource() {
    return (_CRasterTileSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ParkingControlModel

/**
 Модель контрола парковок.

 - Note: Этот интерфейс является потокобезопасным.
*/
class ParkingControlModel implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Состояние элемента управления видимостью парковок.
   true, если парковки видны.
  */
  StatefulChannel<bool> get isEnabledChannel {
    _CStatefulChannel_bool res = _CParkingControlModel_isEnabledChannel(_CParkingControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Состояние элемента управления видимостью парковок.
   true, если парковки видны.
  */
  bool get isEnabled {
    bool res = _CParkingControlModel_isEnabled(_CParkingControlModelMakeDefault().._impl=_self);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CParkingControlModel_releasePtr);

  ParkingControlModel._raw(this._self);
  factory ParkingControlModel._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ParkingControlModel._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Функция создания модели элемента управления парковками.
  
   - Parameter map: карта.
   - Returns: Модель элемента управления видимостью парковок для карты.
  */
  factory ParkingControlModel(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CParkingControlModel res = _CParkingControlModel_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return ParkingControlModel._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ParkingControlModel &&
    other.runtimeType == runtimeType &&
    _CParkingControlModel_cg_objectIdentifier(this._self) == _CParkingControlModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CParkingControlModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: ParkingControlModel: Methods

  /**
   Действие при нажатии на контрол.
   Переключает видимость парковок на карте.
  */
  void toggleParkingsVisibility()  {
    void res = _CParkingControlModel_toggleParkingsVisibility(_CParkingControlModelMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - ParkingControlModel <-> CParkingControlModel

final class _CParkingControlModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CParkingControlModelBasicFunctions on _CParkingControlModel {
  void _releaseIntermediate() {
    _CParkingControlModel_release(_impl);
  }

  _CParkingControlModel _retain() {
    return _CParkingControlModel_retain(_impl);
  }
}

extension _CParkingControlModelToDart on _CParkingControlModel {
  ParkingControlModel _toDart() {
    return ParkingControlModel._create(_retain()._impl);
  }
}


extension _DartToCParkingControlModel on ParkingControlModel {
  _CParkingControlModel _copyFromDartTo_CParkingControlModel() {
    return (_CParkingControlModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PackedMapState

/** Сериализованное состояние карты. */
class PackedMapState implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Получение состояния отображения пробок на карте. */
  bool get showTraffic {
    bool res = _CPackedMapState_showTraffic(_CPackedMapStateMakeDefault().._impl=_self);
    return res;
  }
  set showTraffic(bool showTraffic) {
    void res = _CPackedMapState_setShowTraffic_bool(_CPackedMapStateMakeDefault().._impl=_self, showTraffic);
    return res;
  }
  /** Получение позиции камеры. */
  CameraPosition get cameraPosition {
    _CCameraPosition res = _CPackedMapState_cameraPosition(_CPackedMapStateMakeDefault().._impl=_self);
    return res._toDart();
  }
  set cameraPosition(CameraPosition position) {
    var _a1 = position._copyFromDartTo_CCameraPosition();
    void res = _CPackedMapState_setCameraPosition_CCameraPosition(_CPackedMapStateMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получения режима слежения камеры. */
  CameraBehaviour get cameraBehaviour {
    _CCameraBehaviour res = _CPackedMapState_cameraBehaviour(_CPackedMapStateMakeDefault().._impl=_self);
    return res._toDart();
  }
  set cameraBehaviour(CameraBehaviour behaviour) {
    var _a1 = behaviour._copyFromDartTo_CCameraBehaviour();
    void res = _CPackedMapState_setCameraBehaviour_CCameraBehaviour(_CPackedMapStateMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPackedMapState_releasePtr);

  PackedMapState._raw(this._self);
  factory PackedMapState._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PackedMapState._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PackedMapState &&
    other.runtimeType == runtimeType &&
    _CPackedMapState_cg_objectIdentifier(this._self) == _CPackedMapState_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPackedMapState_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CPackedMapState: Static Methods

  /**
   Получение состояния карты.
  
   - Parameter position: Позиция камеры.
   - Parameter showTraffic: Состояние отображения пробок на карте.
   - Parameter behaviour: Режим слежения камеры.
   - Returns: Сериализованное состояние карты.
  */
  static PackedMapState of(
    CameraPosition position,
    bool showTraffic,
    CameraBehaviour behaviour
  )  {
    var _a0 = position._copyFromDartTo_CCameraPosition();
    var _a2 = behaviour._copyFromDartTo_CCameraBehaviour();
    _CPackedMapState res = _CPackedMapState_S_of_CCameraPosition_bool_CCameraBehaviour(_a0, showTraffic, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получение состояния карты.
  
   - Parameter data: Состояние карты в виде последовательности байтов.
   - Throws: Exception десериализуется неподдерживаемая версия или битые данные.
   - Returns: Сериализованное состояние карты.
  */
  static PackedMapState fromBytes(
    ByteData data
  )  {
    var _a0 = data._copyFromDartTo_CData();
    _CResult_CPackedMapState res = _CPackedMapState_S_fromBytes_CData(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получение состояния карты.
  
   - Parameter map: Карта, состояние которой необходимо получить.
   - Returns: Сериализованное состояние карты.
  */
  static PackedMapState fromMap(
    Map map
  )  {
    var _a0 = map._copyFromDartTo_CMap();
    _CPackedMapState res = _CPackedMapState_S_fromMap_CMap(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: PackedMapState: Methods

  /** Представление состояния карты в виде последовательности байтов. */
  ByteData toBytes()  {
    _CData res = _CPackedMapState_toBytes(_CPackedMapStateMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - PackedMapState <-> CPackedMapState

final class _CPackedMapState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPackedMapStateBasicFunctions on _CPackedMapState {
  void _releaseIntermediate() {
    _CPackedMapState_release(_impl);
  }

  _CPackedMapState _retain() {
    return _CPackedMapState_retain(_impl);
  }
}

extension _CPackedMapStateToDart on _CPackedMapState {
  PackedMapState _toDart() {
    return PackedMapState._create(_retain()._impl);
  }
}


extension _DartToCPackedMapState on PackedMapState {
  _CPackedMapState _copyFromDartTo_CPackedMapState() {
    return (_CPackedMapStateMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PackedMapState <-> _CResult_CPackedMapState

final class _CResult_CPackedMapStateImpl extends ffi.Union {
  
  external _CPackedMapState _value;
  external _CError _error;
}

final class _CResult_CPackedMapState extends ffi.Struct {
  external _CResult_CPackedMapStateImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CPackedMapStateBasicFunctions on _CResult_CPackedMapState {
  void _releaseIntermediate() {
    _CResult_CPackedMapState_release(this);
  }
}

extension _CResult_CPackedMapStateToDart on _CResult_CPackedMapState {
  PackedMapState _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CPackedMapState _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - CalloutMapPosition

/** Положение бабла маршрута. */
class CalloutMapPosition {
  /** Идентификатор карты, для которой приведена позиция. */
  final MapId mapId;
  /** Позиция на карте. */
  final GeoPoint? calloutPosition;
  /** Позиция бабла на маршруте. */
  final RoutePoint? routePoint;

  const CalloutMapPosition({
    required this.mapId,
    required this.calloutPosition,
    required this.routePoint
  });

  CalloutMapPosition copyWith({
    MapId? mapId,
    Optional<GeoPoint?>? calloutPosition,
    Optional<RoutePoint?>? routePoint
  }) {
    return CalloutMapPosition(
      mapId: mapId ?? this.mapId,
      calloutPosition: calloutPosition != null ? calloutPosition.value : this.calloutPosition,
      routePoint: routePoint != null ? routePoint.value : this.routePoint
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CalloutMapPosition &&
    other.runtimeType == runtimeType &&
    other.mapId == mapId &&
    other.calloutPosition == calloutPosition &&
    other.routePoint == routePoint;

  @override
  int get hashCode {
    return Object.hash(mapId, calloutPosition, routePoint);
  }

}
final class _CCalloutMapPosition extends ffi.Struct {
  external _CMapId mapId;

  external _COptional_CGeoPoint calloutPosition;

  external _COptional_CRoutePoint routePoint;

}
// MARK: - CalloutMapPosition <-> _CCalloutMapPosition

extension _CCalloutMapPositionToDart on _CCalloutMapPosition {
  CalloutMapPosition _toDart() {
    return CalloutMapPosition(
      mapId: this.mapId._toDart(),
      calloutPosition: this.calloutPosition._toDart(),
      routePoint: this.routePoint._toDart()
    );
  }
}

extension _DartTo_CCalloutMapPosition on CalloutMapPosition {
  _CCalloutMapPosition _copyFromDartTo_CCalloutMapPosition() {
    final res = _CCalloutMapPositionMakeDefault();
    res.mapId = this.mapId._copyFromDartTo_CMapId();
    res.calloutPosition = this.calloutPosition._copyFromDartTo_COptional_CGeoPoint();
    res.routePoint = this.routePoint._copyFromDartTo_COptional_CRoutePoint();
    return res;
  }
}
extension _CCalloutMapPositionRelease on _CCalloutMapPosition {
  void _releaseIntermediate() {
  }
}

// MARK: - CalloutVisualizationMode

/**
 Режим отображения баблов со временем и длиной маршрута. В отличие от DisplayFlag
 для каждого индивидуального объекта маршрута влияет не только на отображение,
 но и на расчёт позиций баблов.
 См. IRouteMapObject::display_flags.
 См. IRouteMapObject::callout_position.
*/
enum CalloutVisualizationMode {
  /**
   Показывать баблы (с учётом DisplayFlag) и рассчитывать позиции для них
   если в источник добавлен хотя бы один маршрут.
  */
  always(0),
  /**
   Показывать баблы (с учётом DisplayFlag) и рассчитывать позиции для них
   только в том случае, если в источник добавлено более одного объекта маршрута.
  */
  multipleRoutes(1),
  /** Не показывать баблы и не рассчитывать позиции для них. */
  none(2),
  ;

  const CalloutVisualizationMode(this.rawValue);
  final int rawValue;

  static CalloutVisualizationMode getByValue(int value) {
    return CalloutVisualizationMode.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCalloutVisualizationMode extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCalloutVisualizationModeBasicFunctions on _CCalloutVisualizationMode {
  void _releaseIntermediate() {
  }
}

extension _CCalloutVisualizationModeToDart on _CCalloutVisualizationMode {
  CalloutVisualizationMode _toDart() {
    return CalloutVisualizationMode.getByValue(this.rawValue);
  }
}

extension _DartTo_CCalloutVisualizationMode on CalloutVisualizationMode {
  _CCalloutVisualizationMode _copyFromDartTo_CCalloutVisualizationMode() {
    return _CCalloutVisualizationModeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - LanesCalloutMapPosition

/** Положение бабла полосности для маршрута. */
class LanesCalloutMapPosition {
  /** Идентификатор карты, для которой приведена позиция. */
  final MapId mapId;
  /** Позиция бабла полосности на маршруте. */
  final RoutePoint routePoint;
  /** Позиция бабла полосности на карте. */
  final GeoPoint geoPoint;

  const LanesCalloutMapPosition({
    required this.mapId,
    required this.routePoint,
    required this.geoPoint
  });

  LanesCalloutMapPosition copyWith({
    MapId? mapId,
    RoutePoint? routePoint,
    GeoPoint? geoPoint
  }) {
    return LanesCalloutMapPosition(
      mapId: mapId ?? this.mapId,
      routePoint: routePoint ?? this.routePoint,
      geoPoint: geoPoint ?? this.geoPoint
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LanesCalloutMapPosition &&
    other.runtimeType == runtimeType &&
    other.mapId == mapId &&
    other.routePoint == routePoint &&
    other.geoPoint == geoPoint;

  @override
  int get hashCode {
    return Object.hash(mapId, routePoint, geoPoint);
  }

}
final class _CLanesCalloutMapPosition extends ffi.Struct {
  external _CMapId mapId;

  external _CRoutePoint routePoint;

  external _CGeoPoint geoPoint;

}
// MARK: - LanesCalloutMapPosition <-> _CLanesCalloutMapPosition

extension _CLanesCalloutMapPositionToDart on _CLanesCalloutMapPosition {
  LanesCalloutMapPosition _toDart() {
    return LanesCalloutMapPosition(
      mapId: this.mapId._toDart(),
      routePoint: this.routePoint._toDart(),
      geoPoint: this.geoPoint._toDart()
    );
  }
}

extension _DartTo_CLanesCalloutMapPosition on LanesCalloutMapPosition {
  _CLanesCalloutMapPosition _copyFromDartTo_CLanesCalloutMapPosition() {
    final res = _CLanesCalloutMapPositionMakeDefault();
    res.mapId = this.mapId._copyFromDartTo_CMapId();
    res.routePoint = this.routePoint._copyFromDartTo_CRoutePoint();
    res.geoPoint = this.geoPoint._copyFromDartTo_CGeoPoint();
    return res;
  }
}
extension _CLanesCalloutMapPositionRelease on _CLanesCalloutMapPosition {
  void _releaseIntermediate() {
  }
}

// MARK: - IndoorRouteLevelsGetter

/**
 Позволяет получать множество этажей, через которые проходят маршруты,
 отображаемые на карте.
*/
class IndoorRouteLevelsGetter implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  StatefulChannel<Set<LevelId>> get levelIdsChannel {
    _CStatefulChannel_CSet_CLevelId res = _CIndoorRouteLevelsGetter_levelIdsChannel(_CIndoorRouteLevelsGetterMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Set<LevelId> get levelIds {
    _CSet_CLevelId res = _CIndoorRouteLevelsGetter_levelIds(_CIndoorRouteLevelsGetterMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CIndoorRouteLevelsGetter_releasePtr);

  IndoorRouteLevelsGetter._raw(this._self);
  factory IndoorRouteLevelsGetter._create(ffi.Pointer<ffi.Void> self) {
    final classObject = IndoorRouteLevelsGetter._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory IndoorRouteLevelsGetter(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CIndoorRouteLevelsGetter res = _CIndoorRouteLevelsGetter_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return IndoorRouteLevelsGetter._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IndoorRouteLevelsGetter &&
    other.runtimeType == runtimeType &&
    _CIndoorRouteLevelsGetter_cg_objectIdentifier(this._self) == _CIndoorRouteLevelsGetter_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CIndoorRouteLevelsGetter_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - IndoorRouteLevelsGetter <-> CIndoorRouteLevelsGetter

final class _CIndoorRouteLevelsGetter extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CIndoorRouteLevelsGetterBasicFunctions on _CIndoorRouteLevelsGetter {
  void _releaseIntermediate() {
    _CIndoorRouteLevelsGetter_release(_impl);
  }

  _CIndoorRouteLevelsGetter _retain() {
    return _CIndoorRouteLevelsGetter_retain(_impl);
  }
}

extension _CIndoorRouteLevelsGetterToDart on _CIndoorRouteLevelsGetter {
  IndoorRouteLevelsGetter _toDart() {
    return IndoorRouteLevelsGetter._create(_retain()._impl);
  }
}


extension _DartToCIndoorRouteLevelsGetter on IndoorRouteLevelsGetter {
  _CIndoorRouteLevelsGetter _copyFromDartTo_CIndoorRouteLevelsGetter() {
    return (_CIndoorRouteLevelsGetterMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<Set<LevelId>> <-> _CStatefulChannel_CSet_CLevelId

class _CStatefulChannel_CSet_CLevelIdImpl extends StatefulChannel<Set<LevelId>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Set<LevelId>>>{};

  final _CStatefulChannel_CSet_CLevelId _channel;

  _CStatefulChannel_CSet_CLevelIdImpl(this._channel);

  @override
  Set<LevelId> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CSet_CLevelId cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<Set<LevelId>> listen(void onData(Set<LevelId> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CSet_CLevelId, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Set<LevelId>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CSet_CLevelId extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CSet_CLevelIdBasicFunctions on _CStatefulChannel_CSet_CLevelId {
  void _releaseIntermediate() {
    _CStatefulChannel_CSet_CLevelId_release(this);
  }

  _CStatefulChannel_CSet_CLevelId _retain() {
    return _CStatefulChannel_CSet_CLevelId_retain(this);
  }

  Set<LevelId> _getter() {
    final cValue = _CStatefulChannel_CSet_CLevelIdGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CSet_CLevelId, ffi.Int64)> callback) {
    return _CStatefulChannel_CSet_CLevelIdConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CSet_CLevelIdToDart on _CStatefulChannel_CSet_CLevelId {
  StatefulChannel<Set<LevelId>> _toDart() {
    return _CStatefulChannel_CSet_CLevelIdImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CSet_CLevelId on StatefulChannel<Set<LevelId>> {
  _CStatefulChannel_CSet_CLevelId _copyFromDartTo_CStatefulChannel_CSet_CLevelId() {
    return _CStatefulChannel_CSet_CLevelIdMakeDefault();
  }
}
	
// MARK: - RouteMapObjectPassedDistanceVisualization

/** Способ визуализации маршрута с учётом пройденного вдоль маршрута расстояния. */
enum RouteMapObjectPassedDistanceVisualization {
  /** Показывать только оставшуюся часть маршрута - от пройденного расстояния до финиша. */
  showRemainingRoutePart(0),
  /** Показывать только пройденную часть маршрута - от старта до пройденного расстояния. */
  showPassedRoutePart(1),
  /** Показывать весь маршрут независимо от пройденного вдоль него расстояния. */
  showWholeRoute(2),
  ;

  const RouteMapObjectPassedDistanceVisualization(this.rawValue);
  final int rawValue;

  static RouteMapObjectPassedDistanceVisualization getByValue(int value) {
    return RouteMapObjectPassedDistanceVisualization.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouteMapObjectPassedDistanceVisualization extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouteMapObjectPassedDistanceVisualizationBasicFunctions on _CRouteMapObjectPassedDistanceVisualization {
  void _releaseIntermediate() {
  }
}

extension _CRouteMapObjectPassedDistanceVisualizationToDart on _CRouteMapObjectPassedDistanceVisualization {
  RouteMapObjectPassedDistanceVisualization _toDart() {
    return RouteMapObjectPassedDistanceVisualization.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouteMapObjectPassedDistanceVisualization on RouteMapObjectPassedDistanceVisualization {
  _CRouteMapObjectPassedDistanceVisualization _copyFromDartTo_CRouteMapObjectPassedDistanceVisualization() {
    return _CRouteMapObjectPassedDistanceVisualizationMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RouteMapObjectDisplayFlag

/** Флаги, включающие отображение различных составных частей маршрута. */
enum RouteMapObjectDisplayFlag {
  /** Отрезки маршрута. */
  routeParts(1),
  /** Стартовая точка маршрута. */
  startPoint(2),
  /** Конечная точка маршрута. */
  finishPoint(4),
  /** Промежуточные точки маршрута. */
  intermediatePoints(8),
  /**
   Точки соединения отрезков маршрута (кроме маршрутов на общественном транспорте).
   Например, точка в месте соединения пешеходного и автомобильного отрезка.
  */
  transportConnectionPoints(16),
  /** Манёвры. */
  maneuvers(32),
  /** Камеры. */
  cameras(64),
  /** Искуcственные неровности. */
  humps(128),
  /** Перекрытия дороги. */
  barriers(256),
  /** Ворота, шлагбаумы. */
  gates(512),
  /** Лестницы. */
  stairways(1024),
  /** Остановки общественного транспорта. */
  publicTransportPlatforms(4096),
  /** ДТП. */
  accidents(8192),
  /** Дорожные работы. */
  roadWorks(16384),
  /** Комментарии. */
  comments(32768),
  /** Перекрытия дорожного движения. */
  roadRestrictions(65536),
  /** События "Другое". */
  otherEvents(131072),
  /** Начало и конец платной дороги. */
  tollRoads(262144),
  /** Баблы полосности (отображаются только в источнике с режимом навигации). */
  lanesBubbles(524288),
  /** Баблы с временем движения и длиной маршрута. */
  bubbles(1048576),
  /** Перемещение внутри здания на лифте, эскалаторе и т.д. */
  indoorInstructions(2097152),
  /** Показывать части маршрута внутри зданий не только для активного этажа. */
  inactiveFloors(4194304),
  /** Подсвечивать светофоры на маршруте. */
  trafficLights(8388608),
  /** Использовать иммерсивную геометрию для отрезков маршрута (используется совместно с RouteParts). */
  immersiveRouteParts(16777216),
  ;

  const RouteMapObjectDisplayFlag(this.rawValue);
  final int rawValue;

  static RouteMapObjectDisplayFlag getByValue(int value) {
    return RouteMapObjectDisplayFlag.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouteMapObjectDisplayFlag extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouteMapObjectDisplayFlagBasicFunctions on _CRouteMapObjectDisplayFlag {
  void _releaseIntermediate() {
  }
}

extension _CRouteMapObjectDisplayFlagToDart on _CRouteMapObjectDisplayFlag {
  RouteMapObjectDisplayFlag _toDart() {
    return RouteMapObjectDisplayFlag.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouteMapObjectDisplayFlag on RouteMapObjectDisplayFlag {
  _CRouteMapObjectDisplayFlag _copyFromDartTo_CRouteMapObjectDisplayFlag() {
    return _CRouteMapObjectDisplayFlagMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RouteMapObjectPermanentDisplayFlag

/**
 Флаги, исключающие скрытие различных составных частей маршрута с карты при обновлении
 пройденного вдоль маршрута расстояния, если passed_distance_visualization()
 имеет значение, отличное от ShowWholeRoute
*/
enum RouteMapObjectPermanentDisplayFlag {
  /** Стартовая точка маршрута. */
  startPoint(1),
  /** Конечная точка маршрута. */
  finishPoint(2),
  /** Промежуточные точки маршрута. */
  intermediatePoints(4),
  /** Камеры. */
  cameras(8),
  /** ДТП. */
  accidents(16),
  /** Дорожные работы. */
  roadWorks(32),
  /** Комментарии. */
  comments(64),
  /** Перекрытия дорожного движения. */
  roadRestrictions(128),
  /** События "Другое". */
  otherEvents(256),
  /** Начало и конец платной дороги. */
  tollRoads(512),
  ;

  const RouteMapObjectPermanentDisplayFlag(this.rawValue);
  final int rawValue;

  static RouteMapObjectPermanentDisplayFlag getByValue(int value) {
    return RouteMapObjectPermanentDisplayFlag.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouteMapObjectPermanentDisplayFlag extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouteMapObjectPermanentDisplayFlagBasicFunctions on _CRouteMapObjectPermanentDisplayFlag {
  void _releaseIntermediate() {
  }
}

extension _CRouteMapObjectPermanentDisplayFlagToDart on _CRouteMapObjectPermanentDisplayFlag {
  RouteMapObjectPermanentDisplayFlag _toDart() {
    return RouteMapObjectPermanentDisplayFlag.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouteMapObjectPermanentDisplayFlag on RouteMapObjectPermanentDisplayFlag {
  _CRouteMapObjectPermanentDisplayFlag _copyFromDartTo_CRouteMapObjectPermanentDisplayFlag() {
    return _CRouteMapObjectPermanentDisplayFlagMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RouteMapObjectCalloutLabelFlag

/** Флаги, включающие отображение содержимого в баблах маршрута. */
enum RouteMapObjectCalloutLabelFlag {
  /** Время движения по маршруту. */
  duration(1),
  /** Длина маршрута. */
  length(2),
  ;

  const RouteMapObjectCalloutLabelFlag(this.rawValue);
  final int rawValue;

  static RouteMapObjectCalloutLabelFlag getByValue(int value) {
    return RouteMapObjectCalloutLabelFlag.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouteMapObjectCalloutLabelFlag extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouteMapObjectCalloutLabelFlagBasicFunctions on _CRouteMapObjectCalloutLabelFlag {
  void _releaseIntermediate() {
  }
}

extension _CRouteMapObjectCalloutLabelFlagToDart on _CRouteMapObjectCalloutLabelFlag {
  RouteMapObjectCalloutLabelFlag _toDart() {
    return RouteMapObjectCalloutLabelFlag.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouteMapObjectCalloutLabelFlag on RouteMapObjectCalloutLabelFlag {
  _CRouteMapObjectCalloutLabelFlag _copyFromDartTo_CRouteMapObjectCalloutLabelFlag() {
    return _CRouteMapObjectCalloutLabelFlagMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RouteMapObjectCalloutLabelDisplayMode

/** Режим отображения значений в баблах маршрута. */
enum RouteMapObjectCalloutLabelDisplayMode {
  /** Время движения по маршруту и/или длина маршрута отображаются в абсолютных величинах (например: N км, M мин) */
  absoluteValues(0),
  /**
   Время движения по маршруту и/или длина маршрута отображаются в абсолютных величинах только
   для активного маршрута, а для неактивных маршрутов отображается разница с соответствующей величиной
   активного маршрута (например: +/-N км, +/-M мин).
   Если активного маршрута нет или на карте есть более одного активного маршрута, то для всех маршрутов
   время движения и/или длина отображаются в абсолютных величинах.
  */
  relativeToActiveRouteValues(1),
  ;

  const RouteMapObjectCalloutLabelDisplayMode(this.rawValue);
  final int rawValue;

  static RouteMapObjectCalloutLabelDisplayMode getByValue(int value) {
    return RouteMapObjectCalloutLabelDisplayMode.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouteMapObjectCalloutLabelDisplayMode extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouteMapObjectCalloutLabelDisplayModeBasicFunctions on _CRouteMapObjectCalloutLabelDisplayMode {
  void _releaseIntermediate() {
  }
}

extension _CRouteMapObjectCalloutLabelDisplayModeToDart on _CRouteMapObjectCalloutLabelDisplayMode {
  RouteMapObjectCalloutLabelDisplayMode _toDart() {
    return RouteMapObjectCalloutLabelDisplayMode.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouteMapObjectCalloutLabelDisplayMode on RouteMapObjectCalloutLabelDisplayMode {
  _CRouteMapObjectCalloutLabelDisplayMode _copyFromDartTo_CRouteMapObjectCalloutLabelDisplayMode() {
    return _CRouteMapObjectCalloutLabelDisplayModeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RouteMapObject

/** Объект маршрута на карте. */
class RouteMapObject extends MapObject implements ffi.Finalizable {
  /**
   Набор флагов для отображения различных частей маршрута.
   Если не задан, используется логика отображения на основе статуса активности маршрута.
  */
  StatefulChannel<RouteMapObjectDisplayFlagEnumSet?> get displayFlagsChannel {
    _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag res = _CRouteMapObject_displayFlagsChannel(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Набор флагов для отображения различных частей маршрута.
   Если не задан, используется логика отображения на основе статуса активности маршрута.
  */
  RouteMapObjectDisplayFlagEnumSet? get displayFlags {
    _COptional_COptionSet_CRouteMapObjectDisplayFlag res = _CRouteMapObject_displayFlags(_CRouteMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set displayFlags(RouteMapObjectDisplayFlagEnumSet? flags) {
    var _a1 = flags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectDisplayFlag();
    void res = _CRouteMapObject_setDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlag(_CRouteMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Набор флагов для предотвращения скрытия различных составных частей маршрута с карты
   при обновлении пройденного вдоль маршрута расстояния.
   Если не задан, то при обновлении пройденного вдоль маршрута расстояния с карты скрываются
   все элементы маршрута, попадающие в неотображаемую часть маршрута.
  */
  StatefulChannel<RouteMapObjectPermanentDisplayFlagEnumSet?> get permanentDisplayFlagsChannel {
    _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag res = _CRouteMapObject_permanentDisplayFlagsChannel(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Набор флагов для предотвращения скрытия различных составных частей маршрута с карты
   при обновлении пройденного вдоль маршрута расстояния.
   Если не задан, то при обновлении пройденного вдоль маршрута расстояния с карты скрываются
   все элементы маршрута, попадающие в неотображаемую часть маршрута.
  */
  RouteMapObjectPermanentDisplayFlagEnumSet? get permanentDisplayFlags {
    _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag res = _CRouteMapObject_permanentDisplayFlags(_CRouteMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set permanentDisplayFlags(RouteMapObjectPermanentDisplayFlagEnumSet? flags) {
    var _a1 = flags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag();
    void res = _CRouteMapObject_setPermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag(_CRouteMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Статус активности маршрута. */
  StatefulChannel<bool> get isActiveChannel {
    _CStatefulChannel_bool res = _CRouteMapObject_isActiveChannel(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Статус активности маршрута. */
  bool get isActive {
    bool res = _CRouteMapObject_isActive(_CRouteMapObjectMakeDefault().._impl=_self);
    return res;
  }
  set isActive(bool active) {
    void res = _CRouteMapObject_setActive_bool(_CRouteMapObjectMakeDefault().._impl=_self, active);
    return res;
  }
  /** Маршрут. */
  TrafficRoute get route {
    _CTrafficRoute res = _CRouteMapObject_route(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Индекс маршрута в редакторе маршрута. */
  RouteIndex get routeIndex {
    _CRouteIndex res = _CRouteMapObject_routeIndex(_CRouteMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Пройденное расстояние вдоль маршрута. */
  StatefulChannel<RouteDistance> get passedDistanceChannel {
    _CStatefulChannel_CRouteDistance res = _CRouteMapObject_passedDistanceChannel(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Пройденное расстояние вдоль маршрута. */
  RouteDistance get passedDistance {
    _CRouteDistance res = _CRouteMapObject_passedDistance(_CRouteMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set passedDistance(RouteDistance distance) {
    var _a1 = distance._copyFromDartTo_CRouteDistance();
    void res = _CRouteMapObject_setPassedDistance_CRouteDistance(_CRouteMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  StatefulChannel<RouteMapObjectPassedDistanceVisualization> get passedDistanceVisualizationChannel {
    _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization res = _CRouteMapObject_passedDistanceVisualizationChannel(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  RouteMapObjectPassedDistanceVisualization get passedDistanceVisualization {
    _CRouteMapObjectPassedDistanceVisualization res = _CRouteMapObject_passedDistanceVisualization(_CRouteMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set passedDistanceVisualization(RouteMapObjectPassedDistanceVisualization visualization) {
    var _a1 = visualization._copyFromDartTo_CRouteMapObjectPassedDistanceVisualization();
    void res = _CRouteMapObject_setPassedDistanceVisualization_CRouteMapObjectPassedDistanceVisualization(_CRouteMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Положение бабла маршрута. */
  StatefulChannel<List<CalloutMapPosition>> get calloutPositionChannel {
    _CStatefulChannel_CArray_CCalloutMapPosition res = _CRouteMapObject_calloutPositionChannel(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Положение бабла маршрута. */
  List<CalloutMapPosition> get calloutPosition {
    _CArray_CCalloutMapPosition res = _CRouteMapObject_calloutPosition(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Набор флагов для отображения содержимого баблов маршрута.
   Если не задан, то для активного маршрута отображается и время движения по маршруту, и его длина,
   а для неактивных маршрутов - только время движения.
  */
  StatefulChannel<RouteMapObjectCalloutLabelFlagEnumSet?> get calloutLabelFlagsChannel {
    _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag res = _CRouteMapObject_calloutLabelFlagsChannel(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Набор флагов для отображения содержимого баблов маршрута.
   Если не задан, то для активного маршрута отображается и время движения по маршруту, и его длина,
   а для неактивных маршрутов - только время движения.
  */
  RouteMapObjectCalloutLabelFlagEnumSet? get calloutLabelFlags {
    _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag res = _CRouteMapObject_calloutLabelFlags(_CRouteMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set calloutLabelFlags(RouteMapObjectCalloutLabelFlagEnumSet? flags) {
    var _a1 = flags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag();
    void res = _CRouteMapObject_setCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag(_CRouteMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Режим отображения значений в баблах маршрута.
   По умолчанию значения отображаются в виде абсолютных величин.
  */
  StatefulChannel<RouteMapObjectCalloutLabelDisplayMode> get calloutLabelDisplayModeChannel {
    _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode res = _CRouteMapObject_calloutLabelDisplayModeChannel(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Режим отображения значений в баблах маршрута.
   По умолчанию значения отображаются в виде абсолютных величин.
  */
  RouteMapObjectCalloutLabelDisplayMode get calloutLabelDisplayMode {
    _CRouteMapObjectCalloutLabelDisplayMode res = _CRouteMapObject_calloutLabelDisplayMode(_CRouteMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set calloutLabelDisplayMode(RouteMapObjectCalloutLabelDisplayMode mode) {
    var _a1 = mode._copyFromDartTo_CRouteMapObjectCalloutLabelDisplayMode();
    void res = _CRouteMapObject_setCalloutLabelDisplayMode_CRouteMapObjectCalloutLabelDisplayMode(_CRouteMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Положения баблов полосности. Возвращаются только актуальные положения для текущего пройденного расстояния
   по маршруту и только если источник, в который помещён объект, работает в режиме навигации.
  */
  StatefulChannel<List<LanesCalloutMapPosition>> get lanesCalloutPositionsChannel {
    _CStatefulChannel_CArray_CLanesCalloutMapPosition res = _CRouteMapObject_lanesCalloutPositionsChannel(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Положения баблов полосности. Возвращаются только актуальные положения для текущего пройденного расстояния
   по маршруту и только если источник, в который помещён объект, работает в режиме навигации.
  */
  List<LanesCalloutMapPosition> get lanesCalloutPositions {
    _CArray_CLanesCalloutMapPosition res = _CRouteMapObject_lanesCalloutPositions(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Отображаемые на карте объекты дорожных событий вдоль маршрута. */
  StatefulChannel<RoadEventMapObjectRouteAttribute> get roadEventObjectsChannel {
    _CStatefulChannel_CRoadEventMapObjectRouteAttribute res = _CRouteMapObject_roadEventObjectsChannel(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Отображаемые на карте объекты дорожных событий вдоль маршрута. */
  RoadEventMapObjectRouteAttribute get roadEventObjects {
    _CRoadEventMapObjectRouteAttribute res = _CRouteMapObject_roadEventObjects(_CRouteMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRouteMapObject_releasePtr);

  RouteMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RouteMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RouteMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory RouteMapObject(
    TrafficRoute trafficRoute,
    bool isActive,
    RouteIndex index,
    [RouteMapObjectDisplayFlagEnumSet? displayFlags = null,
    RouteMapObjectCalloutLabelFlagEnumSet? calloutLabelFlags = null,
    RouteMapObjectCalloutLabelDisplayMode calloutLabelDisplayMode = RouteMapObjectCalloutLabelDisplayMode.absoluteValues,
    RouteMapObjectPermanentDisplayFlagEnumSet? permanentDisplayFlags = null
    ]) {
    var _a0 = trafficRoute._copyFromDartTo_CTrafficRoute();
    var _a2 = index._copyFromDartTo_CRouteIndex();
    var _a3 = displayFlags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectDisplayFlag();
    var _a4 = calloutLabelFlags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag();
    var _a5 = calloutLabelDisplayMode._copyFromDartTo_CRouteMapObjectCalloutLabelDisplayMode();
    var _a6 = permanentDisplayFlags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag();
    _CRouteMapObject res = _CRouteMapObject_C_createWith_CTrafficRoute_bool_CRouteIndex_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_CRouteMapObjectCalloutLabelDisplayMode_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag(_a0, isActive, _a2, _a3, _a4, _a5, _a6);
    _a0._releaseIntermediate();
    return RouteMapObject._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteMapObject &&
    other.runtimeType == runtimeType &&
    _CRouteMapObject_cg_objectIdentifier(this._self) == _CRouteMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRouteMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - RouteMapObject <-> CRouteMapObject

final class _CRouteMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRouteMapObjectBasicFunctions on _CRouteMapObject {
  void _releaseIntermediate() {
    _CRouteMapObject_release(_impl);
  }

  _CRouteMapObject _retain() {
    return _CRouteMapObject_retain(_impl);
  }
}

extension _CRouteMapObjectToDart on _CRouteMapObject {
  RouteMapObject _toDart() {
    return RouteMapObject._create(_retain()._impl);
  }
}


extension _DartToCRouteMapObject on RouteMapObject {
  _CRouteMapObject _copyFromDartTo_CRouteMapObject() {
    return (_CRouteMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<RouteMapObjectDisplayFlagEnumSet?> <-> _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag

class _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagImpl extends StatefulChannel<RouteMapObjectDisplayFlagEnumSet?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RouteMapObjectDisplayFlagEnumSet?>>{};

  final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag _channel;

  _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagImpl(this._channel);

  @override
  RouteMapObjectDisplayFlagEnumSet? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_COptionSet_CRouteMapObjectDisplayFlag cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<RouteMapObjectDisplayFlagEnumSet?> listen(void onData(RouteMapObjectDisplayFlagEnumSet? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_COptionSet_CRouteMapObjectDisplayFlag, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RouteMapObjectDisplayFlagEnumSet?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagBasicFunctions on _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag_release(this);
  }

  _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag _retain() {
    return _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag_retain(this);
  }

  RouteMapObjectDisplayFlagEnumSet? _getter() {
    final cValue = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_COptionSet_CRouteMapObjectDisplayFlag, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagToDart on _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag {
  StatefulChannel<RouteMapObjectDisplayFlagEnumSet?> _toDart() {
    return _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag on StatefulChannel<RouteMapObjectDisplayFlagEnumSet?> {
  _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag _copyFromDartTo_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag() {
    return _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagMakeDefault();
  }
}
	
// MARK: - RouteMapObjectDisplayFlagEnumSet

class RouteMapObjectDisplayFlagEnumSet extends EnumSet<RouteMapObjectDisplayFlag> {
  RouteMapObjectDisplayFlagEnumSet() : super();

  factory RouteMapObjectDisplayFlagEnumSet.fromRawValue(int rawValue) {
    RouteMapObjectDisplayFlagEnumSet enumSet = RouteMapObjectDisplayFlagEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory RouteMapObjectDisplayFlagEnumSet.of(Iterable<RouteMapObjectDisplayFlag> elements) {
    RouteMapObjectDisplayFlagEnumSet enumSet = RouteMapObjectDisplayFlagEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory RouteMapObjectDisplayFlagEnumSet.all() {
    RouteMapObjectDisplayFlagEnumSet enumSet = RouteMapObjectDisplayFlagEnumSet();
    enumSet.addAll(RouteMapObjectDisplayFlag.values);
    return enumSet;
  }

  @override
  bool contains(RouteMapObjectDisplayFlag value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<RouteMapObjectDisplayFlag> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(RouteMapObjectDisplayFlag value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<RouteMapObjectDisplayFlag> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(RouteMapObjectDisplayFlag value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<RouteMapObjectDisplayFlag> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<RouteMapObjectDisplayFlag> intersection(EnumSet<RouteMapObjectDisplayFlag> other) =>
      RouteMapObjectDisplayFlagEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<RouteMapObjectDisplayFlag> union(EnumSet<RouteMapObjectDisplayFlag> other) =>
      RouteMapObjectDisplayFlagEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<RouteMapObjectDisplayFlag> difference(EnumSet<RouteMapObjectDisplayFlag> other) =>
      RouteMapObjectDisplayFlagEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<RouteMapObjectDisplayFlag> toSet() {
    Set<RouteMapObjectDisplayFlag> result = {};
    RouteMapObjectDisplayFlag.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    RouteMapObjectDisplayFlag.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CRouteMapObjectDisplayFlag extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CRouteMapObjectDisplayFlagBasicFunctions on _COptionSet_CRouteMapObjectDisplayFlag {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CRouteMapObjectDisplayFlagToDart on _COptionSet_CRouteMapObjectDisplayFlag {
  RouteMapObjectDisplayFlagEnumSet _toDart() {
    return RouteMapObjectDisplayFlagEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CRouteMapObjectDisplayFlag on RouteMapObjectDisplayFlagEnumSet {
  _COptionSet_CRouteMapObjectDisplayFlag _copyFromDartTo_COptionSet_CRouteMapObjectDisplayFlag() {
    return _COptionSet_CRouteMapObjectDisplayFlagMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - RouteMapObjectDisplayFlagEnumSet? <-> _COptional_COptionSet_CRouteMapObjectDisplayFlag

final class _COptional_COptionSet_CRouteMapObjectDisplayFlag extends ffi.Struct {
  
  external _COptionSet_CRouteMapObjectDisplayFlag value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_COptionSet_CRouteMapObjectDisplayFlagBasicFunctions on _COptional_COptionSet_CRouteMapObjectDisplayFlag {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_COptionSet_CRouteMapObjectDisplayFlagToDart on _COptional_COptionSet_CRouteMapObjectDisplayFlag {
  RouteMapObjectDisplayFlagEnumSet? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_COptionSet_CRouteMapObjectDisplayFlag on RouteMapObjectDisplayFlagEnumSet? {
  _COptional_COptionSet_CRouteMapObjectDisplayFlag _copyFromDartTo_COptional_COptionSet_CRouteMapObjectDisplayFlag() {
    final cOptional = _COptional_COptionSet_CRouteMapObjectDisplayFlagMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_COptionSet_CRouteMapObjectDisplayFlag();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - StatefulChannel<RouteMapObjectPermanentDisplayFlagEnumSet?> <-> _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag

class _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagImpl extends StatefulChannel<RouteMapObjectPermanentDisplayFlagEnumSet?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RouteMapObjectPermanentDisplayFlagEnumSet?>>{};

  final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag _channel;

  _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagImpl(this._channel);

  @override
  RouteMapObjectPermanentDisplayFlagEnumSet? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<RouteMapObjectPermanentDisplayFlagEnumSet?> listen(void onData(RouteMapObjectPermanentDisplayFlagEnumSet? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RouteMapObjectPermanentDisplayFlagEnumSet?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagBasicFunctions on _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_release(this);
  }

  _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag _retain() {
    return _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_retain(this);
  }

  RouteMapObjectPermanentDisplayFlagEnumSet? _getter() {
    final cValue = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagToDart on _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag {
  StatefulChannel<RouteMapObjectPermanentDisplayFlagEnumSet?> _toDart() {
    return _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag on StatefulChannel<RouteMapObjectPermanentDisplayFlagEnumSet?> {
  _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag _copyFromDartTo_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag() {
    return _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefault();
  }
}
	
// MARK: - RouteMapObjectPermanentDisplayFlagEnumSet

class RouteMapObjectPermanentDisplayFlagEnumSet extends EnumSet<RouteMapObjectPermanentDisplayFlag> {
  RouteMapObjectPermanentDisplayFlagEnumSet() : super();

  factory RouteMapObjectPermanentDisplayFlagEnumSet.fromRawValue(int rawValue) {
    RouteMapObjectPermanentDisplayFlagEnumSet enumSet = RouteMapObjectPermanentDisplayFlagEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory RouteMapObjectPermanentDisplayFlagEnumSet.of(Iterable<RouteMapObjectPermanentDisplayFlag> elements) {
    RouteMapObjectPermanentDisplayFlagEnumSet enumSet = RouteMapObjectPermanentDisplayFlagEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory RouteMapObjectPermanentDisplayFlagEnumSet.all() {
    RouteMapObjectPermanentDisplayFlagEnumSet enumSet = RouteMapObjectPermanentDisplayFlagEnumSet();
    enumSet.addAll(RouteMapObjectPermanentDisplayFlag.values);
    return enumSet;
  }

  @override
  bool contains(RouteMapObjectPermanentDisplayFlag value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<RouteMapObjectPermanentDisplayFlag> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(RouteMapObjectPermanentDisplayFlag value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<RouteMapObjectPermanentDisplayFlag> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(RouteMapObjectPermanentDisplayFlag value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<RouteMapObjectPermanentDisplayFlag> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<RouteMapObjectPermanentDisplayFlag> intersection(EnumSet<RouteMapObjectPermanentDisplayFlag> other) =>
      RouteMapObjectPermanentDisplayFlagEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<RouteMapObjectPermanentDisplayFlag> union(EnumSet<RouteMapObjectPermanentDisplayFlag> other) =>
      RouteMapObjectPermanentDisplayFlagEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<RouteMapObjectPermanentDisplayFlag> difference(EnumSet<RouteMapObjectPermanentDisplayFlag> other) =>
      RouteMapObjectPermanentDisplayFlagEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<RouteMapObjectPermanentDisplayFlag> toSet() {
    Set<RouteMapObjectPermanentDisplayFlag> result = {};
    RouteMapObjectPermanentDisplayFlag.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    RouteMapObjectPermanentDisplayFlag.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CRouteMapObjectPermanentDisplayFlag extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CRouteMapObjectPermanentDisplayFlagBasicFunctions on _COptionSet_CRouteMapObjectPermanentDisplayFlag {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CRouteMapObjectPermanentDisplayFlagToDart on _COptionSet_CRouteMapObjectPermanentDisplayFlag {
  RouteMapObjectPermanentDisplayFlagEnumSet _toDart() {
    return RouteMapObjectPermanentDisplayFlagEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CRouteMapObjectPermanentDisplayFlag on RouteMapObjectPermanentDisplayFlagEnumSet {
  _COptionSet_CRouteMapObjectPermanentDisplayFlag _copyFromDartTo_COptionSet_CRouteMapObjectPermanentDisplayFlag() {
    return _COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - RouteMapObjectPermanentDisplayFlagEnumSet? <-> _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag

final class _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag extends ffi.Struct {
  
  external _COptionSet_CRouteMapObjectPermanentDisplayFlag value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagBasicFunctions on _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagToDart on _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag {
  RouteMapObjectPermanentDisplayFlagEnumSet? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag on RouteMapObjectPermanentDisplayFlagEnumSet? {
  _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag _copyFromDartTo_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag() {
    final cOptional = _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_COptionSet_CRouteMapObjectPermanentDisplayFlag();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - TrafficRoute

class TrafficRoute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Маршрут. */
  Route get route {
    _CRoute res = _CTrafficRoute_route(_CTrafficRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Пробочные данные. */
  Traffic get traffic {
    _CTraffic res = _CTrafficRoute_traffic(_CTrafficRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CTrafficRoute_releasePtr);

  TrafficRoute._raw(this._self);
  factory TrafficRoute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TrafficRoute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficRoute &&
    other.runtimeType == runtimeType &&
    _CTrafficRoute_cg_objectIdentifier(this._self) == _CTrafficRoute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTrafficRoute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CTrafficRoute: Static Methods

  /**
   Создание маршрута из десериализованного состояния навигации с добавлением содержащихся в нём
   объектов в базу дорожных событий (необходимо для отображения событий на маршруте на карте при
   невозможности получить события онлайн).
  */
  static TrafficRoute fromNavigationState(
    PackedNavigationState navigationState,
    Context context
  )  {
    var _a0 = navigationState._copyFromDartTo_CPackedNavigationState();
    var _a1 = context._copyFromDartTo_CContext();
    _CTrafficRoute res = _CTrafficRoute_S_fromNavigationState_CPackedNavigationState_CContext(_a0, _a1);
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - TrafficRoute <-> CTrafficRoute

final class _CTrafficRoute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTrafficRouteBasicFunctions on _CTrafficRoute {
  void _releaseIntermediate() {
    _CTrafficRoute_release(_impl);
  }

  _CTrafficRoute _retain() {
    return _CTrafficRoute_retain(_impl);
  }
}

extension _CTrafficRouteToDart on _CTrafficRoute {
  TrafficRoute _toDart() {
    return TrafficRoute._create(_retain()._impl);
  }
}


extension _DartToCTrafficRoute on TrafficRoute {
  _CTrafficRoute _copyFromDartTo_CTrafficRoute() {
    return (_CTrafficRouteMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Route

/**
 Класс, описывающий маршрут.
 Маршрут представляет собой набор атрибутов, каждый из которых представляет собой контейнер типа
 RouteAttribute или RouteLongAttribute, в котором хранятся элементы атрибутов маршрута.
 Атрибуты маршрута делятся на точечные и протяженные.
 Точечные атрибуты (например, точки геометрии или лежачие полицейские) задаются в виде пары из RoutePoint и значения
 атрибута.
 Протяженные атрибуты (например, ширина проезжей части или ограничение скорости) задаются в виде пары из RoutePoint,
 которая указывает на начало действия атрибута и значения атрибута. В конце маршрута ставится терминатор.
 Например, пусть ширина проезжей части задана в виде набора пар {{0m, 3m}, {10m, 7m}, {20m, 5m}, {30m, 0m}},
 тогда первые 10 метров маршрута проезжая часть имеет ширину 3 метра, на интервале [10м., 20м.) - 7м.,
 с 20м. до конца маршрута - 5м.
*/
class Route implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Геометрия маршрута.
  
   - Note: Не гарантируется, что RoutePoint у точек геометрии будет совпадать с RoutePoint у элементов других
   атрибутов, поэтому для того, чтобы вычислить географическую координату у элемента атрибута,
   не нужно искать в геометрии элемент, RoutePoint которого совпадает с RoutePoint элемента атрибута,
   вместо этого нужно воспользоваться функцией calculate_geo_point.
  */
  GeoPointRouteAttribute get geometry {
    _CGeoPointRouteAttribute res = _CRoute_geometry(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Инструкции, которые необходимо выполнить для движения по маршруту. */
  InstructionRouteAttribute get instructions {
    _CInstructionRouteAttribute res = _CRoute_instructions(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Промежуточные точки, через которые проходит маршрут.
   Маршрут может проходить не прямо через промежуточную точку, а рядом с ней.
   В значении атрибута хранится координата, в которую была установлена промежуточная точка,
   в ключе - координата проекции промежуточной точки на маршрут.
  */
  GeoPointRouteAttribute get intermediatePoints {
    _CGeoPointRouteAttribute res = _CRoute_intermediatePoints(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Высоты на маршруте. */
  DoubleRouteAttribute get altitudes {
    _CDoubleRouteAttribute res = _CRoute_altitudes(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Плохая дорога (на дороге присутствуют кочки и ямы, которые препятствуют проезду). */
  BoolRouteLongAttribute get badRoads {
    _CBoolRouteLongAttribute res = _CRoute_badRoads(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Препятствия на маршруте. */
  ObstacleInfoRouteAttribute get obstacles {
    _CObstacleInfoRouteAttribute res = _CRoute_obstacles(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Названия дорог/улиц. */
  StringRouteLongAttribute get roadNames {
    _CStringRouteLongAttribute res = _CRoute_roadNames(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Признак того, что участок маршрута проходит по населённому пункту. */
  SettlementRouteLongAttribute get settlements {
    _CSettlementRouteLongAttribute res = _CRoute_settlements(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Вид транспорта, для которого построен участок маршрута. */
  TransportTypeRouteLongAttribute get transportTypes {
    _CTransportTypeRouteLongAttribute res = _CRoute_transportTypes(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Дорожные камеры. */
  CameraRouteAttribute get cameras {
    _CCameraRouteAttribute res = _CRoute_cameras(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Ширина проезжей части в метрах.
   0 - ширина неизвестна.
  */
  UIntRouteLongAttribute get carriagewaysWidth {
    _CUIntRouteLongAttribute res = _CRoute_carriagewaysWidth(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Знаки съездов. */
  RouteExitSignRouteAttribute get exitSigns {
    _CRouteExitSignRouteAttribute res = _CRoute_exitSigns(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Искусственные неровности. */
  VoidRouteAttribute get humps {
    _CVoidRouteAttribute res = _CRoute_humps(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Полосы движения. */
  LaneSignRouteLongAttribute get lanes {
    _CLaneSignRouteLongAttribute res = _CRoute_lanes(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Этажи зданий. */
  RouteLevelInfoRouteLongAttribute get levels {
    _CRouteLevelInfoRouteLongAttribute res = _CRoute_levels(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Ограничения максимальной допустимой скорости.
  
   - Note: 0 - ограничение скорости неизвестно.
  */
  FloatRouteLongAttribute get maxSpeedLimits {
    _CFloatRouteLongAttribute res = _CRoute_maxSpeedLimits(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Сторона движения. */
  RoadRuleRouteLongAttribute get roadRules {
    _CRoadRuleRouteLongAttribute res = _CRoute_roadRules(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Дополнительное описание типа дороги, по которой пролегает маршрут. */
  RoadSubtypeRouteLongAttribute get roadSubtypes {
    _CRoadSubtypeRouteLongAttribute res = _CRoute_roadSubtypes(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Покрытие дороги. */
  RoadSurfaceRouteLongAttribute get roadSurfaces {
    _CRoadSurfaceRouteLongAttribute res = _CRoute_roadSurfaces(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Тип дороги, по которой пролегает маршрут. */
  RoadTypeRouteLongAttribute get roadTypes {
    _CRoadTypeRouteLongAttribute res = _CRoute_roadTypes(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Участки маршрута, пролегающие по платным дорогам. */
  BoolRouteLongAttribute get tolls {
    _CBoolRouteLongAttribute res = _CRoute_tolls(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Признак наличия или отсутствия данных для грузовой навигации. */
  BoolRouteLongAttribute get truckData {
    _CBoolRouteLongAttribute res = _CRoute_truckData(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Пропускные зоны для грузового транспорта. */
  TruckPassZoneIdRouteLongAttribute get truckPassZoneIds {
    _CTruckPassZoneIdRouteLongAttribute res = _CRoute_truckPassZoneIds(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Признак действия знака запрета проезда грузового транспорта. */
  BoolRouteLongAttribute get truckRestrictedAreas {
    _CBoolRouteLongAttribute res = _CRoute_truckRestrictedAreas(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Признак действия знака запрета проезда любого автотранспорта (перекрытия). */
  BoolRouteLongAttribute get vehicleRestrictedAreas {
    _CBoolRouteLongAttribute res = _CRoute_vehicleRestrictedAreas(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Признак наличия выделенной велополосы. */
  BoolRouteLongAttribute get bicycleLanes {
    _CBoolRouteLongAttribute res = _CRoute_bicycleLanes(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Признак наличия светофоров. */
  VoidRouteAttribute get trafficLights {
    _CVoidRouteAttribute res = _CRoute_trafficLights(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  BoolRouteLongAttribute get immersiveData {
    _CBoolRouteLongAttribute res = _CRoute_immersiveData(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Описание способов перемещения на общественном транспорте между точками пересадок. */
  PublicTransportTransferRouteLongAttribute get publicTransportTransfers {
    _CPublicTransportTransferRouteLongAttribute res = _CRoute_publicTransportTransfers(_CRouteMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoute_releasePtr);

  Route._raw(this._self);
  factory Route._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Route._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Route &&
    other.runtimeType == runtimeType &&
    _CRoute_cg_objectIdentifier(this._self) == _CRoute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Route <-> CRoute

final class _CRoute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRouteBasicFunctions on _CRoute {
  void _releaseIntermediate() {
    _CRoute_release(_impl);
  }

  _CRoute _retain() {
    return _CRoute_retain(_impl);
  }
}

extension _CRouteToDart on _CRoute {
  Route _toDart() {
    return Route._create(_retain()._impl);
  }
}


extension _DartToCRoute on Route {
  _CRoute _copyFromDartTo_CRoute() {
    return (_CRouteMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - InstructionRouteAttribute

/**
 Контейнер, который описывает точечный атрибут маршрута.
 Каждый элемент хранится в виде точки на маршруте, в которой этот элемент расположен и значения самого элемента.
*/
class InstructionRouteAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CInstructionRouteAttribute_size(_CInstructionRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CInstructionRouteAttribute_isEmpty(_CInstructionRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  InstructionRouteEntry? get first {
    _COptional_CInstructionRouteEntry res = _CInstructionRouteAttribute_first(_CInstructionRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Последний элемент. */
  InstructionRouteEntry? get last {
    _COptional_CInstructionRouteEntry res = _CInstructionRouteAttribute_last(_CInstructionRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Все элементы. */
  List<InstructionRouteEntry> get entries {
    _CArray_CInstructionRouteEntry res = _CInstructionRouteAttribute_entries(_CInstructionRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CInstructionRouteAttribute_releasePtr);

  InstructionRouteAttribute._raw(this._self);
  factory InstructionRouteAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = InstructionRouteAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is InstructionRouteAttribute &&
    other.runtimeType == runtimeType &&
    _CInstructionRouteAttribute_cg_objectIdentifier(this._self) == _CInstructionRouteAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CInstructionRouteAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: InstructionRouteAttribute: Methods

  /**
   Элементы, попадающие в отрезок [begin, end).
  
   - Throws: Exception если begin > end.
  */
  List<InstructionRouteEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CInstructionRouteEntry res = _CInstructionRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CInstructionRouteAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого
   <
   = point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  InstructionRouteEntry? findNearBackward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CInstructionRouteEntry res = _CInstructionRouteAttribute_findNearBackward_CRoutePoint(_CInstructionRouteAttributeMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого >= point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  InstructionRouteEntry? findNearForward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CInstructionRouteEntry res = _CInstructionRouteAttribute_findNearForward_CRoutePoint(_CInstructionRouteAttributeMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - InstructionRouteAttribute <-> CInstructionRouteAttribute

final class _CInstructionRouteAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CInstructionRouteAttributeBasicFunctions on _CInstructionRouteAttribute {
  void _releaseIntermediate() {
    _CInstructionRouteAttribute_release(_impl);
  }

  _CInstructionRouteAttribute _retain() {
    return _CInstructionRouteAttribute_retain(_impl);
  }
}

extension _CInstructionRouteAttributeToDart on _CInstructionRouteAttribute {
  InstructionRouteAttribute _toDart() {
    return InstructionRouteAttribute._create(_retain()._impl);
  }
}


extension _DartToCInstructionRouteAttribute on InstructionRouteAttribute {
  _CInstructionRouteAttribute _copyFromDartTo_CInstructionRouteAttribute() {
    return (_CInstructionRouteAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - BicycleInstructionStart

/** Начало велосипедной части маршрута. */
class BicycleInstructionStart {

  const BicycleInstructionStart();

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BicycleInstructionStart &&
    other.runtimeType == runtimeType;

  @override
  int get hashCode {
    return 0;
  }

}
final class _CBicycleInstructionStart extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
// MARK: - BicycleInstructionStart <-> _CBicycleInstructionStart

extension _CBicycleInstructionStartToDart on _CBicycleInstructionStart {
  BicycleInstructionStart _toDart() {
    return BicycleInstructionStart(
    );
  }
}

extension _DartTo_CBicycleInstructionStart on BicycleInstructionStart {
  _CBicycleInstructionStart _copyFromDartTo_CBicycleInstructionStart() {
    final res = _CBicycleInstructionStartMakeDefault();
    return res;
  }
}
extension _CBicycleInstructionStartRelease on _CBicycleInstructionStart {
  void _releaseIntermediate() {
  }
}

// MARK: - BicycleInstructionFinish

/** Конец велосипедной части маршрута. */
class BicycleInstructionFinish {

  const BicycleInstructionFinish();

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BicycleInstructionFinish &&
    other.runtimeType == runtimeType;

  @override
  int get hashCode {
    return 0;
  }

}
final class _CBicycleInstructionFinish extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
// MARK: - BicycleInstructionFinish <-> _CBicycleInstructionFinish

extension _CBicycleInstructionFinishToDart on _CBicycleInstructionFinish {
  BicycleInstructionFinish _toDart() {
    return BicycleInstructionFinish(
    );
  }
}

extension _DartTo_CBicycleInstructionFinish on BicycleInstructionFinish {
  _CBicycleInstructionFinish _copyFromDartTo_CBicycleInstructionFinish() {
    final res = _CBicycleInstructionFinishMakeDefault();
    return res;
  }
}
extension _CBicycleInstructionFinishRelease on _CBicycleInstructionFinish {
  void _releaseIntermediate() {
  }
}

// MARK: - BicycleInstructionCrossroadLandmark

/** Ориентир. */
enum BicycleInstructionCrossroadLandmark {
  /** Нет ориентира. */
  none(0),
  /** Пешеходный переход. */
  crosswalk(1),
  /** Светофор. */
  trafficLight(2),
  ;

  const BicycleInstructionCrossroadLandmark(this.rawValue);
  final int rawValue;

  static BicycleInstructionCrossroadLandmark getByValue(int value) {
    return BicycleInstructionCrossroadLandmark.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CBicycleInstructionCrossroadLandmark extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CBicycleInstructionCrossroadLandmarkBasicFunctions on _CBicycleInstructionCrossroadLandmark {
  void _releaseIntermediate() {
  }
}

extension _CBicycleInstructionCrossroadLandmarkToDart on _CBicycleInstructionCrossroadLandmark {
  BicycleInstructionCrossroadLandmark _toDart() {
    return BicycleInstructionCrossroadLandmark.getByValue(this.rawValue);
  }
}

extension _DartTo_CBicycleInstructionCrossroadLandmark on BicycleInstructionCrossroadLandmark {
  _CBicycleInstructionCrossroadLandmark _copyFromDartTo_CBicycleInstructionCrossroadLandmark() {
    return _CBicycleInstructionCrossroadLandmarkMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - List<BicycleInstructionCrossroadManeuver> <-> _CArray_CBicycleInstructionCrossroadManeuver

final class _CArray_CBicycleInstructionCrossroadManeuver extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CBicycleInstructionCrossroadManeuverToDart on _CArray_CBicycleInstructionCrossroadManeuver {
  List<BicycleInstructionCrossroadManeuver> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CBicycleInstructionCrossroadManeuver on List<BicycleInstructionCrossroadManeuver> {
  _CArray_CBicycleInstructionCrossroadManeuver _copyFromDartTo_CArray_CBicycleInstructionCrossroadManeuver() {
    final cArray = _CArray_CBicycleInstructionCrossroadManeuvermakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CBicycleInstructionCrossroadManeuver();
        _CArray_CBicycleInstructionCrossroadManeuveraddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CBicycleInstructionCrossroadManeuverBasicFunctions on _CArray_CBicycleInstructionCrossroadManeuver {
  void _releaseIntermediate() {
    _CArray_CBicycleInstructionCrossroadManeuver_release(this);
  }

  static final _listToFill = <BicycleInstructionCrossroadManeuver>[];

  static void _iterate(_CBicycleInstructionCrossroadManeuver item) {
    _listToFill.add(item._toDart());
  }

  List<BicycleInstructionCrossroadManeuver> _fillFromC() {
    _forEach_CArray_CBicycleInstructionCrossroadManeuver(this, ffi.Pointer.fromFunction<ffi.Void Function(_CBicycleInstructionCrossroadManeuver)>(_iterate));
    final result = List<BicycleInstructionCrossroadManeuver>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - BicycleInstructionCrossroad

/** Описание манёвров при проходе через перекрёсток или по пешеходному переходу. */
class BicycleInstructionCrossroad {
  /** Ориентир. */
  final BicycleInstructionCrossroadLandmark landmark;
  /** Цепочка идущих подряд манёвров. */
  final List<BicycleInstructionCrossroadManeuver> maneuvers;

  const BicycleInstructionCrossroad({
    this.landmark = BicycleInstructionCrossroadLandmark.none,
    required this.maneuvers
  });

  BicycleInstructionCrossroad copyWith({
    BicycleInstructionCrossroadLandmark? landmark,
    List<BicycleInstructionCrossroadManeuver>? maneuvers
  }) {
    return BicycleInstructionCrossroad(
      landmark: landmark ?? this.landmark,
      maneuvers: maneuvers ?? this.maneuvers
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BicycleInstructionCrossroad &&
    other.runtimeType == runtimeType &&
    other.landmark == landmark &&
    other.maneuvers == maneuvers;

  @override
  int get hashCode {
    return Object.hash(landmark, maneuvers);
  }

}
final class _CBicycleInstructionCrossroad extends ffi.Struct {
  external _CBicycleInstructionCrossroadLandmark landmark;

  external _CArray_CBicycleInstructionCrossroadManeuver maneuvers;

}
// MARK: - BicycleInstructionCrossroad <-> _CBicycleInstructionCrossroad

extension _CBicycleInstructionCrossroadToDart on _CBicycleInstructionCrossroad {
  BicycleInstructionCrossroad _toDart() {
    return BicycleInstructionCrossroad(
      landmark: this.landmark._toDart(),
      maneuvers: this.maneuvers._toDart()
    );
  }
}

extension _DartTo_CBicycleInstructionCrossroad on BicycleInstructionCrossroad {
  _CBicycleInstructionCrossroad _copyFromDartTo_CBicycleInstructionCrossroad() {
    final res = _CBicycleInstructionCrossroadMakeDefault();
    res.landmark = this.landmark._copyFromDartTo_CBicycleInstructionCrossroadLandmark();
    res.maneuvers = this.maneuvers._copyFromDartTo_CArray_CBicycleInstructionCrossroadManeuver();
    return res;
  }
}
extension _CBicycleInstructionCrossroadRelease on _CBicycleInstructionCrossroad {
  void _releaseIntermediate() {
    maneuvers._releaseIntermediate();
  }
}

// MARK: - CarInstructionStart

/** Начало автомобильной части маршрута. */
class CarInstructionStart {

  const CarInstructionStart();

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CarInstructionStart &&
    other.runtimeType == runtimeType;

  @override
  int get hashCode {
    return 0;
  }

}
final class _CCarInstructionStart extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
// MARK: - CarInstructionStart <-> _CCarInstructionStart

extension _CCarInstructionStartToDart on _CCarInstructionStart {
  CarInstructionStart _toDart() {
    return CarInstructionStart(
    );
  }
}

extension _DartTo_CCarInstructionStart on CarInstructionStart {
  _CCarInstructionStart _copyFromDartTo_CCarInstructionStart() {
    final res = _CCarInstructionStartMakeDefault();
    return res;
  }
}
extension _CCarInstructionStartRelease on _CCarInstructionStart {
  void _releaseIntermediate() {
  }
}

// MARK: - CarInstructionFinish

/** Конец автомобильной части маршрута. */
class CarInstructionFinish {

  const CarInstructionFinish();

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CarInstructionFinish &&
    other.runtimeType == runtimeType;

  @override
  int get hashCode {
    return 0;
  }

}
final class _CCarInstructionFinish extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
// MARK: - CarInstructionFinish <-> _CCarInstructionFinish

extension _CCarInstructionFinishToDart on _CCarInstructionFinish {
  CarInstructionFinish _toDart() {
    return CarInstructionFinish(
    );
  }
}

extension _DartTo_CCarInstructionFinish on CarInstructionFinish {
  _CCarInstructionFinish _copyFromDartTo_CCarInstructionFinish() {
    final res = _CCarInstructionFinishMakeDefault();
    return res;
  }
}
extension _CCarInstructionFinishRelease on _CCarInstructionFinish {
  void _releaseIntermediate() {
  }
}

// MARK: - CarInstructionCrossroadDirection

/** Направление движения на перекрёстке. */
enum CarInstructionCrossroadDirection {
  /** Прямо. */
  straight(0),
  /** Плавный поворот налево. */
  slightlyLeft(1),
  /** Налево. */
  left(2),
  /** Крутой поворот налево. */
  sharplyLeft(3),
  /** Разворот. */
  uTurn(4),
  /** Крутой поворот направо. */
  sharplyRight(5),
  /** Направо. */
  right(6),
  /** Плавный поворот направо. */
  slightlyRight(7),
  /** Держитесь левее. */
  keepLeft(8),
  /** Держитесь правее. */
  keepRight(9),
  ;

  const CarInstructionCrossroadDirection(this.rawValue);
  final int rawValue;

  static CarInstructionCrossroadDirection getByValue(int value) {
    return CarInstructionCrossroadDirection.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCarInstructionCrossroadDirection extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCarInstructionCrossroadDirectionBasicFunctions on _CCarInstructionCrossroadDirection {
  void _releaseIntermediate() {
  }
}

extension _CCarInstructionCrossroadDirectionToDart on _CCarInstructionCrossroadDirection {
  CarInstructionCrossroadDirection _toDart() {
    return CarInstructionCrossroadDirection.getByValue(this.rawValue);
  }
}

extension _DartTo_CCarInstructionCrossroadDirection on CarInstructionCrossroadDirection {
  _CCarInstructionCrossroadDirection _copyFromDartTo_CCarInstructionCrossroadDirection() {
    return _CCarInstructionCrossroadDirectionMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CarInstructionCrossroadLandmark

/** Ориентир. */
enum CarInstructionCrossroadLandmark {
  /** Нет ориентира. */
  none(0),
  /** Перед тоннелем. */
  tunnelBefore(1),
  /** Въезд в тоннель. */
  tunnelEntry(2),
  /** Перед мостом. */
  bridgeBefore(3),
  /** Въезд на мост. */
  bridgeEntry(4),
  /** Въезд под арку. */
  archwayEntry(5),
  /** На светофоре. */
  onTrafficLight(6),
  /** Въезд во двор. */
  courtyardEntry(7),
  ;

  const CarInstructionCrossroadLandmark(this.rawValue);
  final int rawValue;

  static CarInstructionCrossroadLandmark getByValue(int value) {
    return CarInstructionCrossroadLandmark.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCarInstructionCrossroadLandmark extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCarInstructionCrossroadLandmarkBasicFunctions on _CCarInstructionCrossroadLandmark {
  void _releaseIntermediate() {
  }
}

extension _CCarInstructionCrossroadLandmarkToDart on _CCarInstructionCrossroadLandmark {
  CarInstructionCrossroadLandmark _toDart() {
    return CarInstructionCrossroadLandmark.getByValue(this.rawValue);
  }
}

extension _DartTo_CCarInstructionCrossroadLandmark on CarInstructionCrossroadLandmark {
  _CCarInstructionCrossroadLandmark _copyFromDartTo_CCarInstructionCrossroadLandmark() {
    return _CCarInstructionCrossroadLandmarkMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CarInstructionCrossroad

/** Описание манёвров на перекрёстке. */
class CarInstructionCrossroad {
  /** Направление движения на перекрёстке. */
  final CarInstructionCrossroadDirection direction;
  /** Угол поворота в градусах [-180, 180]. */
  final int turnAngle;
  /** Ориентир. */
  final CarInstructionCrossroadLandmark landmark;
  /** Название съезда. */
  final String exitName;

  const CarInstructionCrossroad({
    this.direction = CarInstructionCrossroadDirection.straight,
    this.turnAngle = 0,
    this.landmark = CarInstructionCrossroadLandmark.none,
    required this.exitName
  });

  CarInstructionCrossroad copyWith({
    CarInstructionCrossroadDirection? direction,
    int? turnAngle,
    CarInstructionCrossroadLandmark? landmark,
    String? exitName
  }) {
    return CarInstructionCrossroad(
      direction: direction ?? this.direction,
      turnAngle: turnAngle ?? this.turnAngle,
      landmark: landmark ?? this.landmark,
      exitName: exitName ?? this.exitName
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CarInstructionCrossroad &&
    other.runtimeType == runtimeType &&
    other.direction == direction &&
    other.turnAngle == turnAngle &&
    other.landmark == landmark &&
    other.exitName == exitName;

  @override
  int get hashCode {
    return Object.hash(direction, turnAngle, landmark, exitName);
  }

}
final class _CCarInstructionCrossroad extends ffi.Struct {
  external _CCarInstructionCrossroadDirection direction;

  @ffi.Int32()
  external int turnAngle;

  external _CCarInstructionCrossroadLandmark landmark;

  external _CString exitName;

}
// MARK: - CarInstructionCrossroad <-> _CCarInstructionCrossroad

extension _CCarInstructionCrossroadToDart on _CCarInstructionCrossroad {
  CarInstructionCrossroad _toDart() {
    return CarInstructionCrossroad(
      direction: this.direction._toDart(),
      turnAngle: this.turnAngle,
      landmark: this.landmark._toDart(),
      exitName: this.exitName._toDart()
    );
  }
}

extension _DartTo_CCarInstructionCrossroad on CarInstructionCrossroad {
  _CCarInstructionCrossroad _copyFromDartTo_CCarInstructionCrossroad() {
    final res = _CCarInstructionCrossroadMakeDefault();
    res.direction = this.direction._copyFromDartTo_CCarInstructionCrossroadDirection();
    res.turnAngle = this.turnAngle;
    res.landmark = this.landmark._copyFromDartTo_CCarInstructionCrossroadLandmark();
    res.exitName = this.exitName._copyFromDartTo_CString();
    return res;
  }
}
extension _CCarInstructionCrossroadRelease on _CCarInstructionCrossroad {
  void _releaseIntermediate() {
    exitName._releaseIntermediate();
  }
}

// MARK: - CarInstructionRoundaboutType

/** Тип манёвра на перекрёстке с круговым движением. */
enum CarInstructionRoundaboutType {
  /** Въезд на кольцо. */
  entry(0),
  /** Промежуточная инструкция на кольце. */
  intermediate(1),
  /** Съезд с кольца. */
  exit(2),
  ;

  const CarInstructionRoundaboutType(this.rawValue);
  final int rawValue;

  static CarInstructionRoundaboutType getByValue(int value) {
    return CarInstructionRoundaboutType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCarInstructionRoundaboutType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCarInstructionRoundaboutTypeBasicFunctions on _CCarInstructionRoundaboutType {
  void _releaseIntermediate() {
  }
}

extension _CCarInstructionRoundaboutTypeToDart on _CCarInstructionRoundaboutType {
  CarInstructionRoundaboutType _toDart() {
    return CarInstructionRoundaboutType.getByValue(this.rawValue);
  }
}

extension _DartTo_CCarInstructionRoundaboutType on CarInstructionRoundaboutType {
  _CCarInstructionRoundaboutType _copyFromDartTo_CCarInstructionRoundaboutType() {
    return _CCarInstructionRoundaboutTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CarInstructionRoundabout

/** Описание манёвров на перекрёстке с круговым движением. */
class CarInstructionRoundabout {
  /** Тип инструкции. */
  final CarInstructionRoundaboutType type;
  /** Угол поворота в градусах [-180, 180]. */
  final int turnAngle;
  /** Номер съезда - [1, inf] или 0, если номер съезда неизвестен. */
  final int exitNumber;
  /** Название съезда. */
  final String exitName;

  const CarInstructionRoundabout({
    this.type = CarInstructionRoundaboutType.entry,
    this.turnAngle = 0,
    this.exitNumber = 0,
    required this.exitName
  });

  CarInstructionRoundabout copyWith({
    CarInstructionRoundaboutType? type,
    int? turnAngle,
    int? exitNumber,
    String? exitName
  }) {
    return CarInstructionRoundabout(
      type: type ?? this.type,
      turnAngle: turnAngle ?? this.turnAngle,
      exitNumber: exitNumber ?? this.exitNumber,
      exitName: exitName ?? this.exitName
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CarInstructionRoundabout &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.turnAngle == turnAngle &&
    other.exitNumber == exitNumber &&
    other.exitName == exitName;

  @override
  int get hashCode {
    return Object.hash(type, turnAngle, exitNumber, exitName);
  }

}
final class _CCarInstructionRoundabout extends ffi.Struct {
  external _CCarInstructionRoundaboutType type;

  @ffi.Int32()
  external int turnAngle;

  @ffi.Uint32()
  external int exitNumber;

  external _CString exitName;

}
// MARK: - CarInstructionRoundabout <-> _CCarInstructionRoundabout

extension _CCarInstructionRoundaboutToDart on _CCarInstructionRoundabout {
  CarInstructionRoundabout _toDart() {
    return CarInstructionRoundabout(
      type: this.type._toDart(),
      turnAngle: this.turnAngle,
      exitNumber: this.exitNumber,
      exitName: this.exitName._toDart()
    );
  }
}

extension _DartTo_CCarInstructionRoundabout on CarInstructionRoundabout {
  _CCarInstructionRoundabout _copyFromDartTo_CCarInstructionRoundabout() {
    final res = _CCarInstructionRoundaboutMakeDefault();
    res.type = this.type._copyFromDartTo_CCarInstructionRoundaboutType();
    res.turnAngle = this.turnAngle;
    res.exitNumber = this.exitNumber;
    res.exitName = this.exitName._copyFromDartTo_CString();
    return res;
  }
}
extension _CCarInstructionRoundaboutRelease on _CCarInstructionRoundabout {
  void _releaseIntermediate() {
    exitName._releaseIntermediate();
  }
}

// MARK: - CarInstructionUTurn

/**
 Разворот на дороге (не на перекрёстке).

 - Note: Разворот на перекрестке описывается инструкцией Crossroad.
*/
class CarInstructionUTurn {
  /** Название съезда. */
  final String exitName;

  const CarInstructionUTurn(this.exitName);

  CarInstructionUTurn copyWith({
    String? exitName
  }) {
    return CarInstructionUTurn(
      exitName ?? this.exitName
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CarInstructionUTurn &&
    other.runtimeType == runtimeType &&
    other.exitName == exitName;

  @override
  int get hashCode {
    return exitName.hashCode;
  }

}
final class _CCarInstructionUTurn extends ffi.Struct {
  external _CString exitName;

}
// MARK: - CarInstructionUTurn <-> _CCarInstructionUTurn

extension _CCarInstructionUTurnToDart on _CCarInstructionUTurn {
  CarInstructionUTurn _toDart() {
    return CarInstructionUTurn(
      this.exitName._toDart()
    );
  }
}

extension _DartTo_CCarInstructionUTurn on CarInstructionUTurn {
  _CCarInstructionUTurn _copyFromDartTo_CCarInstructionUTurn() {
    final res = _CCarInstructionUTurnMakeDefault();
    res.exitName = this.exitName._copyFromDartTo_CString();
    return res;
  }
}
extension _CCarInstructionUTurnRelease on _CCarInstructionUTurn {
  void _releaseIntermediate() {
    exitName._releaseIntermediate();
  }
}

// MARK: - PedestrianInstructionStart

/** Начало пешеходной части маршрута. */
class PedestrianInstructionStart {

  const PedestrianInstructionStart();

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PedestrianInstructionStart &&
    other.runtimeType == runtimeType;

  @override
  int get hashCode {
    return 0;
  }

}
final class _CPedestrianInstructionStart extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
// MARK: - PedestrianInstructionStart <-> _CPedestrianInstructionStart

extension _CPedestrianInstructionStartToDart on _CPedestrianInstructionStart {
  PedestrianInstructionStart _toDart() {
    return PedestrianInstructionStart(
    );
  }
}

extension _DartTo_CPedestrianInstructionStart on PedestrianInstructionStart {
  _CPedestrianInstructionStart _copyFromDartTo_CPedestrianInstructionStart() {
    final res = _CPedestrianInstructionStartMakeDefault();
    return res;
  }
}
extension _CPedestrianInstructionStartRelease on _CPedestrianInstructionStart {
  void _releaseIntermediate() {
  }
}

// MARK: - PedestrianInstructionFinish

/** Конец пешеходной части маршрута. */
class PedestrianInstructionFinish {

  const PedestrianInstructionFinish();

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PedestrianInstructionFinish &&
    other.runtimeType == runtimeType;

  @override
  int get hashCode {
    return 0;
  }

}
final class _CPedestrianInstructionFinish extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
// MARK: - PedestrianInstructionFinish <-> _CPedestrianInstructionFinish

extension _CPedestrianInstructionFinishToDart on _CPedestrianInstructionFinish {
  PedestrianInstructionFinish _toDart() {
    return PedestrianInstructionFinish(
    );
  }
}

extension _DartTo_CPedestrianInstructionFinish on PedestrianInstructionFinish {
  _CPedestrianInstructionFinish _copyFromDartTo_CPedestrianInstructionFinish() {
    final res = _CPedestrianInstructionFinishMakeDefault();
    return res;
  }
}
extension _CPedestrianInstructionFinishRelease on _CPedestrianInstructionFinish {
  void _releaseIntermediate() {
  }
}

// MARK: - PedestrianInstructionCrossroadLandmark

/** Ориентир. */
enum PedestrianInstructionCrossroadLandmark {
  /** Нет ориентира. */
  none(0),
  /** Пешеходный переход. */
  crosswalk(1),
  /** Светофор. */
  trafficLight(2),
  ;

  const PedestrianInstructionCrossroadLandmark(this.rawValue);
  final int rawValue;

  static PedestrianInstructionCrossroadLandmark getByValue(int value) {
    return PedestrianInstructionCrossroadLandmark.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CPedestrianInstructionCrossroadLandmark extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CPedestrianInstructionCrossroadLandmarkBasicFunctions on _CPedestrianInstructionCrossroadLandmark {
  void _releaseIntermediate() {
  }
}

extension _CPedestrianInstructionCrossroadLandmarkToDart on _CPedestrianInstructionCrossroadLandmark {
  PedestrianInstructionCrossroadLandmark _toDart() {
    return PedestrianInstructionCrossroadLandmark.getByValue(this.rawValue);
  }
}

extension _DartTo_CPedestrianInstructionCrossroadLandmark on PedestrianInstructionCrossroadLandmark {
  _CPedestrianInstructionCrossroadLandmark _copyFromDartTo_CPedestrianInstructionCrossroadLandmark() {
    return _CPedestrianInstructionCrossroadLandmarkMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - List<PedestrianInstructionCrossroadManeuver> <-> _CArray_CPedestrianInstructionCrossroadManeuver

final class _CArray_CPedestrianInstructionCrossroadManeuver extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CPedestrianInstructionCrossroadManeuverToDart on _CArray_CPedestrianInstructionCrossroadManeuver {
  List<PedestrianInstructionCrossroadManeuver> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CPedestrianInstructionCrossroadManeuver on List<PedestrianInstructionCrossroadManeuver> {
  _CArray_CPedestrianInstructionCrossroadManeuver _copyFromDartTo_CArray_CPedestrianInstructionCrossroadManeuver() {
    final cArray = _CArray_CPedestrianInstructionCrossroadManeuvermakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CPedestrianInstructionCrossroadManeuver();
        _CArray_CPedestrianInstructionCrossroadManeuveraddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CPedestrianInstructionCrossroadManeuverBasicFunctions on _CArray_CPedestrianInstructionCrossroadManeuver {
  void _releaseIntermediate() {
    _CArray_CPedestrianInstructionCrossroadManeuver_release(this);
  }

  static final _listToFill = <PedestrianInstructionCrossroadManeuver>[];

  static void _iterate(_CPedestrianInstructionCrossroadManeuver item) {
    _listToFill.add(item._toDart());
  }

  List<PedestrianInstructionCrossroadManeuver> _fillFromC() {
    _forEach_CArray_CPedestrianInstructionCrossroadManeuver(this, ffi.Pointer.fromFunction<ffi.Void Function(_CPedestrianInstructionCrossroadManeuver)>(_iterate));
    final result = List<PedestrianInstructionCrossroadManeuver>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - PedestrianInstructionCrossroad

/** Описание манёвров при проходе через перекрёсток или по пешеходному переходу. */
class PedestrianInstructionCrossroad {
  /** Ориентир. */
  final PedestrianInstructionCrossroadLandmark landmark;
  /** Цепочка идущих подряд манёвров. */
  final List<PedestrianInstructionCrossroadManeuver> maneuvers;

  const PedestrianInstructionCrossroad({
    this.landmark = PedestrianInstructionCrossroadLandmark.none,
    required this.maneuvers
  });

  PedestrianInstructionCrossroad copyWith({
    PedestrianInstructionCrossroadLandmark? landmark,
    List<PedestrianInstructionCrossroadManeuver>? maneuvers
  }) {
    return PedestrianInstructionCrossroad(
      landmark: landmark ?? this.landmark,
      maneuvers: maneuvers ?? this.maneuvers
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PedestrianInstructionCrossroad &&
    other.runtimeType == runtimeType &&
    other.landmark == landmark &&
    other.maneuvers == maneuvers;

  @override
  int get hashCode {
    return Object.hash(landmark, maneuvers);
  }

}
final class _CPedestrianInstructionCrossroad extends ffi.Struct {
  external _CPedestrianInstructionCrossroadLandmark landmark;

  external _CArray_CPedestrianInstructionCrossroadManeuver maneuvers;

}
// MARK: - PedestrianInstructionCrossroad <-> _CPedestrianInstructionCrossroad

extension _CPedestrianInstructionCrossroadToDart on _CPedestrianInstructionCrossroad {
  PedestrianInstructionCrossroad _toDart() {
    return PedestrianInstructionCrossroad(
      landmark: this.landmark._toDart(),
      maneuvers: this.maneuvers._toDart()
    );
  }
}

extension _DartTo_CPedestrianInstructionCrossroad on PedestrianInstructionCrossroad {
  _CPedestrianInstructionCrossroad _copyFromDartTo_CPedestrianInstructionCrossroad() {
    final res = _CPedestrianInstructionCrossroadMakeDefault();
    res.landmark = this.landmark._copyFromDartTo_CPedestrianInstructionCrossroadLandmark();
    res.maneuvers = this.maneuvers._copyFromDartTo_CArray_CPedestrianInstructionCrossroadManeuver();
    return res;
  }
}
extension _CPedestrianInstructionCrossroadRelease on _CPedestrianInstructionCrossroad {
  void _releaseIntermediate() {
    maneuvers._releaseIntermediate();
  }
}

// MARK: - PedestrianInstructionIndoorFloorChangeType

/** Тип смены этажа. */
enum PedestrianInstructionIndoorFloorChangeType {
  /** Дорожка без ступеней, или неизвестно. */
  undefined(0),
  /** Лестница. */
  stairway(1),
  /** Лифт. */
  elevator(2),
  /** Эскалатор. */
  escalator(3),
  ;

  const PedestrianInstructionIndoorFloorChangeType(this.rawValue);
  final int rawValue;

  static PedestrianInstructionIndoorFloorChangeType getByValue(int value) {
    return PedestrianInstructionIndoorFloorChangeType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CPedestrianInstructionIndoorFloorChangeType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CPedestrianInstructionIndoorFloorChangeTypeBasicFunctions on _CPedestrianInstructionIndoorFloorChangeType {
  void _releaseIntermediate() {
  }
}

extension _CPedestrianInstructionIndoorFloorChangeTypeToDart on _CPedestrianInstructionIndoorFloorChangeType {
  PedestrianInstructionIndoorFloorChangeType _toDart() {
    return PedestrianInstructionIndoorFloorChangeType.getByValue(this.rawValue);
  }
}

extension _DartTo_CPedestrianInstructionIndoorFloorChangeType on PedestrianInstructionIndoorFloorChangeType {
  _CPedestrianInstructionIndoorFloorChangeType _copyFromDartTo_CPedestrianInstructionIndoorFloorChangeType() {
    return _CPedestrianInstructionIndoorFloorChangeTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - PedestrianInstructionIndoorFloorChange

/** Смена этажа в здании. */
class PedestrianInstructionIndoorFloorChange {
  /** Тип смены этажа. */
  final PedestrianInstructionIndoorFloorChangeType type;
  /** Идентификатор этажа до смены. */
  final LevelId beginId;
  /** Идентификатор этажа после смены. */
  final LevelId endId;

  const PedestrianInstructionIndoorFloorChange({
    this.type = PedestrianInstructionIndoorFloorChangeType.undefined,
    this.beginId = const LevelId(),
    this.endId = const LevelId()
  });

  PedestrianInstructionIndoorFloorChange copyWith({
    PedestrianInstructionIndoorFloorChangeType? type,
    LevelId? beginId,
    LevelId? endId
  }) {
    return PedestrianInstructionIndoorFloorChange(
      type: type ?? this.type,
      beginId: beginId ?? this.beginId,
      endId: endId ?? this.endId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PedestrianInstructionIndoorFloorChange &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.beginId == beginId &&
    other.endId == endId;

  @override
  int get hashCode {
    return Object.hash(type, beginId, endId);
  }

}
final class _CPedestrianInstructionIndoorFloorChange extends ffi.Struct {
  external _CPedestrianInstructionIndoorFloorChangeType type;

  external _CLevelId beginId;

  external _CLevelId endId;

}
// MARK: - PedestrianInstructionIndoorFloorChange <-> _CPedestrianInstructionIndoorFloorChange

extension _CPedestrianInstructionIndoorFloorChangeToDart on _CPedestrianInstructionIndoorFloorChange {
  PedestrianInstructionIndoorFloorChange _toDart() {
    return PedestrianInstructionIndoorFloorChange(
      type: this.type._toDart(),
      beginId: this.beginId._toDart(),
      endId: this.endId._toDart()
    );
  }
}

extension _DartTo_CPedestrianInstructionIndoorFloorChange on PedestrianInstructionIndoorFloorChange {
  _CPedestrianInstructionIndoorFloorChange _copyFromDartTo_CPedestrianInstructionIndoorFloorChange() {
    final res = _CPedestrianInstructionIndoorFloorChangeMakeDefault();
    res.type = this.type._copyFromDartTo_CPedestrianInstructionIndoorFloorChangeType();
    res.beginId = this.beginId._copyFromDartTo_CLevelId();
    res.endId = this.endId._copyFromDartTo_CLevelId();
    return res;
  }
}
extension _CPedestrianInstructionIndoorFloorChangeRelease on _CPedestrianInstructionIndoorFloorChange {
  void _releaseIntermediate() {
  }
}

// MARK: - PedestrianInstructionIndoorEnter

/** Вход в здание. */
class PedestrianInstructionIndoorEnter {
  /** Идентификатор этажа после входа в здание. */
  final LevelId levelId;

  const PedestrianInstructionIndoorEnter([this.levelId = const LevelId()]);

  PedestrianInstructionIndoorEnter copyWith({
    LevelId? levelId
  }) {
    return PedestrianInstructionIndoorEnter(
      levelId ?? this.levelId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PedestrianInstructionIndoorEnter &&
    other.runtimeType == runtimeType &&
    other.levelId == levelId;

  @override
  int get hashCode {
    return levelId.hashCode;
  }

}
final class _CPedestrianInstructionIndoorEnter extends ffi.Struct {
  external _CLevelId levelId;

}
// MARK: - PedestrianInstructionIndoorEnter <-> _CPedestrianInstructionIndoorEnter

extension _CPedestrianInstructionIndoorEnterToDart on _CPedestrianInstructionIndoorEnter {
  PedestrianInstructionIndoorEnter _toDart() {
    return PedestrianInstructionIndoorEnter(
      this.levelId._toDart()
    );
  }
}

extension _DartTo_CPedestrianInstructionIndoorEnter on PedestrianInstructionIndoorEnter {
  _CPedestrianInstructionIndoorEnter _copyFromDartTo_CPedestrianInstructionIndoorEnter() {
    final res = _CPedestrianInstructionIndoorEnterMakeDefault();
    res.levelId = this.levelId._copyFromDartTo_CLevelId();
    return res;
  }
}
extension _CPedestrianInstructionIndoorEnterRelease on _CPedestrianInstructionIndoorEnter {
  void _releaseIntermediate() {
  }
}

// MARK: - PedestrianInstructionIndoorExit

/** Выход из здания. */
class PedestrianInstructionIndoorExit {

  const PedestrianInstructionIndoorExit();

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PedestrianInstructionIndoorExit &&
    other.runtimeType == runtimeType;

  @override
  int get hashCode {
    return 0;
  }

}
final class _CPedestrianInstructionIndoorExit extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
// MARK: - PedestrianInstructionIndoorExit <-> _CPedestrianInstructionIndoorExit

extension _CPedestrianInstructionIndoorExitToDart on _CPedestrianInstructionIndoorExit {
  PedestrianInstructionIndoorExit _toDart() {
    return PedestrianInstructionIndoorExit(
    );
  }
}

extension _DartTo_CPedestrianInstructionIndoorExit on PedestrianInstructionIndoorExit {
  _CPedestrianInstructionIndoorExit _copyFromDartTo_CPedestrianInstructionIndoorExit() {
    final res = _CPedestrianInstructionIndoorExitMakeDefault();
    return res;
  }
}
extension _CPedestrianInstructionIndoorExitRelease on _CPedestrianInstructionIndoorExit {
  void _releaseIntermediate() {
  }
}

// MARK: - ScooterInstructionStart

/** Начало самокатной части маршрута. */
class ScooterInstructionStart {

  const ScooterInstructionStart();

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScooterInstructionStart &&
    other.runtimeType == runtimeType;

  @override
  int get hashCode {
    return 0;
  }

}
final class _CScooterInstructionStart extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
// MARK: - ScooterInstructionStart <-> _CScooterInstructionStart

extension _CScooterInstructionStartToDart on _CScooterInstructionStart {
  ScooterInstructionStart _toDart() {
    return ScooterInstructionStart(
    );
  }
}

extension _DartTo_CScooterInstructionStart on ScooterInstructionStart {
  _CScooterInstructionStart _copyFromDartTo_CScooterInstructionStart() {
    final res = _CScooterInstructionStartMakeDefault();
    return res;
  }
}
extension _CScooterInstructionStartRelease on _CScooterInstructionStart {
  void _releaseIntermediate() {
  }
}

// MARK: - ScooterInstructionFinish

/** Конец самокатной части маршрута. */
class ScooterInstructionFinish {

  const ScooterInstructionFinish();

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScooterInstructionFinish &&
    other.runtimeType == runtimeType;

  @override
  int get hashCode {
    return 0;
  }

}
final class _CScooterInstructionFinish extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
// MARK: - ScooterInstructionFinish <-> _CScooterInstructionFinish

extension _CScooterInstructionFinishToDart on _CScooterInstructionFinish {
  ScooterInstructionFinish _toDart() {
    return ScooterInstructionFinish(
    );
  }
}

extension _DartTo_CScooterInstructionFinish on ScooterInstructionFinish {
  _CScooterInstructionFinish _copyFromDartTo_CScooterInstructionFinish() {
    final res = _CScooterInstructionFinishMakeDefault();
    return res;
  }
}
extension _CScooterInstructionFinishRelease on _CScooterInstructionFinish {
  void _releaseIntermediate() {
  }
}

// MARK: - ScooterInstructionCrossroadLandmark

/** Ориентир. */
enum ScooterInstructionCrossroadLandmark {
  /** Нет ориентира. */
  none(0),
  /** Пешеходный переход. */
  crosswalk(1),
  /** Светофор. */
  trafficLight(2),
  ;

  const ScooterInstructionCrossroadLandmark(this.rawValue);
  final int rawValue;

  static ScooterInstructionCrossroadLandmark getByValue(int value) {
    return ScooterInstructionCrossroadLandmark.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CScooterInstructionCrossroadLandmark extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CScooterInstructionCrossroadLandmarkBasicFunctions on _CScooterInstructionCrossroadLandmark {
  void _releaseIntermediate() {
  }
}

extension _CScooterInstructionCrossroadLandmarkToDart on _CScooterInstructionCrossroadLandmark {
  ScooterInstructionCrossroadLandmark _toDart() {
    return ScooterInstructionCrossroadLandmark.getByValue(this.rawValue);
  }
}

extension _DartTo_CScooterInstructionCrossroadLandmark on ScooterInstructionCrossroadLandmark {
  _CScooterInstructionCrossroadLandmark _copyFromDartTo_CScooterInstructionCrossroadLandmark() {
    return _CScooterInstructionCrossroadLandmarkMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - List<ScooterInstructionCrossroadManeuver> <-> _CArray_CScooterInstructionCrossroadManeuver

final class _CArray_CScooterInstructionCrossroadManeuver extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CScooterInstructionCrossroadManeuverToDart on _CArray_CScooterInstructionCrossroadManeuver {
  List<ScooterInstructionCrossroadManeuver> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CScooterInstructionCrossroadManeuver on List<ScooterInstructionCrossroadManeuver> {
  _CArray_CScooterInstructionCrossroadManeuver _copyFromDartTo_CArray_CScooterInstructionCrossroadManeuver() {
    final cArray = _CArray_CScooterInstructionCrossroadManeuvermakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CScooterInstructionCrossroadManeuver();
        _CArray_CScooterInstructionCrossroadManeuveraddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CScooterInstructionCrossroadManeuverBasicFunctions on _CArray_CScooterInstructionCrossroadManeuver {
  void _releaseIntermediate() {
    _CArray_CScooterInstructionCrossroadManeuver_release(this);
  }

  static final _listToFill = <ScooterInstructionCrossroadManeuver>[];

  static void _iterate(_CScooterInstructionCrossroadManeuver item) {
    _listToFill.add(item._toDart());
  }

  List<ScooterInstructionCrossroadManeuver> _fillFromC() {
    _forEach_CArray_CScooterInstructionCrossroadManeuver(this, ffi.Pointer.fromFunction<ffi.Void Function(_CScooterInstructionCrossroadManeuver)>(_iterate));
    final result = List<ScooterInstructionCrossroadManeuver>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - ScooterInstructionCrossroad

/** Описание манёвров при проходе через перекрёсток или по пешеходному переходу. */
class ScooterInstructionCrossroad {
  /** Ориентир. */
  final ScooterInstructionCrossroadLandmark landmark;
  /** Цепочка идущих подряд манёвров. */
  final List<ScooterInstructionCrossroadManeuver> maneuvers;

  const ScooterInstructionCrossroad({
    this.landmark = ScooterInstructionCrossroadLandmark.none,
    required this.maneuvers
  });

  ScooterInstructionCrossroad copyWith({
    ScooterInstructionCrossroadLandmark? landmark,
    List<ScooterInstructionCrossroadManeuver>? maneuvers
  }) {
    return ScooterInstructionCrossroad(
      landmark: landmark ?? this.landmark,
      maneuvers: maneuvers ?? this.maneuvers
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScooterInstructionCrossroad &&
    other.runtimeType == runtimeType &&
    other.landmark == landmark &&
    other.maneuvers == maneuvers;

  @override
  int get hashCode {
    return Object.hash(landmark, maneuvers);
  }

}
final class _CScooterInstructionCrossroad extends ffi.Struct {
  external _CScooterInstructionCrossroadLandmark landmark;

  external _CArray_CScooterInstructionCrossroadManeuver maneuvers;

}
// MARK: - ScooterInstructionCrossroad <-> _CScooterInstructionCrossroad

extension _CScooterInstructionCrossroadToDart on _CScooterInstructionCrossroad {
  ScooterInstructionCrossroad _toDart() {
    return ScooterInstructionCrossroad(
      landmark: this.landmark._toDart(),
      maneuvers: this.maneuvers._toDart()
    );
  }
}

extension _DartTo_CScooterInstructionCrossroad on ScooterInstructionCrossroad {
  _CScooterInstructionCrossroad _copyFromDartTo_CScooterInstructionCrossroad() {
    final res = _CScooterInstructionCrossroadMakeDefault();
    res.landmark = this.landmark._copyFromDartTo_CScooterInstructionCrossroadLandmark();
    res.maneuvers = this.maneuvers._copyFromDartTo_CArray_CScooterInstructionCrossroadManeuver();
    return res;
  }
}
extension _CScooterInstructionCrossroadRelease on _CScooterInstructionCrossroad {
  void _releaseIntermediate() {
    maneuvers._releaseIntermediate();
  }
}

// MARK: - ExtraInstructionInfo

final class ExtraInstructionInfo {
  final Object? _value;
  final int _index;

  ExtraInstructionInfo._raw(this._value, this._index);

  ExtraInstructionInfo.bicycleStart(BicycleInstructionStart value) : this._raw(value, 0);
  ExtraInstructionInfo.bicycleFinish(BicycleInstructionFinish value) : this._raw(value, 1);
  ExtraInstructionInfo.bicycleCrossroad(BicycleInstructionCrossroad value) : this._raw(value, 2);
  ExtraInstructionInfo.carStart(CarInstructionStart value) : this._raw(value, 3);
  ExtraInstructionInfo.carFinish(CarInstructionFinish value) : this._raw(value, 4);
  ExtraInstructionInfo.carCrossroad(CarInstructionCrossroad value) : this._raw(value, 5);
  ExtraInstructionInfo.carRoundabout(CarInstructionRoundabout value) : this._raw(value, 6);
  ExtraInstructionInfo.carUturn(CarInstructionUTurn value) : this._raw(value, 7);
  ExtraInstructionInfo.pedestrianStart(PedestrianInstructionStart value) : this._raw(value, 8);
  ExtraInstructionInfo.pedestrianFinish(PedestrianInstructionFinish value) : this._raw(value, 9);
  ExtraInstructionInfo.pedestrianCrossroad(PedestrianInstructionCrossroad value) : this._raw(value, 10);
  ExtraInstructionInfo.pedestrianIndoorFloorChange(PedestrianInstructionIndoorFloorChange value) : this._raw(value, 11);
  ExtraInstructionInfo.pedestrianIndoorEnter(PedestrianInstructionIndoorEnter value) : this._raw(value, 12);
  ExtraInstructionInfo.pedestrianIndoorExit(PedestrianInstructionIndoorExit value) : this._raw(value, 13);
  ExtraInstructionInfo.scooterStart(ScooterInstructionStart value) : this._raw(value, 14);
  ExtraInstructionInfo.scooterFinish(ScooterInstructionFinish value) : this._raw(value, 15);
  ExtraInstructionInfo.scooterCrossroad(ScooterInstructionCrossroad value) : this._raw(value, 16);

  bool get isBicycleStart => this._index == 0;
  BicycleInstructionStart? get asBicycleStart => this.isBicycleStart ? this._value as BicycleInstructionStart : null;

  bool get isBicycleFinish => this._index == 1;
  BicycleInstructionFinish? get asBicycleFinish => this.isBicycleFinish ? this._value as BicycleInstructionFinish : null;

  bool get isBicycleCrossroad => this._index == 2;
  BicycleInstructionCrossroad? get asBicycleCrossroad => this.isBicycleCrossroad ? this._value as BicycleInstructionCrossroad : null;

  bool get isCarStart => this._index == 3;
  CarInstructionStart? get asCarStart => this.isCarStart ? this._value as CarInstructionStart : null;

  bool get isCarFinish => this._index == 4;
  CarInstructionFinish? get asCarFinish => this.isCarFinish ? this._value as CarInstructionFinish : null;

  bool get isCarCrossroad => this._index == 5;
  CarInstructionCrossroad? get asCarCrossroad => this.isCarCrossroad ? this._value as CarInstructionCrossroad : null;

  bool get isCarRoundabout => this._index == 6;
  CarInstructionRoundabout? get asCarRoundabout => this.isCarRoundabout ? this._value as CarInstructionRoundabout : null;

  bool get isCarUturn => this._index == 7;
  CarInstructionUTurn? get asCarUturn => this.isCarUturn ? this._value as CarInstructionUTurn : null;

  bool get isPedestrianStart => this._index == 8;
  PedestrianInstructionStart? get asPedestrianStart => this.isPedestrianStart ? this._value as PedestrianInstructionStart : null;

  bool get isPedestrianFinish => this._index == 9;
  PedestrianInstructionFinish? get asPedestrianFinish => this.isPedestrianFinish ? this._value as PedestrianInstructionFinish : null;

  bool get isPedestrianCrossroad => this._index == 10;
  PedestrianInstructionCrossroad? get asPedestrianCrossroad => this.isPedestrianCrossroad ? this._value as PedestrianInstructionCrossroad : null;

  bool get isPedestrianIndoorFloorChange => this._index == 11;
  PedestrianInstructionIndoorFloorChange? get asPedestrianIndoorFloorChange => this.isPedestrianIndoorFloorChange ? this._value as PedestrianInstructionIndoorFloorChange : null;

  bool get isPedestrianIndoorEnter => this._index == 12;
  PedestrianInstructionIndoorEnter? get asPedestrianIndoorEnter => this.isPedestrianIndoorEnter ? this._value as PedestrianInstructionIndoorEnter : null;

  bool get isPedestrianIndoorExit => this._index == 13;
  PedestrianInstructionIndoorExit? get asPedestrianIndoorExit => this.isPedestrianIndoorExit ? this._value as PedestrianInstructionIndoorExit : null;

  bool get isScooterStart => this._index == 14;
  ScooterInstructionStart? get asScooterStart => this.isScooterStart ? this._value as ScooterInstructionStart : null;

  bool get isScooterFinish => this._index == 15;
  ScooterInstructionFinish? get asScooterFinish => this.isScooterFinish ? this._value as ScooterInstructionFinish : null;

  bool get isScooterCrossroad => this._index == 16;
  ScooterInstructionCrossroad? get asScooterCrossroad => this.isScooterCrossroad ? this._value as ScooterInstructionCrossroad : null;

  T match<T>({
    required T Function(BicycleInstructionStart value) bicycleStart,
    required T Function(BicycleInstructionFinish value) bicycleFinish,
    required T Function(BicycleInstructionCrossroad value) bicycleCrossroad,
    required T Function(CarInstructionStart value) carStart,
    required T Function(CarInstructionFinish value) carFinish,
    required T Function(CarInstructionCrossroad value) carCrossroad,
    required T Function(CarInstructionRoundabout value) carRoundabout,
    required T Function(CarInstructionUTurn value) carUturn,
    required T Function(PedestrianInstructionStart value) pedestrianStart,
    required T Function(PedestrianInstructionFinish value) pedestrianFinish,
    required T Function(PedestrianInstructionCrossroad value) pedestrianCrossroad,
    required T Function(PedestrianInstructionIndoorFloorChange value) pedestrianIndoorFloorChange,
    required T Function(PedestrianInstructionIndoorEnter value) pedestrianIndoorEnter,
    required T Function(PedestrianInstructionIndoorExit value) pedestrianIndoorExit,
    required T Function(ScooterInstructionStart value) scooterStart,
    required T Function(ScooterInstructionFinish value) scooterFinish,
    required T Function(ScooterInstructionCrossroad value) scooterCrossroad,
  }) {
    return switch (this._index) {
      0 => bicycleStart(this._value as BicycleInstructionStart),
      1 => bicycleFinish(this._value as BicycleInstructionFinish),
      2 => bicycleCrossroad(this._value as BicycleInstructionCrossroad),
      3 => carStart(this._value as CarInstructionStart),
      4 => carFinish(this._value as CarInstructionFinish),
      5 => carCrossroad(this._value as CarInstructionCrossroad),
      6 => carRoundabout(this._value as CarInstructionRoundabout),
      7 => carUturn(this._value as CarInstructionUTurn),
      8 => pedestrianStart(this._value as PedestrianInstructionStart),
      9 => pedestrianFinish(this._value as PedestrianInstructionFinish),
      10 => pedestrianCrossroad(this._value as PedestrianInstructionCrossroad),
      11 => pedestrianIndoorFloorChange(this._value as PedestrianInstructionIndoorFloorChange),
      12 => pedestrianIndoorEnter(this._value as PedestrianInstructionIndoorEnter),
      13 => pedestrianIndoorExit(this._value as PedestrianInstructionIndoorExit),
      14 => scooterStart(this._value as ScooterInstructionStart),
      15 => scooterFinish(this._value as ScooterInstructionFinish),
      16 => scooterCrossroad(this._value as ScooterInstructionCrossroad),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "ExtraInstructionInfo(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ExtraInstructionInfo &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CExtraInstructionInfoImpl extends ffi.Union {
  external _CBicycleInstructionStart _bicycleStart;
  external _CBicycleInstructionFinish _bicycleFinish;
  external _CBicycleInstructionCrossroad _bicycleCrossroad;
  external _CCarInstructionStart _carStart;
  external _CCarInstructionFinish _carFinish;
  external _CCarInstructionCrossroad _carCrossroad;
  external _CCarInstructionRoundabout _carRoundabout;
  external _CCarInstructionUTurn _carUturn;
  external _CPedestrianInstructionStart _pedestrianStart;
  external _CPedestrianInstructionFinish _pedestrianFinish;
  external _CPedestrianInstructionCrossroad _pedestrianCrossroad;
  external _CPedestrianInstructionIndoorFloorChange _pedestrianIndoorFloorChange;
  external _CPedestrianInstructionIndoorEnter _pedestrianIndoorEnter;
  external _CPedestrianInstructionIndoorExit _pedestrianIndoorExit;
  external _CScooterInstructionStart _scooterStart;
  external _CScooterInstructionFinish _scooterFinish;
  external _CScooterInstructionCrossroad _scooterCrossroad;
}

final class _CExtraInstructionInfo extends ffi.Struct {
  external _CExtraInstructionInfoImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CExtraInstructionInfoBasicFunctions on _CExtraInstructionInfo {
  void _releaseIntermediate() {
    _CExtraInstructionInfo_release(this);
  }
}
	
// MARK: - ExtraInstructionInfo <-> CExtraInstructionInfo

extension _CExtraInstructionInfoToDart on _CExtraInstructionInfo {
  ExtraInstructionInfo _toDart() {
    return switch (this._index) {
      0 => ExtraInstructionInfo.bicycleStart(this._impl._bicycleStart._toDart()),
      1 => ExtraInstructionInfo.bicycleFinish(this._impl._bicycleFinish._toDart()),
      2 => ExtraInstructionInfo.bicycleCrossroad(this._impl._bicycleCrossroad._toDart()),
      3 => ExtraInstructionInfo.carStart(this._impl._carStart._toDart()),
      4 => ExtraInstructionInfo.carFinish(this._impl._carFinish._toDart()),
      5 => ExtraInstructionInfo.carCrossroad(this._impl._carCrossroad._toDart()),
      6 => ExtraInstructionInfo.carRoundabout(this._impl._carRoundabout._toDart()),
      7 => ExtraInstructionInfo.carUturn(this._impl._carUturn._toDart()),
      8 => ExtraInstructionInfo.pedestrianStart(this._impl._pedestrianStart._toDart()),
      9 => ExtraInstructionInfo.pedestrianFinish(this._impl._pedestrianFinish._toDart()),
      10 => ExtraInstructionInfo.pedestrianCrossroad(this._impl._pedestrianCrossroad._toDart()),
      11 => ExtraInstructionInfo.pedestrianIndoorFloorChange(this._impl._pedestrianIndoorFloorChange._toDart()),
      12 => ExtraInstructionInfo.pedestrianIndoorEnter(this._impl._pedestrianIndoorEnter._toDart()),
      13 => ExtraInstructionInfo.pedestrianIndoorExit(this._impl._pedestrianIndoorExit._toDart()),
      14 => ExtraInstructionInfo.scooterStart(this._impl._scooterStart._toDart()),
      15 => ExtraInstructionInfo.scooterFinish(this._impl._scooterFinish._toDart()),
      16 => ExtraInstructionInfo.scooterCrossroad(this._impl._scooterCrossroad._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CExtraInstructionInfo on ExtraInstructionInfo {
  _CExtraInstructionInfo _copyFromDartTo_CExtraInstructionInfo() {
    var res = _CExtraInstructionInfoMakeDefault();
    this.match<void>(
      bicycleStart: (BicycleInstructionStart value) {
        res._impl._bicycleStart = value._copyFromDartTo_CBicycleInstructionStart();
        res._index = 0;
      },
      bicycleFinish: (BicycleInstructionFinish value) {
        res._impl._bicycleFinish = value._copyFromDartTo_CBicycleInstructionFinish();
        res._index = 1;
      },
      bicycleCrossroad: (BicycleInstructionCrossroad value) {
        res._impl._bicycleCrossroad = value._copyFromDartTo_CBicycleInstructionCrossroad();
        res._index = 2;
      },
      carStart: (CarInstructionStart value) {
        res._impl._carStart = value._copyFromDartTo_CCarInstructionStart();
        res._index = 3;
      },
      carFinish: (CarInstructionFinish value) {
        res._impl._carFinish = value._copyFromDartTo_CCarInstructionFinish();
        res._index = 4;
      },
      carCrossroad: (CarInstructionCrossroad value) {
        res._impl._carCrossroad = value._copyFromDartTo_CCarInstructionCrossroad();
        res._index = 5;
      },
      carRoundabout: (CarInstructionRoundabout value) {
        res._impl._carRoundabout = value._copyFromDartTo_CCarInstructionRoundabout();
        res._index = 6;
      },
      carUturn: (CarInstructionUTurn value) {
        res._impl._carUturn = value._copyFromDartTo_CCarInstructionUTurn();
        res._index = 7;
      },
      pedestrianStart: (PedestrianInstructionStart value) {
        res._impl._pedestrianStart = value._copyFromDartTo_CPedestrianInstructionStart();
        res._index = 8;
      },
      pedestrianFinish: (PedestrianInstructionFinish value) {
        res._impl._pedestrianFinish = value._copyFromDartTo_CPedestrianInstructionFinish();
        res._index = 9;
      },
      pedestrianCrossroad: (PedestrianInstructionCrossroad value) {
        res._impl._pedestrianCrossroad = value._copyFromDartTo_CPedestrianInstructionCrossroad();
        res._index = 10;
      },
      pedestrianIndoorFloorChange: (PedestrianInstructionIndoorFloorChange value) {
        res._impl._pedestrianIndoorFloorChange = value._copyFromDartTo_CPedestrianInstructionIndoorFloorChange();
        res._index = 11;
      },
      pedestrianIndoorEnter: (PedestrianInstructionIndoorEnter value) {
        res._impl._pedestrianIndoorEnter = value._copyFromDartTo_CPedestrianInstructionIndoorEnter();
        res._index = 12;
      },
      pedestrianIndoorExit: (PedestrianInstructionIndoorExit value) {
        res._impl._pedestrianIndoorExit = value._copyFromDartTo_CPedestrianInstructionIndoorExit();
        res._index = 13;
      },
      scooterStart: (ScooterInstructionStart value) {
        res._impl._scooterStart = value._copyFromDartTo_CScooterInstructionStart();
        res._index = 14;
      },
      scooterFinish: (ScooterInstructionFinish value) {
        res._impl._scooterFinish = value._copyFromDartTo_CScooterInstructionFinish();
        res._index = 15;
      },
      scooterCrossroad: (ScooterInstructionCrossroad value) {
        res._impl._scooterCrossroad = value._copyFromDartTo_CScooterInstructionCrossroad();
        res._index = 16;
      },
    );
    return res;
  }
}

// MARK: - RouteInstruction

/** Инструкция, которую необходимо выполнить для движения по маршруту. */
class RouteInstruction {
  /** Название дороги, на которой окажется пользователь после совершения манёвра. */
  final String roadName;
  /**
   Расстояние после точки инструкции, на протяжении которого считается, что пользователь
   находится в зоне действия инструкции.
  */
  final RouteDistance range;
  /** Специфичная для конкретного типа инструкции информация. */
  final ExtraInstructionInfo extraInstructionInfo;

  const RouteInstruction({
    required this.roadName,
    required this.range,
    required this.extraInstructionInfo
  });

  RouteInstruction copyWith({
    String? roadName,
    RouteDistance? range,
    ExtraInstructionInfo? extraInstructionInfo
  }) {
    return RouteInstruction(
      roadName: roadName ?? this.roadName,
      range: range ?? this.range,
      extraInstructionInfo: extraInstructionInfo ?? this.extraInstructionInfo
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteInstruction &&
    other.runtimeType == runtimeType &&
    other.roadName == roadName &&
    other.range == range &&
    other.extraInstructionInfo == extraInstructionInfo;

  @override
  int get hashCode {
    return Object.hash(roadName, range, extraInstructionInfo);
  }

}
final class _CRouteInstruction extends ffi.Struct {
  external _CString roadName;

  external _CRouteDistance range;

  external _CExtraInstructionInfo extraInstructionInfo;

}
// MARK: - RouteInstruction <-> _CRouteInstruction

extension _CRouteInstructionToDart on _CRouteInstruction {
  RouteInstruction _toDart() {
    return RouteInstruction(
      roadName: this.roadName._toDart(),
      range: this.range._toDart(),
      extraInstructionInfo: this.extraInstructionInfo._toDart()
    );
  }
}

extension _DartTo_CRouteInstruction on RouteInstruction {
  _CRouteInstruction _copyFromDartTo_CRouteInstruction() {
    final res = _CRouteInstructionMakeDefault();
    res.roadName = this.roadName._copyFromDartTo_CString();
    res.range = this.range._copyFromDartTo_CRouteDistance();
    res.extraInstructionInfo = this.extraInstructionInfo._copyFromDartTo_CExtraInstructionInfo();
    return res;
  }
}
extension _CRouteInstructionRelease on _CRouteInstruction {
  void _releaseIntermediate() {
    roadName._releaseIntermediate();
    extraInstructionInfo._releaseIntermediate();
  }
}

// MARK: - InstructionRouteEntry

/** Элемент маршрута - точка и значение в ней. */
class InstructionRouteEntry {
  final RoutePoint point;
  final RouteInstruction value;

  const InstructionRouteEntry({
    required this.point,
    required this.value
  });

  InstructionRouteEntry copyWith({
    RoutePoint? point,
    RouteInstruction? value
  }) {
    return InstructionRouteEntry(
      point: point ?? this.point,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is InstructionRouteEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, value);
  }

}
final class _CInstructionRouteEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteInstruction value;

}
// MARK: - InstructionRouteEntry <-> _CInstructionRouteEntry

extension _CInstructionRouteEntryToDart on _CInstructionRouteEntry {
  InstructionRouteEntry _toDart() {
    return InstructionRouteEntry(
      point: this.point._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CInstructionRouteEntry on InstructionRouteEntry {
  _CInstructionRouteEntry _copyFromDartTo_CInstructionRouteEntry() {
    final res = _CInstructionRouteEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.value = this.value._copyFromDartTo_CRouteInstruction();
    return res;
  }
}
extension _CInstructionRouteEntryRelease on _CInstructionRouteEntry {
  void _releaseIntermediate() {
    value._releaseIntermediate();
  }
}

// MARK: - InstructionRouteEntry? <-> _COptional_CInstructionRouteEntry

final class _COptional_CInstructionRouteEntry extends ffi.Struct {
  
  external _CInstructionRouteEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CInstructionRouteEntryBasicFunctions on _COptional_CInstructionRouteEntry {
  void _releaseIntermediate() {
    _COptional_CInstructionRouteEntry_release(this);
  }
}

extension _COptional_CInstructionRouteEntryToDart on _COptional_CInstructionRouteEntry {
  InstructionRouteEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CInstructionRouteEntry on InstructionRouteEntry? {
  _COptional_CInstructionRouteEntry _copyFromDartTo_COptional_CInstructionRouteEntry() {
    final cOptional = _COptional_CInstructionRouteEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CInstructionRouteEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - BicycleInstructionCrossroadManeuverDirection

/** Направление движения. */
enum BicycleInstructionCrossroadManeuverDirection {
  /** Прямо. */
  straight(0),
  /** Налево. */
  left(1),
  /** Направо. */
  right(2),
  /** Крутой поворот налево. */
  sharplyLeft(3),
  /** Крутой поворот направо. */
  sharplyRight(4),
  /** Держитесь левее. */
  keepLeft(5),
  /** Держитесь правее. */
  keepRight(6),
  ;

  const BicycleInstructionCrossroadManeuverDirection(this.rawValue);
  final int rawValue;

  static BicycleInstructionCrossroadManeuverDirection getByValue(int value) {
    return BicycleInstructionCrossroadManeuverDirection.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CBicycleInstructionCrossroadManeuverDirection extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CBicycleInstructionCrossroadManeuverDirectionBasicFunctions on _CBicycleInstructionCrossroadManeuverDirection {
  void _releaseIntermediate() {
  }
}

extension _CBicycleInstructionCrossroadManeuverDirectionToDart on _CBicycleInstructionCrossroadManeuverDirection {
  BicycleInstructionCrossroadManeuverDirection _toDart() {
    return BicycleInstructionCrossroadManeuverDirection.getByValue(this.rawValue);
  }
}

extension _DartTo_CBicycleInstructionCrossroadManeuverDirection on BicycleInstructionCrossroadManeuverDirection {
  _CBicycleInstructionCrossroadManeuverDirection _copyFromDartTo_CBicycleInstructionCrossroadManeuverDirection() {
    return _CBicycleInstructionCrossroadManeuverDirectionMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - BicycleInstructionCrossroadManeuver

class BicycleInstructionCrossroadManeuver {
  /** Направление движения. */
  final BicycleInstructionCrossroadManeuverDirection direction;
  /** Угол поворота в градусах [-180, 180]. */
  final int turnAngle;

  const BicycleInstructionCrossroadManeuver({
    this.direction = BicycleInstructionCrossroadManeuverDirection.straight,
    this.turnAngle = 0
  });

  BicycleInstructionCrossroadManeuver copyWith({
    BicycleInstructionCrossroadManeuverDirection? direction,
    int? turnAngle
  }) {
    return BicycleInstructionCrossroadManeuver(
      direction: direction ?? this.direction,
      turnAngle: turnAngle ?? this.turnAngle
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BicycleInstructionCrossroadManeuver &&
    other.runtimeType == runtimeType &&
    other.direction == direction &&
    other.turnAngle == turnAngle;

  @override
  int get hashCode {
    return Object.hash(direction, turnAngle);
  }

}
final class _CBicycleInstructionCrossroadManeuver extends ffi.Struct {
  external _CBicycleInstructionCrossroadManeuverDirection direction;

  @ffi.Int32()
  external int turnAngle;

}
// MARK: - BicycleInstructionCrossroadManeuver <-> _CBicycleInstructionCrossroadManeuver

extension _CBicycleInstructionCrossroadManeuverToDart on _CBicycleInstructionCrossroadManeuver {
  BicycleInstructionCrossroadManeuver _toDart() {
    return BicycleInstructionCrossroadManeuver(
      direction: this.direction._toDart(),
      turnAngle: this.turnAngle
    );
  }
}

extension _DartTo_CBicycleInstructionCrossroadManeuver on BicycleInstructionCrossroadManeuver {
  _CBicycleInstructionCrossroadManeuver _copyFromDartTo_CBicycleInstructionCrossroadManeuver() {
    final res = _CBicycleInstructionCrossroadManeuverMakeDefault();
    res.direction = this.direction._copyFromDartTo_CBicycleInstructionCrossroadManeuverDirection();
    res.turnAngle = this.turnAngle;
    return res;
  }
}
extension _CBicycleInstructionCrossroadManeuverRelease on _CBicycleInstructionCrossroadManeuver {
  void _releaseIntermediate() {
  }
}

// MARK: - PedestrianInstructionCrossroadManeuverDirection

/** Направление движения. */
enum PedestrianInstructionCrossroadManeuverDirection {
  /** Прямо. */
  straight(0),
  /** Налево. */
  left(1),
  /** Направо. */
  right(2),
  /** Крутой поворот налево. */
  sharplyLeft(3),
  /** Крутой поворот направо. */
  sharplyRight(4),
  /** Держитесь левее. */
  keepLeft(5),
  /** Держитесь правее. */
  keepRight(6),
  ;

  const PedestrianInstructionCrossroadManeuverDirection(this.rawValue);
  final int rawValue;

  static PedestrianInstructionCrossroadManeuverDirection getByValue(int value) {
    return PedestrianInstructionCrossroadManeuverDirection.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CPedestrianInstructionCrossroadManeuverDirection extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CPedestrianInstructionCrossroadManeuverDirectionBasicFunctions on _CPedestrianInstructionCrossroadManeuverDirection {
  void _releaseIntermediate() {
  }
}

extension _CPedestrianInstructionCrossroadManeuverDirectionToDart on _CPedestrianInstructionCrossroadManeuverDirection {
  PedestrianInstructionCrossroadManeuverDirection _toDart() {
    return PedestrianInstructionCrossroadManeuverDirection.getByValue(this.rawValue);
  }
}

extension _DartTo_CPedestrianInstructionCrossroadManeuverDirection on PedestrianInstructionCrossroadManeuverDirection {
  _CPedestrianInstructionCrossroadManeuverDirection _copyFromDartTo_CPedestrianInstructionCrossroadManeuverDirection() {
    return _CPedestrianInstructionCrossroadManeuverDirectionMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - PedestrianInstructionCrossroadManeuver

class PedestrianInstructionCrossroadManeuver {
  /** Направление движения. */
  final PedestrianInstructionCrossroadManeuverDirection direction;
  /** Угол поворота в градусах [-180, 180]. */
  final int turnAngle;

  const PedestrianInstructionCrossroadManeuver({
    this.direction = PedestrianInstructionCrossroadManeuverDirection.straight,
    this.turnAngle = 0
  });

  PedestrianInstructionCrossroadManeuver copyWith({
    PedestrianInstructionCrossroadManeuverDirection? direction,
    int? turnAngle
  }) {
    return PedestrianInstructionCrossroadManeuver(
      direction: direction ?? this.direction,
      turnAngle: turnAngle ?? this.turnAngle
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PedestrianInstructionCrossroadManeuver &&
    other.runtimeType == runtimeType &&
    other.direction == direction &&
    other.turnAngle == turnAngle;

  @override
  int get hashCode {
    return Object.hash(direction, turnAngle);
  }

}
final class _CPedestrianInstructionCrossroadManeuver extends ffi.Struct {
  external _CPedestrianInstructionCrossroadManeuverDirection direction;

  @ffi.Int32()
  external int turnAngle;

}
// MARK: - PedestrianInstructionCrossroadManeuver <-> _CPedestrianInstructionCrossroadManeuver

extension _CPedestrianInstructionCrossroadManeuverToDart on _CPedestrianInstructionCrossroadManeuver {
  PedestrianInstructionCrossroadManeuver _toDart() {
    return PedestrianInstructionCrossroadManeuver(
      direction: this.direction._toDart(),
      turnAngle: this.turnAngle
    );
  }
}

extension _DartTo_CPedestrianInstructionCrossroadManeuver on PedestrianInstructionCrossroadManeuver {
  _CPedestrianInstructionCrossroadManeuver _copyFromDartTo_CPedestrianInstructionCrossroadManeuver() {
    final res = _CPedestrianInstructionCrossroadManeuverMakeDefault();
    res.direction = this.direction._copyFromDartTo_CPedestrianInstructionCrossroadManeuverDirection();
    res.turnAngle = this.turnAngle;
    return res;
  }
}
extension _CPedestrianInstructionCrossroadManeuverRelease on _CPedestrianInstructionCrossroadManeuver {
  void _releaseIntermediate() {
  }
}

// MARK: - ScooterInstructionCrossroadManeuverDirection

/** Направление движения. */
enum ScooterInstructionCrossroadManeuverDirection {
  /** Прямо. */
  straight(0),
  /** Налево. */
  left(1),
  /** Направо. */
  right(2),
  /** Крутой поворот налево. */
  sharplyLeft(3),
  /** Крутой поворот направо. */
  sharplyRight(4),
  /** Держитесь левее. */
  keepLeft(5),
  /** Держитесь правее. */
  keepRight(6),
  ;

  const ScooterInstructionCrossroadManeuverDirection(this.rawValue);
  final int rawValue;

  static ScooterInstructionCrossroadManeuverDirection getByValue(int value) {
    return ScooterInstructionCrossroadManeuverDirection.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CScooterInstructionCrossroadManeuverDirection extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CScooterInstructionCrossroadManeuverDirectionBasicFunctions on _CScooterInstructionCrossroadManeuverDirection {
  void _releaseIntermediate() {
  }
}

extension _CScooterInstructionCrossroadManeuverDirectionToDart on _CScooterInstructionCrossroadManeuverDirection {
  ScooterInstructionCrossroadManeuverDirection _toDart() {
    return ScooterInstructionCrossroadManeuverDirection.getByValue(this.rawValue);
  }
}

extension _DartTo_CScooterInstructionCrossroadManeuverDirection on ScooterInstructionCrossroadManeuverDirection {
  _CScooterInstructionCrossroadManeuverDirection _copyFromDartTo_CScooterInstructionCrossroadManeuverDirection() {
    return _CScooterInstructionCrossroadManeuverDirectionMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ScooterInstructionCrossroadManeuver

class ScooterInstructionCrossroadManeuver {
  /** Направление движения. */
  final ScooterInstructionCrossroadManeuverDirection direction;
  /** Угол поворота в градусах [-180, 180]. */
  final int turnAngle;

  const ScooterInstructionCrossroadManeuver({
    this.direction = ScooterInstructionCrossroadManeuverDirection.straight,
    this.turnAngle = 0
  });

  ScooterInstructionCrossroadManeuver copyWith({
    ScooterInstructionCrossroadManeuverDirection? direction,
    int? turnAngle
  }) {
    return ScooterInstructionCrossroadManeuver(
      direction: direction ?? this.direction,
      turnAngle: turnAngle ?? this.turnAngle
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScooterInstructionCrossroadManeuver &&
    other.runtimeType == runtimeType &&
    other.direction == direction &&
    other.turnAngle == turnAngle;

  @override
  int get hashCode {
    return Object.hash(direction, turnAngle);
  }

}
final class _CScooterInstructionCrossroadManeuver extends ffi.Struct {
  external _CScooterInstructionCrossroadManeuverDirection direction;

  @ffi.Int32()
  external int turnAngle;

}
// MARK: - ScooterInstructionCrossroadManeuver <-> _CScooterInstructionCrossroadManeuver

extension _CScooterInstructionCrossroadManeuverToDart on _CScooterInstructionCrossroadManeuver {
  ScooterInstructionCrossroadManeuver _toDart() {
    return ScooterInstructionCrossroadManeuver(
      direction: this.direction._toDart(),
      turnAngle: this.turnAngle
    );
  }
}

extension _DartTo_CScooterInstructionCrossroadManeuver on ScooterInstructionCrossroadManeuver {
  _CScooterInstructionCrossroadManeuver _copyFromDartTo_CScooterInstructionCrossroadManeuver() {
    final res = _CScooterInstructionCrossroadManeuverMakeDefault();
    res.direction = this.direction._copyFromDartTo_CScooterInstructionCrossroadManeuverDirection();
    res.turnAngle = this.turnAngle;
    return res;
  }
}
extension _CScooterInstructionCrossroadManeuverRelease on _CScooterInstructionCrossroadManeuver {
  void _releaseIntermediate() {
  }
}

// MARK: - List<InstructionRouteEntry> <-> _CArray_CInstructionRouteEntry

final class _CArray_CInstructionRouteEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CInstructionRouteEntryToDart on _CArray_CInstructionRouteEntry {
  List<InstructionRouteEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CInstructionRouteEntry on List<InstructionRouteEntry> {
  _CArray_CInstructionRouteEntry _copyFromDartTo_CArray_CInstructionRouteEntry() {
    final cArray = _CArray_CInstructionRouteEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CInstructionRouteEntry();
        _CArray_CInstructionRouteEntryaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CInstructionRouteEntryBasicFunctions on _CArray_CInstructionRouteEntry {
  void _releaseIntermediate() {
    _CArray_CInstructionRouteEntry_release(this);
  }

  static final _listToFill = <InstructionRouteEntry>[];

  static void _iterate(_CInstructionRouteEntry item) {
    _listToFill.add(item._toDart());
  }

  List<InstructionRouteEntry> _fillFromC() {
    _forEach_CArray_CInstructionRouteEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CInstructionRouteEntry)>(_iterate));
    final result = List<InstructionRouteEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - DoubleRouteAttribute

/**
 Контейнер, который описывает точечный атрибут маршрута.
 Каждый элемент хранится в виде точки на маршруте, в которой этот элемент расположен и значения самого элемента.
*/
class DoubleRouteAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CDoubleRouteAttribute_size(_CDoubleRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CDoubleRouteAttribute_isEmpty(_CDoubleRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  DoubleRouteEntry? get first {
    _COptional_CDoubleRouteEntry res = _CDoubleRouteAttribute_first(_CDoubleRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  DoubleRouteEntry? get last {
    _COptional_CDoubleRouteEntry res = _CDoubleRouteAttribute_last(_CDoubleRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<DoubleRouteEntry> get entries {
    _CArray_CDoubleRouteEntry res = _CDoubleRouteAttribute_entries(_CDoubleRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CDoubleRouteAttribute_releasePtr);

  DoubleRouteAttribute._raw(this._self);
  factory DoubleRouteAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DoubleRouteAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DoubleRouteAttribute &&
    other.runtimeType == runtimeType &&
    _CDoubleRouteAttribute_cg_objectIdentifier(this._self) == _CDoubleRouteAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDoubleRouteAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: DoubleRouteAttribute: Methods

  /**
   Элементы, попадающие в отрезок [begin, end).
  
   - Throws: Exception если begin > end.
  */
  List<DoubleRouteEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CDoubleRouteEntry res = _CDoubleRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CDoubleRouteAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого
   <
   = point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  DoubleRouteEntry? findNearBackward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CDoubleRouteEntry res = _CDoubleRouteAttribute_findNearBackward_CRoutePoint(_CDoubleRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Найти ближайший элемент, позиция которого >= point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  DoubleRouteEntry? findNearForward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CDoubleRouteEntry res = _CDoubleRouteAttribute_findNearForward_CRoutePoint(_CDoubleRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

}

// MARK: - DoubleRouteAttribute <-> CDoubleRouteAttribute

final class _CDoubleRouteAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDoubleRouteAttributeBasicFunctions on _CDoubleRouteAttribute {
  void _releaseIntermediate() {
    _CDoubleRouteAttribute_release(_impl);
  }

  _CDoubleRouteAttribute _retain() {
    return _CDoubleRouteAttribute_retain(_impl);
  }
}

extension _CDoubleRouteAttributeToDart on _CDoubleRouteAttribute {
  DoubleRouteAttribute _toDart() {
    return DoubleRouteAttribute._create(_retain()._impl);
  }
}


extension _DartToCDoubleRouteAttribute on DoubleRouteAttribute {
  _CDoubleRouteAttribute _copyFromDartTo_CDoubleRouteAttribute() {
    return (_CDoubleRouteAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DoubleRouteEntry

/** Элемент маршрута - точка и значение в ней. */
class DoubleRouteEntry {
  final RoutePoint point;
  final double value;

  const DoubleRouteEntry({
    required this.point,
    required this.value
  });

  DoubleRouteEntry copyWith({
    RoutePoint? point,
    double? value
  }) {
    return DoubleRouteEntry(
      point: point ?? this.point,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DoubleRouteEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, value);
  }

}
final class _CDoubleRouteEntry extends ffi.Struct {
  external _CRoutePoint point;

  @ffi.Double()
  external double value;

}
// MARK: - DoubleRouteEntry <-> _CDoubleRouteEntry

extension _CDoubleRouteEntryToDart on _CDoubleRouteEntry {
  DoubleRouteEntry _toDart() {
    return DoubleRouteEntry(
      point: this.point._toDart(),
      value: this.value
    );
  }
}

extension _DartTo_CDoubleRouteEntry on DoubleRouteEntry {
  _CDoubleRouteEntry _copyFromDartTo_CDoubleRouteEntry() {
    final res = _CDoubleRouteEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.value = this.value;
    return res;
  }
}
extension _CDoubleRouteEntryRelease on _CDoubleRouteEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - DoubleRouteEntry? <-> _COptional_CDoubleRouteEntry

final class _COptional_CDoubleRouteEntry extends ffi.Struct {
  
  external _CDoubleRouteEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CDoubleRouteEntryBasicFunctions on _COptional_CDoubleRouteEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CDoubleRouteEntryToDart on _COptional_CDoubleRouteEntry {
  DoubleRouteEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CDoubleRouteEntry on DoubleRouteEntry? {
  _COptional_CDoubleRouteEntry _copyFromDartTo_COptional_CDoubleRouteEntry() {
    final cOptional = _COptional_CDoubleRouteEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CDoubleRouteEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<DoubleRouteEntry> <-> _CArray_CDoubleRouteEntry

final class _CArray_CDoubleRouteEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CDoubleRouteEntryToDart on _CArray_CDoubleRouteEntry {
  List<DoubleRouteEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CDoubleRouteEntry on List<DoubleRouteEntry> {
  _CArray_CDoubleRouteEntry _copyFromDartTo_CArray_CDoubleRouteEntry() {
    final cArray = _CArray_CDoubleRouteEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CDoubleRouteEntry();
        _CArray_CDoubleRouteEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CDoubleRouteEntryBasicFunctions on _CArray_CDoubleRouteEntry {
  void _releaseIntermediate() {
    _CArray_CDoubleRouteEntry_release(this);
  }

  static final _listToFill = <DoubleRouteEntry>[];

  static void _iterate(_CDoubleRouteEntry item) {
    _listToFill.add(item._toDart());
  }

  List<DoubleRouteEntry> _fillFromC() {
    _forEach_CArray_CDoubleRouteEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CDoubleRouteEntry)>(_iterate));
    final result = List<DoubleRouteEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - BoolRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class BoolRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CBoolRouteLongAttribute_size(_CBoolRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CBoolRouteLongAttribute_isEmpty(_CBoolRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  BoolRouteLongEntry? get first {
    _COptional_CBoolRouteLongEntry res = _CBoolRouteLongAttribute_first(_CBoolRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  BoolRouteLongEntry? get last {
    _COptional_CBoolRouteLongEntry res = _CBoolRouteLongAttribute_last(_CBoolRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<BoolRouteLongEntry> get entries {
    _CArray_CBoolRouteLongEntry res = _CBoolRouteLongAttribute_entries(_CBoolRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CBoolRouteLongAttribute_releasePtr);

  BoolRouteLongAttribute._raw(this._self);
  factory BoolRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = BoolRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BoolRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CBoolRouteLongAttribute_cg_objectIdentifier(this._self) == _CBoolRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CBoolRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: BoolRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  BoolRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CBoolRouteLongEntry res = _CBoolRouteLongAttribute_entry_CRoutePoint(_CBoolRouteLongAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<BoolRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CBoolRouteLongEntry res = _CBoolRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CBoolRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - BoolRouteLongAttribute <-> CBoolRouteLongAttribute

final class _CBoolRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CBoolRouteLongAttributeBasicFunctions on _CBoolRouteLongAttribute {
  void _releaseIntermediate() {
    _CBoolRouteLongAttribute_release(_impl);
  }

  _CBoolRouteLongAttribute _retain() {
    return _CBoolRouteLongAttribute_retain(_impl);
  }
}

extension _CBoolRouteLongAttributeToDart on _CBoolRouteLongAttribute {
  BoolRouteLongAttribute _toDart() {
    return BoolRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCBoolRouteLongAttribute on BoolRouteLongAttribute {
  _CBoolRouteLongAttribute _copyFromDartTo_CBoolRouteLongAttribute() {
    return (_CBoolRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - BoolRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class BoolRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final bool value;

  const BoolRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  BoolRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    bool? value
  }) {
    return BoolRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BoolRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CBoolRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  @ffi.Bool()
  external bool value;

}
// MARK: - BoolRouteLongEntry <-> _CBoolRouteLongEntry

extension _CBoolRouteLongEntryToDart on _CBoolRouteLongEntry {
  BoolRouteLongEntry _toDart() {
    return BoolRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value
    );
  }
}

extension _DartTo_CBoolRouteLongEntry on BoolRouteLongEntry {
  _CBoolRouteLongEntry _copyFromDartTo_CBoolRouteLongEntry() {
    final res = _CBoolRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value;
    return res;
  }
}
extension _CBoolRouteLongEntryRelease on _CBoolRouteLongEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - BoolRouteLongEntry? <-> _COptional_CBoolRouteLongEntry

final class _COptional_CBoolRouteLongEntry extends ffi.Struct {
  
  external _CBoolRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CBoolRouteLongEntryBasicFunctions on _COptional_CBoolRouteLongEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CBoolRouteLongEntryToDart on _COptional_CBoolRouteLongEntry {
  BoolRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CBoolRouteLongEntry on BoolRouteLongEntry? {
  _COptional_CBoolRouteLongEntry _copyFromDartTo_COptional_CBoolRouteLongEntry() {
    final cOptional = _COptional_CBoolRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CBoolRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<BoolRouteLongEntry> <-> _CArray_CBoolRouteLongEntry

final class _CArray_CBoolRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CBoolRouteLongEntryToDart on _CArray_CBoolRouteLongEntry {
  List<BoolRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CBoolRouteLongEntry on List<BoolRouteLongEntry> {
  _CArray_CBoolRouteLongEntry _copyFromDartTo_CArray_CBoolRouteLongEntry() {
    final cArray = _CArray_CBoolRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CBoolRouteLongEntry();
        _CArray_CBoolRouteLongEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CBoolRouteLongEntryBasicFunctions on _CArray_CBoolRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CBoolRouteLongEntry_release(this);
  }

  static final _listToFill = <BoolRouteLongEntry>[];

  static void _iterate(_CBoolRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<BoolRouteLongEntry> _fillFromC() {
    _forEach_CArray_CBoolRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CBoolRouteLongEntry)>(_iterate));
    final result = List<BoolRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - ObstacleInfoRouteAttribute

/**
 Контейнер, который описывает точечный атрибут маршрута.
 Каждый элемент хранится в виде точки на маршруте, в которой этот элемент расположен и значения самого элемента.
*/
class ObstacleInfoRouteAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CObstacleInfoRouteAttribute_size(_CObstacleInfoRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CObstacleInfoRouteAttribute_isEmpty(_CObstacleInfoRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  ObstacleInfoRouteEntry? get first {
    _COptional_CObstacleInfoRouteEntry res = _CObstacleInfoRouteAttribute_first(_CObstacleInfoRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  ObstacleInfoRouteEntry? get last {
    _COptional_CObstacleInfoRouteEntry res = _CObstacleInfoRouteAttribute_last(_CObstacleInfoRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<ObstacleInfoRouteEntry> get entries {
    _CArray_CObstacleInfoRouteEntry res = _CObstacleInfoRouteAttribute_entries(_CObstacleInfoRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CObstacleInfoRouteAttribute_releasePtr);

  ObstacleInfoRouteAttribute._raw(this._self);
  factory ObstacleInfoRouteAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ObstacleInfoRouteAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ObstacleInfoRouteAttribute &&
    other.runtimeType == runtimeType &&
    _CObstacleInfoRouteAttribute_cg_objectIdentifier(this._self) == _CObstacleInfoRouteAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CObstacleInfoRouteAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: ObstacleInfoRouteAttribute: Methods

  /**
   Элементы, попадающие в отрезок [begin, end).
  
   - Throws: Exception если begin > end.
  */
  List<ObstacleInfoRouteEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CObstacleInfoRouteEntry res = _CObstacleInfoRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CObstacleInfoRouteAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого
   <
   = point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  ObstacleInfoRouteEntry? findNearBackward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CObstacleInfoRouteEntry res = _CObstacleInfoRouteAttribute_findNearBackward_CRoutePoint(_CObstacleInfoRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Найти ближайший элемент, позиция которого >= point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  ObstacleInfoRouteEntry? findNearForward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CObstacleInfoRouteEntry res = _CObstacleInfoRouteAttribute_findNearForward_CRoutePoint(_CObstacleInfoRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

}

// MARK: - ObstacleInfoRouteAttribute <-> CObstacleInfoRouteAttribute

final class _CObstacleInfoRouteAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CObstacleInfoRouteAttributeBasicFunctions on _CObstacleInfoRouteAttribute {
  void _releaseIntermediate() {
    _CObstacleInfoRouteAttribute_release(_impl);
  }

  _CObstacleInfoRouteAttribute _retain() {
    return _CObstacleInfoRouteAttribute_retain(_impl);
  }
}

extension _CObstacleInfoRouteAttributeToDart on _CObstacleInfoRouteAttribute {
  ObstacleInfoRouteAttribute _toDart() {
    return ObstacleInfoRouteAttribute._create(_retain()._impl);
  }
}


extension _DartToCObstacleInfoRouteAttribute on ObstacleInfoRouteAttribute {
  _CObstacleInfoRouteAttribute _copyFromDartTo_CObstacleInfoRouteAttribute() {
    return (_CObstacleInfoRouteAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Obstacle

/** Тип препятствия. */
enum Obstacle {
  /** Другое. */
  other(0),
  /** Шлагбаум. */
  barrier(1),
  /** Ворота. */
  gate(2),
  /** Турникет. */
  tourniquet(3),
  /** Калитка. */
  wicket(4),
  ;

  const Obstacle(this.rawValue);
  final int rawValue;

  static Obstacle getByValue(int value) {
    return Obstacle.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CObstacle extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CObstacleBasicFunctions on _CObstacle {
  void _releaseIntermediate() {
  }
}

extension _CObstacleToDart on _CObstacle {
  Obstacle _toDart() {
    return Obstacle.getByValue(this.rawValue);
  }
}

extension _DartTo_CObstacle on Obstacle {
  _CObstacle _copyFromDartTo_CObstacle() {
    return _CObstacleMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ObstaclePassLimitation

/** Ограничения по преодолению препятствия. */
enum ObstaclePassLimitation {
  /** Препятствие без ограничений. */
  unlimited(0),
  /** Проход/проезд через препятствие платный. */
  paid(1),
  /** Для прохода/проезда через препятствие требуется пропуск. */
  passRequired(2),
  ;

  const ObstaclePassLimitation(this.rawValue);
  final int rawValue;

  static ObstaclePassLimitation getByValue(int value) {
    return ObstaclePassLimitation.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CObstaclePassLimitation extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CObstaclePassLimitationBasicFunctions on _CObstaclePassLimitation {
  void _releaseIntermediate() {
  }
}

extension _CObstaclePassLimitationToDart on _CObstaclePassLimitation {
  ObstaclePassLimitation _toDart() {
    return ObstaclePassLimitation.getByValue(this.rawValue);
  }
}

extension _DartTo_CObstaclePassLimitation on ObstaclePassLimitation {
  _CObstaclePassLimitation _copyFromDartTo_CObstaclePassLimitation() {
    return _CObstaclePassLimitationMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ObstacleInfo

/** Информация о препятствии на маршруте. */
class ObstacleInfo {
  final Obstacle type;
  final ObstaclePassLimitation limitation;

  const ObstacleInfo({
    this.type = Obstacle.other,
    this.limitation = ObstaclePassLimitation.unlimited
  });

  ObstacleInfo copyWith({
    Obstacle? type,
    ObstaclePassLimitation? limitation
  }) {
    return ObstacleInfo(
      type: type ?? this.type,
      limitation: limitation ?? this.limitation
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ObstacleInfo &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.limitation == limitation;

  @override
  int get hashCode {
    return Object.hash(type, limitation);
  }

}
final class _CObstacleInfo extends ffi.Struct {
  external _CObstacle type;

  external _CObstaclePassLimitation limitation;

}
// MARK: - ObstacleInfo <-> _CObstacleInfo

extension _CObstacleInfoToDart on _CObstacleInfo {
  ObstacleInfo _toDart() {
    return ObstacleInfo(
      type: this.type._toDart(),
      limitation: this.limitation._toDart()
    );
  }
}

extension _DartTo_CObstacleInfo on ObstacleInfo {
  _CObstacleInfo _copyFromDartTo_CObstacleInfo() {
    final res = _CObstacleInfoMakeDefault();
    res.type = this.type._copyFromDartTo_CObstacle();
    res.limitation = this.limitation._copyFromDartTo_CObstaclePassLimitation();
    return res;
  }
}
extension _CObstacleInfoRelease on _CObstacleInfo {
  void _releaseIntermediate() {
  }
}

// MARK: - ObstacleInfoRouteEntry

/** Элемент маршрута - точка и значение в ней. */
class ObstacleInfoRouteEntry {
  final RoutePoint point;
  final ObstacleInfo value;

  const ObstacleInfoRouteEntry({
    required this.point,
    required this.value
  });

  ObstacleInfoRouteEntry copyWith({
    RoutePoint? point,
    ObstacleInfo? value
  }) {
    return ObstacleInfoRouteEntry(
      point: point ?? this.point,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ObstacleInfoRouteEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, value);
  }

}
final class _CObstacleInfoRouteEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CObstacleInfo value;

}
// MARK: - ObstacleInfoRouteEntry <-> _CObstacleInfoRouteEntry

extension _CObstacleInfoRouteEntryToDart on _CObstacleInfoRouteEntry {
  ObstacleInfoRouteEntry _toDart() {
    return ObstacleInfoRouteEntry(
      point: this.point._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CObstacleInfoRouteEntry on ObstacleInfoRouteEntry {
  _CObstacleInfoRouteEntry _copyFromDartTo_CObstacleInfoRouteEntry() {
    final res = _CObstacleInfoRouteEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.value = this.value._copyFromDartTo_CObstacleInfo();
    return res;
  }
}
extension _CObstacleInfoRouteEntryRelease on _CObstacleInfoRouteEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - ObstacleInfoRouteEntry? <-> _COptional_CObstacleInfoRouteEntry

final class _COptional_CObstacleInfoRouteEntry extends ffi.Struct {
  
  external _CObstacleInfoRouteEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CObstacleInfoRouteEntryBasicFunctions on _COptional_CObstacleInfoRouteEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CObstacleInfoRouteEntryToDart on _COptional_CObstacleInfoRouteEntry {
  ObstacleInfoRouteEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CObstacleInfoRouteEntry on ObstacleInfoRouteEntry? {
  _COptional_CObstacleInfoRouteEntry _copyFromDartTo_COptional_CObstacleInfoRouteEntry() {
    final cOptional = _COptional_CObstacleInfoRouteEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CObstacleInfoRouteEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<ObstacleInfoRouteEntry> <-> _CArray_CObstacleInfoRouteEntry

final class _CArray_CObstacleInfoRouteEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CObstacleInfoRouteEntryToDart on _CArray_CObstacleInfoRouteEntry {
  List<ObstacleInfoRouteEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CObstacleInfoRouteEntry on List<ObstacleInfoRouteEntry> {
  _CArray_CObstacleInfoRouteEntry _copyFromDartTo_CArray_CObstacleInfoRouteEntry() {
    final cArray = _CArray_CObstacleInfoRouteEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CObstacleInfoRouteEntry();
        _CArray_CObstacleInfoRouteEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CObstacleInfoRouteEntryBasicFunctions on _CArray_CObstacleInfoRouteEntry {
  void _releaseIntermediate() {
    _CArray_CObstacleInfoRouteEntry_release(this);
  }

  static final _listToFill = <ObstacleInfoRouteEntry>[];

  static void _iterate(_CObstacleInfoRouteEntry item) {
    _listToFill.add(item._toDart());
  }

  List<ObstacleInfoRouteEntry> _fillFromC() {
    _forEach_CArray_CObstacleInfoRouteEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CObstacleInfoRouteEntry)>(_iterate));
    final result = List<ObstacleInfoRouteEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - StringRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class StringRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CStringRouteLongAttribute_size(_CStringRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CStringRouteLongAttribute_isEmpty(_CStringRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  StringRouteLongEntry? get first {
    _COptional_CStringRouteLongEntry res = _CStringRouteLongAttribute_first(_CStringRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Последний элемент. */
  StringRouteLongEntry? get last {
    _COptional_CStringRouteLongEntry res = _CStringRouteLongAttribute_last(_CStringRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Все элементы. */
  List<StringRouteLongEntry> get entries {
    _CArray_CStringRouteLongEntry res = _CStringRouteLongAttribute_entries(_CStringRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CStringRouteLongAttribute_releasePtr);

  StringRouteLongAttribute._raw(this._self);
  factory StringRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = StringRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is StringRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CStringRouteLongAttribute_cg_objectIdentifier(this._self) == _CStringRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CStringRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: StringRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  StringRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CStringRouteLongEntry res = _CStringRouteLongAttribute_entry_CRoutePoint(_CStringRouteLongAttributeMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<StringRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CStringRouteLongEntry res = _CStringRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CStringRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - StringRouteLongAttribute <-> CStringRouteLongAttribute

final class _CStringRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStringRouteLongAttributeBasicFunctions on _CStringRouteLongAttribute {
  void _releaseIntermediate() {
    _CStringRouteLongAttribute_release(_impl);
  }

  _CStringRouteLongAttribute _retain() {
    return _CStringRouteLongAttribute_retain(_impl);
  }
}

extension _CStringRouteLongAttributeToDart on _CStringRouteLongAttribute {
  StringRouteLongAttribute _toDart() {
    return StringRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCStringRouteLongAttribute on StringRouteLongAttribute {
  _CStringRouteLongAttribute _copyFromDartTo_CStringRouteLongAttribute() {
    return (_CStringRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StringRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class StringRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final String value;

  const StringRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  StringRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    String? value
  }) {
    return StringRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is StringRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CStringRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CString value;

}
// MARK: - StringRouteLongEntry <-> _CStringRouteLongEntry

extension _CStringRouteLongEntryToDart on _CStringRouteLongEntry {
  StringRouteLongEntry _toDart() {
    return StringRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CStringRouteLongEntry on StringRouteLongEntry {
  _CStringRouteLongEntry _copyFromDartTo_CStringRouteLongEntry() {
    final res = _CStringRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CString();
    return res;
  }
}
extension _CStringRouteLongEntryRelease on _CStringRouteLongEntry {
  void _releaseIntermediate() {
    value._releaseIntermediate();
  }
}

// MARK: - StringRouteLongEntry? <-> _COptional_CStringRouteLongEntry

final class _COptional_CStringRouteLongEntry extends ffi.Struct {
  
  external _CStringRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CStringRouteLongEntryBasicFunctions on _COptional_CStringRouteLongEntry {
  void _releaseIntermediate() {
    _COptional_CStringRouteLongEntry_release(this);
  }
}

extension _COptional_CStringRouteLongEntryToDart on _COptional_CStringRouteLongEntry {
  StringRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CStringRouteLongEntry on StringRouteLongEntry? {
  _COptional_CStringRouteLongEntry _copyFromDartTo_COptional_CStringRouteLongEntry() {
    final cOptional = _COptional_CStringRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CStringRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<StringRouteLongEntry> <-> _CArray_CStringRouteLongEntry

final class _CArray_CStringRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CStringRouteLongEntryToDart on _CArray_CStringRouteLongEntry {
  List<StringRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CStringRouteLongEntry on List<StringRouteLongEntry> {
  _CArray_CStringRouteLongEntry _copyFromDartTo_CArray_CStringRouteLongEntry() {
    final cArray = _CArray_CStringRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CStringRouteLongEntry();
        _CArray_CStringRouteLongEntryaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CStringRouteLongEntryBasicFunctions on _CArray_CStringRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CStringRouteLongEntry_release(this);
  }

  static final _listToFill = <StringRouteLongEntry>[];

  static void _iterate(_CStringRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<StringRouteLongEntry> _fillFromC() {
    _forEach_CArray_CStringRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CStringRouteLongEntry)>(_iterate));
    final result = List<StringRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - SettlementRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class SettlementRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CSettlementRouteLongAttribute_size(_CSettlementRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CSettlementRouteLongAttribute_isEmpty(_CSettlementRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  SettlementRouteLongEntry? get first {
    _COptional_CSettlementRouteLongEntry res = _CSettlementRouteLongAttribute_first(_CSettlementRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  SettlementRouteLongEntry? get last {
    _COptional_CSettlementRouteLongEntry res = _CSettlementRouteLongAttribute_last(_CSettlementRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<SettlementRouteLongEntry> get entries {
    _CArray_CSettlementRouteLongEntry res = _CSettlementRouteLongAttribute_entries(_CSettlementRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSettlementRouteLongAttribute_releasePtr);

  SettlementRouteLongAttribute._raw(this._self);
  factory SettlementRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SettlementRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SettlementRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CSettlementRouteLongAttribute_cg_objectIdentifier(this._self) == _CSettlementRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSettlementRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: SettlementRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  SettlementRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CSettlementRouteLongEntry res = _CSettlementRouteLongAttribute_entry_CRoutePoint(_CSettlementRouteLongAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<SettlementRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CSettlementRouteLongEntry res = _CSettlementRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CSettlementRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - SettlementRouteLongAttribute <-> CSettlementRouteLongAttribute

final class _CSettlementRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSettlementRouteLongAttributeBasicFunctions on _CSettlementRouteLongAttribute {
  void _releaseIntermediate() {
    _CSettlementRouteLongAttribute_release(_impl);
  }

  _CSettlementRouteLongAttribute _retain() {
    return _CSettlementRouteLongAttribute_retain(_impl);
  }
}

extension _CSettlementRouteLongAttributeToDart on _CSettlementRouteLongAttribute {
  SettlementRouteLongAttribute _toDart() {
    return SettlementRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCSettlementRouteLongAttribute on SettlementRouteLongAttribute {
  _CSettlementRouteLongAttribute _copyFromDartTo_CSettlementRouteLongAttribute() {
    return (_CSettlementRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Settlement

/** Признак прохождения участка дороги через населённый пункт. */
enum Settlement {
  /** Информация о населённом пункте неизвестна. */
  unknown(0),
  /** Внутри населённого пункта. */
  inside(1),
  /** За пределами населённого пункта. */
  outside(2),
  ;

  const Settlement(this.rawValue);
  final int rawValue;

  static Settlement getByValue(int value) {
    return Settlement.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSettlement extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSettlementBasicFunctions on _CSettlement {
  void _releaseIntermediate() {
  }
}

extension _CSettlementToDart on _CSettlement {
  Settlement _toDart() {
    return Settlement.getByValue(this.rawValue);
  }
}

extension _DartTo_CSettlement on Settlement {
  _CSettlement _copyFromDartTo_CSettlement() {
    return _CSettlementMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SettlementRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class SettlementRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final Settlement value;

  const SettlementRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  SettlementRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    Settlement? value
  }) {
    return SettlementRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SettlementRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CSettlementRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CSettlement value;

}
// MARK: - SettlementRouteLongEntry <-> _CSettlementRouteLongEntry

extension _CSettlementRouteLongEntryToDart on _CSettlementRouteLongEntry {
  SettlementRouteLongEntry _toDart() {
    return SettlementRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CSettlementRouteLongEntry on SettlementRouteLongEntry {
  _CSettlementRouteLongEntry _copyFromDartTo_CSettlementRouteLongEntry() {
    final res = _CSettlementRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CSettlement();
    return res;
  }
}
extension _CSettlementRouteLongEntryRelease on _CSettlementRouteLongEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - SettlementRouteLongEntry? <-> _COptional_CSettlementRouteLongEntry

final class _COptional_CSettlementRouteLongEntry extends ffi.Struct {
  
  external _CSettlementRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CSettlementRouteLongEntryBasicFunctions on _COptional_CSettlementRouteLongEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CSettlementRouteLongEntryToDart on _COptional_CSettlementRouteLongEntry {
  SettlementRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CSettlementRouteLongEntry on SettlementRouteLongEntry? {
  _COptional_CSettlementRouteLongEntry _copyFromDartTo_COptional_CSettlementRouteLongEntry() {
    final cOptional = _COptional_CSettlementRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CSettlementRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<SettlementRouteLongEntry> <-> _CArray_CSettlementRouteLongEntry

final class _CArray_CSettlementRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSettlementRouteLongEntryToDart on _CArray_CSettlementRouteLongEntry {
  List<SettlementRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSettlementRouteLongEntry on List<SettlementRouteLongEntry> {
  _CArray_CSettlementRouteLongEntry _copyFromDartTo_CArray_CSettlementRouteLongEntry() {
    final cArray = _CArray_CSettlementRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSettlementRouteLongEntry();
        _CArray_CSettlementRouteLongEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CSettlementRouteLongEntryBasicFunctions on _CArray_CSettlementRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CSettlementRouteLongEntry_release(this);
  }

  static final _listToFill = <SettlementRouteLongEntry>[];

  static void _iterate(_CSettlementRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<SettlementRouteLongEntry> _fillFromC() {
    _forEach_CArray_CSettlementRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSettlementRouteLongEntry)>(_iterate));
    final result = List<SettlementRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - TransportTypeRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class TransportTypeRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CTransportTypeRouteLongAttribute_size(_CTransportTypeRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CTransportTypeRouteLongAttribute_isEmpty(_CTransportTypeRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  TransportTypeRouteLongEntry? get first {
    _COptional_CTransportTypeRouteLongEntry res = _CTransportTypeRouteLongAttribute_first(_CTransportTypeRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  TransportTypeRouteLongEntry? get last {
    _COptional_CTransportTypeRouteLongEntry res = _CTransportTypeRouteLongAttribute_last(_CTransportTypeRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<TransportTypeRouteLongEntry> get entries {
    _CArray_CTransportTypeRouteLongEntry res = _CTransportTypeRouteLongAttribute_entries(_CTransportTypeRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CTransportTypeRouteLongAttribute_releasePtr);

  TransportTypeRouteLongAttribute._raw(this._self);
  factory TransportTypeRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TransportTypeRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TransportTypeRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CTransportTypeRouteLongAttribute_cg_objectIdentifier(this._self) == _CTransportTypeRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTransportTypeRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: TransportTypeRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  TransportTypeRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CTransportTypeRouteLongEntry res = _CTransportTypeRouteLongAttribute_entry_CRoutePoint(_CTransportTypeRouteLongAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<TransportTypeRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CTransportTypeRouteLongEntry res = _CTransportTypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CTransportTypeRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - TransportTypeRouteLongAttribute <-> CTransportTypeRouteLongAttribute

final class _CTransportTypeRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTransportTypeRouteLongAttributeBasicFunctions on _CTransportTypeRouteLongAttribute {
  void _releaseIntermediate() {
    _CTransportTypeRouteLongAttribute_release(_impl);
  }

  _CTransportTypeRouteLongAttribute _retain() {
    return _CTransportTypeRouteLongAttribute_retain(_impl);
  }
}

extension _CTransportTypeRouteLongAttributeToDart on _CTransportTypeRouteLongAttribute {
  TransportTypeRouteLongAttribute _toDart() {
    return TransportTypeRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCTransportTypeRouteLongAttribute on TransportTypeRouteLongAttribute {
  _CTransportTypeRouteLongAttribute _copyFromDartTo_CTransportTypeRouteLongAttribute() {
    return (_CTransportTypeRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - TransportType

/** Описывает вид транспорта, для которого построен участок маршрута. */
enum TransportType {
  /** Неизвестно, как преодолеть данный участок маршрута, или он может быть непроходим. */
  unknown(0),
  /** Велосипед. */
  bicycle(1),
  /** Автомобиль. */
  car(2),
  /** Пешеход. */
  pedestrian(3),
  /** Общественный транспорт. */
  public(4),
  /** Самокат. */
  scooter(5),
  ;

  const TransportType(this.rawValue);
  final int rawValue;

  static TransportType getByValue(int value) {
    return TransportType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CTransportType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CTransportTypeBasicFunctions on _CTransportType {
  void _releaseIntermediate() {
  }
}

extension _CTransportTypeToDart on _CTransportType {
  TransportType _toDart() {
    return TransportType.getByValue(this.rawValue);
  }
}

extension _DartTo_CTransportType on TransportType {
  _CTransportType _copyFromDartTo_CTransportType() {
    return _CTransportTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - TransportTypeRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class TransportTypeRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final TransportType value;

  const TransportTypeRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  TransportTypeRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    TransportType? value
  }) {
    return TransportTypeRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TransportTypeRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CTransportTypeRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CTransportType value;

}
// MARK: - TransportTypeRouteLongEntry <-> _CTransportTypeRouteLongEntry

extension _CTransportTypeRouteLongEntryToDart on _CTransportTypeRouteLongEntry {
  TransportTypeRouteLongEntry _toDart() {
    return TransportTypeRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CTransportTypeRouteLongEntry on TransportTypeRouteLongEntry {
  _CTransportTypeRouteLongEntry _copyFromDartTo_CTransportTypeRouteLongEntry() {
    final res = _CTransportTypeRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CTransportType();
    return res;
  }
}
extension _CTransportTypeRouteLongEntryRelease on _CTransportTypeRouteLongEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - TransportTypeRouteLongEntry? <-> _COptional_CTransportTypeRouteLongEntry

final class _COptional_CTransportTypeRouteLongEntry extends ffi.Struct {
  
  external _CTransportTypeRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CTransportTypeRouteLongEntryBasicFunctions on _COptional_CTransportTypeRouteLongEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CTransportTypeRouteLongEntryToDart on _COptional_CTransportTypeRouteLongEntry {
  TransportTypeRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CTransportTypeRouteLongEntry on TransportTypeRouteLongEntry? {
  _COptional_CTransportTypeRouteLongEntry _copyFromDartTo_COptional_CTransportTypeRouteLongEntry() {
    final cOptional = _COptional_CTransportTypeRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CTransportTypeRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<TransportTypeRouteLongEntry> <-> _CArray_CTransportTypeRouteLongEntry

final class _CArray_CTransportTypeRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CTransportTypeRouteLongEntryToDart on _CArray_CTransportTypeRouteLongEntry {
  List<TransportTypeRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CTransportTypeRouteLongEntry on List<TransportTypeRouteLongEntry> {
  _CArray_CTransportTypeRouteLongEntry _copyFromDartTo_CArray_CTransportTypeRouteLongEntry() {
    final cArray = _CArray_CTransportTypeRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CTransportTypeRouteLongEntry();
        _CArray_CTransportTypeRouteLongEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CTransportTypeRouteLongEntryBasicFunctions on _CArray_CTransportTypeRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CTransportTypeRouteLongEntry_release(this);
  }

  static final _listToFill = <TransportTypeRouteLongEntry>[];

  static void _iterate(_CTransportTypeRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<TransportTypeRouteLongEntry> _fillFromC() {
    _forEach_CArray_CTransportTypeRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CTransportTypeRouteLongEntry)>(_iterate));
    final result = List<TransportTypeRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - CameraRouteAttribute

/**
 Контейнер, который описывает точечный атрибут маршрута.
 Каждый элемент хранится в виде точки на маршруте, в которой этот элемент расположен и значения самого элемента.
*/
class CameraRouteAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CCameraRouteAttribute_size(_CCameraRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CCameraRouteAttribute_isEmpty(_CCameraRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  CameraRouteEntry? get first {
    _COptional_CCameraRouteEntry res = _CCameraRouteAttribute_first(_CCameraRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  CameraRouteEntry? get last {
    _COptional_CCameraRouteEntry res = _CCameraRouteAttribute_last(_CCameraRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<CameraRouteEntry> get entries {
    _CArray_CCameraRouteEntry res = _CCameraRouteAttribute_entries(_CCameraRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CCameraRouteAttribute_releasePtr);

  CameraRouteAttribute._raw(this._self);
  factory CameraRouteAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CameraRouteAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraRouteAttribute &&
    other.runtimeType == runtimeType &&
    _CCameraRouteAttribute_cg_objectIdentifier(this._self) == _CCameraRouteAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCameraRouteAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CameraRouteAttribute: Methods

  /**
   Элементы, попадающие в отрезок [begin, end).
  
   - Throws: Exception если begin > end.
  */
  List<CameraRouteEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CCameraRouteEntry res = _CCameraRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CCameraRouteAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого
   <
   = point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  CameraRouteEntry? findNearBackward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CCameraRouteEntry res = _CCameraRouteAttribute_findNearBackward_CRoutePoint(_CCameraRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Найти ближайший элемент, позиция которого >= point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  CameraRouteEntry? findNearForward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CCameraRouteEntry res = _CCameraRouteAttribute_findNearForward_CRoutePoint(_CCameraRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

}

// MARK: - CameraRouteAttribute <-> CCameraRouteAttribute

final class _CCameraRouteAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCameraRouteAttributeBasicFunctions on _CCameraRouteAttribute {
  void _releaseIntermediate() {
    _CCameraRouteAttribute_release(_impl);
  }

  _CCameraRouteAttribute _retain() {
    return _CCameraRouteAttribute_retain(_impl);
  }
}

extension _CCameraRouteAttributeToDart on _CCameraRouteAttribute {
  CameraRouteAttribute _toDart() {
    return CameraRouteAttribute._create(_retain()._impl);
  }
}


extension _DartToCCameraRouteAttribute on CameraRouteAttribute {
  _CCameraRouteAttribute _copyFromDartTo_CCameraRouteAttribute() {
    return (_CCameraRouteAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RouteCameraPurpose

/** Назначение камеры. */
enum RouteCameraPurpose {
  /** Фиксация превышения скорости. */
  speedControl(1),
  /** Фиксация проезда на запрещающий сигнал светофора. */
  trafficLightsControl(2),
  /** Фиксация выезда за стоп-линию, проезда без остановки знака "Стоп", выезда на перекрёсток во время затора. */
  stopLineControl(4),
  /** Фиксация движения по выделенной полосе для общественного транспорта. */
  publicTransportLaneControl(8),
  /** Фиксация движения по встречной полосе. */
  oncomingTrafficLaneControl(16),
  /** Фиксация непредоставления преимущества пешеходам. */
  pedestrianAdvantageControl(32),
  /** Фиксация нарушения рядности поворота на перекрёстке. */
  laneDisciplineControl(64),
  /** Фиксация пересечения сплошной линии разметки, движения по обочине. */
  roadMarkingsCrossingControl(128),
  /** Фиксация превышения средней скорости на участке. */
  averageSpeedControl(256),
  /** Фиксация нарушения запрета остановки. */
  noStoppingControl(512),
  /** Муляж. */
  dummy(1024),
  /** Камера системы "Платон": https://platon.ru/ru/about/ */
  platon(2048),
  ;

  const RouteCameraPurpose(this.rawValue);
  final int rawValue;

  static RouteCameraPurpose getByValue(int value) {
    return RouteCameraPurpose.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouteCameraPurpose extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouteCameraPurposeBasicFunctions on _CRouteCameraPurpose {
  void _releaseIntermediate() {
  }
}

extension _CRouteCameraPurposeToDart on _CRouteCameraPurpose {
  RouteCameraPurpose _toDart() {
    return RouteCameraPurpose.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouteCameraPurpose on RouteCameraPurpose {
  _CRouteCameraPurpose _copyFromDartTo_CRouteCameraPurpose() {
    return _CRouteCameraPurposeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RouteCameraPurposeEnumSet

class RouteCameraPurposeEnumSet extends EnumSet<RouteCameraPurpose> {
  RouteCameraPurposeEnumSet() : super();

  factory RouteCameraPurposeEnumSet.fromRawValue(int rawValue) {
    RouteCameraPurposeEnumSet enumSet = RouteCameraPurposeEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory RouteCameraPurposeEnumSet.of(Iterable<RouteCameraPurpose> elements) {
    RouteCameraPurposeEnumSet enumSet = RouteCameraPurposeEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory RouteCameraPurposeEnumSet.all() {
    RouteCameraPurposeEnumSet enumSet = RouteCameraPurposeEnumSet();
    enumSet.addAll(RouteCameraPurpose.values);
    return enumSet;
  }

  @override
  bool contains(RouteCameraPurpose value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<RouteCameraPurpose> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(RouteCameraPurpose value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<RouteCameraPurpose> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(RouteCameraPurpose value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<RouteCameraPurpose> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<RouteCameraPurpose> intersection(EnumSet<RouteCameraPurpose> other) =>
      RouteCameraPurposeEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<RouteCameraPurpose> union(EnumSet<RouteCameraPurpose> other) =>
      RouteCameraPurposeEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<RouteCameraPurpose> difference(EnumSet<RouteCameraPurpose> other) =>
      RouteCameraPurposeEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<RouteCameraPurpose> toSet() {
    Set<RouteCameraPurpose> result = {};
    RouteCameraPurpose.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    RouteCameraPurpose.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CRouteCameraPurpose extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CRouteCameraPurposeBasicFunctions on _COptionSet_CRouteCameraPurpose {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CRouteCameraPurposeToDart on _COptionSet_CRouteCameraPurpose {
  RouteCameraPurposeEnumSet _toDart() {
    return RouteCameraPurposeEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CRouteCameraPurpose on RouteCameraPurposeEnumSet {
  _COptionSet_CRouteCameraPurpose _copyFromDartTo_COptionSet_CRouteCameraPurpose() {
    return _COptionSet_CRouteCameraPurposeMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - RouteCameraDirection

/** Направление действия камеры. */
enum RouteCameraDirection {
  /** Против хода движения. */
  against(0),
  /** По ходу движения (в спину). */
  along(1),
  /** Двунаправленная камера. */
  both(2),
  ;

  const RouteCameraDirection(this.rawValue);
  final int rawValue;

  static RouteCameraDirection getByValue(int value) {
    return RouteCameraDirection.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouteCameraDirection extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouteCameraDirectionBasicFunctions on _CRouteCameraDirection {
  void _releaseIntermediate() {
  }
}

extension _CRouteCameraDirectionToDart on _CRouteCameraDirection {
  RouteCameraDirection _toDart() {
    return RouteCameraDirection.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouteCameraDirection on RouteCameraDirection {
  _CRouteCameraDirection _copyFromDartTo_CRouteCameraDirection() {
    return _CRouteCameraDirectionMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RouteCamera

/** Структура, описывающая дорожную камеру. */
class RouteCamera {
  /** Назначения камеры. */
  final RouteCameraPurposeEnumSet purposes;
  /** Дальность действия камеры против хода движения. */
  final RouteDistance rangeAgainst;
  /** Дальность действия камеры по ходу движения. */
  final RouteDistance rangeAlong;
  /** Направление действия камеры. */
  final RouteCameraDirection direction;
  /**
   Скорость, превышение которое фиксируется камерой, в м/с. Отсутствует, если
   камера не фиксирует превышение скорости.
  */
  final double? maxSpeedLimit;

  const RouteCamera({
    required this.purposes,
    required this.rangeAgainst,
    required this.rangeAlong,
    this.direction = RouteCameraDirection.against,
    required this.maxSpeedLimit
  });

  RouteCamera copyWith({
    RouteCameraPurposeEnumSet? purposes,
    RouteDistance? rangeAgainst,
    RouteDistance? rangeAlong,
    RouteCameraDirection? direction,
    Optional<double?>? maxSpeedLimit
  }) {
    return RouteCamera(
      purposes: purposes ?? this.purposes,
      rangeAgainst: rangeAgainst ?? this.rangeAgainst,
      rangeAlong: rangeAlong ?? this.rangeAlong,
      direction: direction ?? this.direction,
      maxSpeedLimit: maxSpeedLimit != null ? maxSpeedLimit.value : this.maxSpeedLimit
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteCamera &&
    other.runtimeType == runtimeType &&
    other.purposes == purposes &&
    other.rangeAgainst == rangeAgainst &&
    other.rangeAlong == rangeAlong &&
    other.direction == direction &&
    other.maxSpeedLimit == maxSpeedLimit;

  @override
  int get hashCode {
    return Object.hash(purposes, rangeAgainst, rangeAlong, direction, maxSpeedLimit);
  }

}
final class _CRouteCamera extends ffi.Struct {
  external _COptionSet_CRouteCameraPurpose purposes;

  external _CRouteDistance rangeAgainst;

  external _CRouteDistance rangeAlong;

  external _CRouteCameraDirection direction;

  external _COptional_float maxSpeedLimit;

}
// MARK: - RouteCamera <-> _CRouteCamera

extension _CRouteCameraToDart on _CRouteCamera {
  RouteCamera _toDart() {
    return RouteCamera(
      purposes: this.purposes._toDart(),
      rangeAgainst: this.rangeAgainst._toDart(),
      rangeAlong: this.rangeAlong._toDart(),
      direction: this.direction._toDart(),
      maxSpeedLimit: this.maxSpeedLimit._toDart()
    );
  }
}

extension _DartTo_CRouteCamera on RouteCamera {
  _CRouteCamera _copyFromDartTo_CRouteCamera() {
    final res = _CRouteCameraMakeDefault();
    res.purposes = this.purposes._copyFromDartTo_COptionSet_CRouteCameraPurpose();
    res.rangeAgainst = this.rangeAgainst._copyFromDartTo_CRouteDistance();
    res.rangeAlong = this.rangeAlong._copyFromDartTo_CRouteDistance();
    res.direction = this.direction._copyFromDartTo_CRouteCameraDirection();
    res.maxSpeedLimit = this.maxSpeedLimit._copyFromDartTo_COptional_float();
    return res;
  }
}
extension _CRouteCameraRelease on _CRouteCamera {
  void _releaseIntermediate() {
  }
}

// MARK: - CameraRouteEntry

/** Элемент маршрута - точка и значение в ней. */
class CameraRouteEntry {
  final RoutePoint point;
  final RouteCamera value;

  const CameraRouteEntry({
    required this.point,
    required this.value
  });

  CameraRouteEntry copyWith({
    RoutePoint? point,
    RouteCamera? value
  }) {
    return CameraRouteEntry(
      point: point ?? this.point,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraRouteEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, value);
  }

}
final class _CCameraRouteEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteCamera value;

}
// MARK: - CameraRouteEntry <-> _CCameraRouteEntry

extension _CCameraRouteEntryToDart on _CCameraRouteEntry {
  CameraRouteEntry _toDart() {
    return CameraRouteEntry(
      point: this.point._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CCameraRouteEntry on CameraRouteEntry {
  _CCameraRouteEntry _copyFromDartTo_CCameraRouteEntry() {
    final res = _CCameraRouteEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.value = this.value._copyFromDartTo_CRouteCamera();
    return res;
  }
}
extension _CCameraRouteEntryRelease on _CCameraRouteEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - CameraRouteEntry? <-> _COptional_CCameraRouteEntry

final class _COptional_CCameraRouteEntry extends ffi.Struct {
  
  external _CCameraRouteEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CCameraRouteEntryBasicFunctions on _COptional_CCameraRouteEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CCameraRouteEntryToDart on _COptional_CCameraRouteEntry {
  CameraRouteEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CCameraRouteEntry on CameraRouteEntry? {
  _COptional_CCameraRouteEntry _copyFromDartTo_COptional_CCameraRouteEntry() {
    final cOptional = _COptional_CCameraRouteEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CCameraRouteEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<CameraRouteEntry> <-> _CArray_CCameraRouteEntry

final class _CArray_CCameraRouteEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CCameraRouteEntryToDart on _CArray_CCameraRouteEntry {
  List<CameraRouteEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CCameraRouteEntry on List<CameraRouteEntry> {
  _CArray_CCameraRouteEntry _copyFromDartTo_CArray_CCameraRouteEntry() {
    final cArray = _CArray_CCameraRouteEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CCameraRouteEntry();
        _CArray_CCameraRouteEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CCameraRouteEntryBasicFunctions on _CArray_CCameraRouteEntry {
  void _releaseIntermediate() {
    _CArray_CCameraRouteEntry_release(this);
  }

  static final _listToFill = <CameraRouteEntry>[];

  static void _iterate(_CCameraRouteEntry item) {
    _listToFill.add(item._toDart());
  }

  List<CameraRouteEntry> _fillFromC() {
    _forEach_CArray_CCameraRouteEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CCameraRouteEntry)>(_iterate));
    final result = List<CameraRouteEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - UIntRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class UIntRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CUIntRouteLongAttribute_size(_CUIntRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CUIntRouteLongAttribute_isEmpty(_CUIntRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  UIntRouteLongEntry? get first {
    _COptional_CUIntRouteLongEntry res = _CUIntRouteLongAttribute_first(_CUIntRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  UIntRouteLongEntry? get last {
    _COptional_CUIntRouteLongEntry res = _CUIntRouteLongAttribute_last(_CUIntRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<UIntRouteLongEntry> get entries {
    _CArray_CUIntRouteLongEntry res = _CUIntRouteLongAttribute_entries(_CUIntRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CUIntRouteLongAttribute_releasePtr);

  UIntRouteLongAttribute._raw(this._self);
  factory UIntRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = UIntRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is UIntRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CUIntRouteLongAttribute_cg_objectIdentifier(this._self) == _CUIntRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CUIntRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: UIntRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  UIntRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CUIntRouteLongEntry res = _CUIntRouteLongAttribute_entry_CRoutePoint(_CUIntRouteLongAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<UIntRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CUIntRouteLongEntry res = _CUIntRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CUIntRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - UIntRouteLongAttribute <-> CUIntRouteLongAttribute

final class _CUIntRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CUIntRouteLongAttributeBasicFunctions on _CUIntRouteLongAttribute {
  void _releaseIntermediate() {
    _CUIntRouteLongAttribute_release(_impl);
  }

  _CUIntRouteLongAttribute _retain() {
    return _CUIntRouteLongAttribute_retain(_impl);
  }
}

extension _CUIntRouteLongAttributeToDart on _CUIntRouteLongAttribute {
  UIntRouteLongAttribute _toDart() {
    return UIntRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCUIntRouteLongAttribute on UIntRouteLongAttribute {
  _CUIntRouteLongAttribute _copyFromDartTo_CUIntRouteLongAttribute() {
    return (_CUIntRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - UIntRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class UIntRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final int value;

  const UIntRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  UIntRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    int? value
  }) {
    return UIntRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is UIntRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CUIntRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  @ffi.Uint32()
  external int value;

}
// MARK: - UIntRouteLongEntry <-> _CUIntRouteLongEntry

extension _CUIntRouteLongEntryToDart on _CUIntRouteLongEntry {
  UIntRouteLongEntry _toDart() {
    return UIntRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value
    );
  }
}

extension _DartTo_CUIntRouteLongEntry on UIntRouteLongEntry {
  _CUIntRouteLongEntry _copyFromDartTo_CUIntRouteLongEntry() {
    final res = _CUIntRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value;
    return res;
  }
}
extension _CUIntRouteLongEntryRelease on _CUIntRouteLongEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - UIntRouteLongEntry? <-> _COptional_CUIntRouteLongEntry

final class _COptional_CUIntRouteLongEntry extends ffi.Struct {
  
  external _CUIntRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CUIntRouteLongEntryBasicFunctions on _COptional_CUIntRouteLongEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CUIntRouteLongEntryToDart on _COptional_CUIntRouteLongEntry {
  UIntRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CUIntRouteLongEntry on UIntRouteLongEntry? {
  _COptional_CUIntRouteLongEntry _copyFromDartTo_COptional_CUIntRouteLongEntry() {
    final cOptional = _COptional_CUIntRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CUIntRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<UIntRouteLongEntry> <-> _CArray_CUIntRouteLongEntry

final class _CArray_CUIntRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CUIntRouteLongEntryToDart on _CArray_CUIntRouteLongEntry {
  List<UIntRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CUIntRouteLongEntry on List<UIntRouteLongEntry> {
  _CArray_CUIntRouteLongEntry _copyFromDartTo_CArray_CUIntRouteLongEntry() {
    final cArray = _CArray_CUIntRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CUIntRouteLongEntry();
        _CArray_CUIntRouteLongEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CUIntRouteLongEntryBasicFunctions on _CArray_CUIntRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CUIntRouteLongEntry_release(this);
  }

  static final _listToFill = <UIntRouteLongEntry>[];

  static void _iterate(_CUIntRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<UIntRouteLongEntry> _fillFromC() {
    _forEach_CArray_CUIntRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CUIntRouteLongEntry)>(_iterate));
    final result = List<UIntRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RouteExitSignRouteAttribute

/**
 Контейнер, который описывает точечный атрибут маршрута.
 Каждый элемент хранится в виде точки на маршруте, в которой этот элемент расположен и значения самого элемента.
*/
class RouteExitSignRouteAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CRouteExitSignRouteAttribute_size(_CRouteExitSignRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CRouteExitSignRouteAttribute_isEmpty(_CRouteExitSignRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  RouteExitSignRouteEntry? get first {
    _COptional_CRouteExitSignRouteEntry res = _CRouteExitSignRouteAttribute_first(_CRouteExitSignRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Последний элемент. */
  RouteExitSignRouteEntry? get last {
    _COptional_CRouteExitSignRouteEntry res = _CRouteExitSignRouteAttribute_last(_CRouteExitSignRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Все элементы. */
  List<RouteExitSignRouteEntry> get entries {
    _CArray_CRouteExitSignRouteEntry res = _CRouteExitSignRouteAttribute_entries(_CRouteExitSignRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRouteExitSignRouteAttribute_releasePtr);

  RouteExitSignRouteAttribute._raw(this._self);
  factory RouteExitSignRouteAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RouteExitSignRouteAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteExitSignRouteAttribute &&
    other.runtimeType == runtimeType &&
    _CRouteExitSignRouteAttribute_cg_objectIdentifier(this._self) == _CRouteExitSignRouteAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRouteExitSignRouteAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RouteExitSignRouteAttribute: Methods

  /**
   Элементы, попадающие в отрезок [begin, end).
  
   - Throws: Exception если begin > end.
  */
  List<RouteExitSignRouteEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CRouteExitSignRouteEntry res = _CRouteExitSignRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CRouteExitSignRouteAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого
   <
   = point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  RouteExitSignRouteEntry? findNearBackward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRouteExitSignRouteEntry res = _CRouteExitSignRouteAttribute_findNearBackward_CRoutePoint(_CRouteExitSignRouteAttributeMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого >= point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  RouteExitSignRouteEntry? findNearForward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRouteExitSignRouteEntry res = _CRouteExitSignRouteAttribute_findNearForward_CRoutePoint(_CRouteExitSignRouteAttributeMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RouteExitSignRouteAttribute <-> CRouteExitSignRouteAttribute

final class _CRouteExitSignRouteAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRouteExitSignRouteAttributeBasicFunctions on _CRouteExitSignRouteAttribute {
  void _releaseIntermediate() {
    _CRouteExitSignRouteAttribute_release(_impl);
  }

  _CRouteExitSignRouteAttribute _retain() {
    return _CRouteExitSignRouteAttribute_retain(_impl);
  }
}

extension _CRouteExitSignRouteAttributeToDart on _CRouteExitSignRouteAttribute {
  RouteExitSignRouteAttribute _toDart() {
    return RouteExitSignRouteAttribute._create(_retain()._impl);
  }
}


extension _DartToCRouteExitSignRouteAttribute on RouteExitSignRouteAttribute {
  _CRouteExitSignRouteAttribute _copyFromDartTo_CRouteExitSignRouteAttribute() {
    return (_CRouteExitSignRouteAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RouteExitSignType

/** Тип съезда. */
enum RouteExitSignType {
  /** Не определён. */
  undefined(0),
  /** Съезд в аэропорт. */
  airport(1),
  ;

  const RouteExitSignType(this.rawValue);
  final int rawValue;

  static RouteExitSignType getByValue(int value) {
    return RouteExitSignType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouteExitSignType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouteExitSignTypeBasicFunctions on _CRouteExitSignType {
  void _releaseIntermediate() {
  }
}

extension _CRouteExitSignTypeToDart on _CRouteExitSignType {
  RouteExitSignType _toDart() {
    return RouteExitSignType.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouteExitSignType on RouteExitSignType {
  _CRouteExitSignType _copyFromDartTo_CRouteExitSignType() {
    return _CRouteExitSignTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RouteExitSignTableColor

/**
 Цвет фона таблички съезда. Соответствует цвету фона знака, установленного
 в соответствующем месте маршрута.
*/
enum RouteExitSignTableColor {
  /** цвет знака не определён. */
  undefined(0),
  /** Белый. */
  white(1),
  /** Красный. */
  red(2),
  /** Зелёный. */
  green(3),
  /** Синий. */
  blue(4),
  /** Коричневый. */
  brown(5),
  ;

  const RouteExitSignTableColor(this.rawValue);
  final int rawValue;

  static RouteExitSignTableColor getByValue(int value) {
    return RouteExitSignTableColor.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouteExitSignTableColor extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouteExitSignTableColorBasicFunctions on _CRouteExitSignTableColor {
  void _releaseIntermediate() {
  }
}

extension _CRouteExitSignTableColorToDart on _CRouteExitSignTableColor {
  RouteExitSignTableColor _toDart() {
    return RouteExitSignTableColor.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouteExitSignTableColor on RouteExitSignTableColor {
  _CRouteExitSignTableColor _copyFromDartTo_CRouteExitSignTableColor() {
    return _CRouteExitSignTableColorMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RouteExitSignTable

/** Информация о табличке съезда. */
class RouteExitSignTable {
  /** Цвет фона таблички съезда. */
  final RouteExitSignTableColor backgroundColor;
  /** Текст на табличке съезда. */
  final String text;

  const RouteExitSignTable({
    this.backgroundColor = RouteExitSignTableColor.undefined,
    required this.text
  });

  RouteExitSignTable copyWith({
    RouteExitSignTableColor? backgroundColor,
    String? text
  }) {
    return RouteExitSignTable(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      text: text ?? this.text
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteExitSignTable &&
    other.runtimeType == runtimeType &&
    other.backgroundColor == backgroundColor &&
    other.text == text;

  @override
  int get hashCode {
    return Object.hash(backgroundColor, text);
  }

}
final class _CRouteExitSignTable extends ffi.Struct {
  external _CRouteExitSignTableColor backgroundColor;

  external _CString text;

}
// MARK: - RouteExitSignTable <-> _CRouteExitSignTable

extension _CRouteExitSignTableToDart on _CRouteExitSignTable {
  RouteExitSignTable _toDart() {
    return RouteExitSignTable(
      backgroundColor: this.backgroundColor._toDart(),
      text: this.text._toDart()
    );
  }
}

extension _DartTo_CRouteExitSignTable on RouteExitSignTable {
  _CRouteExitSignTable _copyFromDartTo_CRouteExitSignTable() {
    final res = _CRouteExitSignTableMakeDefault();
    res.backgroundColor = this.backgroundColor._copyFromDartTo_CRouteExitSignTableColor();
    res.text = this.text._copyFromDartTo_CString();
    return res;
  }
}
extension _CRouteExitSignTableRelease on _CRouteExitSignTable {
  void _releaseIntermediate() {
    text._releaseIntermediate();
  }
}

// MARK: - RouteExitSignTable? <-> _COptional_CRouteExitSignTable

final class _COptional_CRouteExitSignTable extends ffi.Struct {
  
  external _CRouteExitSignTable value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRouteExitSignTableBasicFunctions on _COptional_CRouteExitSignTable {
  void _releaseIntermediate() {
    _COptional_CRouteExitSignTable_release(this);
  }
}

extension _COptional_CRouteExitSignTableToDart on _COptional_CRouteExitSignTable {
  RouteExitSignTable? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRouteExitSignTable on RouteExitSignTable? {
  _COptional_CRouteExitSignTable _copyFromDartTo_COptional_CRouteExitSignTable() {
    final cOptional = _COptional_CRouteExitSignTableMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRouteExitSignTable();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - RouteExitSign

/** Информация о знаке съезда. */
class RouteExitSign {
  /** Тип съезда. */
  final RouteExitSignType type;
  /** Табличка съезда с названием дороги. */
  final RouteExitSignTable roadNameTable;
  /** Табличка съезда с номером дороги. */
  final RouteExitSignTable? roadNumberTable;

  const RouteExitSign({
    this.type = RouteExitSignType.undefined,
    required this.roadNameTable,
    required this.roadNumberTable
  });

  RouteExitSign copyWith({
    RouteExitSignType? type,
    RouteExitSignTable? roadNameTable,
    Optional<RouteExitSignTable?>? roadNumberTable
  }) {
    return RouteExitSign(
      type: type ?? this.type,
      roadNameTable: roadNameTable ?? this.roadNameTable,
      roadNumberTable: roadNumberTable != null ? roadNumberTable.value : this.roadNumberTable
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteExitSign &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.roadNameTable == roadNameTable &&
    other.roadNumberTable == roadNumberTable;

  @override
  int get hashCode {
    return Object.hash(type, roadNameTable, roadNumberTable);
  }

}
final class _CRouteExitSign extends ffi.Struct {
  external _CRouteExitSignType type;

  external _CRouteExitSignTable roadNameTable;

  external _COptional_CRouteExitSignTable roadNumberTable;

}
// MARK: - RouteExitSign <-> _CRouteExitSign

extension _CRouteExitSignToDart on _CRouteExitSign {
  RouteExitSign _toDart() {
    return RouteExitSign(
      type: this.type._toDart(),
      roadNameTable: this.roadNameTable._toDart(),
      roadNumberTable: this.roadNumberTable._toDart()
    );
  }
}

extension _DartTo_CRouteExitSign on RouteExitSign {
  _CRouteExitSign _copyFromDartTo_CRouteExitSign() {
    final res = _CRouteExitSignMakeDefault();
    res.type = this.type._copyFromDartTo_CRouteExitSignType();
    res.roadNameTable = this.roadNameTable._copyFromDartTo_CRouteExitSignTable();
    res.roadNumberTable = this.roadNumberTable._copyFromDartTo_COptional_CRouteExitSignTable();
    return res;
  }
}
extension _CRouteExitSignRelease on _CRouteExitSign {
  void _releaseIntermediate() {
    roadNameTable._releaseIntermediate();
    roadNumberTable._releaseIntermediate();
  }
}

// MARK: - RouteExitSignRouteEntry

/** Элемент маршрута - точка и значение в ней. */
class RouteExitSignRouteEntry {
  final RoutePoint point;
  final RouteExitSign value;

  const RouteExitSignRouteEntry({
    required this.point,
    required this.value
  });

  RouteExitSignRouteEntry copyWith({
    RoutePoint? point,
    RouteExitSign? value
  }) {
    return RouteExitSignRouteEntry(
      point: point ?? this.point,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteExitSignRouteEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, value);
  }

}
final class _CRouteExitSignRouteEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteExitSign value;

}
// MARK: - RouteExitSignRouteEntry <-> _CRouteExitSignRouteEntry

extension _CRouteExitSignRouteEntryToDart on _CRouteExitSignRouteEntry {
  RouteExitSignRouteEntry _toDart() {
    return RouteExitSignRouteEntry(
      point: this.point._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CRouteExitSignRouteEntry on RouteExitSignRouteEntry {
  _CRouteExitSignRouteEntry _copyFromDartTo_CRouteExitSignRouteEntry() {
    final res = _CRouteExitSignRouteEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.value = this.value._copyFromDartTo_CRouteExitSign();
    return res;
  }
}
extension _CRouteExitSignRouteEntryRelease on _CRouteExitSignRouteEntry {
  void _releaseIntermediate() {
    value._releaseIntermediate();
  }
}

// MARK: - RouteExitSignRouteEntry? <-> _COptional_CRouteExitSignRouteEntry

final class _COptional_CRouteExitSignRouteEntry extends ffi.Struct {
  
  external _CRouteExitSignRouteEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRouteExitSignRouteEntryBasicFunctions on _COptional_CRouteExitSignRouteEntry {
  void _releaseIntermediate() {
    _COptional_CRouteExitSignRouteEntry_release(this);
  }
}

extension _COptional_CRouteExitSignRouteEntryToDart on _COptional_CRouteExitSignRouteEntry {
  RouteExitSignRouteEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRouteExitSignRouteEntry on RouteExitSignRouteEntry? {
  _COptional_CRouteExitSignRouteEntry _copyFromDartTo_COptional_CRouteExitSignRouteEntry() {
    final cOptional = _COptional_CRouteExitSignRouteEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRouteExitSignRouteEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<RouteExitSignRouteEntry> <-> _CArray_CRouteExitSignRouteEntry

final class _CArray_CRouteExitSignRouteEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRouteExitSignRouteEntryToDart on _CArray_CRouteExitSignRouteEntry {
  List<RouteExitSignRouteEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRouteExitSignRouteEntry on List<RouteExitSignRouteEntry> {
  _CArray_CRouteExitSignRouteEntry _copyFromDartTo_CArray_CRouteExitSignRouteEntry() {
    final cArray = _CArray_CRouteExitSignRouteEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRouteExitSignRouteEntry();
        _CArray_CRouteExitSignRouteEntryaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CRouteExitSignRouteEntryBasicFunctions on _CArray_CRouteExitSignRouteEntry {
  void _releaseIntermediate() {
    _CArray_CRouteExitSignRouteEntry_release(this);
  }

  static final _listToFill = <RouteExitSignRouteEntry>[];

  static void _iterate(_CRouteExitSignRouteEntry item) {
    _listToFill.add(item._toDart());
  }

  List<RouteExitSignRouteEntry> _fillFromC() {
    _forEach_CArray_CRouteExitSignRouteEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRouteExitSignRouteEntry)>(_iterate));
    final result = List<RouteExitSignRouteEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - VoidRouteAttribute

/**
 Контейнер, который описывает точечный атрибут маршрута.
 Каждый элемент хранится в виде точки на маршруте, в которой этот элемент расположен и значения самого элемента.
*/
class VoidRouteAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CVoidRouteAttribute_size(_CVoidRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CVoidRouteAttribute_isEmpty(_CVoidRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  RoutePoint? get first {
    _COptional_CRoutePoint res = _CVoidRouteAttribute_first(_CVoidRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  RoutePoint? get last {
    _COptional_CRoutePoint res = _CVoidRouteAttribute_last(_CVoidRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<RoutePoint> get entries {
    _CArray_CRoutePoint res = _CVoidRouteAttribute_entries(_CVoidRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CVoidRouteAttribute_releasePtr);

  VoidRouteAttribute._raw(this._self);
  factory VoidRouteAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = VoidRouteAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is VoidRouteAttribute &&
    other.runtimeType == runtimeType &&
    _CVoidRouteAttribute_cg_objectIdentifier(this._self) == _CVoidRouteAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CVoidRouteAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: VoidRouteAttribute: Methods

  /**
   Элементы, попадающие в отрезок [begin, end).
  
   - Throws: Exception если begin > end.
  */
  List<RoutePoint> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CRoutePoint res = _CVoidRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CVoidRouteAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого
   <
   = point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  RoutePoint? findNearBackward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRoutePoint res = _CVoidRouteAttribute_findNearBackward_CRoutePoint(_CVoidRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Найти ближайший элемент, позиция которого >= point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  RoutePoint? findNearForward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRoutePoint res = _CVoidRouteAttribute_findNearForward_CRoutePoint(_CVoidRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

}

// MARK: - VoidRouteAttribute <-> CVoidRouteAttribute

final class _CVoidRouteAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CVoidRouteAttributeBasicFunctions on _CVoidRouteAttribute {
  void _releaseIntermediate() {
    _CVoidRouteAttribute_release(_impl);
  }

  _CVoidRouteAttribute _retain() {
    return _CVoidRouteAttribute_retain(_impl);
  }
}

extension _CVoidRouteAttributeToDart on _CVoidRouteAttribute {
  VoidRouteAttribute _toDart() {
    return VoidRouteAttribute._create(_retain()._impl);
  }
}


extension _DartToCVoidRouteAttribute on VoidRouteAttribute {
  _CVoidRouteAttribute _copyFromDartTo_CVoidRouteAttribute() {
    return (_CVoidRouteAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<RoutePoint> <-> _CArray_CRoutePoint

final class _CArray_CRoutePoint extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRoutePointToDart on _CArray_CRoutePoint {
  List<RoutePoint> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRoutePoint on List<RoutePoint> {
  _CArray_CRoutePoint _copyFromDartTo_CArray_CRoutePoint() {
    final cArray = _CArray_CRoutePointmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRoutePoint();
        _CArray_CRoutePointaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CRoutePointBasicFunctions on _CArray_CRoutePoint {
  void _releaseIntermediate() {
    _CArray_CRoutePoint_release(this);
  }

  static final _listToFill = <RoutePoint>[];

  static void _iterate(_CRoutePoint item) {
    _listToFill.add(item._toDart());
  }

  List<RoutePoint> _fillFromC() {
    _forEach_CArray_CRoutePoint(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRoutePoint)>(_iterate));
    final result = List<RoutePoint>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - LaneSignRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class LaneSignRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CLaneSignRouteLongAttribute_size(_CLaneSignRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CLaneSignRouteLongAttribute_isEmpty(_CLaneSignRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  LaneSignRouteLongEntry? get first {
    _COptional_CLaneSignRouteLongEntry res = _CLaneSignRouteLongAttribute_first(_CLaneSignRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Последний элемент. */
  LaneSignRouteLongEntry? get last {
    _COptional_CLaneSignRouteLongEntry res = _CLaneSignRouteLongAttribute_last(_CLaneSignRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Все элементы. */
  List<LaneSignRouteLongEntry> get entries {
    _CArray_CLaneSignRouteLongEntry res = _CLaneSignRouteLongAttribute_entries(_CLaneSignRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CLaneSignRouteLongAttribute_releasePtr);

  LaneSignRouteLongAttribute._raw(this._self);
  factory LaneSignRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = LaneSignRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LaneSignRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CLaneSignRouteLongAttribute_cg_objectIdentifier(this._self) == _CLaneSignRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLaneSignRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: LaneSignRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  LaneSignRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CLaneSignRouteLongEntry res = _CLaneSignRouteLongAttribute_entry_CRoutePoint(_CLaneSignRouteLongAttributeMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<LaneSignRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CLaneSignRouteLongEntry res = _CLaneSignRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CLaneSignRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - LaneSignRouteLongAttribute <-> CLaneSignRouteLongAttribute

final class _CLaneSignRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLaneSignRouteLongAttributeBasicFunctions on _CLaneSignRouteLongAttribute {
  void _releaseIntermediate() {
    _CLaneSignRouteLongAttribute_release(_impl);
  }

  _CLaneSignRouteLongAttribute _retain() {
    return _CLaneSignRouteLongAttribute_retain(_impl);
  }
}

extension _CLaneSignRouteLongAttributeToDart on _CLaneSignRouteLongAttribute {
  LaneSignRouteLongAttribute _toDart() {
    return LaneSignRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCLaneSignRouteLongAttribute on LaneSignRouteLongAttribute {
  _CLaneSignRouteLongAttribute _copyFromDartTo_CLaneSignRouteLongAttribute() {
    return (_CLaneSignRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<RouteLane> <-> _CArray_CRouteLane

final class _CArray_CRouteLane extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRouteLaneToDart on _CArray_CRouteLane {
  List<RouteLane> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRouteLane on List<RouteLane> {
  _CArray_CRouteLane _copyFromDartTo_CArray_CRouteLane() {
    final cArray = _CArray_CRouteLanemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRouteLane();
        _CArray_CRouteLaneaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CRouteLaneBasicFunctions on _CArray_CRouteLane {
  void _releaseIntermediate() {
    _CArray_CRouteLane_release(this);
  }

  static final _listToFill = <RouteLane>[];

  static void _iterate(_CRouteLane item) {
    _listToFill.add(item._toDart());
  }

  List<RouteLane> _fillFromC() {
    _forEach_CArray_CRouteLane(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRouteLane)>(_iterate));
    final result = List<RouteLane>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RouteLaneSign

/** Описание полос движения. */
class RouteLaneSign {
  /**
   Полосы движения для автомобилей на участке дороги.
   Перечислены в порядке следования от середины проезжей части к обочине.
  
   - Note: Если количество полос неизвестно либо в направлении маршрута на дороге находится одна полоса движения,
   то этот массив будет пустым.
  */
  final List<RouteLane> lanes;
  /**
   Точка на маршруте, в которой начинается действие знака, регулирующего движение по полосам.
   null, если положение начала действия знака неизвестно.
  */
  final RoutePoint? signStartPoint;
  /**
   Точка на маршруте, в которой установлен знак, регулирующий движение по полосам.
   null, если положение знака неизвестно.
  */
  final RoutePoint? signPoint;
  /**
   Точка на маршруте, в которой заканчивается действие знака, регулирующего движение по полосам.
   null, если положение окончания действия знака неизвестно.
  */
  final RoutePoint? signEndPoint;

  const RouteLaneSign({
    required this.lanes,
    required this.signStartPoint,
    required this.signPoint,
    required this.signEndPoint
  });

  RouteLaneSign copyWith({
    List<RouteLane>? lanes,
    Optional<RoutePoint?>? signStartPoint,
    Optional<RoutePoint?>? signPoint,
    Optional<RoutePoint?>? signEndPoint
  }) {
    return RouteLaneSign(
      lanes: lanes ?? this.lanes,
      signStartPoint: signStartPoint != null ? signStartPoint.value : this.signStartPoint,
      signPoint: signPoint != null ? signPoint.value : this.signPoint,
      signEndPoint: signEndPoint != null ? signEndPoint.value : this.signEndPoint
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteLaneSign &&
    other.runtimeType == runtimeType &&
    other.lanes == lanes &&
    other.signStartPoint == signStartPoint &&
    other.signPoint == signPoint &&
    other.signEndPoint == signEndPoint;

  @override
  int get hashCode {
    return Object.hash(lanes, signStartPoint, signPoint, signEndPoint);
  }

}
final class _CRouteLaneSign extends ffi.Struct {
  external _CArray_CRouteLane lanes;

  external _COptional_CRoutePoint signStartPoint;

  external _COptional_CRoutePoint signPoint;

  external _COptional_CRoutePoint signEndPoint;

}
// MARK: - RouteLaneSign <-> _CRouteLaneSign

extension _CRouteLaneSignToDart on _CRouteLaneSign {
  RouteLaneSign _toDart() {
    return RouteLaneSign(
      lanes: this.lanes._toDart(),
      signStartPoint: this.signStartPoint._toDart(),
      signPoint: this.signPoint._toDart(),
      signEndPoint: this.signEndPoint._toDart()
    );
  }
}

extension _DartTo_CRouteLaneSign on RouteLaneSign {
  _CRouteLaneSign _copyFromDartTo_CRouteLaneSign() {
    final res = _CRouteLaneSignMakeDefault();
    res.lanes = this.lanes._copyFromDartTo_CArray_CRouteLane();
    res.signStartPoint = this.signStartPoint._copyFromDartTo_COptional_CRoutePoint();
    res.signPoint = this.signPoint._copyFromDartTo_COptional_CRoutePoint();
    res.signEndPoint = this.signEndPoint._copyFromDartTo_COptional_CRoutePoint();
    return res;
  }
}
extension _CRouteLaneSignRelease on _CRouteLaneSign {
  void _releaseIntermediate() {
    lanes._releaseIntermediate();
  }
}

// MARK: - LaneSignRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class LaneSignRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final RouteLaneSign value;

  const LaneSignRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  LaneSignRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    RouteLaneSign? value
  }) {
    return LaneSignRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LaneSignRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CLaneSignRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CRouteLaneSign value;

}
// MARK: - LaneSignRouteLongEntry <-> _CLaneSignRouteLongEntry

extension _CLaneSignRouteLongEntryToDart on _CLaneSignRouteLongEntry {
  LaneSignRouteLongEntry _toDart() {
    return LaneSignRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CLaneSignRouteLongEntry on LaneSignRouteLongEntry {
  _CLaneSignRouteLongEntry _copyFromDartTo_CLaneSignRouteLongEntry() {
    final res = _CLaneSignRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CRouteLaneSign();
    return res;
  }
}
extension _CLaneSignRouteLongEntryRelease on _CLaneSignRouteLongEntry {
  void _releaseIntermediate() {
    value._releaseIntermediate();
  }
}

// MARK: - LaneSignRouteLongEntry? <-> _COptional_CLaneSignRouteLongEntry

final class _COptional_CLaneSignRouteLongEntry extends ffi.Struct {
  
  external _CLaneSignRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLaneSignRouteLongEntryBasicFunctions on _COptional_CLaneSignRouteLongEntry {
  void _releaseIntermediate() {
    _COptional_CLaneSignRouteLongEntry_release(this);
  }
}

extension _COptional_CLaneSignRouteLongEntryToDart on _COptional_CLaneSignRouteLongEntry {
  LaneSignRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLaneSignRouteLongEntry on LaneSignRouteLongEntry? {
  _COptional_CLaneSignRouteLongEntry _copyFromDartTo_COptional_CLaneSignRouteLongEntry() {
    final cOptional = _COptional_CLaneSignRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLaneSignRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - RouteLaneManeuver

/** Манёвр на полосе движения. */
enum RouteLaneManeuver {
  /** Не задан. */
  undefined(0),
  /** Прямо. */
  forward(1),
  /** Направо. */
  right(2),
  /** Налево. */
  left(4),
  /** слегка направо. */
  slightlyRight(8),
  /** слегка налево. */
  slightlyLeft(16),
  /** резко направо. */
  sharplyRight(32),
  /** резко налево. */
  sharplyLeft(64),
  /** Направо с последующим поворотом налево. */
  rightWithLeftTurns(128),
  /** Разворот. */
  turnover(256),
  ;

  const RouteLaneManeuver(this.rawValue);
  final int rawValue;

  static RouteLaneManeuver getByValue(int value) {
    return RouteLaneManeuver.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouteLaneManeuver extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouteLaneManeuverBasicFunctions on _CRouteLaneManeuver {
  void _releaseIntermediate() {
  }
}

extension _CRouteLaneManeuverToDart on _CRouteLaneManeuver {
  RouteLaneManeuver _toDart() {
    return RouteLaneManeuver.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouteLaneManeuver on RouteLaneManeuver {
  _CRouteLaneManeuver _copyFromDartTo_CRouteLaneManeuver() {
    return _CRouteLaneManeuverMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RouteLaneManeuverEnumSet

class RouteLaneManeuverEnumSet extends EnumSet<RouteLaneManeuver> {
  RouteLaneManeuverEnumSet() : super();

  factory RouteLaneManeuverEnumSet.fromRawValue(int rawValue) {
    RouteLaneManeuverEnumSet enumSet = RouteLaneManeuverEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory RouteLaneManeuverEnumSet.of(Iterable<RouteLaneManeuver> elements) {
    RouteLaneManeuverEnumSet enumSet = RouteLaneManeuverEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory RouteLaneManeuverEnumSet.all() {
    RouteLaneManeuverEnumSet enumSet = RouteLaneManeuverEnumSet();
    enumSet.addAll(RouteLaneManeuver.values);
    return enumSet;
  }

  @override
  bool contains(RouteLaneManeuver value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<RouteLaneManeuver> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(RouteLaneManeuver value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<RouteLaneManeuver> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(RouteLaneManeuver value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<RouteLaneManeuver> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<RouteLaneManeuver> intersection(EnumSet<RouteLaneManeuver> other) =>
      RouteLaneManeuverEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<RouteLaneManeuver> union(EnumSet<RouteLaneManeuver> other) =>
      RouteLaneManeuverEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<RouteLaneManeuver> difference(EnumSet<RouteLaneManeuver> other) =>
      RouteLaneManeuverEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<RouteLaneManeuver> toSet() {
    Set<RouteLaneManeuver> result = {};
    RouteLaneManeuver.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    RouteLaneManeuver.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CRouteLaneManeuver extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CRouteLaneManeuverBasicFunctions on _COptionSet_CRouteLaneManeuver {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CRouteLaneManeuverToDart on _COptionSet_CRouteLaneManeuver {
  RouteLaneManeuverEnumSet _toDart() {
    return RouteLaneManeuverEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CRouteLaneManeuver on RouteLaneManeuverEnumSet {
  _COptionSet_CRouteLaneManeuver _copyFromDartTo_COptionSet_CRouteLaneManeuver() {
    return _COptionSet_CRouteLaneManeuverMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - RouteLane

/** Структура, описывающая одну полосу движения. */
class RouteLane {
  /** Манёвр, который необходимо совершить для движения по маршруту. */
  final RouteLaneManeuver routeManeuver;
  /** Допустимые манёвры на полосе. */
  final RouteLaneManeuverEnumSet maneuvers;
  /** Максимальная разрешенная скорость на полосе, м/с. 0 - ограничение скорости неизвестно. */
  final double speedLimit;
  /** Проезд по полосе запрещён. */
  final bool prohibited;
  /** Полоса для общественного транспорта. */
  final bool onlyPublicTransport;

  const RouteLane({
    this.routeManeuver = RouteLaneManeuver.undefined,
    required this.maneuvers,
    this.speedLimit = 0,
    this.prohibited = false,
    this.onlyPublicTransport = false
  });

  RouteLane copyWith({
    RouteLaneManeuver? routeManeuver,
    RouteLaneManeuverEnumSet? maneuvers,
    double? speedLimit,
    bool? prohibited,
    bool? onlyPublicTransport
  }) {
    return RouteLane(
      routeManeuver: routeManeuver ?? this.routeManeuver,
      maneuvers: maneuvers ?? this.maneuvers,
      speedLimit: speedLimit ?? this.speedLimit,
      prohibited: prohibited ?? this.prohibited,
      onlyPublicTransport: onlyPublicTransport ?? this.onlyPublicTransport
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteLane &&
    other.runtimeType == runtimeType &&
    other.routeManeuver == routeManeuver &&
    other.maneuvers == maneuvers &&
    other.speedLimit == speedLimit &&
    other.prohibited == prohibited &&
    other.onlyPublicTransport == onlyPublicTransport;

  @override
  int get hashCode {
    return Object.hash(routeManeuver, maneuvers, speedLimit, prohibited, onlyPublicTransport);
  }

}
final class _CRouteLane extends ffi.Struct {
  external _CRouteLaneManeuver routeManeuver;

  external _COptionSet_CRouteLaneManeuver maneuvers;

  @ffi.Float()
  external double speedLimit;

  @ffi.Bool()
  external bool prohibited;

  @ffi.Bool()
  external bool onlyPublicTransport;

}
// MARK: - RouteLane <-> _CRouteLane

extension _CRouteLaneToDart on _CRouteLane {
  RouteLane _toDart() {
    return RouteLane(
      routeManeuver: this.routeManeuver._toDart(),
      maneuvers: this.maneuvers._toDart(),
      speedLimit: this.speedLimit,
      prohibited: this.prohibited,
      onlyPublicTransport: this.onlyPublicTransport
    );
  }
}

extension _DartTo_CRouteLane on RouteLane {
  _CRouteLane _copyFromDartTo_CRouteLane() {
    final res = _CRouteLaneMakeDefault();
    res.routeManeuver = this.routeManeuver._copyFromDartTo_CRouteLaneManeuver();
    res.maneuvers = this.maneuvers._copyFromDartTo_COptionSet_CRouteLaneManeuver();
    res.speedLimit = this.speedLimit;
    res.prohibited = this.prohibited;
    res.onlyPublicTransport = this.onlyPublicTransport;
    return res;
  }
}
extension _CRouteLaneRelease on _CRouteLane {
  void _releaseIntermediate() {
  }
}

// MARK: - List<LaneSignRouteLongEntry> <-> _CArray_CLaneSignRouteLongEntry

final class _CArray_CLaneSignRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CLaneSignRouteLongEntryToDart on _CArray_CLaneSignRouteLongEntry {
  List<LaneSignRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CLaneSignRouteLongEntry on List<LaneSignRouteLongEntry> {
  _CArray_CLaneSignRouteLongEntry _copyFromDartTo_CArray_CLaneSignRouteLongEntry() {
    final cArray = _CArray_CLaneSignRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CLaneSignRouteLongEntry();
        _CArray_CLaneSignRouteLongEntryaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CLaneSignRouteLongEntryBasicFunctions on _CArray_CLaneSignRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CLaneSignRouteLongEntry_release(this);
  }

  static final _listToFill = <LaneSignRouteLongEntry>[];

  static void _iterate(_CLaneSignRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<LaneSignRouteLongEntry> _fillFromC() {
    _forEach_CArray_CLaneSignRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CLaneSignRouteLongEntry)>(_iterate));
    final result = List<LaneSignRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RouteLevelInfoRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class RouteLevelInfoRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CRouteLevelInfoRouteLongAttribute_size(_CRouteLevelInfoRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CRouteLevelInfoRouteLongAttribute_isEmpty(_CRouteLevelInfoRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  RouteLevelInfoRouteLongEntry? get first {
    _COptional_CRouteLevelInfoRouteLongEntry res = _CRouteLevelInfoRouteLongAttribute_first(_CRouteLevelInfoRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Последний элемент. */
  RouteLevelInfoRouteLongEntry? get last {
    _COptional_CRouteLevelInfoRouteLongEntry res = _CRouteLevelInfoRouteLongAttribute_last(_CRouteLevelInfoRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Все элементы. */
  List<RouteLevelInfoRouteLongEntry> get entries {
    _CArray_CRouteLevelInfoRouteLongEntry res = _CRouteLevelInfoRouteLongAttribute_entries(_CRouteLevelInfoRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRouteLevelInfoRouteLongAttribute_releasePtr);

  RouteLevelInfoRouteLongAttribute._raw(this._self);
  factory RouteLevelInfoRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RouteLevelInfoRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteLevelInfoRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CRouteLevelInfoRouteLongAttribute_cg_objectIdentifier(this._self) == _CRouteLevelInfoRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRouteLevelInfoRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RouteLevelInfoRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  RouteLevelInfoRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRouteLevelInfoRouteLongEntry res = _CRouteLevelInfoRouteLongAttribute_entry_CRoutePoint(_CRouteLevelInfoRouteLongAttributeMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<RouteLevelInfoRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CRouteLevelInfoRouteLongEntry res = _CRouteLevelInfoRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CRouteLevelInfoRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RouteLevelInfoRouteLongAttribute <-> CRouteLevelInfoRouteLongAttribute

final class _CRouteLevelInfoRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRouteLevelInfoRouteLongAttributeBasicFunctions on _CRouteLevelInfoRouteLongAttribute {
  void _releaseIntermediate() {
    _CRouteLevelInfoRouteLongAttribute_release(_impl);
  }

  _CRouteLevelInfoRouteLongAttribute _retain() {
    return _CRouteLevelInfoRouteLongAttribute_retain(_impl);
  }
}

extension _CRouteLevelInfoRouteLongAttributeToDart on _CRouteLevelInfoRouteLongAttribute {
  RouteLevelInfoRouteLongAttribute _toDart() {
    return RouteLevelInfoRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCRouteLevelInfoRouteLongAttribute on RouteLevelInfoRouteLongAttribute {
  _CRouteLevelInfoRouteLongAttribute _copyFromDartTo_CRouteLevelInfoRouteLongAttribute() {
    return (_CRouteLevelInfoRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RouteLevelInfo

/** Информация об этаже здания, соответствующая участку маршрута. */
class RouteLevelInfo {
  /**
   Идентификатор этажного плана в начальной точке участка маршрута.
   Отсутствует, если точка не находится в здании.
  */
  final LevelId? beginId;
  /**
   Идентификатор этажного плана в конечной точке участка маршрута.
   Отсутствует, если точка не находится в здании.
  */
  final LevelId? endId;
  /**
   Название этажа.
   Пусто, если участок маршрута соединяет разные этажи.
  */
  final String name;

  const RouteLevelInfo({
    required this.beginId,
    required this.endId,
    required this.name
  });

  RouteLevelInfo copyWith({
    Optional<LevelId?>? beginId,
    Optional<LevelId?>? endId,
    String? name
  }) {
    return RouteLevelInfo(
      beginId: beginId != null ? beginId.value : this.beginId,
      endId: endId != null ? endId.value : this.endId,
      name: name ?? this.name
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteLevelInfo &&
    other.runtimeType == runtimeType &&
    other.beginId == beginId &&
    other.endId == endId &&
    other.name == name;

  @override
  int get hashCode {
    return Object.hash(beginId, endId, name);
  }

}
final class _CRouteLevelInfo extends ffi.Struct {
  external _COptional_CLevelId beginId;

  external _COptional_CLevelId endId;

  external _CString name;

}
// MARK: - RouteLevelInfo <-> _CRouteLevelInfo

extension _CRouteLevelInfoToDart on _CRouteLevelInfo {
  RouteLevelInfo _toDart() {
    return RouteLevelInfo(
      beginId: this.beginId._toDart(),
      endId: this.endId._toDart(),
      name: this.name._toDart()
    );
  }
}

extension _DartTo_CRouteLevelInfo on RouteLevelInfo {
  _CRouteLevelInfo _copyFromDartTo_CRouteLevelInfo() {
    final res = _CRouteLevelInfoMakeDefault();
    res.beginId = this.beginId._copyFromDartTo_COptional_CLevelId();
    res.endId = this.endId._copyFromDartTo_COptional_CLevelId();
    res.name = this.name._copyFromDartTo_CString();
    return res;
  }
}
extension _CRouteLevelInfoRelease on _CRouteLevelInfo {
  void _releaseIntermediate() {
    name._releaseIntermediate();
  }
}

// MARK: - RouteLevelInfoRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class RouteLevelInfoRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final RouteLevelInfo value;

  const RouteLevelInfoRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  RouteLevelInfoRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    RouteLevelInfo? value
  }) {
    return RouteLevelInfoRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteLevelInfoRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CRouteLevelInfoRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CRouteLevelInfo value;

}
// MARK: - RouteLevelInfoRouteLongEntry <-> _CRouteLevelInfoRouteLongEntry

extension _CRouteLevelInfoRouteLongEntryToDart on _CRouteLevelInfoRouteLongEntry {
  RouteLevelInfoRouteLongEntry _toDart() {
    return RouteLevelInfoRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CRouteLevelInfoRouteLongEntry on RouteLevelInfoRouteLongEntry {
  _CRouteLevelInfoRouteLongEntry _copyFromDartTo_CRouteLevelInfoRouteLongEntry() {
    final res = _CRouteLevelInfoRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CRouteLevelInfo();
    return res;
  }
}
extension _CRouteLevelInfoRouteLongEntryRelease on _CRouteLevelInfoRouteLongEntry {
  void _releaseIntermediate() {
    value._releaseIntermediate();
  }
}

// MARK: - RouteLevelInfoRouteLongEntry? <-> _COptional_CRouteLevelInfoRouteLongEntry

final class _COptional_CRouteLevelInfoRouteLongEntry extends ffi.Struct {
  
  external _CRouteLevelInfoRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRouteLevelInfoRouteLongEntryBasicFunctions on _COptional_CRouteLevelInfoRouteLongEntry {
  void _releaseIntermediate() {
    _COptional_CRouteLevelInfoRouteLongEntry_release(this);
  }
}

extension _COptional_CRouteLevelInfoRouteLongEntryToDart on _COptional_CRouteLevelInfoRouteLongEntry {
  RouteLevelInfoRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRouteLevelInfoRouteLongEntry on RouteLevelInfoRouteLongEntry? {
  _COptional_CRouteLevelInfoRouteLongEntry _copyFromDartTo_COptional_CRouteLevelInfoRouteLongEntry() {
    final cOptional = _COptional_CRouteLevelInfoRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRouteLevelInfoRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<RouteLevelInfoRouteLongEntry> <-> _CArray_CRouteLevelInfoRouteLongEntry

final class _CArray_CRouteLevelInfoRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRouteLevelInfoRouteLongEntryToDart on _CArray_CRouteLevelInfoRouteLongEntry {
  List<RouteLevelInfoRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRouteLevelInfoRouteLongEntry on List<RouteLevelInfoRouteLongEntry> {
  _CArray_CRouteLevelInfoRouteLongEntry _copyFromDartTo_CArray_CRouteLevelInfoRouteLongEntry() {
    final cArray = _CArray_CRouteLevelInfoRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRouteLevelInfoRouteLongEntry();
        _CArray_CRouteLevelInfoRouteLongEntryaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CRouteLevelInfoRouteLongEntryBasicFunctions on _CArray_CRouteLevelInfoRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CRouteLevelInfoRouteLongEntry_release(this);
  }

  static final _listToFill = <RouteLevelInfoRouteLongEntry>[];

  static void _iterate(_CRouteLevelInfoRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<RouteLevelInfoRouteLongEntry> _fillFromC() {
    _forEach_CArray_CRouteLevelInfoRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRouteLevelInfoRouteLongEntry)>(_iterate));
    final result = List<RouteLevelInfoRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - FloatRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class FloatRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CFloatRouteLongAttribute_size(_CFloatRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CFloatRouteLongAttribute_isEmpty(_CFloatRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  FloatRouteLongEntry? get first {
    _COptional_CFloatRouteLongEntry res = _CFloatRouteLongAttribute_first(_CFloatRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  FloatRouteLongEntry? get last {
    _COptional_CFloatRouteLongEntry res = _CFloatRouteLongAttribute_last(_CFloatRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<FloatRouteLongEntry> get entries {
    _CArray_CFloatRouteLongEntry res = _CFloatRouteLongAttribute_entries(_CFloatRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CFloatRouteLongAttribute_releasePtr);

  FloatRouteLongAttribute._raw(this._self);
  factory FloatRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = FloatRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FloatRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CFloatRouteLongAttribute_cg_objectIdentifier(this._self) == _CFloatRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CFloatRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: FloatRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  FloatRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CFloatRouteLongEntry res = _CFloatRouteLongAttribute_entry_CRoutePoint(_CFloatRouteLongAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<FloatRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CFloatRouteLongEntry res = _CFloatRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CFloatRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - FloatRouteLongAttribute <-> CFloatRouteLongAttribute

final class _CFloatRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CFloatRouteLongAttributeBasicFunctions on _CFloatRouteLongAttribute {
  void _releaseIntermediate() {
    _CFloatRouteLongAttribute_release(_impl);
  }

  _CFloatRouteLongAttribute _retain() {
    return _CFloatRouteLongAttribute_retain(_impl);
  }
}

extension _CFloatRouteLongAttributeToDart on _CFloatRouteLongAttribute {
  FloatRouteLongAttribute _toDart() {
    return FloatRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCFloatRouteLongAttribute on FloatRouteLongAttribute {
  _CFloatRouteLongAttribute _copyFromDartTo_CFloatRouteLongAttribute() {
    return (_CFloatRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - FloatRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class FloatRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final double value;

  const FloatRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  FloatRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    double? value
  }) {
    return FloatRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FloatRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CFloatRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  @ffi.Float()
  external double value;

}
// MARK: - FloatRouteLongEntry <-> _CFloatRouteLongEntry

extension _CFloatRouteLongEntryToDart on _CFloatRouteLongEntry {
  FloatRouteLongEntry _toDart() {
    return FloatRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value
    );
  }
}

extension _DartTo_CFloatRouteLongEntry on FloatRouteLongEntry {
  _CFloatRouteLongEntry _copyFromDartTo_CFloatRouteLongEntry() {
    final res = _CFloatRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value;
    return res;
  }
}
extension _CFloatRouteLongEntryRelease on _CFloatRouteLongEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - FloatRouteLongEntry? <-> _COptional_CFloatRouteLongEntry

final class _COptional_CFloatRouteLongEntry extends ffi.Struct {
  
  external _CFloatRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CFloatRouteLongEntryBasicFunctions on _COptional_CFloatRouteLongEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CFloatRouteLongEntryToDart on _COptional_CFloatRouteLongEntry {
  FloatRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CFloatRouteLongEntry on FloatRouteLongEntry? {
  _COptional_CFloatRouteLongEntry _copyFromDartTo_COptional_CFloatRouteLongEntry() {
    final cOptional = _COptional_CFloatRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CFloatRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<FloatRouteLongEntry> <-> _CArray_CFloatRouteLongEntry

final class _CArray_CFloatRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CFloatRouteLongEntryToDart on _CArray_CFloatRouteLongEntry {
  List<FloatRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CFloatRouteLongEntry on List<FloatRouteLongEntry> {
  _CArray_CFloatRouteLongEntry _copyFromDartTo_CArray_CFloatRouteLongEntry() {
    final cArray = _CArray_CFloatRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CFloatRouteLongEntry();
        _CArray_CFloatRouteLongEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CFloatRouteLongEntryBasicFunctions on _CArray_CFloatRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CFloatRouteLongEntry_release(this);
  }

  static final _listToFill = <FloatRouteLongEntry>[];

  static void _iterate(_CFloatRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<FloatRouteLongEntry> _fillFromC() {
    _forEach_CArray_CFloatRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CFloatRouteLongEntry)>(_iterate));
    final result = List<FloatRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RoadRuleRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class RoadRuleRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CRoadRuleRouteLongAttribute_size(_CRoadRuleRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CRoadRuleRouteLongAttribute_isEmpty(_CRoadRuleRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  RoadRuleRouteLongEntry? get first {
    _COptional_CRoadRuleRouteLongEntry res = _CRoadRuleRouteLongAttribute_first(_CRoadRuleRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  RoadRuleRouteLongEntry? get last {
    _COptional_CRoadRuleRouteLongEntry res = _CRoadRuleRouteLongAttribute_last(_CRoadRuleRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<RoadRuleRouteLongEntry> get entries {
    _CArray_CRoadRuleRouteLongEntry res = _CRoadRuleRouteLongAttribute_entries(_CRoadRuleRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadRuleRouteLongAttribute_releasePtr);

  RoadRuleRouteLongAttribute._raw(this._self);
  factory RoadRuleRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadRuleRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadRuleRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CRoadRuleRouteLongAttribute_cg_objectIdentifier(this._self) == _CRoadRuleRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadRuleRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadRuleRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  RoadRuleRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRoadRuleRouteLongEntry res = _CRoadRuleRouteLongAttribute_entry_CRoutePoint(_CRoadRuleRouteLongAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<RoadRuleRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CRoadRuleRouteLongEntry res = _CRoadRuleRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CRoadRuleRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadRuleRouteLongAttribute <-> CRoadRuleRouteLongAttribute

final class _CRoadRuleRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadRuleRouteLongAttributeBasicFunctions on _CRoadRuleRouteLongAttribute {
  void _releaseIntermediate() {
    _CRoadRuleRouteLongAttribute_release(_impl);
  }

  _CRoadRuleRouteLongAttribute _retain() {
    return _CRoadRuleRouteLongAttribute_retain(_impl);
  }
}

extension _CRoadRuleRouteLongAttributeToDart on _CRoadRuleRouteLongAttribute {
  RoadRuleRouteLongAttribute _toDart() {
    return RoadRuleRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCRoadRuleRouteLongAttribute on RoadRuleRouteLongAttribute {
  _CRoadRuleRouteLongAttribute _copyFromDartTo_CRoadRuleRouteLongAttribute() {
    return (_CRoadRuleRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadRule

/** Сторона движения. */
enum RoadRule {
  /** Неизвестна. */
  unknown(0),
  /** Правостороннее движение. */
  rightHandTraffic(1),
  /** Левостороннее движение. */
  leftHandTraffic(2),
  ;

  const RoadRule(this.rawValue);
  final int rawValue;

  static RoadRule getByValue(int value) {
    return RoadRule.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoadRule extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoadRuleBasicFunctions on _CRoadRule {
  void _releaseIntermediate() {
  }
}

extension _CRoadRuleToDart on _CRoadRule {
  RoadRule _toDart() {
    return RoadRule.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoadRule on RoadRule {
  _CRoadRule _copyFromDartTo_CRoadRule() {
    return _CRoadRuleMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RoadRuleRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class RoadRuleRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final RoadRule value;

  const RoadRuleRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  RoadRuleRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    RoadRule? value
  }) {
    return RoadRuleRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadRuleRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CRoadRuleRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CRoadRule value;

}
// MARK: - RoadRuleRouteLongEntry <-> _CRoadRuleRouteLongEntry

extension _CRoadRuleRouteLongEntryToDart on _CRoadRuleRouteLongEntry {
  RoadRuleRouteLongEntry _toDart() {
    return RoadRuleRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CRoadRuleRouteLongEntry on RoadRuleRouteLongEntry {
  _CRoadRuleRouteLongEntry _copyFromDartTo_CRoadRuleRouteLongEntry() {
    final res = _CRoadRuleRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CRoadRule();
    return res;
  }
}
extension _CRoadRuleRouteLongEntryRelease on _CRoadRuleRouteLongEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - RoadRuleRouteLongEntry? <-> _COptional_CRoadRuleRouteLongEntry

final class _COptional_CRoadRuleRouteLongEntry extends ffi.Struct {
  
  external _CRoadRuleRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRoadRuleRouteLongEntryBasicFunctions on _COptional_CRoadRuleRouteLongEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CRoadRuleRouteLongEntryToDart on _COptional_CRoadRuleRouteLongEntry {
  RoadRuleRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRoadRuleRouteLongEntry on RoadRuleRouteLongEntry? {
  _COptional_CRoadRuleRouteLongEntry _copyFromDartTo_COptional_CRoadRuleRouteLongEntry() {
    final cOptional = _COptional_CRoadRuleRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRoadRuleRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<RoadRuleRouteLongEntry> <-> _CArray_CRoadRuleRouteLongEntry

final class _CArray_CRoadRuleRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRoadRuleRouteLongEntryToDart on _CArray_CRoadRuleRouteLongEntry {
  List<RoadRuleRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRoadRuleRouteLongEntry on List<RoadRuleRouteLongEntry> {
  _CArray_CRoadRuleRouteLongEntry _copyFromDartTo_CArray_CRoadRuleRouteLongEntry() {
    final cArray = _CArray_CRoadRuleRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRoadRuleRouteLongEntry();
        _CArray_CRoadRuleRouteLongEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CRoadRuleRouteLongEntryBasicFunctions on _CArray_CRoadRuleRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CRoadRuleRouteLongEntry_release(this);
  }

  static final _listToFill = <RoadRuleRouteLongEntry>[];

  static void _iterate(_CRoadRuleRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<RoadRuleRouteLongEntry> _fillFromC() {
    _forEach_CArray_CRoadRuleRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRoadRuleRouteLongEntry)>(_iterate));
    final result = List<RoadRuleRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RoadSubtypeRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class RoadSubtypeRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CRoadSubtypeRouteLongAttribute_size(_CRoadSubtypeRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CRoadSubtypeRouteLongAttribute_isEmpty(_CRoadSubtypeRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  RoadSubtypeRouteLongEntry? get first {
    _COptional_CRoadSubtypeRouteLongEntry res = _CRoadSubtypeRouteLongAttribute_first(_CRoadSubtypeRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  RoadSubtypeRouteLongEntry? get last {
    _COptional_CRoadSubtypeRouteLongEntry res = _CRoadSubtypeRouteLongAttribute_last(_CRoadSubtypeRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<RoadSubtypeRouteLongEntry> get entries {
    _CArray_CRoadSubtypeRouteLongEntry res = _CRoadSubtypeRouteLongAttribute_entries(_CRoadSubtypeRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadSubtypeRouteLongAttribute_releasePtr);

  RoadSubtypeRouteLongAttribute._raw(this._self);
  factory RoadSubtypeRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadSubtypeRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadSubtypeRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CRoadSubtypeRouteLongAttribute_cg_objectIdentifier(this._self) == _CRoadSubtypeRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadSubtypeRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadSubtypeRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  RoadSubtypeRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRoadSubtypeRouteLongEntry res = _CRoadSubtypeRouteLongAttribute_entry_CRoutePoint(_CRoadSubtypeRouteLongAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<RoadSubtypeRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CRoadSubtypeRouteLongEntry res = _CRoadSubtypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CRoadSubtypeRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadSubtypeRouteLongAttribute <-> CRoadSubtypeRouteLongAttribute

final class _CRoadSubtypeRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadSubtypeRouteLongAttributeBasicFunctions on _CRoadSubtypeRouteLongAttribute {
  void _releaseIntermediate() {
    _CRoadSubtypeRouteLongAttribute_release(_impl);
  }

  _CRoadSubtypeRouteLongAttribute _retain() {
    return _CRoadSubtypeRouteLongAttribute_retain(_impl);
  }
}

extension _CRoadSubtypeRouteLongAttributeToDart on _CRoadSubtypeRouteLongAttribute {
  RoadSubtypeRouteLongAttribute _toDart() {
    return RoadSubtypeRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCRoadSubtypeRouteLongAttribute on RoadSubtypeRouteLongAttribute {
  _CRoadSubtypeRouteLongAttribute _copyFromDartTo_CRoadSubtypeRouteLongAttribute() {
    return (_CRoadSubtypeRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadSubtype

/** Дополнительное описание типа дороги, по которой пролегает маршрут. */
enum RoadSubtype {
  /** Дополнительное описание типа дороги отсутствует. */
  none(0),
  /** Aрка. */
  archway(1),
  /** Мост. */
  bridge(2),
  /** Пешеходный переход. */
  crosswalk(3),
  /** Пешеходный мост. */
  footbridge(4),
  /** Брод. */
  ford(5),
  /** Помещение. */
  indoor(6),
  /** Надземный переход. */
  overgroundCrossing(7),
  /** Парковая тропинка. */
  parkFootpath(8),
  /** Парковая дорога. */
  parkPath(9),
  /** Жилая территория. */
  residentialArea(10),
  /** Лестница, направленная вверх. */
  stairwayUp(11),
  /** Лестница, направленная вниз. */
  stairwayDown(12),
  /** Переход метро. */
  subwayCrossing(13),
  /** Туннель. */
  tunnel(14),
  /** Подземный переход. */
  underpass(15),
  ;

  const RoadSubtype(this.rawValue);
  final int rawValue;

  static RoadSubtype getByValue(int value) {
    return RoadSubtype.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoadSubtype extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoadSubtypeBasicFunctions on _CRoadSubtype {
  void _releaseIntermediate() {
  }
}

extension _CRoadSubtypeToDart on _CRoadSubtype {
  RoadSubtype _toDart() {
    return RoadSubtype.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoadSubtype on RoadSubtype {
  _CRoadSubtype _copyFromDartTo_CRoadSubtype() {
    return _CRoadSubtypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RoadSubtypeRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class RoadSubtypeRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final RoadSubtype value;

  const RoadSubtypeRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  RoadSubtypeRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    RoadSubtype? value
  }) {
    return RoadSubtypeRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadSubtypeRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CRoadSubtypeRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CRoadSubtype value;

}
// MARK: - RoadSubtypeRouteLongEntry <-> _CRoadSubtypeRouteLongEntry

extension _CRoadSubtypeRouteLongEntryToDart on _CRoadSubtypeRouteLongEntry {
  RoadSubtypeRouteLongEntry _toDart() {
    return RoadSubtypeRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CRoadSubtypeRouteLongEntry on RoadSubtypeRouteLongEntry {
  _CRoadSubtypeRouteLongEntry _copyFromDartTo_CRoadSubtypeRouteLongEntry() {
    final res = _CRoadSubtypeRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CRoadSubtype();
    return res;
  }
}
extension _CRoadSubtypeRouteLongEntryRelease on _CRoadSubtypeRouteLongEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - RoadSubtypeRouteLongEntry? <-> _COptional_CRoadSubtypeRouteLongEntry

final class _COptional_CRoadSubtypeRouteLongEntry extends ffi.Struct {
  
  external _CRoadSubtypeRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRoadSubtypeRouteLongEntryBasicFunctions on _COptional_CRoadSubtypeRouteLongEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CRoadSubtypeRouteLongEntryToDart on _COptional_CRoadSubtypeRouteLongEntry {
  RoadSubtypeRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRoadSubtypeRouteLongEntry on RoadSubtypeRouteLongEntry? {
  _COptional_CRoadSubtypeRouteLongEntry _copyFromDartTo_COptional_CRoadSubtypeRouteLongEntry() {
    final cOptional = _COptional_CRoadSubtypeRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRoadSubtypeRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<RoadSubtypeRouteLongEntry> <-> _CArray_CRoadSubtypeRouteLongEntry

final class _CArray_CRoadSubtypeRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRoadSubtypeRouteLongEntryToDart on _CArray_CRoadSubtypeRouteLongEntry {
  List<RoadSubtypeRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRoadSubtypeRouteLongEntry on List<RoadSubtypeRouteLongEntry> {
  _CArray_CRoadSubtypeRouteLongEntry _copyFromDartTo_CArray_CRoadSubtypeRouteLongEntry() {
    final cArray = _CArray_CRoadSubtypeRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRoadSubtypeRouteLongEntry();
        _CArray_CRoadSubtypeRouteLongEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CRoadSubtypeRouteLongEntryBasicFunctions on _CArray_CRoadSubtypeRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CRoadSubtypeRouteLongEntry_release(this);
  }

  static final _listToFill = <RoadSubtypeRouteLongEntry>[];

  static void _iterate(_CRoadSubtypeRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<RoadSubtypeRouteLongEntry> _fillFromC() {
    _forEach_CArray_CRoadSubtypeRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRoadSubtypeRouteLongEntry)>(_iterate));
    final result = List<RoadSubtypeRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RoadSurfaceRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class RoadSurfaceRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CRoadSurfaceRouteLongAttribute_size(_CRoadSurfaceRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CRoadSurfaceRouteLongAttribute_isEmpty(_CRoadSurfaceRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  RoadSurfaceRouteLongEntry? get first {
    _COptional_CRoadSurfaceRouteLongEntry res = _CRoadSurfaceRouteLongAttribute_first(_CRoadSurfaceRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  RoadSurfaceRouteLongEntry? get last {
    _COptional_CRoadSurfaceRouteLongEntry res = _CRoadSurfaceRouteLongAttribute_last(_CRoadSurfaceRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<RoadSurfaceRouteLongEntry> get entries {
    _CArray_CRoadSurfaceRouteLongEntry res = _CRoadSurfaceRouteLongAttribute_entries(_CRoadSurfaceRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadSurfaceRouteLongAttribute_releasePtr);

  RoadSurfaceRouteLongAttribute._raw(this._self);
  factory RoadSurfaceRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadSurfaceRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadSurfaceRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CRoadSurfaceRouteLongAttribute_cg_objectIdentifier(this._self) == _CRoadSurfaceRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadSurfaceRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadSurfaceRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  RoadSurfaceRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRoadSurfaceRouteLongEntry res = _CRoadSurfaceRouteLongAttribute_entry_CRoutePoint(_CRoadSurfaceRouteLongAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<RoadSurfaceRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CRoadSurfaceRouteLongEntry res = _CRoadSurfaceRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CRoadSurfaceRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadSurfaceRouteLongAttribute <-> CRoadSurfaceRouteLongAttribute

final class _CRoadSurfaceRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadSurfaceRouteLongAttributeBasicFunctions on _CRoadSurfaceRouteLongAttribute {
  void _releaseIntermediate() {
    _CRoadSurfaceRouteLongAttribute_release(_impl);
  }

  _CRoadSurfaceRouteLongAttribute _retain() {
    return _CRoadSurfaceRouteLongAttribute_retain(_impl);
  }
}

extension _CRoadSurfaceRouteLongAttributeToDart on _CRoadSurfaceRouteLongAttribute {
  RoadSurfaceRouteLongAttribute _toDart() {
    return RoadSurfaceRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCRoadSurfaceRouteLongAttribute on RoadSurfaceRouteLongAttribute {
  _CRoadSurfaceRouteLongAttribute _copyFromDartTo_CRoadSurfaceRouteLongAttribute() {
    return (_CRoadSurfaceRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadSurface

/** Покрытие дороги. */
enum RoadSurface {
  /** Неизвестно. */
  unknown(0),
  /** Асфальт. */
  asphalt(1),
  /** Гравий. */
  gravel(2),
  /** Грунт. */
  ground(3),
  /** Бетон. */
  concrete(4),
  ;

  const RoadSurface(this.rawValue);
  final int rawValue;

  static RoadSurface getByValue(int value) {
    return RoadSurface.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoadSurface extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoadSurfaceBasicFunctions on _CRoadSurface {
  void _releaseIntermediate() {
  }
}

extension _CRoadSurfaceToDart on _CRoadSurface {
  RoadSurface _toDart() {
    return RoadSurface.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoadSurface on RoadSurface {
  _CRoadSurface _copyFromDartTo_CRoadSurface() {
    return _CRoadSurfaceMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RoadSurfaceRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class RoadSurfaceRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final RoadSurface value;

  const RoadSurfaceRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  RoadSurfaceRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    RoadSurface? value
  }) {
    return RoadSurfaceRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadSurfaceRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CRoadSurfaceRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CRoadSurface value;

}
// MARK: - RoadSurfaceRouteLongEntry <-> _CRoadSurfaceRouteLongEntry

extension _CRoadSurfaceRouteLongEntryToDart on _CRoadSurfaceRouteLongEntry {
  RoadSurfaceRouteLongEntry _toDart() {
    return RoadSurfaceRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CRoadSurfaceRouteLongEntry on RoadSurfaceRouteLongEntry {
  _CRoadSurfaceRouteLongEntry _copyFromDartTo_CRoadSurfaceRouteLongEntry() {
    final res = _CRoadSurfaceRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CRoadSurface();
    return res;
  }
}
extension _CRoadSurfaceRouteLongEntryRelease on _CRoadSurfaceRouteLongEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - RoadSurfaceRouteLongEntry? <-> _COptional_CRoadSurfaceRouteLongEntry

final class _COptional_CRoadSurfaceRouteLongEntry extends ffi.Struct {
  
  external _CRoadSurfaceRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRoadSurfaceRouteLongEntryBasicFunctions on _COptional_CRoadSurfaceRouteLongEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CRoadSurfaceRouteLongEntryToDart on _COptional_CRoadSurfaceRouteLongEntry {
  RoadSurfaceRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRoadSurfaceRouteLongEntry on RoadSurfaceRouteLongEntry? {
  _COptional_CRoadSurfaceRouteLongEntry _copyFromDartTo_COptional_CRoadSurfaceRouteLongEntry() {
    final cOptional = _COptional_CRoadSurfaceRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRoadSurfaceRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<RoadSurfaceRouteLongEntry> <-> _CArray_CRoadSurfaceRouteLongEntry

final class _CArray_CRoadSurfaceRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRoadSurfaceRouteLongEntryToDart on _CArray_CRoadSurfaceRouteLongEntry {
  List<RoadSurfaceRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRoadSurfaceRouteLongEntry on List<RoadSurfaceRouteLongEntry> {
  _CArray_CRoadSurfaceRouteLongEntry _copyFromDartTo_CArray_CRoadSurfaceRouteLongEntry() {
    final cArray = _CArray_CRoadSurfaceRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRoadSurfaceRouteLongEntry();
        _CArray_CRoadSurfaceRouteLongEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CRoadSurfaceRouteLongEntryBasicFunctions on _CArray_CRoadSurfaceRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CRoadSurfaceRouteLongEntry_release(this);
  }

  static final _listToFill = <RoadSurfaceRouteLongEntry>[];

  static void _iterate(_CRoadSurfaceRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<RoadSurfaceRouteLongEntry> _fillFromC() {
    _forEach_CArray_CRoadSurfaceRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRoadSurfaceRouteLongEntry)>(_iterate));
    final result = List<RoadSurfaceRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RoadTypeRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class RoadTypeRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CRoadTypeRouteLongAttribute_size(_CRoadTypeRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CRoadTypeRouteLongAttribute_isEmpty(_CRoadTypeRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  RoadTypeRouteLongEntry? get first {
    _COptional_CRoadTypeRouteLongEntry res = _CRoadTypeRouteLongAttribute_first(_CRoadTypeRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  RoadTypeRouteLongEntry? get last {
    _COptional_CRoadTypeRouteLongEntry res = _CRoadTypeRouteLongAttribute_last(_CRoadTypeRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<RoadTypeRouteLongEntry> get entries {
    _CArray_CRoadTypeRouteLongEntry res = _CRoadTypeRouteLongAttribute_entries(_CRoadTypeRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadTypeRouteLongAttribute_releasePtr);

  RoadTypeRouteLongAttribute._raw(this._self);
  factory RoadTypeRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadTypeRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadTypeRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CRoadTypeRouteLongAttribute_cg_objectIdentifier(this._self) == _CRoadTypeRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadTypeRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadTypeRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  RoadTypeRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRoadTypeRouteLongEntry res = _CRoadTypeRouteLongAttribute_entry_CRoutePoint(_CRoadTypeRouteLongAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<RoadTypeRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CRoadTypeRouteLongEntry res = _CRoadTypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CRoadTypeRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadTypeRouteLongAttribute <-> CRoadTypeRouteLongAttribute

final class _CRoadTypeRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadTypeRouteLongAttributeBasicFunctions on _CRoadTypeRouteLongAttribute {
  void _releaseIntermediate() {
    _CRoadTypeRouteLongAttribute_release(_impl);
  }

  _CRoadTypeRouteLongAttribute _retain() {
    return _CRoadTypeRouteLongAttribute_retain(_impl);
  }
}

extension _CRoadTypeRouteLongAttributeToDart on _CRoadTypeRouteLongAttribute {
  RoadTypeRouteLongAttribute _toDart() {
    return RoadTypeRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCRoadTypeRouteLongAttribute on RoadTypeRouteLongAttribute {
  _CRoadTypeRouteLongAttribute _copyFromDartTo_CRoadTypeRouteLongAttribute() {
    return (_CRoadTypeRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadType

/** Описывает тип дороги, по которой пролегает маршрут. */
enum RoadType {
  /** Неизвестен. */
  unknown(0),
  /** Пешеходная дорожка либо участок дороги, на котором разрешено движение пешеходов. */
  walkway(1),
  /** Велосипедная дорожка либо участок дороги, на котором разрешено движение велосипедов. */
  bikeway(2),
  /** Автомобильная дорога минимальной значимости. */
  pathway(3),
  /** Полевая или лесная дорога. */
  fieldForestRoad(4),
  /** Подъездная дорога/внутриквартальный проезд. */
  serviceRoad(5),
  /** Автомобильная дорога, проходящая по прочим улицам населённого пункта. */
  otherStreetRoad(6),
  /** Автомобильная дорога, проходящая по основным улицам населённого пункта. */
  mainStreetRoad(7),
  /** Шоссе. */
  highway(8),
  /** Междугородняя трасса. */
  intercityRoad(9),
  /** Дорога федерального значения. */
  federalRoad(10),
  ;

  const RoadType(this.rawValue);
  final int rawValue;

  static RoadType getByValue(int value) {
    return RoadType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoadType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoadTypeBasicFunctions on _CRoadType {
  void _releaseIntermediate() {
  }
}

extension _CRoadTypeToDart on _CRoadType {
  RoadType _toDart() {
    return RoadType.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoadType on RoadType {
  _CRoadType _copyFromDartTo_CRoadType() {
    return _CRoadTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RoadTypeRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class RoadTypeRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final RoadType value;

  const RoadTypeRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  RoadTypeRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    RoadType? value
  }) {
    return RoadTypeRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadTypeRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CRoadTypeRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CRoadType value;

}
// MARK: - RoadTypeRouteLongEntry <-> _CRoadTypeRouteLongEntry

extension _CRoadTypeRouteLongEntryToDart on _CRoadTypeRouteLongEntry {
  RoadTypeRouteLongEntry _toDart() {
    return RoadTypeRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CRoadTypeRouteLongEntry on RoadTypeRouteLongEntry {
  _CRoadTypeRouteLongEntry _copyFromDartTo_CRoadTypeRouteLongEntry() {
    final res = _CRoadTypeRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CRoadType();
    return res;
  }
}
extension _CRoadTypeRouteLongEntryRelease on _CRoadTypeRouteLongEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - RoadTypeRouteLongEntry? <-> _COptional_CRoadTypeRouteLongEntry

final class _COptional_CRoadTypeRouteLongEntry extends ffi.Struct {
  
  external _CRoadTypeRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRoadTypeRouteLongEntryBasicFunctions on _COptional_CRoadTypeRouteLongEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CRoadTypeRouteLongEntryToDart on _COptional_CRoadTypeRouteLongEntry {
  RoadTypeRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRoadTypeRouteLongEntry on RoadTypeRouteLongEntry? {
  _COptional_CRoadTypeRouteLongEntry _copyFromDartTo_COptional_CRoadTypeRouteLongEntry() {
    final cOptional = _COptional_CRoadTypeRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRoadTypeRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<RoadTypeRouteLongEntry> <-> _CArray_CRoadTypeRouteLongEntry

final class _CArray_CRoadTypeRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRoadTypeRouteLongEntryToDart on _CArray_CRoadTypeRouteLongEntry {
  List<RoadTypeRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRoadTypeRouteLongEntry on List<RoadTypeRouteLongEntry> {
  _CArray_CRoadTypeRouteLongEntry _copyFromDartTo_CArray_CRoadTypeRouteLongEntry() {
    final cArray = _CArray_CRoadTypeRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRoadTypeRouteLongEntry();
        _CArray_CRoadTypeRouteLongEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CRoadTypeRouteLongEntryBasicFunctions on _CArray_CRoadTypeRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CRoadTypeRouteLongEntry_release(this);
  }

  static final _listToFill = <RoadTypeRouteLongEntry>[];

  static void _iterate(_CRoadTypeRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<RoadTypeRouteLongEntry> _fillFromC() {
    _forEach_CArray_CRoadTypeRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRoadTypeRouteLongEntry)>(_iterate));
    final result = List<RoadTypeRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - TruckPassZoneIdRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class TruckPassZoneIdRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CTruckPassZoneIdRouteLongAttribute_size(_CTruckPassZoneIdRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CTruckPassZoneIdRouteLongAttribute_isEmpty(_CTruckPassZoneIdRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  TruckPassZoneIdRouteLongEntry? get first {
    _COptional_CTruckPassZoneIdRouteLongEntry res = _CTruckPassZoneIdRouteLongAttribute_first(_CTruckPassZoneIdRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  TruckPassZoneIdRouteLongEntry? get last {
    _COptional_CTruckPassZoneIdRouteLongEntry res = _CTruckPassZoneIdRouteLongAttribute_last(_CTruckPassZoneIdRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<TruckPassZoneIdRouteLongEntry> get entries {
    _CArray_CTruckPassZoneIdRouteLongEntry res = _CTruckPassZoneIdRouteLongAttribute_entries(_CTruckPassZoneIdRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CTruckPassZoneIdRouteLongAttribute_releasePtr);

  TruckPassZoneIdRouteLongAttribute._raw(this._self);
  factory TruckPassZoneIdRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TruckPassZoneIdRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TruckPassZoneIdRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CTruckPassZoneIdRouteLongAttribute_cg_objectIdentifier(this._self) == _CTruckPassZoneIdRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTruckPassZoneIdRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: TruckPassZoneIdRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  TruckPassZoneIdRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CTruckPassZoneIdRouteLongEntry res = _CTruckPassZoneIdRouteLongAttribute_entry_CRoutePoint(_CTruckPassZoneIdRouteLongAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<TruckPassZoneIdRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CTruckPassZoneIdRouteLongEntry res = _CTruckPassZoneIdRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CTruckPassZoneIdRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - TruckPassZoneIdRouteLongAttribute <-> CTruckPassZoneIdRouteLongAttribute

final class _CTruckPassZoneIdRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTruckPassZoneIdRouteLongAttributeBasicFunctions on _CTruckPassZoneIdRouteLongAttribute {
  void _releaseIntermediate() {
    _CTruckPassZoneIdRouteLongAttribute_release(_impl);
  }

  _CTruckPassZoneIdRouteLongAttribute _retain() {
    return _CTruckPassZoneIdRouteLongAttribute_retain(_impl);
  }
}

extension _CTruckPassZoneIdRouteLongAttributeToDart on _CTruckPassZoneIdRouteLongAttribute {
  TruckPassZoneIdRouteLongAttribute _toDart() {
    return TruckPassZoneIdRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCTruckPassZoneIdRouteLongAttribute on TruckPassZoneIdRouteLongAttribute {
  _CTruckPassZoneIdRouteLongAttribute _copyFromDartTo_CTruckPassZoneIdRouteLongAttribute() {
    return (_CTruckPassZoneIdRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - TruckPassZoneId

/**
 Идентификатор пропускной зоны для грузовиков.
 Значение 0 соответствует отсутствию пропускной зоны.
*/
class TruckPassZoneId {
  final int value;

  const TruckPassZoneId([this.value = 0]);

  TruckPassZoneId copyWith({
    int? value
  }) {
    return TruckPassZoneId(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TruckPassZoneId &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CTruckPassZoneId extends ffi.Struct {
  @ffi.Uint32()
  external int value;

}
// MARK: - TruckPassZoneId <-> _CTruckPassZoneId

extension _CTruckPassZoneIdToDart on _CTruckPassZoneId {
  TruckPassZoneId _toDart() {
    return TruckPassZoneId(
      this.value
    );
  }
}

extension _DartTo_CTruckPassZoneId on TruckPassZoneId {
  _CTruckPassZoneId _copyFromDartTo_CTruckPassZoneId() {
    final res = _CTruckPassZoneIdMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CTruckPassZoneIdRelease on _CTruckPassZoneId {
  void _releaseIntermediate() {
  }
}

// MARK: - TruckPassZoneIdRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class TruckPassZoneIdRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final TruckPassZoneId value;

  const TruckPassZoneIdRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  TruckPassZoneIdRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    TruckPassZoneId? value
  }) {
    return TruckPassZoneIdRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TruckPassZoneIdRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CTruckPassZoneIdRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CTruckPassZoneId value;

}
// MARK: - TruckPassZoneIdRouteLongEntry <-> _CTruckPassZoneIdRouteLongEntry

extension _CTruckPassZoneIdRouteLongEntryToDart on _CTruckPassZoneIdRouteLongEntry {
  TruckPassZoneIdRouteLongEntry _toDart() {
    return TruckPassZoneIdRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CTruckPassZoneIdRouteLongEntry on TruckPassZoneIdRouteLongEntry {
  _CTruckPassZoneIdRouteLongEntry _copyFromDartTo_CTruckPassZoneIdRouteLongEntry() {
    final res = _CTruckPassZoneIdRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CTruckPassZoneId();
    return res;
  }
}
extension _CTruckPassZoneIdRouteLongEntryRelease on _CTruckPassZoneIdRouteLongEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - TruckPassZoneIdRouteLongEntry? <-> _COptional_CTruckPassZoneIdRouteLongEntry

final class _COptional_CTruckPassZoneIdRouteLongEntry extends ffi.Struct {
  
  external _CTruckPassZoneIdRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CTruckPassZoneIdRouteLongEntryBasicFunctions on _COptional_CTruckPassZoneIdRouteLongEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CTruckPassZoneIdRouteLongEntryToDart on _COptional_CTruckPassZoneIdRouteLongEntry {
  TruckPassZoneIdRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CTruckPassZoneIdRouteLongEntry on TruckPassZoneIdRouteLongEntry? {
  _COptional_CTruckPassZoneIdRouteLongEntry _copyFromDartTo_COptional_CTruckPassZoneIdRouteLongEntry() {
    final cOptional = _COptional_CTruckPassZoneIdRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CTruckPassZoneIdRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<TruckPassZoneIdRouteLongEntry> <-> _CArray_CTruckPassZoneIdRouteLongEntry

final class _CArray_CTruckPassZoneIdRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CTruckPassZoneIdRouteLongEntryToDart on _CArray_CTruckPassZoneIdRouteLongEntry {
  List<TruckPassZoneIdRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CTruckPassZoneIdRouteLongEntry on List<TruckPassZoneIdRouteLongEntry> {
  _CArray_CTruckPassZoneIdRouteLongEntry _copyFromDartTo_CArray_CTruckPassZoneIdRouteLongEntry() {
    final cArray = _CArray_CTruckPassZoneIdRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CTruckPassZoneIdRouteLongEntry();
        _CArray_CTruckPassZoneIdRouteLongEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CTruckPassZoneIdRouteLongEntryBasicFunctions on _CArray_CTruckPassZoneIdRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CTruckPassZoneIdRouteLongEntry_release(this);
  }

  static final _listToFill = <TruckPassZoneIdRouteLongEntry>[];

  static void _iterate(_CTruckPassZoneIdRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<TruckPassZoneIdRouteLongEntry> _fillFromC() {
    _forEach_CArray_CTruckPassZoneIdRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CTruckPassZoneIdRouteLongEntry)>(_iterate));
    final result = List<TruckPassZoneIdRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - PublicTransportTransferRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class PublicTransportTransferRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CPublicTransportTransferRouteLongAttribute_size(_CPublicTransportTransferRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CPublicTransportTransferRouteLongAttribute_isEmpty(_CPublicTransportTransferRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  PublicTransportTransferRouteLongEntry? get first {
    _COptional_CPublicTransportTransferRouteLongEntry res = _CPublicTransportTransferRouteLongAttribute_first(_CPublicTransportTransferRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Последний элемент. */
  PublicTransportTransferRouteLongEntry? get last {
    _COptional_CPublicTransportTransferRouteLongEntry res = _CPublicTransportTransferRouteLongAttribute_last(_CPublicTransportTransferRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Все элементы. */
  List<PublicTransportTransferRouteLongEntry> get entries {
    _CArray_CPublicTransportTransferRouteLongEntry res = _CPublicTransportTransferRouteLongAttribute_entries(_CPublicTransportTransferRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPublicTransportTransferRouteLongAttribute_releasePtr);

  PublicTransportTransferRouteLongAttribute._raw(this._self);
  factory PublicTransportTransferRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PublicTransportTransferRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PublicTransportTransferRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CPublicTransportTransferRouteLongAttribute_cg_objectIdentifier(this._self) == _CPublicTransportTransferRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPublicTransportTransferRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: PublicTransportTransferRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  PublicTransportTransferRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CPublicTransportTransferRouteLongEntry res = _CPublicTransportTransferRouteLongAttribute_entry_CRoutePoint(_CPublicTransportTransferRouteLongAttributeMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<PublicTransportTransferRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CPublicTransportTransferRouteLongEntry res = _CPublicTransportTransferRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CPublicTransportTransferRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - PublicTransportTransferRouteLongAttribute <-> CPublicTransportTransferRouteLongAttribute

final class _CPublicTransportTransferRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPublicTransportTransferRouteLongAttributeBasicFunctions on _CPublicTransportTransferRouteLongAttribute {
  void _releaseIntermediate() {
    _CPublicTransportTransferRouteLongAttribute_release(_impl);
  }

  _CPublicTransportTransferRouteLongAttribute _retain() {
    return _CPublicTransportTransferRouteLongAttribute_retain(_impl);
  }
}

extension _CPublicTransportTransferRouteLongAttributeToDart on _CPublicTransportTransferRouteLongAttribute {
  PublicTransportTransferRouteLongAttribute _toDart() {
    return PublicTransportTransferRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCPublicTransportTransferRouteLongAttribute on PublicTransportTransferRouteLongAttribute {
  _CPublicTransportTransferRouteLongAttribute _copyFromDartTo_CPublicTransportTransferRouteLongAttribute() {
    return (_CPublicTransportTransferRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<PublicRoutePart> <-> _CArray_CPublicRoutePart

final class _CArray_CPublicRoutePart extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CPublicRoutePartToDart on _CArray_CPublicRoutePart {
  List<PublicRoutePart> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CPublicRoutePart on List<PublicRoutePart> {
  _CArray_CPublicRoutePart _copyFromDartTo_CArray_CPublicRoutePart() {
    final cArray = _CArray_CPublicRoutePartmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CPublicRoutePart();
        _CArray_CPublicRoutePartaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CPublicRoutePartBasicFunctions on _CArray_CPublicRoutePart {
  void _releaseIntermediate() {
    _CArray_CPublicRoutePart_release(this);
  }

  static final _listToFill = <PublicRoutePart>[];

  static void _iterate(_CPublicRoutePart item) {
    _listToFill.add(item._toDart());
  }

  List<PublicRoutePart> _fillFromC() {
    _forEach_CArray_CPublicRoutePart(this, ffi.Pointer.fromFunction<ffi.Void Function(_CPublicRoutePart)>(_iterate));
    final result = List<PublicRoutePart>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - PublicTransportTransfer

/** Описание способа добраться на общественном транспорте до следующей точки пересадки. */
class PublicTransportTransfer {
  /** Название точки, из которой начинается движение для данного участка маршрута. */
  final String startPointName;
  /** Название точки назначения для данного участка маршрута. */
  final String finishPointName;
  /**
   Описание участка маршрута на общественном транспорте, по которому можно добраться до следующей точки пересадки.
  
   - Note: Все участки маршрута из этого списка проходят по одной и той же линии геометрии.
   - Note: Если список пустой, то данный участок маршрута предлагается преодолеть на личном или арендуемом
   транспорте либо пешком.
  */
  final List<PublicRoutePart> routeParts;

  const PublicTransportTransfer({
    required this.startPointName,
    required this.finishPointName,
    required this.routeParts
  });

  PublicTransportTransfer copyWith({
    String? startPointName,
    String? finishPointName,
    List<PublicRoutePart>? routeParts
  }) {
    return PublicTransportTransfer(
      startPointName: startPointName ?? this.startPointName,
      finishPointName: finishPointName ?? this.finishPointName,
      routeParts: routeParts ?? this.routeParts
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PublicTransportTransfer &&
    other.runtimeType == runtimeType &&
    other.startPointName == startPointName &&
    other.finishPointName == finishPointName &&
    other.routeParts == routeParts;

  @override
  int get hashCode {
    return Object.hash(startPointName, finishPointName, routeParts);
  }

}
final class _CPublicTransportTransfer extends ffi.Struct {
  external _CString startPointName;

  external _CString finishPointName;

  external _CArray_CPublicRoutePart routeParts;

}
// MARK: - PublicTransportTransfer <-> _CPublicTransportTransfer

extension _CPublicTransportTransferToDart on _CPublicTransportTransfer {
  PublicTransportTransfer _toDart() {
    return PublicTransportTransfer(
      startPointName: this.startPointName._toDart(),
      finishPointName: this.finishPointName._toDart(),
      routeParts: this.routeParts._toDart()
    );
  }
}

extension _DartTo_CPublicTransportTransfer on PublicTransportTransfer {
  _CPublicTransportTransfer _copyFromDartTo_CPublicTransportTransfer() {
    final res = _CPublicTransportTransferMakeDefault();
    res.startPointName = this.startPointName._copyFromDartTo_CString();
    res.finishPointName = this.finishPointName._copyFromDartTo_CString();
    res.routeParts = this.routeParts._copyFromDartTo_CArray_CPublicRoutePart();
    return res;
  }
}
extension _CPublicTransportTransferRelease on _CPublicTransportTransfer {
  void _releaseIntermediate() {
    startPointName._releaseIntermediate();
    finishPointName._releaseIntermediate();
    routeParts._releaseIntermediate();
  }
}

// MARK: - PublicTransportTransferRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class PublicTransportTransferRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final PublicTransportTransfer value;

  const PublicTransportTransferRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  PublicTransportTransferRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    PublicTransportTransfer? value
  }) {
    return PublicTransportTransferRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PublicTransportTransferRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CPublicTransportTransferRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CPublicTransportTransfer value;

}
// MARK: - PublicTransportTransferRouteLongEntry <-> _CPublicTransportTransferRouteLongEntry

extension _CPublicTransportTransferRouteLongEntryToDart on _CPublicTransportTransferRouteLongEntry {
  PublicTransportTransferRouteLongEntry _toDart() {
    return PublicTransportTransferRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CPublicTransportTransferRouteLongEntry on PublicTransportTransferRouteLongEntry {
  _CPublicTransportTransferRouteLongEntry _copyFromDartTo_CPublicTransportTransferRouteLongEntry() {
    final res = _CPublicTransportTransferRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CPublicTransportTransfer();
    return res;
  }
}
extension _CPublicTransportTransferRouteLongEntryRelease on _CPublicTransportTransferRouteLongEntry {
  void _releaseIntermediate() {
    value._releaseIntermediate();
  }
}

// MARK: - PublicTransportTransferRouteLongEntry? <-> _COptional_CPublicTransportTransferRouteLongEntry

final class _COptional_CPublicTransportTransferRouteLongEntry extends ffi.Struct {
  
  external _CPublicTransportTransferRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CPublicTransportTransferRouteLongEntryBasicFunctions on _COptional_CPublicTransportTransferRouteLongEntry {
  void _releaseIntermediate() {
    _COptional_CPublicTransportTransferRouteLongEntry_release(this);
  }
}

extension _COptional_CPublicTransportTransferRouteLongEntryToDart on _COptional_CPublicTransportTransferRouteLongEntry {
  PublicTransportTransferRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CPublicTransportTransferRouteLongEntry on PublicTransportTransferRouteLongEntry? {
  _COptional_CPublicTransportTransferRouteLongEntry _copyFromDartTo_COptional_CPublicTransportTransferRouteLongEntry() {
    final cOptional = _COptional_CPublicTransportTransferRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CPublicTransportTransferRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<PublicTransportInfo> <-> _CArray_CPublicTransportInfo

final class _CArray_CPublicTransportInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CPublicTransportInfoToDart on _CArray_CPublicTransportInfo {
  List<PublicTransportInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CPublicTransportInfo on List<PublicTransportInfo> {
  _CArray_CPublicTransportInfo _copyFromDartTo_CArray_CPublicTransportInfo() {
    final cArray = _CArray_CPublicTransportInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CPublicTransportInfo();
        _CArray_CPublicTransportInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CPublicTransportInfoBasicFunctions on _CArray_CPublicTransportInfo {
  void _releaseIntermediate() {
    _CArray_CPublicTransportInfo_release(this);
  }

  static final _listToFill = <PublicTransportInfo>[];

  static void _iterate(_CPublicTransportInfo item) {
    _listToFill.add(item._toDart());
  }

  List<PublicTransportInfo> _fillFromC() {
    _forEach_CArray_CPublicTransportInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CPublicTransportInfo)>(_iterate));
    final result = List<PublicTransportInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<PublicTransportStop> <-> _CArray_CPublicTransportStop

final class _CArray_CPublicTransportStop extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CPublicTransportStopToDart on _CArray_CPublicTransportStop {
  List<PublicTransportStop> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CPublicTransportStop on List<PublicTransportStop> {
  _CArray_CPublicTransportStop _copyFromDartTo_CArray_CPublicTransportStop() {
    final cArray = _CArray_CPublicTransportStopmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CPublicTransportStop();
        _CArray_CPublicTransportStopaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CPublicTransportStopBasicFunctions on _CArray_CPublicTransportStop {
  void _releaseIntermediate() {
    _CArray_CPublicTransportStop_release(this);
  }

  static final _listToFill = <PublicTransportStop>[];

  static void _iterate(_CPublicTransportStop item) {
    _listToFill.add(item._toDart());
  }

  List<PublicTransportStop> _fillFromC() {
    _forEach_CArray_CPublicTransportStop(this, ffi.Pointer.fromFunction<ffi.Void Function(_CPublicTransportStop)>(_iterate));
    final result = List<PublicTransportStop>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - PublicRoutePart

/** Описание участка маршрута на общественном транспорте. */
class PublicRoutePart {
  /**
   Виды общественного транспорта, на котором можно проехать данный участок маршрута.
  
   - Note: Если список пустой, то данный участок маршрута предлагается преодолеть на личном или арендуемом
   транспорте либо пешком.
  */
  final List<PublicTransportInfo> transports;
  /**
   Промежуточные остановки, которые транспорт проедет прежде, чем доберется до точки пересадки.
  
   - Note: Остановки отсортированы в порядке следования по маршруту.
   - Note: На этих остановках не нужно выходить.
   - Note: Начальная и конечная остановки не входят в этот список.
  */
  final List<PublicTransportStop> intermediateStops;

  const PublicRoutePart({
    required this.transports,
    required this.intermediateStops
  });

  PublicRoutePart copyWith({
    List<PublicTransportInfo>? transports,
    List<PublicTransportStop>? intermediateStops
  }) {
    return PublicRoutePart(
      transports: transports ?? this.transports,
      intermediateStops: intermediateStops ?? this.intermediateStops
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PublicRoutePart &&
    other.runtimeType == runtimeType &&
    other.transports == transports &&
    other.intermediateStops == intermediateStops;

  @override
  int get hashCode {
    return Object.hash(transports, intermediateStops);
  }

}
final class _CPublicRoutePart extends ffi.Struct {
  external _CArray_CPublicTransportInfo transports;

  external _CArray_CPublicTransportStop intermediateStops;

}
// MARK: - PublicRoutePart <-> _CPublicRoutePart

extension _CPublicRoutePartToDart on _CPublicRoutePart {
  PublicRoutePart _toDart() {
    return PublicRoutePart(
      transports: this.transports._toDart(),
      intermediateStops: this.intermediateStops._toDart()
    );
  }
}

extension _DartTo_CPublicRoutePart on PublicRoutePart {
  _CPublicRoutePart _copyFromDartTo_CPublicRoutePart() {
    final res = _CPublicRoutePartMakeDefault();
    res.transports = this.transports._copyFromDartTo_CArray_CPublicTransportInfo();
    res.intermediateStops = this.intermediateStops._copyFromDartTo_CArray_CPublicTransportStop();
    return res;
  }
}
extension _CPublicRoutePartRelease on _CPublicRoutePart {
  void _releaseIntermediate() {
    transports._releaseIntermediate();
    intermediateStops._releaseIntermediate();
  }
}

// MARK: - PublicTransportType

/** Тип общественного транспорта. */
enum PublicTransportType {
  /** Автобус. */
  bus(1),
  /** Троллейбус. */
  trolleybus(2),
  /** Трамвай. */
  tram(4),
  /** Маршрутное такси. */
  shuttleBus(8),
  /** Метро. */
  metro(16),
  /** Пригородный поезд. */
  suburbanTrain(32),
  /** Фуникулёр. */
  funicularRailway(64),
  /** Монорельс. */
  monorail(128),
  /** Водный транспорт. */
  waterwayTransport(256),
  /** Канатная дорога. */
  cableCar(512),
  /** Скоростной трамвай. */
  speedTram(1024),
  /** Подземный трамвай. */
  premetro(2048),
  /** Лёгкое метро. */
  lightMetro(4096),
  /** Аэроэкспресс. */
  aeroexpress(8192),
  /** Московское центральное кольцо. */
  moscowCentralRing(16384),
  /** Московские центральные диаметры. */
  moscowCentralDiameters(32768),
  ;

  const PublicTransportType(this.rawValue);
  final int rawValue;

  static PublicTransportType getByValue(int value) {
    return PublicTransportType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CPublicTransportType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CPublicTransportTypeBasicFunctions on _CPublicTransportType {
  void _releaseIntermediate() {
  }
}

extension _CPublicTransportTypeToDart on _CPublicTransportType {
  PublicTransportType _toDart() {
    return PublicTransportType.getByValue(this.rawValue);
  }
}

extension _DartTo_CPublicTransportType on PublicTransportType {
  _CPublicTransportType _copyFromDartTo_CPublicTransportType() {
    return _CPublicTransportTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - List<int> <-> _CArray_uint32_t

final class _CArray_uint32_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_uint32_tToDart on _CArray_uint32_t {
  List<int> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_uint32_t on List<int> {
  _CArray_uint32_t _copyFromDartTo_CArray_uint32_t() {
    final cArray = _CArray_uint32_tmakeEmpty();
    forEach((item) {
        final cItem = item;
        _CArray_uint32_taddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_uint32_tBasicFunctions on _CArray_uint32_t {
  void _releaseIntermediate() {
    _CArray_uint32_t_release(this);
  }

  static final _listToFill = <int>[];

  static void _iterate(int item) {
    _listToFill.add(item);
  }

  List<int> _fillFromC() {
    _forEach_CArray_uint32_t(this, ffi.Pointer.fromFunction<ffi.Void Function(ffi.Uint32)>(_iterate));
    final result = List<int>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - PublicTransportInfo

/** Описание общественного транспортного средства. */
class PublicTransportInfo {
  /** Тип общественного транспортного средства. */
  final PublicTransportType type;
  /** Названия маршрутов общественного транспорта, на которых происходит проезд. */
  final List<String> names;
  /**
   Номера вагонов, в которые рекомендуется посадка.
  
   - Note: Если транспортное средство состоит из одного вагона или можно садиться в любой вагон,
   то этот список будет пустым.
  */
  final List<int> suggestedCarNumbers;
  /** Текстовое описание вагонов, в которые рекомендуется посадка. */
  final String boardingSuggest;
  /**
   Argb представление цвета, ассоциированного с данным видом общественного транспорта,
   например, цвет линии метро. При отсутствии информации о цвете в поле будет значение null.
  */
  final int? color;
  /** Идентификатор иконки для остановок маршрута. Пустая строка, если информация недоступна. Техническое поле. */
  final String routeLogo;

  const PublicTransportInfo({
    this.type = PublicTransportType.bus,
    required this.names,
    required this.suggestedCarNumbers,
    required this.boardingSuggest,
    required this.color,
    required this.routeLogo
  });

  PublicTransportInfo copyWith({
    PublicTransportType? type,
    List<String>? names,
    List<int>? suggestedCarNumbers,
    String? boardingSuggest,
    Optional<int?>? color,
    String? routeLogo
  }) {
    return PublicTransportInfo(
      type: type ?? this.type,
      names: names ?? this.names,
      suggestedCarNumbers: suggestedCarNumbers ?? this.suggestedCarNumbers,
      boardingSuggest: boardingSuggest ?? this.boardingSuggest,
      color: color != null ? color.value : this.color,
      routeLogo: routeLogo ?? this.routeLogo
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PublicTransportInfo &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.names == names &&
    other.suggestedCarNumbers == suggestedCarNumbers &&
    other.boardingSuggest == boardingSuggest &&
    other.color == color &&
    other.routeLogo == routeLogo;

  @override
  int get hashCode {
    return Object.hash(type, names, suggestedCarNumbers, boardingSuggest, color, routeLogo);
  }

}
final class _CPublicTransportInfo extends ffi.Struct {
  external _CPublicTransportType type;

  external _CArray_CString names;

  external _CArray_uint32_t suggestedCarNumbers;

  external _CString boardingSuggest;

  external _COptional_uint32_t color;

  external _CString routeLogo;

}
// MARK: - PublicTransportInfo <-> _CPublicTransportInfo

extension _CPublicTransportInfoToDart on _CPublicTransportInfo {
  PublicTransportInfo _toDart() {
    return PublicTransportInfo(
      type: this.type._toDart(),
      names: this.names._toDart(),
      suggestedCarNumbers: this.suggestedCarNumbers._toDart(),
      boardingSuggest: this.boardingSuggest._toDart(),
      color: this.color._toDart(),
      routeLogo: this.routeLogo._toDart()
    );
  }
}

extension _DartTo_CPublicTransportInfo on PublicTransportInfo {
  _CPublicTransportInfo _copyFromDartTo_CPublicTransportInfo() {
    final res = _CPublicTransportInfoMakeDefault();
    res.type = this.type._copyFromDartTo_CPublicTransportType();
    res.names = this.names._copyFromDartTo_CArray_CString();
    res.suggestedCarNumbers = this.suggestedCarNumbers._copyFromDartTo_CArray_uint32_t();
    res.boardingSuggest = this.boardingSuggest._copyFromDartTo_CString();
    res.color = this.color._copyFromDartTo_COptional_uint32_t();
    res.routeLogo = this.routeLogo._copyFromDartTo_CString();
    return res;
  }
}
extension _CPublicTransportInfoRelease on _CPublicTransportInfo {
  void _releaseIntermediate() {
    names._releaseIntermediate();
    suggestedCarNumbers._releaseIntermediate();
    boardingSuggest._releaseIntermediate();
    routeLogo._releaseIntermediate();
  }
}

// MARK: - PublicTransportStop

/** Описание остановки общественного транспорта. */
class PublicTransportStop {
  /** Название остановки. */
  final String name;
  /** Географические координаты остановки. */
  final GeoPoint coordinates;

  const PublicTransportStop({
    required this.name,
    required this.coordinates
  });

  PublicTransportStop copyWith({
    String? name,
    GeoPoint? coordinates
  }) {
    return PublicTransportStop(
      name: name ?? this.name,
      coordinates: coordinates ?? this.coordinates
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PublicTransportStop &&
    other.runtimeType == runtimeType &&
    other.name == name &&
    other.coordinates == coordinates;

  @override
  int get hashCode {
    return Object.hash(name, coordinates);
  }

}
final class _CPublicTransportStop extends ffi.Struct {
  external _CString name;

  external _CGeoPoint coordinates;

}
// MARK: - PublicTransportStop <-> _CPublicTransportStop

extension _CPublicTransportStopToDart on _CPublicTransportStop {
  PublicTransportStop _toDart() {
    return PublicTransportStop(
      name: this.name._toDart(),
      coordinates: this.coordinates._toDart()
    );
  }
}

extension _DartTo_CPublicTransportStop on PublicTransportStop {
  _CPublicTransportStop _copyFromDartTo_CPublicTransportStop() {
    final res = _CPublicTransportStopMakeDefault();
    res.name = this.name._copyFromDartTo_CString();
    res.coordinates = this.coordinates._copyFromDartTo_CGeoPoint();
    return res;
  }
}
extension _CPublicTransportStopRelease on _CPublicTransportStop {
  void _releaseIntermediate() {
    name._releaseIntermediate();
  }
}

// MARK: - List<PublicTransportTransferRouteLongEntry> <-> _CArray_CPublicTransportTransferRouteLongEntry

final class _CArray_CPublicTransportTransferRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CPublicTransportTransferRouteLongEntryToDart on _CArray_CPublicTransportTransferRouteLongEntry {
  List<PublicTransportTransferRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CPublicTransportTransferRouteLongEntry on List<PublicTransportTransferRouteLongEntry> {
  _CArray_CPublicTransportTransferRouteLongEntry _copyFromDartTo_CArray_CPublicTransportTransferRouteLongEntry() {
    final cArray = _CArray_CPublicTransportTransferRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CPublicTransportTransferRouteLongEntry();
        _CArray_CPublicTransportTransferRouteLongEntryaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CPublicTransportTransferRouteLongEntryBasicFunctions on _CArray_CPublicTransportTransferRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CPublicTransportTransferRouteLongEntry_release(this);
  }

  static final _listToFill = <PublicTransportTransferRouteLongEntry>[];

  static void _iterate(_CPublicTransportTransferRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<PublicTransportTransferRouteLongEntry> _fillFromC() {
    _forEach_CArray_CPublicTransportTransferRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CPublicTransportTransferRouteLongEntry)>(_iterate));
    final result = List<PublicTransportTransferRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - Traffic

/** Описание пробочных данных. */
class Traffic implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Длительности движения на участках маршрута.
   0 - длительность движения на участке маршрута неизвестна.
  */
  MillisecondsRouteAttribute get durations {
    _CMillisecondsRouteAttribute res = _CTraffic_durations(_CTrafficMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Цветовое представление скоростей движения ТС на маршруте (протяженный атрибут). */
  TrafficSpeedColorRouteLongAttribute get speedColors {
    _CTrafficSpeedColorRouteLongAttribute res = _CTraffic_speedColors(_CTrafficMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CTraffic_releasePtr);

  Traffic._raw(this._self);
  factory Traffic._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Traffic._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Traffic &&
    other.runtimeType == runtimeType &&
    _CTraffic_cg_objectIdentifier(this._self) == _CTraffic_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTraffic_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Traffic <-> CTraffic

final class _CTraffic extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTrafficBasicFunctions on _CTraffic {
  void _releaseIntermediate() {
    _CTraffic_release(_impl);
  }

  _CTraffic _retain() {
    return _CTraffic_retain(_impl);
  }
}

extension _CTrafficToDart on _CTraffic {
  Traffic _toDart() {
    return Traffic._create(_retain()._impl);
  }
}


extension _DartToCTraffic on Traffic {
  _CTraffic _copyFromDartTo_CTraffic() {
    return (_CTrafficMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MillisecondsRouteAttribute

/**
 Контейнер, который описывает точечный атрибут маршрута.
 Каждый элемент хранится в виде точки на маршруте, в которой этот элемент расположен и значения самого элемента.
*/
class MillisecondsRouteAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CMillisecondsRouteAttribute_size(_CMillisecondsRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CMillisecondsRouteAttribute_isEmpty(_CMillisecondsRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  MillisecondsRouteEntry? get first {
    _COptional_CMillisecondsRouteEntry res = _CMillisecondsRouteAttribute_first(_CMillisecondsRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  MillisecondsRouteEntry? get last {
    _COptional_CMillisecondsRouteEntry res = _CMillisecondsRouteAttribute_last(_CMillisecondsRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<MillisecondsRouteEntry> get entries {
    _CArray_CMillisecondsRouteEntry res = _CMillisecondsRouteAttribute_entries(_CMillisecondsRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Длительность маршрута. */
  Duration get duration {
    _CTimeInterval res = _CMillisecondsRouteAttribute_duration(_CMillisecondsRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CMillisecondsRouteAttribute_releasePtr);

  MillisecondsRouteAttribute._raw(this._self);
  factory MillisecondsRouteAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MillisecondsRouteAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MillisecondsRouteAttribute &&
    other.runtimeType == runtimeType &&
    _CMillisecondsRouteAttribute_cg_objectIdentifier(this._self) == _CMillisecondsRouteAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMillisecondsRouteAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: MillisecondsRouteAttribute: Methods

  /**
   Элементы, попадающие в отрезок [begin, end).
  
   - Throws: Exception если begin > end.
  */
  List<MillisecondsRouteEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CMillisecondsRouteEntry res = _CMillisecondsRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CMillisecondsRouteAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого
   <
   = point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  MillisecondsRouteEntry? findNearBackward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CMillisecondsRouteEntry res = _CMillisecondsRouteAttribute_findNearBackward_CRoutePoint(_CMillisecondsRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Найти ближайший элемент, позиция которого >= point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  MillisecondsRouteEntry? findNearForward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CMillisecondsRouteEntry res = _CMillisecondsRouteAttribute_findNearForward_CRoutePoint(_CMillisecondsRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  Duration calculateDurationToRoutePoint(
    RoutePoint routePoint
  )  {
    var _a1 = routePoint._copyFromDartTo_CRoutePoint();
    _CTimeInterval res = _CMillisecondsRouteAttribute_calculateDurationToRoutePoint_CRoutePoint(_CMillisecondsRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  Duration calculateDuration(
    RoutePoint fromRoutePoint,
    RoutePoint toRoutePoint
  )  {
    var _a1 = fromRoutePoint._copyFromDartTo_CRoutePoint();
    var _a2 = toRoutePoint._copyFromDartTo_CRoutePoint();
    _CTimeInterval res = _CMillisecondsRouteAttribute_calculateDuration_CRoutePoint_CRoutePoint(_CMillisecondsRouteAttributeMakeDefault().._impl=_self, _a1, _a2);
    return res._toDart();
  }

}

// MARK: - MillisecondsRouteAttribute <-> CMillisecondsRouteAttribute

final class _CMillisecondsRouteAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMillisecondsRouteAttributeBasicFunctions on _CMillisecondsRouteAttribute {
  void _releaseIntermediate() {
    _CMillisecondsRouteAttribute_release(_impl);
  }

  _CMillisecondsRouteAttribute _retain() {
    return _CMillisecondsRouteAttribute_retain(_impl);
  }
}

extension _CMillisecondsRouteAttributeToDart on _CMillisecondsRouteAttribute {
  MillisecondsRouteAttribute _toDart() {
    return MillisecondsRouteAttribute._create(_retain()._impl);
  }
}


extension _DartToCMillisecondsRouteAttribute on MillisecondsRouteAttribute {
  _CMillisecondsRouteAttribute _copyFromDartTo_CMillisecondsRouteAttribute() {
    return (_CMillisecondsRouteAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MillisecondsRouteEntry

/** Элемент маршрута - точка и значение в ней. */
class MillisecondsRouteEntry {
  final RoutePoint point;
  final Duration value;

  const MillisecondsRouteEntry({
    required this.point,
    required this.value
  });

  MillisecondsRouteEntry copyWith({
    RoutePoint? point,
    Duration? value
  }) {
    return MillisecondsRouteEntry(
      point: point ?? this.point,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MillisecondsRouteEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, value);
  }

}
final class _CMillisecondsRouteEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CTimeInterval value;

}
// MARK: - MillisecondsRouteEntry <-> _CMillisecondsRouteEntry

extension _CMillisecondsRouteEntryToDart on _CMillisecondsRouteEntry {
  MillisecondsRouteEntry _toDart() {
    return MillisecondsRouteEntry(
      point: this.point._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CMillisecondsRouteEntry on MillisecondsRouteEntry {
  _CMillisecondsRouteEntry _copyFromDartTo_CMillisecondsRouteEntry() {
    final res = _CMillisecondsRouteEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.value = this.value._copyFromDartTo_CTimeInterval();
    return res;
  }
}
extension _CMillisecondsRouteEntryRelease on _CMillisecondsRouteEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - MillisecondsRouteEntry? <-> _COptional_CMillisecondsRouteEntry

final class _COptional_CMillisecondsRouteEntry extends ffi.Struct {
  
  external _CMillisecondsRouteEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CMillisecondsRouteEntryBasicFunctions on _COptional_CMillisecondsRouteEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CMillisecondsRouteEntryToDart on _COptional_CMillisecondsRouteEntry {
  MillisecondsRouteEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CMillisecondsRouteEntry on MillisecondsRouteEntry? {
  _COptional_CMillisecondsRouteEntry _copyFromDartTo_COptional_CMillisecondsRouteEntry() {
    final cOptional = _COptional_CMillisecondsRouteEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CMillisecondsRouteEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<MillisecondsRouteEntry> <-> _CArray_CMillisecondsRouteEntry

final class _CArray_CMillisecondsRouteEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CMillisecondsRouteEntryToDart on _CArray_CMillisecondsRouteEntry {
  List<MillisecondsRouteEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CMillisecondsRouteEntry on List<MillisecondsRouteEntry> {
  _CArray_CMillisecondsRouteEntry _copyFromDartTo_CArray_CMillisecondsRouteEntry() {
    final cArray = _CArray_CMillisecondsRouteEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CMillisecondsRouteEntry();
        _CArray_CMillisecondsRouteEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CMillisecondsRouteEntryBasicFunctions on _CArray_CMillisecondsRouteEntry {
  void _releaseIntermediate() {
    _CArray_CMillisecondsRouteEntry_release(this);
  }

  static final _listToFill = <MillisecondsRouteEntry>[];

  static void _iterate(_CMillisecondsRouteEntry item) {
    _listToFill.add(item._toDart());
  }

  List<MillisecondsRouteEntry> _fillFromC() {
    _forEach_CArray_CMillisecondsRouteEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CMillisecondsRouteEntry)>(_iterate));
    final result = List<MillisecondsRouteEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - TrafficSpeedColorRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class TrafficSpeedColorRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CTrafficSpeedColorRouteLongAttribute_size(_CTrafficSpeedColorRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CTrafficSpeedColorRouteLongAttribute_isEmpty(_CTrafficSpeedColorRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  TrafficSpeedColorRouteLongEntry? get first {
    _COptional_CTrafficSpeedColorRouteLongEntry res = _CTrafficSpeedColorRouteLongAttribute_first(_CTrafficSpeedColorRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  TrafficSpeedColorRouteLongEntry? get last {
    _COptional_CTrafficSpeedColorRouteLongEntry res = _CTrafficSpeedColorRouteLongAttribute_last(_CTrafficSpeedColorRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<TrafficSpeedColorRouteLongEntry> get entries {
    _CArray_CTrafficSpeedColorRouteLongEntry res = _CTrafficSpeedColorRouteLongAttribute_entries(_CTrafficSpeedColorRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CTrafficSpeedColorRouteLongAttribute_releasePtr);

  TrafficSpeedColorRouteLongAttribute._raw(this._self);
  factory TrafficSpeedColorRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TrafficSpeedColorRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficSpeedColorRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CTrafficSpeedColorRouteLongAttribute_cg_objectIdentifier(this._self) == _CTrafficSpeedColorRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTrafficSpeedColorRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: TrafficSpeedColorRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  TrafficSpeedColorRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CTrafficSpeedColorRouteLongEntry res = _CTrafficSpeedColorRouteLongAttribute_entry_CRoutePoint(_CTrafficSpeedColorRouteLongAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<TrafficSpeedColorRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CTrafficSpeedColorRouteLongEntry res = _CTrafficSpeedColorRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CTrafficSpeedColorRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - TrafficSpeedColorRouteLongAttribute <-> CTrafficSpeedColorRouteLongAttribute

final class _CTrafficSpeedColorRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTrafficSpeedColorRouteLongAttributeBasicFunctions on _CTrafficSpeedColorRouteLongAttribute {
  void _releaseIntermediate() {
    _CTrafficSpeedColorRouteLongAttribute_release(_impl);
  }

  _CTrafficSpeedColorRouteLongAttribute _retain() {
    return _CTrafficSpeedColorRouteLongAttribute_retain(_impl);
  }
}

extension _CTrafficSpeedColorRouteLongAttributeToDart on _CTrafficSpeedColorRouteLongAttribute {
  TrafficSpeedColorRouteLongAttribute _toDart() {
    return TrafficSpeedColorRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCTrafficSpeedColorRouteLongAttribute on TrafficSpeedColorRouteLongAttribute {
  _CTrafficSpeedColorRouteLongAttribute _copyFromDartTo_CTrafficSpeedColorRouteLongAttribute() {
    return (_CTrafficSpeedColorRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - TrafficSpeedColor

enum TrafficSpeedColor {
  undefined(0),
  green(1),
  yellow(2),
  red(3),
  deepRed(4),
  ;

  const TrafficSpeedColor(this.rawValue);
  final int rawValue;

  static TrafficSpeedColor getByValue(int value) {
    return TrafficSpeedColor.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CTrafficSpeedColor extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CTrafficSpeedColorBasicFunctions on _CTrafficSpeedColor {
  void _releaseIntermediate() {
  }
}

extension _CTrafficSpeedColorToDart on _CTrafficSpeedColor {
  TrafficSpeedColor _toDart() {
    return TrafficSpeedColor.getByValue(this.rawValue);
  }
}

extension _DartTo_CTrafficSpeedColor on TrafficSpeedColor {
  _CTrafficSpeedColor _copyFromDartTo_CTrafficSpeedColor() {
    return _CTrafficSpeedColorMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - TrafficSpeedColorRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class TrafficSpeedColorRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final TrafficSpeedColor value;

  const TrafficSpeedColorRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  TrafficSpeedColorRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    TrafficSpeedColor? value
  }) {
    return TrafficSpeedColorRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficSpeedColorRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CTrafficSpeedColorRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CTrafficSpeedColor value;

}
// MARK: - TrafficSpeedColorRouteLongEntry <-> _CTrafficSpeedColorRouteLongEntry

extension _CTrafficSpeedColorRouteLongEntryToDart on _CTrafficSpeedColorRouteLongEntry {
  TrafficSpeedColorRouteLongEntry _toDart() {
    return TrafficSpeedColorRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CTrafficSpeedColorRouteLongEntry on TrafficSpeedColorRouteLongEntry {
  _CTrafficSpeedColorRouteLongEntry _copyFromDartTo_CTrafficSpeedColorRouteLongEntry() {
    final res = _CTrafficSpeedColorRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CTrafficSpeedColor();
    return res;
  }
}
extension _CTrafficSpeedColorRouteLongEntryRelease on _CTrafficSpeedColorRouteLongEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - TrafficSpeedColorRouteLongEntry? <-> _COptional_CTrafficSpeedColorRouteLongEntry

final class _COptional_CTrafficSpeedColorRouteLongEntry extends ffi.Struct {
  
  external _CTrafficSpeedColorRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CTrafficSpeedColorRouteLongEntryBasicFunctions on _COptional_CTrafficSpeedColorRouteLongEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CTrafficSpeedColorRouteLongEntryToDart on _COptional_CTrafficSpeedColorRouteLongEntry {
  TrafficSpeedColorRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CTrafficSpeedColorRouteLongEntry on TrafficSpeedColorRouteLongEntry? {
  _COptional_CTrafficSpeedColorRouteLongEntry _copyFromDartTo_COptional_CTrafficSpeedColorRouteLongEntry() {
    final cOptional = _COptional_CTrafficSpeedColorRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CTrafficSpeedColorRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<TrafficSpeedColorRouteLongEntry> <-> _CArray_CTrafficSpeedColorRouteLongEntry

final class _CArray_CTrafficSpeedColorRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CTrafficSpeedColorRouteLongEntryToDart on _CArray_CTrafficSpeedColorRouteLongEntry {
  List<TrafficSpeedColorRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CTrafficSpeedColorRouteLongEntry on List<TrafficSpeedColorRouteLongEntry> {
  _CArray_CTrafficSpeedColorRouteLongEntry _copyFromDartTo_CArray_CTrafficSpeedColorRouteLongEntry() {
    final cArray = _CArray_CTrafficSpeedColorRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CTrafficSpeedColorRouteLongEntry();
        _CArray_CTrafficSpeedColorRouteLongEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CTrafficSpeedColorRouteLongEntryBasicFunctions on _CArray_CTrafficSpeedColorRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CTrafficSpeedColorRouteLongEntry_release(this);
  }

  static final _listToFill = <TrafficSpeedColorRouteLongEntry>[];

  static void _iterate(_CTrafficSpeedColorRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<TrafficSpeedColorRouteLongEntry> _fillFromC() {
    _forEach_CArray_CTrafficSpeedColorRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CTrafficSpeedColorRouteLongEntry)>(_iterate));
    final result = List<TrafficSpeedColorRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - State

/** Состояние навигатора. */
enum State {
  /** Неактивен (начальное состояние, переходит в него после вызова метода Stop). */
  disabled(0),
  /** Режим ведения по маршруту. */
  navigation(1),
  /** Поиск нового маршрута. */
  routeSearch(2),
  /** Достигнута конечная точка. */
  finished(3),
  ;

  const State(this.rawValue);
  final int rawValue;

  static State getByValue(int value) {
    return State.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CStateBasicFunctions on _CState {
  void _releaseIntermediate() {
  }
}

extension _CStateToDart on _CState {
  State _toDart() {
    return State.getByValue(this.rawValue);
  }
}

extension _DartTo_CState on State {
  _CState _copyFromDartTo_CState() {
    return _CStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - PackedNavigationState

/** Вспомогательный объект для сериализации и десериализации состояния навигации. */
class PackedNavigationState implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Маршрут. */
  TrafficRoute get trafficRoute {
    _CTrafficRoute res = _CPackedNavigationState_trafficRoute(_CPackedNavigationStateMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set trafficRoute(TrafficRoute trafficRoute) {
    var _a1 = trafficRoute._copyFromDartTo_CTrafficRoute();
    void res = _CPackedNavigationState_setTrafficRoute_CTrafficRoute(_CPackedNavigationStateMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Конечная точка маршрута. */
  RouteSearchPoint? get finishPoint {
    _COptional_CRouteSearchPoint res = _CPackedNavigationState_finishPoint(_CPackedNavigationStateMakeDefault().._impl=_self);
    return res._toDart();
  }
  set finishPoint(RouteSearchPoint? finishPoint) {
    var _a1 = finishPoint._copyFromDartTo_COptional_CRouteSearchPoint();
    void res = _CPackedNavigationState_setFinishPoint_COptional_CRouteSearchPoint(_CPackedNavigationStateMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Опции построения маршрута. */
  RouteSearchOptions? get routeSearchOptions {
    _COptional_CRouteSearchOptions res = _CPackedNavigationState_routeSearchOptions(_CPackedNavigationStateMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set routeSearchOptions(RouteSearchOptions? routeSearchOptions) {
    var _a1 = routeSearchOptions._copyFromDartTo_COptional_CRouteSearchOptions();
    void res = _CPackedNavigationState_setRouteSearchOptions_COptional_CRouteSearchOptions(_CPackedNavigationStateMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Позиция на маршруте. */
  RoutePoint? get routePosition {
    _COptional_CRoutePoint res = _CPackedNavigationState_routePosition(_CPackedNavigationStateMakeDefault().._impl=_self);
    return res._toDart();
  }
  set routePosition(RoutePoint? routePosition) {
    var _a1 = routePosition._copyFromDartTo_COptional_CRoutePoint();
    void res = _CPackedNavigationState_setRoutePosition_COptional_CRoutePoint(_CPackedNavigationStateMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Текущее состояние навигации. */
  State get state {
    _CState res = _CPackedNavigationState_state(_CPackedNavigationStateMakeDefault().._impl=_self);
    return res._toDart();
  }
  set state(State state) {
    var _a1 = state._copyFromDartTo_CState();
    void res = _CPackedNavigationState_setState_CState(_CPackedNavigationStateMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPackedNavigationState_releasePtr);

  PackedNavigationState._raw(this._self);
  factory PackedNavigationState._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PackedNavigationState._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PackedNavigationState &&
    other.runtimeType == runtimeType &&
    _CPackedNavigationState_cg_objectIdentifier(this._self) == _CPackedNavigationState_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPackedNavigationState_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CPackedNavigationState: Static Methods

  /** Создание объекта из перечисленных элементов. */
  static PackedNavigationState of(
    TrafficRoute trafficRoute,
    [RouteSearchOptions? routeSearchOptions = null,
    RouteSearchPoint? finishPoint = null,
    RoutePoint? routePosition = null,
    State state = State.disabled
    ])  {
    var _a0 = trafficRoute._copyFromDartTo_CTrafficRoute();
    var _a1 = routeSearchOptions._copyFromDartTo_COptional_CRouteSearchOptions();
    var _a2 = finishPoint._copyFromDartTo_COptional_CRouteSearchPoint();
    var _a3 = routePosition._copyFromDartTo_COptional_CRoutePoint();
    var _a4 = state._copyFromDartTo_CState();
    _CPackedNavigationState res = _CPackedNavigationState_S_of_CTrafficRoute_COptional_CRouteSearchOptions_COptional_CRouteSearchPoint_COptional_CRoutePoint_CState(_a0, _a1, _a2, _a3, _a4);
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Десериализация состояния навигации.
   Недопустимые элементы в сохранённом состоянии пропускаются либо
   заменяются значениями по умолчанию.
  
   - Throws: Exception десериализуется неподдерживаемая версия.
  */
  static PackedNavigationState fromBytes(
    ByteData data
  )  {
    var _a0 = data._copyFromDartTo_CData();
    _CResult_CPackedNavigationState res = _CPackedNavigationState_S_fromBytes_CData(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Создание объекта из модели навигатора. */
  static PackedNavigationState fromModel(
    Model model
  )  {
    var _a0 = model._copyFromDartTo_CModel();
    _CPackedNavigationState res = _CPackedNavigationState_S_fromModel_CModel(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: PackedNavigationState: Methods

  /** Сериализация состояния навигации. */
  ByteData toBytes()  {
    _CData res = _CPackedNavigationState_toBytes(_CPackedNavigationStateMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - PackedNavigationState <-> CPackedNavigationState

final class _CPackedNavigationState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPackedNavigationStateBasicFunctions on _CPackedNavigationState {
  void _releaseIntermediate() {
    _CPackedNavigationState_release(_impl);
  }

  _CPackedNavigationState _retain() {
    return _CPackedNavigationState_retain(_impl);
  }
}

extension _CPackedNavigationStateToDart on _CPackedNavigationState {
  PackedNavigationState _toDart() {
    return PackedNavigationState._create(_retain()._impl);
  }
}


extension _DartToCPackedNavigationState on PackedNavigationState {
  _CPackedNavigationState _copyFromDartTo_CPackedNavigationState() {
    return (_CPackedNavigationStateMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<ExcludedArea> <-> _CArray_CExcludedArea

final class _CArray_CExcludedArea extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CExcludedAreaToDart on _CArray_CExcludedArea {
  List<ExcludedArea> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CExcludedArea on List<ExcludedArea> {
  _CArray_CExcludedArea _copyFromDartTo_CArray_CExcludedArea() {
    final cArray = _CArray_CExcludedAreamakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CExcludedArea();
        _CArray_CExcludedAreaaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CExcludedAreaBasicFunctions on _CArray_CExcludedArea {
  void _releaseIntermediate() {
    _CArray_CExcludedArea_release(this);
  }

  static final _listToFill = <ExcludedArea>[];

  static void _iterate(_CExcludedArea item) {
    _listToFill.add(item._toDart());
  }

  List<ExcludedArea> _fillFromC() {
    _forEach_CArray_CExcludedArea(this, ffi.Pointer.fromFunction<ffi.Void Function(_CExcludedArea)>(_iterate));
    final result = List<ExcludedArea>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - BicycleRouteSearchOptions

/** Параметры поиска маршрута на велосипеде. */
class BicycleRouteSearchOptions {
  /** Избегать автомобильных дорог. */
  final bool avoidCarRoads;
  /** Избегать лестниц. */
  final bool avoidStairways;
  /** Избегать подземных и надземных переходов. */
  final bool avoidUnderpassesAndOverpasses;
  /** Исключаемые области (не больше 25). */
  final List<ExcludedArea> excludedAreas;

  const BicycleRouteSearchOptions({
    this.avoidCarRoads = false,
    this.avoidStairways = false,
    this.avoidUnderpassesAndOverpasses = false,
    this.excludedAreas = const []
  });

  BicycleRouteSearchOptions copyWith({
    bool? avoidCarRoads,
    bool? avoidStairways,
    bool? avoidUnderpassesAndOverpasses,
    List<ExcludedArea>? excludedAreas
  }) {
    return BicycleRouteSearchOptions(
      avoidCarRoads: avoidCarRoads ?? this.avoidCarRoads,
      avoidStairways: avoidStairways ?? this.avoidStairways,
      avoidUnderpassesAndOverpasses: avoidUnderpassesAndOverpasses ?? this.avoidUnderpassesAndOverpasses,
      excludedAreas: excludedAreas ?? this.excludedAreas
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BicycleRouteSearchOptions &&
    other.runtimeType == runtimeType &&
    other.avoidCarRoads == avoidCarRoads &&
    other.avoidStairways == avoidStairways &&
    other.avoidUnderpassesAndOverpasses == avoidUnderpassesAndOverpasses &&
    other.excludedAreas == excludedAreas;

  @override
  int get hashCode {
    return Object.hash(avoidCarRoads, avoidStairways, avoidUnderpassesAndOverpasses, excludedAreas);
  }

}
final class _CBicycleRouteSearchOptions extends ffi.Struct {
  @ffi.Bool()
  external bool avoidCarRoads;

  @ffi.Bool()
  external bool avoidStairways;

  @ffi.Bool()
  external bool avoidUnderpassesAndOverpasses;

  external _CArray_CExcludedArea excludedAreas;

}
// MARK: - BicycleRouteSearchOptions <-> _CBicycleRouteSearchOptions

extension _CBicycleRouteSearchOptionsToDart on _CBicycleRouteSearchOptions {
  BicycleRouteSearchOptions _toDart() {
    return BicycleRouteSearchOptions(
      avoidCarRoads: this.avoidCarRoads,
      avoidStairways: this.avoidStairways,
      avoidUnderpassesAndOverpasses: this.avoidUnderpassesAndOverpasses,
      excludedAreas: this.excludedAreas._toDart()
    );
  }
}

extension _DartTo_CBicycleRouteSearchOptions on BicycleRouteSearchOptions {
  _CBicycleRouteSearchOptions _copyFromDartTo_CBicycleRouteSearchOptions() {
    final res = _CBicycleRouteSearchOptionsMakeDefault();
    res.avoidCarRoads = this.avoidCarRoads;
    res.avoidStairways = this.avoidStairways;
    res.avoidUnderpassesAndOverpasses = this.avoidUnderpassesAndOverpasses;
    res.excludedAreas = this.excludedAreas._copyFromDartTo_CArray_CExcludedArea();
    return res;
  }
}
extension _CBicycleRouteSearchOptionsRelease on _CBicycleRouteSearchOptions {
  void _releaseIntermediate() {
    excludedAreas._releaseIntermediate();
  }
}

// MARK: - RouteSearchType

/** Тип поиска маршрута. */
enum RouteSearchType {
  /** Поиск маршрута с учётом актуальных пробочных данных. */
  jam(0),
  /** Поиск маршрута с учётом статистических пробочных данных. */
  statistic(1),
  /** Поиск кратчайшего маршрута. */
  shortest(2),
  ;

  const RouteSearchType(this.rawValue);
  final int rawValue;

  static RouteSearchType getByValue(int value) {
    return RouteSearchType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouteSearchType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouteSearchTypeBasicFunctions on _CRouteSearchType {
  void _releaseIntermediate() {
  }
}

extension _CRouteSearchTypeToDart on _CRouteSearchType {
  RouteSearchType _toDart() {
    return RouteSearchType.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouteSearchType on RouteSearchType {
  _CRouteSearchType _copyFromDartTo_CRouteSearchType() {
    return _CRouteSearchTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CarRouteSearchOptions

/** Параметры поиска маршрута на легковом автомобиле. */
class CarRouteSearchOptions {
  /** Избегать платных дорог. */
  final bool avoidTollRoads;
  /** Избегать грунтовых дорог. */
  final bool avoidUnpavedRoads;
  /** Избегать паромных переправ. */
  final bool avoidFerries;
  /**
   Избегать закрытых для проезда дорог.
   При значении true поиск маршрута не будет учитывать перекрытые для проезда участки дорог.
   При значении false маршрут может быть проложен через перекрытые для проезда участки дорог, если невозможно
   построить маршрут без проезда через перекрытые участки.
  */
  final bool avoidLockedRoads;
  /** Тип поиска маршрута. */
  final RouteSearchType routeSearchType;
  /** Исключаемые области (не больше 25). */
  final List<ExcludedArea> excludedAreas;

  const CarRouteSearchOptions({
    this.avoidTollRoads = false,
    this.avoidUnpavedRoads = false,
    this.avoidFerries = false,
    this.avoidLockedRoads = true,
    this.routeSearchType = RouteSearchType.jam,
    this.excludedAreas = const []
  });

  CarRouteSearchOptions copyWith({
    bool? avoidTollRoads,
    bool? avoidUnpavedRoads,
    bool? avoidFerries,
    bool? avoidLockedRoads,
    RouteSearchType? routeSearchType,
    List<ExcludedArea>? excludedAreas
  }) {
    return CarRouteSearchOptions(
      avoidTollRoads: avoidTollRoads ?? this.avoidTollRoads,
      avoidUnpavedRoads: avoidUnpavedRoads ?? this.avoidUnpavedRoads,
      avoidFerries: avoidFerries ?? this.avoidFerries,
      avoidLockedRoads: avoidLockedRoads ?? this.avoidLockedRoads,
      routeSearchType: routeSearchType ?? this.routeSearchType,
      excludedAreas: excludedAreas ?? this.excludedAreas
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CarRouteSearchOptions &&
    other.runtimeType == runtimeType &&
    other.avoidTollRoads == avoidTollRoads &&
    other.avoidUnpavedRoads == avoidUnpavedRoads &&
    other.avoidFerries == avoidFerries &&
    other.avoidLockedRoads == avoidLockedRoads &&
    other.routeSearchType == routeSearchType &&
    other.excludedAreas == excludedAreas;

  @override
  int get hashCode {
    return Object.hash(avoidTollRoads, avoidUnpavedRoads, avoidFerries, avoidLockedRoads, routeSearchType, excludedAreas);
  }

}
final class _CCarRouteSearchOptions extends ffi.Struct {
  @ffi.Bool()
  external bool avoidTollRoads;

  @ffi.Bool()
  external bool avoidUnpavedRoads;

  @ffi.Bool()
  external bool avoidFerries;

  @ffi.Bool()
  external bool avoidLockedRoads;

  external _CRouteSearchType routeSearchType;

  external _CArray_CExcludedArea excludedAreas;

}
// MARK: - CarRouteSearchOptions <-> _CCarRouteSearchOptions

extension _CCarRouteSearchOptionsToDart on _CCarRouteSearchOptions {
  CarRouteSearchOptions _toDart() {
    return CarRouteSearchOptions(
      avoidTollRoads: this.avoidTollRoads,
      avoidUnpavedRoads: this.avoidUnpavedRoads,
      avoidFerries: this.avoidFerries,
      avoidLockedRoads: this.avoidLockedRoads,
      routeSearchType: this.routeSearchType._toDart(),
      excludedAreas: this.excludedAreas._toDart()
    );
  }
}

extension _DartTo_CCarRouteSearchOptions on CarRouteSearchOptions {
  _CCarRouteSearchOptions _copyFromDartTo_CCarRouteSearchOptions() {
    final res = _CCarRouteSearchOptionsMakeDefault();
    res.avoidTollRoads = this.avoidTollRoads;
    res.avoidUnpavedRoads = this.avoidUnpavedRoads;
    res.avoidFerries = this.avoidFerries;
    res.avoidLockedRoads = this.avoidLockedRoads;
    res.routeSearchType = this.routeSearchType._copyFromDartTo_CRouteSearchType();
    res.excludedAreas = this.excludedAreas._copyFromDartTo_CArray_CExcludedArea();
    return res;
  }
}
extension _CCarRouteSearchOptionsRelease on _CCarRouteSearchOptions {
  void _releaseIntermediate() {
    excludedAreas._releaseIntermediate();
  }
}

// MARK: - PedestrianRouteSearchOptions

/** Параметры поиска пешеходного маршрута. */
class PedestrianRouteSearchOptions {
  /** Избегать лестниц. */
  final bool avoidStairways;
  /** Избегать подземных и надземных переходов. */
  final bool avoidUnderpassesAndOverpasses;
  /** Строить маршруты внутри зданий. */
  final bool useIndoor;
  /** Исключаемые области (не больше 25). */
  final List<ExcludedArea> excludedAreas;

  const PedestrianRouteSearchOptions({
    this.avoidStairways = false,
    this.avoidUnderpassesAndOverpasses = false,
    this.useIndoor = true,
    this.excludedAreas = const []
  });

  PedestrianRouteSearchOptions copyWith({
    bool? avoidStairways,
    bool? avoidUnderpassesAndOverpasses,
    bool? useIndoor,
    List<ExcludedArea>? excludedAreas
  }) {
    return PedestrianRouteSearchOptions(
      avoidStairways: avoidStairways ?? this.avoidStairways,
      avoidUnderpassesAndOverpasses: avoidUnderpassesAndOverpasses ?? this.avoidUnderpassesAndOverpasses,
      useIndoor: useIndoor ?? this.useIndoor,
      excludedAreas: excludedAreas ?? this.excludedAreas
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PedestrianRouteSearchOptions &&
    other.runtimeType == runtimeType &&
    other.avoidStairways == avoidStairways &&
    other.avoidUnderpassesAndOverpasses == avoidUnderpassesAndOverpasses &&
    other.useIndoor == useIndoor &&
    other.excludedAreas == excludedAreas;

  @override
  int get hashCode {
    return Object.hash(avoidStairways, avoidUnderpassesAndOverpasses, useIndoor, excludedAreas);
  }

}
final class _CPedestrianRouteSearchOptions extends ffi.Struct {
  @ffi.Bool()
  external bool avoidStairways;

  @ffi.Bool()
  external bool avoidUnderpassesAndOverpasses;

  @ffi.Bool()
  external bool useIndoor;

  external _CArray_CExcludedArea excludedAreas;

}
// MARK: - PedestrianRouteSearchOptions <-> _CPedestrianRouteSearchOptions

extension _CPedestrianRouteSearchOptionsToDart on _CPedestrianRouteSearchOptions {
  PedestrianRouteSearchOptions _toDart() {
    return PedestrianRouteSearchOptions(
      avoidStairways: this.avoidStairways,
      avoidUnderpassesAndOverpasses: this.avoidUnderpassesAndOverpasses,
      useIndoor: this.useIndoor,
      excludedAreas: this.excludedAreas._toDart()
    );
  }
}

extension _DartTo_CPedestrianRouteSearchOptions on PedestrianRouteSearchOptions {
  _CPedestrianRouteSearchOptions _copyFromDartTo_CPedestrianRouteSearchOptions() {
    final res = _CPedestrianRouteSearchOptionsMakeDefault();
    res.avoidStairways = this.avoidStairways;
    res.avoidUnderpassesAndOverpasses = this.avoidUnderpassesAndOverpasses;
    res.useIndoor = this.useIndoor;
    res.excludedAreas = this.excludedAreas._copyFromDartTo_CArray_CExcludedArea();
    return res;
  }
}
extension _CPedestrianRouteSearchOptionsRelease on _CPedestrianRouteSearchOptions {
  void _releaseIntermediate() {
    excludedAreas._releaseIntermediate();
  }
}

// MARK: - PublicTransportTypeEnumSet

class PublicTransportTypeEnumSet extends EnumSet<PublicTransportType> {
  PublicTransportTypeEnumSet() : super();

  factory PublicTransportTypeEnumSet.fromRawValue(int rawValue) {
    PublicTransportTypeEnumSet enumSet = PublicTransportTypeEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory PublicTransportTypeEnumSet.of(Iterable<PublicTransportType> elements) {
    PublicTransportTypeEnumSet enumSet = PublicTransportTypeEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory PublicTransportTypeEnumSet.all() {
    PublicTransportTypeEnumSet enumSet = PublicTransportTypeEnumSet();
    enumSet.addAll(PublicTransportType.values);
    return enumSet;
  }

  @override
  bool contains(PublicTransportType value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<PublicTransportType> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(PublicTransportType value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<PublicTransportType> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(PublicTransportType value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<PublicTransportType> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<PublicTransportType> intersection(EnumSet<PublicTransportType> other) =>
      PublicTransportTypeEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<PublicTransportType> union(EnumSet<PublicTransportType> other) =>
      PublicTransportTypeEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<PublicTransportType> difference(EnumSet<PublicTransportType> other) =>
      PublicTransportTypeEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<PublicTransportType> toSet() {
    Set<PublicTransportType> result = {};
    PublicTransportType.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    PublicTransportType.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CPublicTransportType extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CPublicTransportTypeBasicFunctions on _COptionSet_CPublicTransportType {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CPublicTransportTypeToDart on _COptionSet_CPublicTransportType {
  PublicTransportTypeEnumSet _toDart() {
    return PublicTransportTypeEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CPublicTransportType on PublicTransportTypeEnumSet {
  _COptionSet_CPublicTransportType _copyFromDartTo_COptionSet_CPublicTransportType() {
    return _COptionSet_CPublicTransportTypeMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - PublicTransportRouteSearchOptions

/** Параметры поиска маршрута на общественном транспорте. */
class PublicTransportRouteSearchOptions {
  /** Время в UTC, на которое нужно построить маршрут. Если не задано, используется текущее время. */
  final DateTime? startTime;
  /** Учёт расписания движения общественного транспорта при построении маршрута. */
  final bool useSchedule;
  /**
   Типы общественного транспорта. Если не заполнены, маршруты будут строиться для всех поддерживаемых типов
   общественного транспорта.
  */
  final PublicTransportTypeEnumSet transportTypes;

  const PublicTransportRouteSearchOptions({
    this.startTime = null,
    this.useSchedule = false,
    required this.transportTypes
  });

  PublicTransportRouteSearchOptions copyWith({
    Optional<DateTime?>? startTime,
    bool? useSchedule,
    PublicTransportTypeEnumSet? transportTypes
  }) {
    return PublicTransportRouteSearchOptions(
      startTime: startTime != null ? startTime.value : this.startTime,
      useSchedule: useSchedule ?? this.useSchedule,
      transportTypes: transportTypes ?? this.transportTypes
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PublicTransportRouteSearchOptions &&
    other.runtimeType == runtimeType &&
    other.startTime == startTime &&
    other.useSchedule == useSchedule &&
    other.transportTypes == transportTypes;

  @override
  int get hashCode {
    return Object.hash(startTime, useSchedule, transportTypes);
  }

}
final class _CPublicTransportRouteSearchOptions extends ffi.Struct {
  external _COptional_CDate startTime;

  @ffi.Bool()
  external bool useSchedule;

  external _COptionSet_CPublicTransportType transportTypes;

}
// MARK: - PublicTransportRouteSearchOptions <-> _CPublicTransportRouteSearchOptions

extension _CPublicTransportRouteSearchOptionsToDart on _CPublicTransportRouteSearchOptions {
  PublicTransportRouteSearchOptions _toDart() {
    return PublicTransportRouteSearchOptions(
      startTime: this.startTime._toDart(),
      useSchedule: this.useSchedule,
      transportTypes: this.transportTypes._toDart()
    );
  }
}

extension _DartTo_CPublicTransportRouteSearchOptions on PublicTransportRouteSearchOptions {
  _CPublicTransportRouteSearchOptions _copyFromDartTo_CPublicTransportRouteSearchOptions() {
    final res = _CPublicTransportRouteSearchOptionsMakeDefault();
    res.startTime = this.startTime._copyFromDartTo_COptional_CDate();
    res.useSchedule = this.useSchedule;
    res.transportTypes = this.transportTypes._copyFromDartTo_COptionSet_CPublicTransportType();
    return res;
  }
}
extension _CPublicTransportRouteSearchOptionsRelease on _CPublicTransportRouteSearchOptions {
  void _releaseIntermediate() {
  }
}

// MARK: - ScooterRouteSearchOptions

/** Параметры поиска маршрута на самокате. */
class ScooterRouteSearchOptions {
  /** Избегать автомобильных дорог. */
  final bool avoidCarRoads;
  /** Избегать лестниц. */
  final bool avoidStairways;
  /** Избегать подземных и надземных переходов. */
  final bool avoidUnderpassesAndOverpasses;
  /** Исключаемые области (не больше 25). */
  final List<ExcludedArea> excludedAreas;

  const ScooterRouteSearchOptions({
    this.avoidCarRoads = true,
    this.avoidStairways = true,
    this.avoidUnderpassesAndOverpasses = true,
    this.excludedAreas = const []
  });

  ScooterRouteSearchOptions copyWith({
    bool? avoidCarRoads,
    bool? avoidStairways,
    bool? avoidUnderpassesAndOverpasses,
    List<ExcludedArea>? excludedAreas
  }) {
    return ScooterRouteSearchOptions(
      avoidCarRoads: avoidCarRoads ?? this.avoidCarRoads,
      avoidStairways: avoidStairways ?? this.avoidStairways,
      avoidUnderpassesAndOverpasses: avoidUnderpassesAndOverpasses ?? this.avoidUnderpassesAndOverpasses,
      excludedAreas: excludedAreas ?? this.excludedAreas
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScooterRouteSearchOptions &&
    other.runtimeType == runtimeType &&
    other.avoidCarRoads == avoidCarRoads &&
    other.avoidStairways == avoidStairways &&
    other.avoidUnderpassesAndOverpasses == avoidUnderpassesAndOverpasses &&
    other.excludedAreas == excludedAreas;

  @override
  int get hashCode {
    return Object.hash(avoidCarRoads, avoidStairways, avoidUnderpassesAndOverpasses, excludedAreas);
  }

}
final class _CScooterRouteSearchOptions extends ffi.Struct {
  @ffi.Bool()
  external bool avoidCarRoads;

  @ffi.Bool()
  external bool avoidStairways;

  @ffi.Bool()
  external bool avoidUnderpassesAndOverpasses;

  external _CArray_CExcludedArea excludedAreas;

}
// MARK: - ScooterRouteSearchOptions <-> _CScooterRouteSearchOptions

extension _CScooterRouteSearchOptionsToDart on _CScooterRouteSearchOptions {
  ScooterRouteSearchOptions _toDart() {
    return ScooterRouteSearchOptions(
      avoidCarRoads: this.avoidCarRoads,
      avoidStairways: this.avoidStairways,
      avoidUnderpassesAndOverpasses: this.avoidUnderpassesAndOverpasses,
      excludedAreas: this.excludedAreas._toDart()
    );
  }
}

extension _DartTo_CScooterRouteSearchOptions on ScooterRouteSearchOptions {
  _CScooterRouteSearchOptions _copyFromDartTo_CScooterRouteSearchOptions() {
    final res = _CScooterRouteSearchOptionsMakeDefault();
    res.avoidCarRoads = this.avoidCarRoads;
    res.avoidStairways = this.avoidStairways;
    res.avoidUnderpassesAndOverpasses = this.avoidUnderpassesAndOverpasses;
    res.excludedAreas = this.excludedAreas._copyFromDartTo_CArray_CExcludedArea();
    return res;
  }
}
extension _CScooterRouteSearchOptionsRelease on _CScooterRouteSearchOptions {
  void _releaseIntermediate() {
    excludedAreas._releaseIntermediate();
  }
}

// MARK: - TaxiRouteSearchOptions

/** Параметры поиска маршрута на такси. */
class TaxiRouteSearchOptions {
  /** Параметры поиска маршрута, общие с прочими автомобильными. */
  final CarRouteSearchOptions car;

  const TaxiRouteSearchOptions(this.car);

  TaxiRouteSearchOptions copyWith({
    CarRouteSearchOptions? car
  }) {
    return TaxiRouteSearchOptions(
      car ?? this.car
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TaxiRouteSearchOptions &&
    other.runtimeType == runtimeType &&
    other.car == car;

  @override
  int get hashCode {
    return car.hashCode;
  }

}
final class _CTaxiRouteSearchOptions extends ffi.Struct {
  external _CCarRouteSearchOptions car;

}
// MARK: - TaxiRouteSearchOptions <-> _CTaxiRouteSearchOptions

extension _CTaxiRouteSearchOptionsToDart on _CTaxiRouteSearchOptions {
  TaxiRouteSearchOptions _toDart() {
    return TaxiRouteSearchOptions(
      this.car._toDart()
    );
  }
}

extension _DartTo_CTaxiRouteSearchOptions on TaxiRouteSearchOptions {
  _CTaxiRouteSearchOptions _copyFromDartTo_CTaxiRouteSearchOptions() {
    final res = _CTaxiRouteSearchOptionsMakeDefault();
    res.car = this.car._copyFromDartTo_CCarRouteSearchOptions();
    return res;
  }
}
extension _CTaxiRouteSearchOptionsRelease on _CTaxiRouteSearchOptions {
  void _releaseIntermediate() {
    car._releaseIntermediate();
  }
}

// MARK: - Set<TruckPassZonePassId> <-> _CSet_CTruckPassZonePassId

final class _CSet_CTruckPassZonePassId extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSet_CTruckPassZonePassIdToDart on _CSet_CTruckPassZonePassId {
  Set<TruckPassZonePassId> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CSet_CTruckPassZonePassId on Set<TruckPassZonePassId> {
  _CSet_CTruckPassZonePassId _copyFromDartTo_CSet_CTruckPassZonePassId() {
    final cSet = _CSet_CTruckPassZonePassIdmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CTruckPassZonePassId();
        _CSet_CTruckPassZonePassIdaddElement(cSet, cItem);
        
    });
    return cSet;
  }
}

extension _CSet_CTruckPassZonePassIdBasicFunctions on _CSet_CTruckPassZonePassId {
  void _releaseIntermediate() {
    _CSet_CTruckPassZonePassId_release(this);
  }

 static final _setToFill = <TruckPassZonePassId>{};

  static void _iterate(_CTruckPassZonePassId item) {
    _setToFill.add(item._toDart());
  }

  Set<TruckPassZonePassId> _fillFromC() {
    _forEach_CSet_CTruckPassZonePassId(this, ffi.Pointer.fromFunction<ffi.Void Function(_CTruckPassZonePassId)>(_iterate));
    final result = Set<TruckPassZonePassId>.from(_setToFill);
    _setToFill.clear();
    return result;
  }
}
	
// MARK: - TruckRouteSearchOptions

/**
 Параметры поиска маршрута на грузовом транспорте.
 При поиске маршрута учитываются только заполненные параметры.
*/
class TruckRouteSearchOptions {
  /** Параметры поиска маршрута, общие с прочими автомобильными. */
  final CarRouteSearchOptions car;
  /** Длина грузового транспортного средства в миллиметрах. */
  final int? truckLength;
  /** Высота грузового транспортного средства в миллиметрах. */
  final int? truckHeight;
  /** Ширина грузового транспортного средства в миллиметрах. */
  final int? truckWidth;
  /** Фактическая масса грузового транспортного средства в килограммах. */
  final int? actualMass;
  /** Разрешённая максимальная масса грузового транспортного средства в килограммах. */
  final int? maxPermittedMass;
  /** Нагрузка на ось в килограммах. */
  final int? axleLoad;
  /** Признак наличия опасного груза. */
  final bool dangerousCargo;
  /** Признак наличия взрывчатых веществ в грузе. */
  final bool explosiveCargo;
  /** Идентификаторы имеющихся у пользователя пропусков, требующихся для движения в пределах пропускных зон. */
  final Set<TruckPassZonePassId> passIds;
  /**
   Использование автоматического фоллбека с поиска грузового маршрута на поиск автомобильного маршрута
   при невозможности найти грузовой маршрут, удовлетворяющий параметрам поиска.
  */
  final bool fallbackOnCar;

  const TruckRouteSearchOptions({
    required this.car,
    this.truckLength = null,
    this.truckHeight = null,
    this.truckWidth = null,
    this.actualMass = null,
    this.maxPermittedMass = null,
    this.axleLoad = null,
    this.dangerousCargo = false,
    this.explosiveCargo = false,
    this.passIds = const {},
    this.fallbackOnCar = false
  });

  TruckRouteSearchOptions copyWith({
    CarRouteSearchOptions? car,
    Optional<int?>? truckLength,
    Optional<int?>? truckHeight,
    Optional<int?>? truckWidth,
    Optional<int?>? actualMass,
    Optional<int?>? maxPermittedMass,
    Optional<int?>? axleLoad,
    bool? dangerousCargo,
    bool? explosiveCargo,
    Set<TruckPassZonePassId>? passIds,
    bool? fallbackOnCar
  }) {
    return TruckRouteSearchOptions(
      car: car ?? this.car,
      truckLength: truckLength != null ? truckLength.value : this.truckLength,
      truckHeight: truckHeight != null ? truckHeight.value : this.truckHeight,
      truckWidth: truckWidth != null ? truckWidth.value : this.truckWidth,
      actualMass: actualMass != null ? actualMass.value : this.actualMass,
      maxPermittedMass: maxPermittedMass != null ? maxPermittedMass.value : this.maxPermittedMass,
      axleLoad: axleLoad != null ? axleLoad.value : this.axleLoad,
      dangerousCargo: dangerousCargo ?? this.dangerousCargo,
      explosiveCargo: explosiveCargo ?? this.explosiveCargo,
      passIds: passIds ?? this.passIds,
      fallbackOnCar: fallbackOnCar ?? this.fallbackOnCar
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TruckRouteSearchOptions &&
    other.runtimeType == runtimeType &&
    other.car == car &&
    other.truckLength == truckLength &&
    other.truckHeight == truckHeight &&
    other.truckWidth == truckWidth &&
    other.actualMass == actualMass &&
    other.maxPermittedMass == maxPermittedMass &&
    other.axleLoad == axleLoad &&
    other.dangerousCargo == dangerousCargo &&
    other.explosiveCargo == explosiveCargo &&
    other.passIds == passIds &&
    other.fallbackOnCar == fallbackOnCar;

  @override
  int get hashCode {
    return Object.hash(car, truckLength, truckHeight, truckWidth, actualMass, maxPermittedMass, axleLoad, dangerousCargo, explosiveCargo, passIds, fallbackOnCar);
  }

}
final class _CTruckRouteSearchOptions extends ffi.Struct {
  external _CCarRouteSearchOptions car;

  external _COptional_uint32_t truckLength;

  external _COptional_uint32_t truckHeight;

  external _COptional_uint32_t truckWidth;

  external _COptional_uint32_t actualMass;

  external _COptional_uint32_t maxPermittedMass;

  external _COptional_uint32_t axleLoad;

  @ffi.Bool()
  external bool dangerousCargo;

  @ffi.Bool()
  external bool explosiveCargo;

  external _CSet_CTruckPassZonePassId passIds;

  @ffi.Bool()
  external bool fallbackOnCar;

}
// MARK: - TruckRouteSearchOptions <-> _CTruckRouteSearchOptions

extension _CTruckRouteSearchOptionsToDart on _CTruckRouteSearchOptions {
  TruckRouteSearchOptions _toDart() {
    return TruckRouteSearchOptions(
      car: this.car._toDart(),
      truckLength: this.truckLength._toDart(),
      truckHeight: this.truckHeight._toDart(),
      truckWidth: this.truckWidth._toDart(),
      actualMass: this.actualMass._toDart(),
      maxPermittedMass: this.maxPermittedMass._toDart(),
      axleLoad: this.axleLoad._toDart(),
      dangerousCargo: this.dangerousCargo,
      explosiveCargo: this.explosiveCargo,
      passIds: this.passIds._toDart(),
      fallbackOnCar: this.fallbackOnCar
    );
  }
}

extension _DartTo_CTruckRouteSearchOptions on TruckRouteSearchOptions {
  _CTruckRouteSearchOptions _copyFromDartTo_CTruckRouteSearchOptions() {
    final res = _CTruckRouteSearchOptionsMakeDefault();
    res.car = this.car._copyFromDartTo_CCarRouteSearchOptions();
    res.truckLength = this.truckLength._copyFromDartTo_COptional_uint32_t();
    res.truckHeight = this.truckHeight._copyFromDartTo_COptional_uint32_t();
    res.truckWidth = this.truckWidth._copyFromDartTo_COptional_uint32_t();
    res.actualMass = this.actualMass._copyFromDartTo_COptional_uint32_t();
    res.maxPermittedMass = this.maxPermittedMass._copyFromDartTo_COptional_uint32_t();
    res.axleLoad = this.axleLoad._copyFromDartTo_COptional_uint32_t();
    res.dangerousCargo = this.dangerousCargo;
    res.explosiveCargo = this.explosiveCargo;
    res.passIds = this.passIds._copyFromDartTo_CSet_CTruckPassZonePassId();
    res.fallbackOnCar = this.fallbackOnCar;
    return res;
  }
}
extension _CTruckRouteSearchOptionsRelease on _CTruckRouteSearchOptions {
  void _releaseIntermediate() {
    car._releaseIntermediate();
    passIds._releaseIntermediate();
  }
}

// MARK: - RouteSearchOptions

/** Параметры поиска маршрута. */
final class RouteSearchOptions {
  final Object? _value;
  final int _index;

  RouteSearchOptions._raw(this._value, this._index);

  RouteSearchOptions.bicycle(BicycleRouteSearchOptions value) : this._raw(value, 0);
  RouteSearchOptions.car(CarRouteSearchOptions value) : this._raw(value, 1);
  RouteSearchOptions.pedestrian(PedestrianRouteSearchOptions value) : this._raw(value, 2);
  RouteSearchOptions.publicTransport(PublicTransportRouteSearchOptions value) : this._raw(value, 3);
  RouteSearchOptions.scooter(ScooterRouteSearchOptions value) : this._raw(value, 4);
  RouteSearchOptions.taxi(TaxiRouteSearchOptions value) : this._raw(value, 5);
  RouteSearchOptions.truck(TruckRouteSearchOptions value) : this._raw(value, 6);

  bool get isBicycle => this._index == 0;
  BicycleRouteSearchOptions? get asBicycle => this.isBicycle ? this._value as BicycleRouteSearchOptions : null;

  bool get isCar => this._index == 1;
  CarRouteSearchOptions? get asCar => this.isCar ? this._value as CarRouteSearchOptions : null;

  bool get isPedestrian => this._index == 2;
  PedestrianRouteSearchOptions? get asPedestrian => this.isPedestrian ? this._value as PedestrianRouteSearchOptions : null;

  bool get isPublicTransport => this._index == 3;
  PublicTransportRouteSearchOptions? get asPublicTransport => this.isPublicTransport ? this._value as PublicTransportRouteSearchOptions : null;

  bool get isScooter => this._index == 4;
  ScooterRouteSearchOptions? get asScooter => this.isScooter ? this._value as ScooterRouteSearchOptions : null;

  bool get isTaxi => this._index == 5;
  TaxiRouteSearchOptions? get asTaxi => this.isTaxi ? this._value as TaxiRouteSearchOptions : null;

  bool get isTruck => this._index == 6;
  TruckRouteSearchOptions? get asTruck => this.isTruck ? this._value as TruckRouteSearchOptions : null;

  T match<T>({
    required T Function(BicycleRouteSearchOptions value) bicycle,
    required T Function(CarRouteSearchOptions value) car,
    required T Function(PedestrianRouteSearchOptions value) pedestrian,
    required T Function(PublicTransportRouteSearchOptions value) publicTransport,
    required T Function(ScooterRouteSearchOptions value) scooter,
    required T Function(TaxiRouteSearchOptions value) taxi,
    required T Function(TruckRouteSearchOptions value) truck,
  }) {
    return switch (this._index) {
      0 => bicycle(this._value as BicycleRouteSearchOptions),
      1 => car(this._value as CarRouteSearchOptions),
      2 => pedestrian(this._value as PedestrianRouteSearchOptions),
      3 => publicTransport(this._value as PublicTransportRouteSearchOptions),
      4 => scooter(this._value as ScooterRouteSearchOptions),
      5 => taxi(this._value as TaxiRouteSearchOptions),
      6 => truck(this._value as TruckRouteSearchOptions),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "RouteSearchOptions(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteSearchOptions &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CRouteSearchOptionsImpl extends ffi.Union {
  external _CBicycleRouteSearchOptions _bicycle;
  external _CCarRouteSearchOptions _car;
  external _CPedestrianRouteSearchOptions _pedestrian;
  external _CPublicTransportRouteSearchOptions _publicTransport;
  external _CScooterRouteSearchOptions _scooter;
  external _CTaxiRouteSearchOptions _taxi;
  external _CTruckRouteSearchOptions _truck;
}

final class _CRouteSearchOptions extends ffi.Struct {
  external _CRouteSearchOptionsImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CRouteSearchOptionsBasicFunctions on _CRouteSearchOptions {
  void _releaseIntermediate() {
    _CRouteSearchOptions_release(this);
  }
}
	
// MARK: - RouteSearchOptions <-> CRouteSearchOptions

extension _CRouteSearchOptionsToDart on _CRouteSearchOptions {
  RouteSearchOptions _toDart() {
    return switch (this._index) {
      0 => RouteSearchOptions.bicycle(this._impl._bicycle._toDart()),
      1 => RouteSearchOptions.car(this._impl._car._toDart()),
      2 => RouteSearchOptions.pedestrian(this._impl._pedestrian._toDart()),
      3 => RouteSearchOptions.publicTransport(this._impl._publicTransport._toDart()),
      4 => RouteSearchOptions.scooter(this._impl._scooter._toDart()),
      5 => RouteSearchOptions.taxi(this._impl._taxi._toDart()),
      6 => RouteSearchOptions.truck(this._impl._truck._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CRouteSearchOptions on RouteSearchOptions {
  _CRouteSearchOptions _copyFromDartTo_CRouteSearchOptions() {
    var res = _CRouteSearchOptionsMakeDefault();
    this.match<void>(
      bicycle: (BicycleRouteSearchOptions value) {
        res._impl._bicycle = value._copyFromDartTo_CBicycleRouteSearchOptions();
        res._index = 0;
      },
      car: (CarRouteSearchOptions value) {
        res._impl._car = value._copyFromDartTo_CCarRouteSearchOptions();
        res._index = 1;
      },
      pedestrian: (PedestrianRouteSearchOptions value) {
        res._impl._pedestrian = value._copyFromDartTo_CPedestrianRouteSearchOptions();
        res._index = 2;
      },
      publicTransport: (PublicTransportRouteSearchOptions value) {
        res._impl._publicTransport = value._copyFromDartTo_CPublicTransportRouteSearchOptions();
        res._index = 3;
      },
      scooter: (ScooterRouteSearchOptions value) {
        res._impl._scooter = value._copyFromDartTo_CScooterRouteSearchOptions();
        res._index = 4;
      },
      taxi: (TaxiRouteSearchOptions value) {
        res._impl._taxi = value._copyFromDartTo_CTaxiRouteSearchOptions();
        res._index = 5;
      },
      truck: (TruckRouteSearchOptions value) {
        res._impl._truck = value._copyFromDartTo_CTruckRouteSearchOptions();
        res._index = 6;
      },
    );
    return res;
  }
}

// MARK: - RouteSearchOptions? <-> _COptional_CRouteSearchOptions

final class _COptional_CRouteSearchOptions extends ffi.Struct {
  
  external _CRouteSearchOptions value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRouteSearchOptionsBasicFunctions on _COptional_CRouteSearchOptions {
  void _releaseIntermediate() {
    _COptional_CRouteSearchOptions_release(this);
  }
}

extension _COptional_CRouteSearchOptionsToDart on _COptional_CRouteSearchOptions {
  RouteSearchOptions? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRouteSearchOptions on RouteSearchOptions? {
  _COptional_CRouteSearchOptions _copyFromDartTo_COptional_CRouteSearchOptions() {
    final cOptional = _COptional_CRouteSearchOptionsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRouteSearchOptions();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ExcludedAreaType

/** Тип исключаемой области. */
enum ExcludedAreaType {
  /**
   Исключаемая область - это окружность с центром в первой точке points и радиусом, равным extent.
   В points должна находиться ровно одна точка, в противном случае запрос завершится ошибкой.
  */
  point(0),
  /** Исключаемая область - это ломаная линия с шириной, равной extent (points - вершины линии). */
  polyline(1),
  /**
   Исключаемая область - это полигон с вершинами в points. При этом от сторон полигона
   дополнительно делается отступ на extent.
  */
  polygon(2),
  ;

  const ExcludedAreaType(this.rawValue);
  final int rawValue;

  static ExcludedAreaType getByValue(int value) {
    return ExcludedAreaType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CExcludedAreaType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CExcludedAreaTypeBasicFunctions on _CExcludedAreaType {
  void _releaseIntermediate() {
  }
}

extension _CExcludedAreaTypeToDart on _CExcludedAreaType {
  ExcludedAreaType _toDart() {
    return ExcludedAreaType.getByValue(this.rawValue);
  }
}

extension _DartTo_CExcludedAreaType on ExcludedAreaType {
  _CExcludedAreaType _copyFromDartTo_CExcludedAreaType() {
    return _CExcludedAreaTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ExcludedAreaSeverity

/** Приоритет исключения области. */
enum ExcludedAreaSeverity {
  /** Низкий приоритет исключения, область будет избегаться по возможности. */
  soft(0),
  /** Высокий приоритет исключения, область будет избегаться обязательно. */
  hard(1),
  ;

  const ExcludedAreaSeverity(this.rawValue);
  final int rawValue;

  static ExcludedAreaSeverity getByValue(int value) {
    return ExcludedAreaSeverity.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CExcludedAreaSeverity extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CExcludedAreaSeverityBasicFunctions on _CExcludedAreaSeverity {
  void _releaseIntermediate() {
  }
}

extension _CExcludedAreaSeverityToDart on _CExcludedAreaSeverity {
  ExcludedAreaSeverity _toDart() {
    return ExcludedAreaSeverity.getByValue(this.rawValue);
  }
}

extension _DartTo_CExcludedAreaSeverity on ExcludedAreaSeverity {
  _CExcludedAreaSeverity _copyFromDartTo_CExcludedAreaSeverity() {
    return _CExcludedAreaSeverityMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ExcludedArea

/** Исключаемая область, которую следует избегать при построении маршрута. */
class ExcludedArea {
  /** Тип исключаемой области. */
  final ExcludedAreaType type;
  /** Приоритет исключения области. */
  final ExcludedAreaSeverity severity;
  /** Размер исключаемой области (не больше 25 км). */
  final RouteDistance extent;
  /** Координаты точек исключаемой области (не больше 500). */
  final List<GeoPoint> points;

  const ExcludedArea({
    this.type = ExcludedAreaType.point,
    this.severity = ExcludedAreaSeverity.soft,
    required this.extent,
    required this.points
  });

  ExcludedArea copyWith({
    ExcludedAreaType? type,
    ExcludedAreaSeverity? severity,
    RouteDistance? extent,
    List<GeoPoint>? points
  }) {
    return ExcludedArea(
      type: type ?? this.type,
      severity: severity ?? this.severity,
      extent: extent ?? this.extent,
      points: points ?? this.points
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ExcludedArea &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.severity == severity &&
    other.extent == extent &&
    other.points == points;

  @override
  int get hashCode {
    return Object.hash(type, severity, extent, points);
  }

}
final class _CExcludedArea extends ffi.Struct {
  external _CExcludedAreaType type;

  external _CExcludedAreaSeverity severity;

  external _CRouteDistance extent;

  external _CArray_CGeoPoint points;

}
// MARK: - ExcludedArea <-> _CExcludedArea

extension _CExcludedAreaToDart on _CExcludedArea {
  ExcludedArea _toDart() {
    return ExcludedArea(
      type: this.type._toDart(),
      severity: this.severity._toDart(),
      extent: this.extent._toDart(),
      points: this.points._toDart()
    );
  }
}

extension _DartTo_CExcludedArea on ExcludedArea {
  _CExcludedArea _copyFromDartTo_CExcludedArea() {
    final res = _CExcludedAreaMakeDefault();
    res.type = this.type._copyFromDartTo_CExcludedAreaType();
    res.severity = this.severity._copyFromDartTo_CExcludedAreaSeverity();
    res.extent = this.extent._copyFromDartTo_CRouteDistance();
    res.points = this.points._copyFromDartTo_CArray_CGeoPoint();
    return res;
  }
}
extension _CExcludedAreaRelease on _CExcludedArea {
  void _releaseIntermediate() {
    points._releaseIntermediate();
  }
}

// MARK: - TruckPassZonePassId

/** Идентификатор пропуска, разрешающего движение грузового транспорта в пропускных зонах. */
class TruckPassZonePassId {
  final int value;

  const TruckPassZonePassId([this.value = 0]);

  TruckPassZonePassId copyWith({
    int? value
  }) {
    return TruckPassZonePassId(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TruckPassZonePassId &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CTruckPassZonePassId extends ffi.Struct {
  @ffi.Uint32()
  external int value;

}
// MARK: - TruckPassZonePassId <-> _CTruckPassZonePassId

extension _CTruckPassZonePassIdToDart on _CTruckPassZonePassId {
  TruckPassZonePassId _toDart() {
    return TruckPassZonePassId(
      this.value
    );
  }
}

extension _DartTo_CTruckPassZonePassId on TruckPassZonePassId {
  _CTruckPassZonePassId _copyFromDartTo_CTruckPassZonePassId() {
    final res = _CTruckPassZonePassIdMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CTruckPassZonePassIdRelease on _CTruckPassZonePassId {
  void _releaseIntermediate() {
  }
}

// MARK: - RouteSearchPoint

/** Описание точек, по которым строится маршрут. */
class RouteSearchPoint {
  /** Координаты, через которые нужно проложить маршрут. */
  final GeoPoint coordinates;
  /** Направление, в котором нужно преодолеть точку. */
  final Bearing? course;
  /** ID объекта, до которого будет проложена пешеходная часть маршрута. */
  final DgisObjectId objectId;
  /** Идентификатор этажного плана (для пешеходных маршрутов). */
  final LevelId? levelId;

  const RouteSearchPoint({
    required this.coordinates,
    this.course = null,
    this.objectId = const DgisObjectId(objectId: 0, entranceId: 0),
    this.levelId = null
  });

  RouteSearchPoint copyWith({
    GeoPoint? coordinates,
    Optional<Bearing?>? course,
    DgisObjectId? objectId,
    Optional<LevelId?>? levelId
  }) {
    return RouteSearchPoint(
      coordinates: coordinates ?? this.coordinates,
      course: course != null ? course.value : this.course,
      objectId: objectId ?? this.objectId,
      levelId: levelId != null ? levelId.value : this.levelId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteSearchPoint &&
    other.runtimeType == runtimeType &&
    other.coordinates == coordinates &&
    other.course == course &&
    other.objectId == objectId &&
    other.levelId == levelId;

  @override
  int get hashCode {
    return Object.hash(coordinates, course, objectId, levelId);
  }

}
final class _CRouteSearchPoint extends ffi.Struct {
  external _CGeoPoint coordinates;

  external _COptional_CBearing course;

  external _CDgisObjectId objectId;

  external _COptional_CLevelId levelId;

}
// MARK: - RouteSearchPoint <-> _CRouteSearchPoint

extension _CRouteSearchPointToDart on _CRouteSearchPoint {
  RouteSearchPoint _toDart() {
    return RouteSearchPoint(
      coordinates: this.coordinates._toDart(),
      course: this.course._toDart(),
      objectId: this.objectId._toDart(),
      levelId: this.levelId._toDart()
    );
  }
}

extension _DartTo_CRouteSearchPoint on RouteSearchPoint {
  _CRouteSearchPoint _copyFromDartTo_CRouteSearchPoint() {
    final res = _CRouteSearchPointMakeDefault();
    res.coordinates = this.coordinates._copyFromDartTo_CGeoPoint();
    res.course = this.course._copyFromDartTo_COptional_CBearing();
    res.objectId = this.objectId._copyFromDartTo_CDgisObjectId();
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    return res;
  }
}
extension _CRouteSearchPointRelease on _CRouteSearchPoint {
  void _releaseIntermediate() {
  }
}

// MARK: - RouteSearchPoint? <-> _COptional_CRouteSearchPoint

final class _COptional_CRouteSearchPoint extends ffi.Struct {
  
  external _CRouteSearchPoint value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRouteSearchPointBasicFunctions on _COptional_CRouteSearchPoint {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CRouteSearchPointToDart on _COptional_CRouteSearchPoint {
  RouteSearchPoint? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRouteSearchPoint on RouteSearchPoint? {
  _COptional_CRouteSearchPoint _copyFromDartTo_COptional_CRouteSearchPoint() {
    final cOptional = _COptional_CRouteSearchPointMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRouteSearchPoint();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - PackedNavigationState <-> _CResult_CPackedNavigationState

final class _CResult_CPackedNavigationStateImpl extends ffi.Union {
  
  external _CPackedNavigationState _value;
  external _CError _error;
}

final class _CResult_CPackedNavigationState extends ffi.Struct {
  external _CResult_CPackedNavigationStateImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CPackedNavigationStateBasicFunctions on _CResult_CPackedNavigationState {
  void _releaseIntermediate() {
    _CResult_CPackedNavigationState_release(this);
  }
}

extension _CResult_CPackedNavigationStateToDart on _CResult_CPackedNavigationState {
  PackedNavigationState _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CPackedNavigationState _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - BetterRouteResponse

/** Ответ пользователя на предложение альтернативного маршрута. */
enum BetterRouteResponse {
  /** Пользователь принял предложение перейти на альтернативный маршрут. */
  accept(0),
  /** Пользователь явно отказался от предложения перейти на альтернативный маршрут. */
  reject(1),
  timeout(2),
  ;

  const BetterRouteResponse(this.rawValue);
  final int rawValue;

  static BetterRouteResponse getByValue(int value) {
    return BetterRouteResponse.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CBetterRouteResponse extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CBetterRouteResponseBasicFunctions on _CBetterRouteResponse {
  void _releaseIntermediate() {
  }
}

extension _CBetterRouteResponseToDart on _CBetterRouteResponse {
  BetterRouteResponse _toDart() {
    return BetterRouteResponse.getByValue(this.rawValue);
  }
}

extension _DartTo_CBetterRouteResponse on BetterRouteResponse {
  _CBetterRouteResponse _copyFromDartTo_CBetterRouteResponse() {
    return _CBetterRouteResponseMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Model

/** Модель навигатора, предназначенная для отображения в UI. */
class Model implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Состояние навигатора. */
  StatefulChannel<State> get stateChannel {
    _CStatefulChannel_CState res = _CModel_stateChannel(_CModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Состояние навигатора. */
  State get state {
    _CState res = _CModel_state(_CModelMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Текущая геопозиция, с которой работает навигатор.
  
   - see: location_available_channel
  */
  StatefulChannel<Location?> get locationChannel {
    _CStatefulChannel_COptional_CLocation res = _CModel_locationChannel(_CModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Текущая геопозиция, с которой работает навигатор.
  
   - see: location_available_channel
  */
  Location? get location {
    _COptional_CLocation res = _CModel_location(_CModelMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Флаг, который указывает используется ли текущая геопозия для навигации.
   После получения геопозиции навигатор решает пригодна ли она для того, чтобы использовать её для навигации
   (например, если у геопозиции слишком большая погрешность, навигатор может решить, что она не пригодна для
   навигации)
   Если геопозиция пригодна для навигации, навигатор выставляет в этом канале значение true,
   если не пригодна - false.
  
   - Note: Даже если значение в данном канале равно false, в канале location_channel геопозиция может обновляться.
   - see: location_channel
  */
  StatefulChannel<bool> get locationAvailableChannel {
    _CStatefulChannel_bool res = _CModel_locationAvailableChannel(_CModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Флаг, который указывает используется ли текущая геопозия для навигации.
   После получения геопозиции навигатор решает пригодна ли она для того, чтобы использовать её для навигации
   (например, если у геопозиции слишком большая погрешность, навигатор может решить, что она не пригодна для
   навигации)
   Если геопозиция пригодна для навигации, навигатор выставляет в этом канале значение true,
   если не пригодна - false.
  
   - Note: Даже если значение в данном канале равно false, в канале location_channel геопозиция может обновляться.
   - see: location_channel
  */
  bool get locationAvailable {
    bool res = _CModel_locationAvailable(_CModelMakeDefault().._impl=_self);
    return res;
  }
  /**
   Маршрут с манёврами.
  
   - Note: В режиме свободной езды (StateChannel::FreeRoam) отсутствует маршрут по которому движется пользователь.
   Поэтому участок дороги, по которой в данный момент движется пользователь,
   навигатор представляет в виде маршрута и отдает его как текущий маршрут.
   Такое описание дороги не является полноценным маршрутом, т.к. у него нет финиша и манёвров.
  */
  StatefulChannel<RouteInfo> get routeChannel {
    _CStatefulChannel_CRouteInfo res = _CModel_routeChannel(_CModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Маршрут с манёврами.
  
   - Note: В режиме свободной езды (StateChannel::FreeRoam) отсутствует маршрут по которому движется пользователь.
   Поэтому участок дороги, по которой в данный момент движется пользователь,
   навигатор представляет в виде маршрута и отдает его как текущий маршрут.
   Такое описание дороги не является полноценным маршрутом, т.к. у него нет финиша и манёвров.
  */
  RouteInfo get route {
    _CRouteInfo res = _CModel_route(_CModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Дорожные события и пробочные данные на маршруте
   или на прогнозируемой части маршрута для режима FreeRoam.
  */
  StatefulChannel<DynamicRouteInfo> get dynamicRouteInfoChannel {
    _CStatefulChannel_CDynamicRouteInfo res = _CModel_dynamicRouteInfoChannel(_CModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Дорожные события и пробочные данные на маршруте
   или на прогнозируемой части маршрута для режима FreeRoam.
  */
  DynamicRouteInfo get dynamicRouteInfo {
    _CDynamicRouteInfo res = _CModel_dynamicRouteInfo(_CModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Текущая позиция пользователя на маршруте. */
  StatefulChannel<RoutePoint?> get routePositionChannel {
    _CStatefulChannel_COptional_CRoutePoint res = _CModel_routePositionChannel(_CModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Текущая позиция пользователя на маршруте. */
  RoutePoint? get routePosition {
    _COptional_CRoutePoint res = _CModel_routePosition(_CModelMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Флаг превышения максимальной разрешенной скорости. */
  StatefulChannel<bool> get exceedingMaxSpeedLimitChannel {
    _CStatefulChannel_bool res = _CModel_exceedingMaxSpeedLimitChannel(_CModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Флаг превышения максимальной разрешенной скорости. */
  bool get exceedingMaxSpeedLimit {
    bool res = _CModel_exceedingMaxSpeedLimit(_CModelMakeDefault().._impl=_self);
    return res;
  }
  /**
   Сигнал о нахождении альтернативного маршрута с меньшей ожидаемой длительностью движения.
   Если значение в канале равно null, это значит, что альтернативный маршрут
   не найден, либо перестал быть актуальным.
  */
  StatefulChannel<BetterRouteInfo?> get betterRouteChannel {
    _CStatefulChannel_COptional_CBetterRouteInfo res = _CModel_betterRouteChannel(_CModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Сигнал о нахождении альтернативного маршрута с меньшей ожидаемой длительностью движения.
   Если значение в канале равно null, это значит, что альтернативный маршрут
   не найден, либо перестал быть актуальным.
  */
  BetterRouteInfo? get betterRoute {
    _COptional_CBetterRouteInfo res = _CModel_betterRoute(_CModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CModel_releasePtr);

  Model._raw(this._self);
  factory Model._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Model._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Model &&
    other.runtimeType == runtimeType &&
    _CModel_cg_objectIdentifier(this._self) == _CModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Model: Methods

  /** Ответ пользователя о применении предложенного маршрута лучше. */
  void betterRouteResponse(
    BetterRouteResponse response
  )  {
    var _a1 = response._copyFromDartTo_CBetterRouteResponse();
    void res = _CModel_betterRouteResponse_CBetterRouteResponse(_CModelMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - Model <-> CModel

final class _CModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CModelBasicFunctions on _CModel {
  void _releaseIntermediate() {
    _CModel_release(_impl);
  }

  _CModel _retain() {
    return _CModel_retain(_impl);
  }
}

extension _CModelToDart on _CModel {
  Model _toDart() {
    return Model._create(_retain()._impl);
  }
}


extension _DartToCModel on Model {
  _CModel _copyFromDartTo_CModel() {
    return (_CModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<State> <-> _CStatefulChannel_CState

class _CStatefulChannel_CStateImpl extends StatefulChannel<State> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<State>>{};

  final _CStatefulChannel_CState _channel;

  _CStatefulChannel_CStateImpl(this._channel);

  @override
  State get value {
    return this._channel._getter();
  }

  static void valueFunction(_CState cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<State> listen(void onData(State event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CState, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<State>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CStateBasicFunctions on _CStatefulChannel_CState {
  void _releaseIntermediate() {
    _CStatefulChannel_CState_release(this);
  }

  _CStatefulChannel_CState _retain() {
    return _CStatefulChannel_CState_retain(this);
  }

  State _getter() {
    final cValue = _CStatefulChannel_CStateGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CState, ffi.Int64)> callback) {
    return _CStatefulChannel_CStateConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CStateToDart on _CStatefulChannel_CState {
  StatefulChannel<State> _toDart() {
    return _CStatefulChannel_CStateImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CState on StatefulChannel<State> {
  _CStatefulChannel_CState _copyFromDartTo_CStatefulChannel_CState() {
    return _CStatefulChannel_CStateMakeDefault();
  }
}
	
// MARK: - StatefulChannel<Location?> <-> _CStatefulChannel_COptional_CLocation

class _CStatefulChannel_COptional_CLocationImpl extends StatefulChannel<Location?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Location?>>{};

  final _CStatefulChannel_COptional_CLocation _channel;

  _CStatefulChannel_COptional_CLocationImpl(this._channel);

  @override
  Location? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CLocation cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<Location?> listen(void onData(Location? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CLocation, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Location?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CLocation extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CLocationBasicFunctions on _CStatefulChannel_COptional_CLocation {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CLocation_release(this);
  }

  _CStatefulChannel_COptional_CLocation _retain() {
    return _CStatefulChannel_COptional_CLocation_retain(this);
  }

  Location? _getter() {
    final cValue = _CStatefulChannel_COptional_CLocationGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CLocation, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CLocationConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CLocationToDart on _CStatefulChannel_COptional_CLocation {
  StatefulChannel<Location?> _toDart() {
    return _CStatefulChannel_COptional_CLocationImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CLocation on StatefulChannel<Location?> {
  _CStatefulChannel_COptional_CLocation _copyFromDartTo_CStatefulChannel_COptional_CLocation() {
    return _CStatefulChannel_COptional_CLocationMakeDefault();
  }
}
	
// MARK: - StatefulChannel<RouteInfo> <-> _CStatefulChannel_CRouteInfo

class _CStatefulChannel_CRouteInfoImpl extends StatefulChannel<RouteInfo> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RouteInfo>>{};

  final _CStatefulChannel_CRouteInfo _channel;

  _CStatefulChannel_CRouteInfoImpl(this._channel);

  @override
  RouteInfo get value {
    return this._channel._getter();
  }

  static void valueFunction(_CRouteInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<RouteInfo> listen(void onData(RouteInfo event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CRouteInfo, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RouteInfo>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CRouteInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CRouteInfoBasicFunctions on _CStatefulChannel_CRouteInfo {
  void _releaseIntermediate() {
    _CStatefulChannel_CRouteInfo_release(this);
  }

  _CStatefulChannel_CRouteInfo _retain() {
    return _CStatefulChannel_CRouteInfo_retain(this);
  }

  RouteInfo _getter() {
    final cValue = _CStatefulChannel_CRouteInfoGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CRouteInfo, ffi.Int64)> callback) {
    return _CStatefulChannel_CRouteInfoConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CRouteInfoToDart on _CStatefulChannel_CRouteInfo {
  StatefulChannel<RouteInfo> _toDart() {
    return _CStatefulChannel_CRouteInfoImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CRouteInfo on StatefulChannel<RouteInfo> {
  _CStatefulChannel_CRouteInfo _copyFromDartTo_CStatefulChannel_CRouteInfo() {
    return _CStatefulChannel_CRouteInfoMakeDefault();
  }
}
	
// MARK: - RouteBuildOptions

/** Структура, которая описывает параметры построения маршрута в навигаторе. */
class RouteBuildOptions {
  /** Точка, к которой строится маршут. */
  final RouteSearchPoint finishPoint;
  /** Параметры поиска маршрута. */
  final RouteSearchOptions routeSearchOptions;

  const RouteBuildOptions({
    required this.finishPoint,
    required this.routeSearchOptions
  });

  RouteBuildOptions copyWith({
    RouteSearchPoint? finishPoint,
    RouteSearchOptions? routeSearchOptions
  }) {
    return RouteBuildOptions(
      finishPoint: finishPoint ?? this.finishPoint,
      routeSearchOptions: routeSearchOptions ?? this.routeSearchOptions
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteBuildOptions &&
    other.runtimeType == runtimeType &&
    other.finishPoint == finishPoint &&
    other.routeSearchOptions == routeSearchOptions;

  @override
  int get hashCode {
    return Object.hash(finishPoint, routeSearchOptions);
  }

}
final class _CRouteBuildOptions extends ffi.Struct {
  external _CRouteSearchPoint finishPoint;

  external _CRouteSearchOptions routeSearchOptions;

}
// MARK: - RouteBuildOptions <-> _CRouteBuildOptions

extension _CRouteBuildOptionsToDart on _CRouteBuildOptions {
  RouteBuildOptions _toDart() {
    return RouteBuildOptions(
      finishPoint: this.finishPoint._toDart(),
      routeSearchOptions: this.routeSearchOptions._toDart()
    );
  }
}

extension _DartTo_CRouteBuildOptions on RouteBuildOptions {
  _CRouteBuildOptions _copyFromDartTo_CRouteBuildOptions() {
    final res = _CRouteBuildOptionsMakeDefault();
    res.finishPoint = this.finishPoint._copyFromDartTo_CRouteSearchPoint();
    res.routeSearchOptions = this.routeSearchOptions._copyFromDartTo_CRouteSearchOptions();
    return res;
  }
}
extension _CRouteBuildOptionsRelease on _CRouteBuildOptions {
  void _releaseIntermediate() {
    routeSearchOptions._releaseIntermediate();
  }
}

// MARK: - RouteBuildOptions? <-> _COptional_CRouteBuildOptions

final class _COptional_CRouteBuildOptions extends ffi.Struct {
  
  external _CRouteBuildOptions value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRouteBuildOptionsBasicFunctions on _COptional_CRouteBuildOptions {
  void _releaseIntermediate() {
    _COptional_CRouteBuildOptions_release(this);
  }
}

extension _COptional_CRouteBuildOptionsToDart on _COptional_CRouteBuildOptions {
  RouteBuildOptions? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRouteBuildOptions on RouteBuildOptions? {
  _COptional_CRouteBuildOptions _copyFromDartTo_COptional_CRouteBuildOptions() {
    final cOptional = _COptional_CRouteBuildOptionsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRouteBuildOptions();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - RouteInfo

/** Описание маршрута с манёврами. */
class RouteInfo {
  /** Маршрут. */
  final Route route;
  /**
   Параметры построения маршрута в навигаторе.
   Значение равное null означает, что у маршрута отсутствует конечная точка.
   В этом случае, на основании дорожного графа и параметров движения пользователя, вычисляется участок дороги,
   по которому предположительно движется пользователь и возвращается в виде маршрута в поле route.
   Следовательно, такой "маршрут" не может содержать инструкции и последняя точка в этом "маршруте"
   не является точкой назначения, в которую движется пользователь, а просто является точкой,
   до которой удалось предугадать движение пользователя. Куда он поедет дальше - неизвестно.
   Такой режим работы навигатора называется режим ведения без маршрута или free roam.
  */
  final RouteBuildOptions? routeBuildOptions;
  /**
   Источник маршрута.
   True - маршрут передан навигатору снаружи в методе start.
   False - маршрут сгенерирован самим навигатором.
  */
  final bool external_;

  const RouteInfo({
    required this.route,
    required this.routeBuildOptions,
    this.external_ = false
  });

  RouteInfo copyWith({
    Route? route,
    Optional<RouteBuildOptions?>? routeBuildOptions,
    bool? external_
  }) {
    return RouteInfo(
      route: route ?? this.route,
      routeBuildOptions: routeBuildOptions != null ? routeBuildOptions.value : this.routeBuildOptions,
      external_: external_ ?? this.external_
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteInfo &&
    other.runtimeType == runtimeType &&
    other.route == route &&
    other.routeBuildOptions == routeBuildOptions &&
    other.external_ == external_;

  @override
  int get hashCode {
    return Object.hash(route, routeBuildOptions, external_);
  }

}
final class _CRouteInfo extends ffi.Struct {
  external _CRoute route;

  external _COptional_CRouteBuildOptions routeBuildOptions;

  @ffi.Bool()
  external bool external_;

}
// MARK: - RouteInfo <-> _CRouteInfo

extension _CRouteInfoToDart on _CRouteInfo {
  RouteInfo _toDart() {
    return RouteInfo(
      route: this.route._toDart(),
      routeBuildOptions: this.routeBuildOptions._toDart(),
      external_: this.external_
    );
  }
}

extension _DartTo_CRouteInfo on RouteInfo {
  _CRouteInfo _copyFromDartTo_CRouteInfo() {
    final res = _CRouteInfoMakeDefault();
    res.route = this.route._copyFromDartTo_CRoute();
    res.routeBuildOptions = this.routeBuildOptions._copyFromDartTo_COptional_CRouteBuildOptions();
    res.external_ = this.external_;
    return res;
  }
}
extension _CRouteInfoRelease on _CRouteInfo {
  void _releaseIntermediate() {
    route._releaseIntermediate();
    routeBuildOptions._releaseIntermediate();
  }
}

// MARK: - StatefulChannel<DynamicRouteInfo> <-> _CStatefulChannel_CDynamicRouteInfo

class _CStatefulChannel_CDynamicRouteInfoImpl extends StatefulChannel<DynamicRouteInfo> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<DynamicRouteInfo>>{};

  final _CStatefulChannel_CDynamicRouteInfo _channel;

  _CStatefulChannel_CDynamicRouteInfoImpl(this._channel);

  @override
  DynamicRouteInfo get value {
    return this._channel._getter();
  }

  static void valueFunction(_CDynamicRouteInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<DynamicRouteInfo> listen(void onData(DynamicRouteInfo event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CDynamicRouteInfo, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<DynamicRouteInfo>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CDynamicRouteInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CDynamicRouteInfoBasicFunctions on _CStatefulChannel_CDynamicRouteInfo {
  void _releaseIntermediate() {
    _CStatefulChannel_CDynamicRouteInfo_release(this);
  }

  _CStatefulChannel_CDynamicRouteInfo _retain() {
    return _CStatefulChannel_CDynamicRouteInfo_retain(this);
  }

  DynamicRouteInfo _getter() {
    final cValue = _CStatefulChannel_CDynamicRouteInfoGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CDynamicRouteInfo, ffi.Int64)> callback) {
    return _CStatefulChannel_CDynamicRouteInfoConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CDynamicRouteInfoToDart on _CStatefulChannel_CDynamicRouteInfo {
  StatefulChannel<DynamicRouteInfo> _toDart() {
    return _CStatefulChannel_CDynamicRouteInfoImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CDynamicRouteInfo on StatefulChannel<DynamicRouteInfo> {
  _CStatefulChannel_CDynamicRouteInfo _copyFromDartTo_CStatefulChannel_CDynamicRouteInfo() {
    return _CStatefulChannel_CDynamicRouteInfoMakeDefault();
  }
}
	
// MARK: - RoadEventRouteAttribute

/**
 Контейнер, который описывает точечный атрибут маршрута.
 Каждый элемент хранится в виде точки на маршруте, в которой этот элемент расположен и значения самого элемента.
*/
class RoadEventRouteAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CRoadEventRouteAttribute_size(_CRoadEventRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CRoadEventRouteAttribute_isEmpty(_CRoadEventRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  RoadEventRouteEntry? get first {
    _COptional_CRoadEventRouteEntry res = _CRoadEventRouteAttribute_first(_CRoadEventRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  RoadEventRouteEntry? get last {
    _COptional_CRoadEventRouteEntry res = _CRoadEventRouteAttribute_last(_CRoadEventRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<RoadEventRouteEntry> get entries {
    _CArray_CRoadEventRouteEntry res = _CRoadEventRouteAttribute_entries(_CRoadEventRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadEventRouteAttribute_releasePtr);

  RoadEventRouteAttribute._raw(this._self);
  factory RoadEventRouteAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEventRouteAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventRouteAttribute &&
    other.runtimeType == runtimeType &&
    _CRoadEventRouteAttribute_cg_objectIdentifier(this._self) == _CRoadEventRouteAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEventRouteAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadEventRouteAttribute: Methods

  /**
   Элементы, попадающие в отрезок [begin, end).
  
   - Throws: Exception если begin > end.
  */
  List<RoadEventRouteEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CRoadEventRouteEntry res = _CRoadEventRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CRoadEventRouteAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого
   <
   = point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  RoadEventRouteEntry? findNearBackward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRoadEventRouteEntry res = _CRoadEventRouteAttribute_findNearBackward_CRoutePoint(_CRoadEventRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Найти ближайший элемент, позиция которого >= point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  RoadEventRouteEntry? findNearForward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRoadEventRouteEntry res = _CRoadEventRouteAttribute_findNearForward_CRoutePoint(_CRoadEventRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

}

// MARK: - RoadEventRouteAttribute <-> CRoadEventRouteAttribute

final class _CRoadEventRouteAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventRouteAttributeBasicFunctions on _CRoadEventRouteAttribute {
  void _releaseIntermediate() {
    _CRoadEventRouteAttribute_release(_impl);
  }

  _CRoadEventRouteAttribute _retain() {
    return _CRoadEventRouteAttribute_retain(_impl);
  }
}

extension _CRoadEventRouteAttributeToDart on _CRoadEventRouteAttribute {
  RoadEventRouteAttribute _toDart() {
    return RoadEventRouteAttribute._create(_retain()._impl);
  }
}


extension _DartToCRoadEventRouteAttribute on RoadEventRouteAttribute {
  _CRoadEventRouteAttribute _copyFromDartTo_CRoadEventRouteAttribute() {
    return (_CRoadEventRouteAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DynamicRouteInfo

class DynamicRouteInfo {
  final RoadEventRouteAttribute roadEvents;
  final Traffic traffic;

  const DynamicRouteInfo({
    required this.roadEvents,
    required this.traffic
  });

  DynamicRouteInfo copyWith({
    RoadEventRouteAttribute? roadEvents,
    Traffic? traffic
  }) {
    return DynamicRouteInfo(
      roadEvents: roadEvents ?? this.roadEvents,
      traffic: traffic ?? this.traffic
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DynamicRouteInfo &&
    other.runtimeType == runtimeType &&
    other.roadEvents == roadEvents &&
    other.traffic == traffic;

  @override
  int get hashCode {
    return Object.hash(roadEvents, traffic);
  }

}
final class _CDynamicRouteInfo extends ffi.Struct {
  external _CRoadEventRouteAttribute roadEvents;

  external _CTraffic traffic;

}
// MARK: - DynamicRouteInfo <-> _CDynamicRouteInfo

extension _CDynamicRouteInfoToDart on _CDynamicRouteInfo {
  DynamicRouteInfo _toDart() {
    return DynamicRouteInfo(
      roadEvents: this.roadEvents._toDart(),
      traffic: this.traffic._toDart()
    );
  }
}

extension _DartTo_CDynamicRouteInfo on DynamicRouteInfo {
  _CDynamicRouteInfo _copyFromDartTo_CDynamicRouteInfo() {
    final res = _CDynamicRouteInfoMakeDefault();
    res.roadEvents = this.roadEvents._copyFromDartTo_CRoadEventRouteAttribute();
    res.traffic = this.traffic._copyFromDartTo_CTraffic();
    return res;
  }
}
extension _CDynamicRouteInfoRelease on _CDynamicRouteInfo {
  void _releaseIntermediate() {
    roadEvents._releaseIntermediate();
    traffic._releaseIntermediate();
  }
}

// MARK: - BriefRoadEvent

class BriefRoadEvent {
  final int id;
  final RoadEventType eventType;
  final LaneEnumSet lanes;

  const BriefRoadEvent({
    this.id = 0,
    this.eventType = RoadEventType.other,
    required this.lanes
  });

  BriefRoadEvent copyWith({
    int? id,
    RoadEventType? eventType,
    LaneEnumSet? lanes
  }) {
    return BriefRoadEvent(
      id: id ?? this.id,
      eventType: eventType ?? this.eventType,
      lanes: lanes ?? this.lanes
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BriefRoadEvent &&
    other.runtimeType == runtimeType &&
    other.id == id &&
    other.eventType == eventType &&
    other.lanes == lanes;

  @override
  int get hashCode {
    return Object.hash(id, eventType, lanes);
  }

}
final class _CBriefRoadEvent extends ffi.Struct {
  @ffi.Uint64()
  external int id;

  external _CRoadEventType eventType;

  external _COptionSet_CLane lanes;

}
// MARK: - BriefRoadEvent <-> _CBriefRoadEvent

extension _CBriefRoadEventToDart on _CBriefRoadEvent {
  BriefRoadEvent _toDart() {
    return BriefRoadEvent(
      id: this.id,
      eventType: this.eventType._toDart(),
      lanes: this.lanes._toDart()
    );
  }
}

extension _DartTo_CBriefRoadEvent on BriefRoadEvent {
  _CBriefRoadEvent _copyFromDartTo_CBriefRoadEvent() {
    final res = _CBriefRoadEventMakeDefault();
    res.id = this.id;
    res.eventType = this.eventType._copyFromDartTo_CRoadEventType();
    res.lanes = this.lanes._copyFromDartTo_COptionSet_CLane();
    return res;
  }
}
extension _CBriefRoadEventRelease on _CBriefRoadEvent {
  void _releaseIntermediate() {
  }
}

// MARK: - RoadEventRouteEntry

/** Элемент маршрута - точка и значение в ней. */
class RoadEventRouteEntry {
  final RoutePoint point;
  final BriefRoadEvent value;

  const RoadEventRouteEntry({
    required this.point,
    required this.value
  });

  RoadEventRouteEntry copyWith({
    RoutePoint? point,
    BriefRoadEvent? value
  }) {
    return RoadEventRouteEntry(
      point: point ?? this.point,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventRouteEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, value);
  }

}
final class _CRoadEventRouteEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CBriefRoadEvent value;

}
// MARK: - RoadEventRouteEntry <-> _CRoadEventRouteEntry

extension _CRoadEventRouteEntryToDart on _CRoadEventRouteEntry {
  RoadEventRouteEntry _toDart() {
    return RoadEventRouteEntry(
      point: this.point._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CRoadEventRouteEntry on RoadEventRouteEntry {
  _CRoadEventRouteEntry _copyFromDartTo_CRoadEventRouteEntry() {
    final res = _CRoadEventRouteEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.value = this.value._copyFromDartTo_CBriefRoadEvent();
    return res;
  }
}
extension _CRoadEventRouteEntryRelease on _CRoadEventRouteEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - RoadEventRouteEntry? <-> _COptional_CRoadEventRouteEntry

final class _COptional_CRoadEventRouteEntry extends ffi.Struct {
  
  external _CRoadEventRouteEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRoadEventRouteEntryBasicFunctions on _COptional_CRoadEventRouteEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CRoadEventRouteEntryToDart on _COptional_CRoadEventRouteEntry {
  RoadEventRouteEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRoadEventRouteEntry on RoadEventRouteEntry? {
  _COptional_CRoadEventRouteEntry _copyFromDartTo_COptional_CRoadEventRouteEntry() {
    final cOptional = _COptional_CRoadEventRouteEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRoadEventRouteEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<RoadEventRouteEntry> <-> _CArray_CRoadEventRouteEntry

final class _CArray_CRoadEventRouteEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRoadEventRouteEntryToDart on _CArray_CRoadEventRouteEntry {
  List<RoadEventRouteEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRoadEventRouteEntry on List<RoadEventRouteEntry> {
  _CArray_CRoadEventRouteEntry _copyFromDartTo_CArray_CRoadEventRouteEntry() {
    final cArray = _CArray_CRoadEventRouteEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRoadEventRouteEntry();
        _CArray_CRoadEventRouteEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CRoadEventRouteEntryBasicFunctions on _CArray_CRoadEventRouteEntry {
  void _releaseIntermediate() {
    _CArray_CRoadEventRouteEntry_release(this);
  }

  static final _listToFill = <RoadEventRouteEntry>[];

  static void _iterate(_CRoadEventRouteEntry item) {
    _listToFill.add(item._toDart());
  }

  List<RoadEventRouteEntry> _fillFromC() {
    _forEach_CArray_CRoadEventRouteEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRoadEventRouteEntry)>(_iterate));
    final result = List<RoadEventRouteEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - StatefulChannel<RoutePoint?> <-> _CStatefulChannel_COptional_CRoutePoint

class _CStatefulChannel_COptional_CRoutePointImpl extends StatefulChannel<RoutePoint?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RoutePoint?>>{};

  final _CStatefulChannel_COptional_CRoutePoint _channel;

  _CStatefulChannel_COptional_CRoutePointImpl(this._channel);

  @override
  RoutePoint? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CRoutePoint cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<RoutePoint?> listen(void onData(RoutePoint? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CRoutePoint, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RoutePoint?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CRoutePoint extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CRoutePointBasicFunctions on _CStatefulChannel_COptional_CRoutePoint {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CRoutePoint_release(this);
  }

  _CStatefulChannel_COptional_CRoutePoint _retain() {
    return _CStatefulChannel_COptional_CRoutePoint_retain(this);
  }

  RoutePoint? _getter() {
    final cValue = _CStatefulChannel_COptional_CRoutePointGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CRoutePoint, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CRoutePointConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CRoutePointToDart on _CStatefulChannel_COptional_CRoutePoint {
  StatefulChannel<RoutePoint?> _toDart() {
    return _CStatefulChannel_COptional_CRoutePointImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CRoutePoint on StatefulChannel<RoutePoint?> {
  _CStatefulChannel_COptional_CRoutePoint _copyFromDartTo_CStatefulChannel_COptional_CRoutePoint() {
    return _CStatefulChannel_COptional_CRoutePointMakeDefault();
  }
}
	
// MARK: - StatefulChannel<BetterRouteInfo?> <-> _CStatefulChannel_COptional_CBetterRouteInfo

class _CStatefulChannel_COptional_CBetterRouteInfoImpl extends StatefulChannel<BetterRouteInfo?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<BetterRouteInfo?>>{};

  final _CStatefulChannel_COptional_CBetterRouteInfo _channel;

  _CStatefulChannel_COptional_CBetterRouteInfoImpl(this._channel);

  @override
  BetterRouteInfo? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CBetterRouteInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<BetterRouteInfo?> listen(void onData(BetterRouteInfo? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CBetterRouteInfo, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<BetterRouteInfo?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CBetterRouteInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CBetterRouteInfoBasicFunctions on _CStatefulChannel_COptional_CBetterRouteInfo {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CBetterRouteInfo_release(this);
  }

  _CStatefulChannel_COptional_CBetterRouteInfo _retain() {
    return _CStatefulChannel_COptional_CBetterRouteInfo_retain(this);
  }

  BetterRouteInfo? _getter() {
    final cValue = _CStatefulChannel_COptional_CBetterRouteInfoGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CBetterRouteInfo, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CBetterRouteInfoConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CBetterRouteInfoToDart on _CStatefulChannel_COptional_CBetterRouteInfo {
  StatefulChannel<BetterRouteInfo?> _toDart() {
    return _CStatefulChannel_COptional_CBetterRouteInfoImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CBetterRouteInfo on StatefulChannel<BetterRouteInfo?> {
  _CStatefulChannel_COptional_CBetterRouteInfo _copyFromDartTo_CStatefulChannel_COptional_CBetterRouteInfo() {
    return _CStatefulChannel_COptional_CBetterRouteInfoMakeDefault();
  }
}
	
// MARK: - BetterRouteInfo

/** Информация о доступном альтернативном маршруте. */
class BetterRouteInfo {
  /** Альтернативный маршрут. */
  final TrafficRoute trafficRoute;
  /**
   Точка на альтернативном маршруте, с которой начнётся движение в случае
   перехода на этот маршрут
  */
  final RoutePoint startPoint;

  const BetterRouteInfo({
    required this.trafficRoute,
    required this.startPoint
  });

  BetterRouteInfo copyWith({
    TrafficRoute? trafficRoute,
    RoutePoint? startPoint
  }) {
    return BetterRouteInfo(
      trafficRoute: trafficRoute ?? this.trafficRoute,
      startPoint: startPoint ?? this.startPoint
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BetterRouteInfo &&
    other.runtimeType == runtimeType &&
    other.trafficRoute == trafficRoute &&
    other.startPoint == startPoint;

  @override
  int get hashCode {
    return Object.hash(trafficRoute, startPoint);
  }

}
final class _CBetterRouteInfo extends ffi.Struct {
  external _CTrafficRoute trafficRoute;

  external _CRoutePoint startPoint;

}
// MARK: - BetterRouteInfo <-> _CBetterRouteInfo

extension _CBetterRouteInfoToDart on _CBetterRouteInfo {
  BetterRouteInfo _toDart() {
    return BetterRouteInfo(
      trafficRoute: this.trafficRoute._toDart(),
      startPoint: this.startPoint._toDart()
    );
  }
}

extension _DartTo_CBetterRouteInfo on BetterRouteInfo {
  _CBetterRouteInfo _copyFromDartTo_CBetterRouteInfo() {
    final res = _CBetterRouteInfoMakeDefault();
    res.trafficRoute = this.trafficRoute._copyFromDartTo_CTrafficRoute();
    res.startPoint = this.startPoint._copyFromDartTo_CRoutePoint();
    return res;
  }
}
extension _CBetterRouteInfoRelease on _CBetterRouteInfo {
  void _releaseIntermediate() {
    trafficRoute._releaseIntermediate();
  }
}

// MARK: - BetterRouteInfo? <-> _COptional_CBetterRouteInfo

final class _COptional_CBetterRouteInfo extends ffi.Struct {
  
  external _CBetterRouteInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CBetterRouteInfoBasicFunctions on _COptional_CBetterRouteInfo {
  void _releaseIntermediate() {
    _COptional_CBetterRouteInfo_release(this);
  }
}

extension _COptional_CBetterRouteInfoToDart on _COptional_CBetterRouteInfo {
  BetterRouteInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CBetterRouteInfo on BetterRouteInfo? {
  _COptional_CBetterRouteInfo _copyFromDartTo_COptional_CBetterRouteInfo() {
    final cOptional = _COptional_CBetterRouteInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CBetterRouteInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - RouteIndex

/** Индекс активного маршрута. */
class RouteIndex {
  final int value;

  const RouteIndex([this.value = 0]);

  RouteIndex copyWith({
    int? value
  }) {
    return RouteIndex(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteIndex &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CRouteIndex extends ffi.Struct {
  @ffi.Uint64()
  external int value;

}
// MARK: - RouteIndex <-> _CRouteIndex

extension _CRouteIndexToDart on _CRouteIndex {
  RouteIndex _toDart() {
    return RouteIndex(
      this.value
    );
  }
}

extension _DartTo_CRouteIndex on RouteIndex {
  _CRouteIndex _copyFromDartTo_CRouteIndex() {
    final res = _CRouteIndexMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CRouteIndexRelease on _CRouteIndex {
  void _releaseIntermediate() {
  }
}

// MARK: - StatefulChannel<RouteDistance> <-> _CStatefulChannel_CRouteDistance

class _CStatefulChannel_CRouteDistanceImpl extends StatefulChannel<RouteDistance> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RouteDistance>>{};

  final _CStatefulChannel_CRouteDistance _channel;

  _CStatefulChannel_CRouteDistanceImpl(this._channel);

  @override
  RouteDistance get value {
    return this._channel._getter();
  }

  static void valueFunction(_CRouteDistance cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<RouteDistance> listen(void onData(RouteDistance event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CRouteDistance, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RouteDistance>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CRouteDistance extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CRouteDistanceBasicFunctions on _CStatefulChannel_CRouteDistance {
  void _releaseIntermediate() {
    _CStatefulChannel_CRouteDistance_release(this);
  }

  _CStatefulChannel_CRouteDistance _retain() {
    return _CStatefulChannel_CRouteDistance_retain(this);
  }

  RouteDistance _getter() {
    final cValue = _CStatefulChannel_CRouteDistanceGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CRouteDistance, ffi.Int64)> callback) {
    return _CStatefulChannel_CRouteDistanceConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CRouteDistanceToDart on _CStatefulChannel_CRouteDistance {
  StatefulChannel<RouteDistance> _toDart() {
    return _CStatefulChannel_CRouteDistanceImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CRouteDistance on StatefulChannel<RouteDistance> {
  _CStatefulChannel_CRouteDistance _copyFromDartTo_CStatefulChannel_CRouteDistance() {
    return _CStatefulChannel_CRouteDistanceMakeDefault();
  }
}
	
// MARK: - StatefulChannel<RouteMapObjectPassedDistanceVisualization> <-> _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization

class _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationImpl extends StatefulChannel<RouteMapObjectPassedDistanceVisualization> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RouteMapObjectPassedDistanceVisualization>>{};

  final _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization _channel;

  _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationImpl(this._channel);

  @override
  RouteMapObjectPassedDistanceVisualization get value {
    return this._channel._getter();
  }

  static void valueFunction(_CRouteMapObjectPassedDistanceVisualization cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<RouteMapObjectPassedDistanceVisualization> listen(void onData(RouteMapObjectPassedDistanceVisualization event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CRouteMapObjectPassedDistanceVisualization, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RouteMapObjectPassedDistanceVisualization>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationBasicFunctions on _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization {
  void _releaseIntermediate() {
    _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization_release(this);
  }

  _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization _retain() {
    return _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization_retain(this);
  }

  RouteMapObjectPassedDistanceVisualization _getter() {
    final cValue = _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CRouteMapObjectPassedDistanceVisualization, ffi.Int64)> callback) {
    return _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationToDart on _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization {
  StatefulChannel<RouteMapObjectPassedDistanceVisualization> _toDart() {
    return _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization on StatefulChannel<RouteMapObjectPassedDistanceVisualization> {
  _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization _copyFromDartTo_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization() {
    return _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationMakeDefault();
  }
}
	
// MARK: - StatefulChannel<List<CalloutMapPosition>> <-> _CStatefulChannel_CArray_CCalloutMapPosition

class _CStatefulChannel_CArray_CCalloutMapPositionImpl extends StatefulChannel<List<CalloutMapPosition>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<CalloutMapPosition>>>{};

  final _CStatefulChannel_CArray_CCalloutMapPosition _channel;

  _CStatefulChannel_CArray_CCalloutMapPositionImpl(this._channel);

  @override
  List<CalloutMapPosition> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CArray_CCalloutMapPosition cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<CalloutMapPosition>> listen(void onData(List<CalloutMapPosition> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CCalloutMapPosition, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<CalloutMapPosition>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CArray_CCalloutMapPosition extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CArray_CCalloutMapPositionBasicFunctions on _CStatefulChannel_CArray_CCalloutMapPosition {
  void _releaseIntermediate() {
    _CStatefulChannel_CArray_CCalloutMapPosition_release(this);
  }

  _CStatefulChannel_CArray_CCalloutMapPosition _retain() {
    return _CStatefulChannel_CArray_CCalloutMapPosition_retain(this);
  }

  List<CalloutMapPosition> _getter() {
    final cValue = _CStatefulChannel_CArray_CCalloutMapPositionGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CCalloutMapPosition, ffi.Int64)> callback) {
    return _CStatefulChannel_CArray_CCalloutMapPositionConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CArray_CCalloutMapPositionToDart on _CStatefulChannel_CArray_CCalloutMapPosition {
  StatefulChannel<List<CalloutMapPosition>> _toDart() {
    return _CStatefulChannel_CArray_CCalloutMapPositionImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CArray_CCalloutMapPosition on StatefulChannel<List<CalloutMapPosition>> {
  _CStatefulChannel_CArray_CCalloutMapPosition _copyFromDartTo_CStatefulChannel_CArray_CCalloutMapPosition() {
    return _CStatefulChannel_CArray_CCalloutMapPositionMakeDefault();
  }
}
	
// MARK: - List<CalloutMapPosition> <-> _CArray_CCalloutMapPosition

final class _CArray_CCalloutMapPosition extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CCalloutMapPositionToDart on _CArray_CCalloutMapPosition {
  List<CalloutMapPosition> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CCalloutMapPosition on List<CalloutMapPosition> {
  _CArray_CCalloutMapPosition _copyFromDartTo_CArray_CCalloutMapPosition() {
    final cArray = _CArray_CCalloutMapPositionmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CCalloutMapPosition();
        _CArray_CCalloutMapPositionaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CCalloutMapPositionBasicFunctions on _CArray_CCalloutMapPosition {
  void _releaseIntermediate() {
    _CArray_CCalloutMapPosition_release(this);
  }

  static final _listToFill = <CalloutMapPosition>[];

  static void _iterate(_CCalloutMapPosition item) {
    _listToFill.add(item._toDart());
  }

  List<CalloutMapPosition> _fillFromC() {
    _forEach_CArray_CCalloutMapPosition(this, ffi.Pointer.fromFunction<ffi.Void Function(_CCalloutMapPosition)>(_iterate));
    final result = List<CalloutMapPosition>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - StatefulChannel<RouteMapObjectCalloutLabelFlagEnumSet?> <-> _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag

class _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagImpl extends StatefulChannel<RouteMapObjectCalloutLabelFlagEnumSet?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RouteMapObjectCalloutLabelFlagEnumSet?>>{};

  final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag _channel;

  _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagImpl(this._channel);

  @override
  RouteMapObjectCalloutLabelFlagEnumSet? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<RouteMapObjectCalloutLabelFlagEnumSet?> listen(void onData(RouteMapObjectCalloutLabelFlagEnumSet? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RouteMapObjectCalloutLabelFlagEnumSet?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagBasicFunctions on _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_release(this);
  }

  _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag _retain() {
    return _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_retain(this);
  }

  RouteMapObjectCalloutLabelFlagEnumSet? _getter() {
    final cValue = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagToDart on _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag {
  StatefulChannel<RouteMapObjectCalloutLabelFlagEnumSet?> _toDart() {
    return _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag on StatefulChannel<RouteMapObjectCalloutLabelFlagEnumSet?> {
  _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag _copyFromDartTo_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag() {
    return _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefault();
  }
}
	
// MARK: - RouteMapObjectCalloutLabelFlagEnumSet

class RouteMapObjectCalloutLabelFlagEnumSet extends EnumSet<RouteMapObjectCalloutLabelFlag> {
  RouteMapObjectCalloutLabelFlagEnumSet() : super();

  factory RouteMapObjectCalloutLabelFlagEnumSet.fromRawValue(int rawValue) {
    RouteMapObjectCalloutLabelFlagEnumSet enumSet = RouteMapObjectCalloutLabelFlagEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory RouteMapObjectCalloutLabelFlagEnumSet.of(Iterable<RouteMapObjectCalloutLabelFlag> elements) {
    RouteMapObjectCalloutLabelFlagEnumSet enumSet = RouteMapObjectCalloutLabelFlagEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory RouteMapObjectCalloutLabelFlagEnumSet.all() {
    RouteMapObjectCalloutLabelFlagEnumSet enumSet = RouteMapObjectCalloutLabelFlagEnumSet();
    enumSet.addAll(RouteMapObjectCalloutLabelFlag.values);
    return enumSet;
  }

  @override
  bool contains(RouteMapObjectCalloutLabelFlag value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<RouteMapObjectCalloutLabelFlag> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(RouteMapObjectCalloutLabelFlag value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<RouteMapObjectCalloutLabelFlag> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(RouteMapObjectCalloutLabelFlag value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<RouteMapObjectCalloutLabelFlag> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<RouteMapObjectCalloutLabelFlag> intersection(EnumSet<RouteMapObjectCalloutLabelFlag> other) =>
      RouteMapObjectCalloutLabelFlagEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<RouteMapObjectCalloutLabelFlag> union(EnumSet<RouteMapObjectCalloutLabelFlag> other) =>
      RouteMapObjectCalloutLabelFlagEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<RouteMapObjectCalloutLabelFlag> difference(EnumSet<RouteMapObjectCalloutLabelFlag> other) =>
      RouteMapObjectCalloutLabelFlagEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<RouteMapObjectCalloutLabelFlag> toSet() {
    Set<RouteMapObjectCalloutLabelFlag> result = {};
    RouteMapObjectCalloutLabelFlag.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    RouteMapObjectCalloutLabelFlag.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CRouteMapObjectCalloutLabelFlag extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CRouteMapObjectCalloutLabelFlagBasicFunctions on _COptionSet_CRouteMapObjectCalloutLabelFlag {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CRouteMapObjectCalloutLabelFlagToDart on _COptionSet_CRouteMapObjectCalloutLabelFlag {
  RouteMapObjectCalloutLabelFlagEnumSet _toDart() {
    return RouteMapObjectCalloutLabelFlagEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CRouteMapObjectCalloutLabelFlag on RouteMapObjectCalloutLabelFlagEnumSet {
  _COptionSet_CRouteMapObjectCalloutLabelFlag _copyFromDartTo_COptionSet_CRouteMapObjectCalloutLabelFlag() {
    return _COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - RouteMapObjectCalloutLabelFlagEnumSet? <-> _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag

final class _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag extends ffi.Struct {
  
  external _COptionSet_CRouteMapObjectCalloutLabelFlag value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_COptionSet_CRouteMapObjectCalloutLabelFlagBasicFunctions on _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_COptionSet_CRouteMapObjectCalloutLabelFlagToDart on _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag {
  RouteMapObjectCalloutLabelFlagEnumSet? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag on RouteMapObjectCalloutLabelFlagEnumSet? {
  _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag _copyFromDartTo_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag() {
    final cOptional = _COptional_COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_COptionSet_CRouteMapObjectCalloutLabelFlag();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - StatefulChannel<RouteMapObjectCalloutLabelDisplayMode> <-> _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode

class _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeImpl extends StatefulChannel<RouteMapObjectCalloutLabelDisplayMode> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RouteMapObjectCalloutLabelDisplayMode>>{};

  final _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode _channel;

  _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeImpl(this._channel);

  @override
  RouteMapObjectCalloutLabelDisplayMode get value {
    return this._channel._getter();
  }

  static void valueFunction(_CRouteMapObjectCalloutLabelDisplayMode cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<RouteMapObjectCalloutLabelDisplayMode> listen(void onData(RouteMapObjectCalloutLabelDisplayMode event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CRouteMapObjectCalloutLabelDisplayMode, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RouteMapObjectCalloutLabelDisplayMode>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeBasicFunctions on _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode {
  void _releaseIntermediate() {
    _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode_release(this);
  }

  _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode _retain() {
    return _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode_retain(this);
  }

  RouteMapObjectCalloutLabelDisplayMode _getter() {
    final cValue = _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CRouteMapObjectCalloutLabelDisplayMode, ffi.Int64)> callback) {
    return _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeToDart on _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode {
  StatefulChannel<RouteMapObjectCalloutLabelDisplayMode> _toDart() {
    return _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode on StatefulChannel<RouteMapObjectCalloutLabelDisplayMode> {
  _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode _copyFromDartTo_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode() {
    return _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeMakeDefault();
  }
}
	
// MARK: - StatefulChannel<List<LanesCalloutMapPosition>> <-> _CStatefulChannel_CArray_CLanesCalloutMapPosition

class _CStatefulChannel_CArray_CLanesCalloutMapPositionImpl extends StatefulChannel<List<LanesCalloutMapPosition>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<LanesCalloutMapPosition>>>{};

  final _CStatefulChannel_CArray_CLanesCalloutMapPosition _channel;

  _CStatefulChannel_CArray_CLanesCalloutMapPositionImpl(this._channel);

  @override
  List<LanesCalloutMapPosition> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CArray_CLanesCalloutMapPosition cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<LanesCalloutMapPosition>> listen(void onData(List<LanesCalloutMapPosition> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CLanesCalloutMapPosition, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<LanesCalloutMapPosition>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CArray_CLanesCalloutMapPosition extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CArray_CLanesCalloutMapPositionBasicFunctions on _CStatefulChannel_CArray_CLanesCalloutMapPosition {
  void _releaseIntermediate() {
    _CStatefulChannel_CArray_CLanesCalloutMapPosition_release(this);
  }

  _CStatefulChannel_CArray_CLanesCalloutMapPosition _retain() {
    return _CStatefulChannel_CArray_CLanesCalloutMapPosition_retain(this);
  }

  List<LanesCalloutMapPosition> _getter() {
    final cValue = _CStatefulChannel_CArray_CLanesCalloutMapPositionGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CLanesCalloutMapPosition, ffi.Int64)> callback) {
    return _CStatefulChannel_CArray_CLanesCalloutMapPositionConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CArray_CLanesCalloutMapPositionToDart on _CStatefulChannel_CArray_CLanesCalloutMapPosition {
  StatefulChannel<List<LanesCalloutMapPosition>> _toDart() {
    return _CStatefulChannel_CArray_CLanesCalloutMapPositionImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CArray_CLanesCalloutMapPosition on StatefulChannel<List<LanesCalloutMapPosition>> {
  _CStatefulChannel_CArray_CLanesCalloutMapPosition _copyFromDartTo_CStatefulChannel_CArray_CLanesCalloutMapPosition() {
    return _CStatefulChannel_CArray_CLanesCalloutMapPositionMakeDefault();
  }
}
	
// MARK: - List<LanesCalloutMapPosition> <-> _CArray_CLanesCalloutMapPosition

final class _CArray_CLanesCalloutMapPosition extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CLanesCalloutMapPositionToDart on _CArray_CLanesCalloutMapPosition {
  List<LanesCalloutMapPosition> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CLanesCalloutMapPosition on List<LanesCalloutMapPosition> {
  _CArray_CLanesCalloutMapPosition _copyFromDartTo_CArray_CLanesCalloutMapPosition() {
    final cArray = _CArray_CLanesCalloutMapPositionmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CLanesCalloutMapPosition();
        _CArray_CLanesCalloutMapPositionaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CLanesCalloutMapPositionBasicFunctions on _CArray_CLanesCalloutMapPosition {
  void _releaseIntermediate() {
    _CArray_CLanesCalloutMapPosition_release(this);
  }

  static final _listToFill = <LanesCalloutMapPosition>[];

  static void _iterate(_CLanesCalloutMapPosition item) {
    _listToFill.add(item._toDart());
  }

  List<LanesCalloutMapPosition> _fillFromC() {
    _forEach_CArray_CLanesCalloutMapPosition(this, ffi.Pointer.fromFunction<ffi.Void Function(_CLanesCalloutMapPosition)>(_iterate));
    final result = List<LanesCalloutMapPosition>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - StatefulChannel<RoadEventMapObjectRouteAttribute> <-> _CStatefulChannel_CRoadEventMapObjectRouteAttribute

class _CStatefulChannel_CRoadEventMapObjectRouteAttributeImpl extends StatefulChannel<RoadEventMapObjectRouteAttribute> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RoadEventMapObjectRouteAttribute>>{};

  final _CStatefulChannel_CRoadEventMapObjectRouteAttribute _channel;

  _CStatefulChannel_CRoadEventMapObjectRouteAttributeImpl(this._channel);

  @override
  RoadEventMapObjectRouteAttribute get value {
    return this._channel._getter();
  }

  static void valueFunction(_CRoadEventMapObjectRouteAttribute cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<RoadEventMapObjectRouteAttribute> listen(void onData(RoadEventMapObjectRouteAttribute event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CRoadEventMapObjectRouteAttribute, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RoadEventMapObjectRouteAttribute>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CRoadEventMapObjectRouteAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CRoadEventMapObjectRouteAttributeBasicFunctions on _CStatefulChannel_CRoadEventMapObjectRouteAttribute {
  void _releaseIntermediate() {
    _CStatefulChannel_CRoadEventMapObjectRouteAttribute_release(this);
  }

  _CStatefulChannel_CRoadEventMapObjectRouteAttribute _retain() {
    return _CStatefulChannel_CRoadEventMapObjectRouteAttribute_retain(this);
  }

  RoadEventMapObjectRouteAttribute _getter() {
    final cValue = _CStatefulChannel_CRoadEventMapObjectRouteAttributeGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CRoadEventMapObjectRouteAttribute, ffi.Int64)> callback) {
    return _CStatefulChannel_CRoadEventMapObjectRouteAttributeConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CRoadEventMapObjectRouteAttributeToDart on _CStatefulChannel_CRoadEventMapObjectRouteAttribute {
  StatefulChannel<RoadEventMapObjectRouteAttribute> _toDart() {
    return _CStatefulChannel_CRoadEventMapObjectRouteAttributeImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CRoadEventMapObjectRouteAttribute on StatefulChannel<RoadEventMapObjectRouteAttribute> {
  _CStatefulChannel_CRoadEventMapObjectRouteAttribute _copyFromDartTo_CStatefulChannel_CRoadEventMapObjectRouteAttribute() {
    return _CStatefulChannel_CRoadEventMapObjectRouteAttributeMakeDefault();
  }
}
	
// MARK: - RoadEventMapObjectRouteAttribute

/**
 Контейнер, который описывает точечный атрибут маршрута.
 Каждый элемент хранится в виде точки на маршруте, в которой этот элемент расположен и значения самого элемента.
*/
class RoadEventMapObjectRouteAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CRoadEventMapObjectRouteAttribute_size(_CRoadEventMapObjectRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CRoadEventMapObjectRouteAttribute_isEmpty(_CRoadEventMapObjectRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  RoadEventMapObjectRouteEntry? get first {
    _COptional_CRoadEventMapObjectRouteEntry res = _CRoadEventMapObjectRouteAttribute_first(_CRoadEventMapObjectRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Последний элемент. */
  RoadEventMapObjectRouteEntry? get last {
    _COptional_CRoadEventMapObjectRouteEntry res = _CRoadEventMapObjectRouteAttribute_last(_CRoadEventMapObjectRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Все элементы. */
  List<RoadEventMapObjectRouteEntry> get entries {
    _CArray_CRoadEventMapObjectRouteEntry res = _CRoadEventMapObjectRouteAttribute_entries(_CRoadEventMapObjectRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadEventMapObjectRouteAttribute_releasePtr);

  RoadEventMapObjectRouteAttribute._raw(this._self);
  factory RoadEventMapObjectRouteAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEventMapObjectRouteAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventMapObjectRouteAttribute &&
    other.runtimeType == runtimeType &&
    _CRoadEventMapObjectRouteAttribute_cg_objectIdentifier(this._self) == _CRoadEventMapObjectRouteAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEventMapObjectRouteAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadEventMapObjectRouteAttribute: Methods

  /**
   Элементы, попадающие в отрезок [begin, end).
  
   - Throws: Exception если begin > end.
  */
  List<RoadEventMapObjectRouteEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CRoadEventMapObjectRouteEntry res = _CRoadEventMapObjectRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CRoadEventMapObjectRouteAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого
   <
   = point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  RoadEventMapObjectRouteEntry? findNearBackward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRoadEventMapObjectRouteEntry res = _CRoadEventMapObjectRouteAttribute_findNearBackward_CRoutePoint(_CRoadEventMapObjectRouteAttributeMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого >= point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  RoadEventMapObjectRouteEntry? findNearForward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CRoadEventMapObjectRouteEntry res = _CRoadEventMapObjectRouteAttribute_findNearForward_CRoutePoint(_CRoadEventMapObjectRouteAttributeMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadEventMapObjectRouteAttribute <-> CRoadEventMapObjectRouteAttribute

final class _CRoadEventMapObjectRouteAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventMapObjectRouteAttributeBasicFunctions on _CRoadEventMapObjectRouteAttribute {
  void _releaseIntermediate() {
    _CRoadEventMapObjectRouteAttribute_release(_impl);
  }

  _CRoadEventMapObjectRouteAttribute _retain() {
    return _CRoadEventMapObjectRouteAttribute_retain(_impl);
  }
}

extension _CRoadEventMapObjectRouteAttributeToDart on _CRoadEventMapObjectRouteAttribute {
  RoadEventMapObjectRouteAttribute _toDart() {
    return RoadEventMapObjectRouteAttribute._create(_retain()._impl);
  }
}


extension _DartToCRoadEventMapObjectRouteAttribute on RoadEventMapObjectRouteAttribute {
  _CRoadEventMapObjectRouteAttribute _copyFromDartTo_CRoadEventMapObjectRouteAttribute() {
    return (_CRoadEventMapObjectRouteAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadEventMapObjectRouteEntry

/** Элемент маршрута - точка и значение в ней. */
class RoadEventMapObjectRouteEntry {
  final RoutePoint point;
  final RoadEventMapObject value;

  const RoadEventMapObjectRouteEntry({
    required this.point,
    required this.value
  });

  RoadEventMapObjectRouteEntry copyWith({
    RoutePoint? point,
    RoadEventMapObject? value
  }) {
    return RoadEventMapObjectRouteEntry(
      point: point ?? this.point,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventMapObjectRouteEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, value);
  }

}
final class _CRoadEventMapObjectRouteEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRoadEventMapObject value;

}
// MARK: - RoadEventMapObjectRouteEntry <-> _CRoadEventMapObjectRouteEntry

extension _CRoadEventMapObjectRouteEntryToDart on _CRoadEventMapObjectRouteEntry {
  RoadEventMapObjectRouteEntry _toDart() {
    return RoadEventMapObjectRouteEntry(
      point: this.point._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CRoadEventMapObjectRouteEntry on RoadEventMapObjectRouteEntry {
  _CRoadEventMapObjectRouteEntry _copyFromDartTo_CRoadEventMapObjectRouteEntry() {
    final res = _CRoadEventMapObjectRouteEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.value = this.value._copyFromDartTo_CRoadEventMapObject();
    return res;
  }
}
extension _CRoadEventMapObjectRouteEntryRelease on _CRoadEventMapObjectRouteEntry {
  void _releaseIntermediate() {
    value._releaseIntermediate();
  }
}

// MARK: - RoadEventMapObjectRouteEntry? <-> _COptional_CRoadEventMapObjectRouteEntry

final class _COptional_CRoadEventMapObjectRouteEntry extends ffi.Struct {
  
  external _CRoadEventMapObjectRouteEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRoadEventMapObjectRouteEntryBasicFunctions on _COptional_CRoadEventMapObjectRouteEntry {
  void _releaseIntermediate() {
    _COptional_CRoadEventMapObjectRouteEntry_release(this);
  }
}

extension _COptional_CRoadEventMapObjectRouteEntryToDart on _COptional_CRoadEventMapObjectRouteEntry {
  RoadEventMapObjectRouteEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRoadEventMapObjectRouteEntry on RoadEventMapObjectRouteEntry? {
  _COptional_CRoadEventMapObjectRouteEntry _copyFromDartTo_COptional_CRoadEventMapObjectRouteEntry() {
    final cOptional = _COptional_CRoadEventMapObjectRouteEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRoadEventMapObjectRouteEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<RoadEventMapObjectRouteEntry> <-> _CArray_CRoadEventMapObjectRouteEntry

final class _CArray_CRoadEventMapObjectRouteEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRoadEventMapObjectRouteEntryToDart on _CArray_CRoadEventMapObjectRouteEntry {
  List<RoadEventMapObjectRouteEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRoadEventMapObjectRouteEntry on List<RoadEventMapObjectRouteEntry> {
  _CArray_CRoadEventMapObjectRouteEntry _copyFromDartTo_CArray_CRoadEventMapObjectRouteEntry() {
    final cArray = _CArray_CRoadEventMapObjectRouteEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRoadEventMapObjectRouteEntry();
        _CArray_CRoadEventMapObjectRouteEntryaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CRoadEventMapObjectRouteEntryBasicFunctions on _CArray_CRoadEventMapObjectRouteEntry {
  void _releaseIntermediate() {
    _CArray_CRoadEventMapObjectRouteEntry_release(this);
  }

  static final _listToFill = <RoadEventMapObjectRouteEntry>[];

  static void _iterate(_CRoadEventMapObjectRouteEntry item) {
    _listToFill.add(item._toDart());
  }

  List<RoadEventMapObjectRouteEntry> _fillFromC() {
    _forEach_CArray_CRoadEventMapObjectRouteEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRoadEventMapObjectRouteEntry)>(_iterate));
    final result = List<RoadEventMapObjectRouteEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RouteSourceSettings

/** Настройки источника маршрута. */
class RouteSourceSettings implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Смещение от точки съезда с кольца до начала и конца стрелки маневра для крупного масштаба.
   Позволяет задать размер стрелки маневра.
  */
  double get largeScaleRingroadOffsetMeters {
    double res = _CRouteSourceSettings_getLargeScaleRingroadOffsetMeters(_CRouteSourceSettingsMakeDefault().._impl=_self);
    return res;
  }
  set largeScaleRingroadOffsetMeters(double offset) {
    void res = _CRouteSourceSettings_setLargeScaleRingroadOffsetMeters_float(_CRouteSourceSettingsMakeDefault().._impl=_self, offset);
    return res;
  }
  /**
   Смещение от точки съезда с кольца до начала и конца стрелки маневра для мелкого масштаба.
   Позволяет задать размер стрелки маневра.
  */
  double get smallScaleRingroadOffsetMeters {
    double res = _CRouteSourceSettings_getSmallScaleRingroadOffsetMeters(_CRouteSourceSettingsMakeDefault().._impl=_self);
    return res;
  }
  set smallScaleRingroadOffsetMeters(double offset) {
    void res = _CRouteSourceSettings_setSmallScaleRingroadOffsetMeters_float(_CRouteSourceSettingsMakeDefault().._impl=_self, offset);
    return res;
  }
  /** Режим отображения баблов со временем и длиной маршрута. */
  CalloutVisualizationMode get calloutVisualizationMode {
    _CCalloutVisualizationMode res = _CRouteSourceSettings_calloutVisualizationMode(_CRouteSourceSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set calloutVisualizationMode(CalloutVisualizationMode mode) {
    var _a1 = mode._copyFromDartTo_CCalloutVisualizationMode();
    void res = _CRouteSourceSettings_setCalloutVisualizationMode_CCalloutVisualizationMode(_CRouteSourceSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRouteSourceSettings_releasePtr);

  RouteSourceSettings._raw(this._self);
  factory RouteSourceSettings._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RouteSourceSettings._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteSourceSettings &&
    other.runtimeType == runtimeType &&
    _CRouteSourceSettings_cg_objectIdentifier(this._self) == _CRouteSourceSettings_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRouteSourceSettings_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RouteSourceSettings: Methods

  /**
   Минимально допустимое расстояние в метрах между последовательными стрелками манёвров для крупного масштаба.
   Если расстояние меньше заданного, то стрелки объединяются.
  
   - Parameter transportType: Тип транспорта, для которого запрашивается расстояние.
  */
  double getLargeScaleMergeDistanceMeters(
    TransportType transportType
  )  {
    var _a1 = transportType._copyFromDartTo_CTransportType();
    double res = _CRouteSourceSettings_getLargeScaleMergeDistanceMeters_CTransportType(_CRouteSourceSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Установить минимально допустимое расстояние в метрах между последовательными стрелками манёвров
   для крупного масштаба.
  
   - Parameter distance: Расстояние в метрах.
   - Parameter transportType: Тип транспорта, для которого устанавливается расстояние.
  */
  void setLargeScaleMergeDistanceMeters(
    double distance,
    TransportType transportType
  )  {
    var _a2 = transportType._copyFromDartTo_CTransportType();
    void res = _CRouteSourceSettings_setLargeScaleMergeDistanceMeters_float_CTransportType(_CRouteSourceSettingsMakeDefault().._impl=_self, distance, _a2);
    return res;
  }

  /**
   Минимально допустимое расстояние в метрах между последовательными стрелками манёвров для мелкого масштаба.
   Если расстояние меньше заданного, то стрелки объединяются.
  
   - Parameter transportType: Тип транспорта, для которого запрашивается расстояние.
  */
  double getSmallScaleMergeDistanceMeters(
    TransportType transportType
  )  {
    var _a1 = transportType._copyFromDartTo_CTransportType();
    double res = _CRouteSourceSettings_getSmallScaleMergeDistanceMeters_CTransportType(_CRouteSourceSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Установить минимально допустимое расстояние в метрах между последовательными стрелками манёвров
   для мелкого масштаба.
  
   - Parameter distance: Расстояние в метрах.
   - Parameter transportType: Тип транспорта, для которого устанавливается расстояние.
  */
  void setSmallScaleMergeDistanceMeters(
    double distance,
    TransportType transportType
  )  {
    var _a2 = transportType._copyFromDartTo_CTransportType();
    void res = _CRouteSourceSettings_setSmallScaleMergeDistanceMeters_float_CTransportType(_CRouteSourceSettingsMakeDefault().._impl=_self, distance, _a2);
    return res;
  }

  /**
   Смещение в метрах от точки перекрестка до начала и конца стрелки манёвра для крупного масштаба.
  
   - Parameter transportType: Тип транспорта, для которого запрашивается смещение.
  */
  double getLargeScaleCrossroadsOffsetMeters(
    TransportType transportType
  )  {
    var _a1 = transportType._copyFromDartTo_CTransportType();
    double res = _CRouteSourceSettings_getLargeScaleCrossroadsOffsetMeters_CTransportType(_CRouteSourceSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Установить смещение в метрах от точки перекрестка до начала и конца стрелки маневра для крупного масштаба.
   Позволяет задать размер стрелки маневра.
  
   - Parameter offset: Смещение в метрах.
   - Parameter transportType: Тип транспорта, для которого устанавливается смещение.
  */
  void setLargeScaleCrossroadsOffsetMeters(
    double offset,
    TransportType transportType
  )  {
    var _a2 = transportType._copyFromDartTo_CTransportType();
    void res = _CRouteSourceSettings_setLargeScaleCrossroadsOffsetMeters_float_CTransportType(_CRouteSourceSettingsMakeDefault().._impl=_self, offset, _a2);
    return res;
  }

  /**
   Смещение от точки перекрестка до начала и конца стрелки манёвра для мелкого масштаба.
  
   - Parameter transportType: Тип транспорта, для которого запрашивается смещение.
  */
  double getSmallScaleCrossroadsOffsetMeters(
    TransportType transportType
  )  {
    var _a1 = transportType._copyFromDartTo_CTransportType();
    double res = _CRouteSourceSettings_getSmallScaleCrossroadsOffsetMeters_CTransportType(_CRouteSourceSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Установить смещение от точки перекрестка до начала и конца стрелки маневра для мелкого масштаба.
   Позволяет задать размер стрелки маневра.
  
   - Parameter offset: Смещение в метрах.
   - Parameter transportType: Тип транспорта, для которого устанавливается смещение.
  */
  void setSmallScaleCrossroadsOffsetMeters(
    double offset,
    TransportType transportType
  )  {
    var _a2 = transportType._copyFromDartTo_CTransportType();
    void res = _CRouteSourceSettings_setSmallScaleCrossroadsOffsetMeters_float_CTransportType(_CRouteSourceSettingsMakeDefault().._impl=_self, offset, _a2);
    return res;
  }

}

// MARK: - RouteSourceSettings <-> CRouteSourceSettings

final class _CRouteSourceSettings extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRouteSourceSettingsBasicFunctions on _CRouteSourceSettings {
  void _releaseIntermediate() {
    _CRouteSourceSettings_release(_impl);
  }

  _CRouteSourceSettings _retain() {
    return _CRouteSourceSettings_retain(_impl);
  }
}

extension _CRouteSourceSettingsToDart on _CRouteSourceSettings {
  RouteSourceSettings _toDart() {
    return RouteSourceSettings._create(_retain()._impl);
  }
}


extension _DartToCRouteSourceSettings on RouteSourceSettings {
  _CRouteSourceSettings _copyFromDartTo_CRouteSourceSettings() {
    return (_CRouteSourceSettingsMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RouteEditorSource

/** Интерфейс класса, управляющего отображением маршрутов на карте. */
class RouteEditorSource extends Source implements ffi.Finalizable {
  /** Объекты маршрута на карте. */
  List<RouteMapObject> get objects {
    _CArray_CRouteMapObject res = _CRouteEditorSource_objects(_CRouteEditorSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Настройки отображения маневров на маршруте. */
  RouteSourceSettings get routeSourceSettings {
    _CRouteSourceSettings res = _CRouteEditorSource_routeSourceSettings(_CRouteEditorSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Флаги отображения активного маршрута.
   См. IRouteMapObject::display_flags.
  */
  RouteMapObjectDisplayFlagEnumSet? get activeDisplayFlags {
    _COptional_COptionSet_CRouteMapObjectDisplayFlag res = _CRouteEditorSource_activeDisplayFlags(_CRouteEditorSourceMakeDefault().._impl=_self);
    return res._toDart();
  }
  set activeDisplayFlags(RouteMapObjectDisplayFlagEnumSet? flags) {
    var _a1 = flags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectDisplayFlag();
    void res = _CRouteEditorSource_setActiveDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlag(_CRouteEditorSourceMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Флаги отображения неактивных маршрутов.
   См. IRouteMapObject::display_flags.
  */
  RouteMapObjectDisplayFlagEnumSet? get inactiveDisplayFlags {
    _COptional_COptionSet_CRouteMapObjectDisplayFlag res = _CRouteEditorSource_inactiveDisplayFlags(_CRouteEditorSourceMakeDefault().._impl=_self);
    return res._toDart();
  }
  set inactiveDisplayFlags(RouteMapObjectDisplayFlagEnumSet? flags) {
    var _a1 = flags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectDisplayFlag();
    void res = _CRouteEditorSource_setInactiveDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlag(_CRouteEditorSourceMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Флаги, включающие отображение содержимого в баблах активного маршрута.
   См. IRouteMapObject::callout_label_flags.
  */
  RouteMapObjectCalloutLabelFlagEnumSet? get activeCalloutLabelFlags {
    _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag res = _CRouteEditorSource_activeCalloutLabelFlags(_CRouteEditorSourceMakeDefault().._impl=_self);
    return res._toDart();
  }
  set activeCalloutLabelFlags(RouteMapObjectCalloutLabelFlagEnumSet? flags) {
    var _a1 = flags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag();
    void res = _CRouteEditorSource_setActiveCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag(_CRouteEditorSourceMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Флаги, включающие отображение содержимого в баблах неактивных маршрутов.
   См. IRouteMapObject::callout_label_flags.
  */
  RouteMapObjectCalloutLabelFlagEnumSet? get inactiveCalloutLabelFlags {
    _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag res = _CRouteEditorSource_inactiveCalloutLabelFlags(_CRouteEditorSourceMakeDefault().._impl=_self);
    return res._toDart();
  }
  set inactiveCalloutLabelFlags(RouteMapObjectCalloutLabelFlagEnumSet? flags) {
    var _a1 = flags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag();
    void res = _CRouteEditorSource_setInactiveCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag(_CRouteEditorSourceMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Режим отображения значений в баблах маршрутов.
   См. IRouteMapObject::callout_label_display_mode.
  */
  RouteMapObjectCalloutLabelDisplayMode get calloutLabelDisplayMode {
    _CRouteMapObjectCalloutLabelDisplayMode res = _CRouteEditorSource_calloutLabelDisplayMode(_CRouteEditorSourceMakeDefault().._impl=_self);
    return res._toDart();
  }
  set calloutLabelDisplayMode(RouteMapObjectCalloutLabelDisplayMode mode) {
    var _a1 = mode._copyFromDartTo_CRouteMapObjectCalloutLabelDisplayMode();
    void res = _CRouteEditorSource_setCalloutLabelDisplayMode_CRouteMapObjectCalloutLabelDisplayMode(_CRouteEditorSourceMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Флаги, исключающие скрытие компонентов активного маршрута с карты.
   См. IRouteMapObject::permanent_display_flags.
  */
  RouteMapObjectPermanentDisplayFlagEnumSet? get activePermanentDisplayFlags {
    _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag res = _CRouteEditorSource_activePermanentDisplayFlags(_CRouteEditorSourceMakeDefault().._impl=_self);
    return res._toDart();
  }
  set activePermanentDisplayFlags(RouteMapObjectPermanentDisplayFlagEnumSet? flags) {
    var _a1 = flags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag();
    void res = _CRouteEditorSource_setActivePermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag(_CRouteEditorSourceMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Флаги, исключающие скрытие компонентов неактивных маршрутов с карты.
   См. IRouteMapObject::permanent_display_flags.
  */
  RouteMapObjectPermanentDisplayFlagEnumSet? get inactivePermanentDisplayFlags {
    _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag res = _CRouteEditorSource_inactivePermanentDisplayFlags(_CRouteEditorSourceMakeDefault().._impl=_self);
    return res._toDart();
  }
  set inactivePermanentDisplayFlags(RouteMapObjectPermanentDisplayFlagEnumSet? flags) {
    var _a1 = flags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag();
    void res = _CRouteEditorSource_setInactivePermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag(_CRouteEditorSourceMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRouteEditorSource_releasePtr);

  RouteEditorSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RouteEditorSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RouteEditorSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Функция создания IRouteEditorSource.
  
   - Throws: Exception если невозможно получить зависимости IRouteEditorSource
   из контекста или если route_editor равен null
  */
  factory RouteEditorSource(
    Context context,
    RouteEditor routeEditor,
    [RouteMapObjectDisplayFlagEnumSet? activeDisplayFlags = null,
    RouteMapObjectDisplayFlagEnumSet? inactiveDisplayFlags = null,
    RouteMapObjectCalloutLabelFlagEnumSet? activeCalloutLabelFlags = null,
    RouteMapObjectCalloutLabelFlagEnumSet? inactiveCalloutLabelFlags = null,
    RouteMapObjectCalloutLabelDisplayMode calloutLabelDisplayMode = RouteMapObjectCalloutLabelDisplayMode.absoluteValues,
    RouteMapObjectPermanentDisplayFlagEnumSet? activePermanentDisplayFlags = null,
    RouteMapObjectPermanentDisplayFlagEnumSet? inactivePermanentDisplayFlags = null
    ]) {
    var _a0 = context._copyFromDartTo_CContext();
    var _a1 = routeEditor._copyFromDartTo_CRouteEditor();
    var _a2 = activeDisplayFlags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectDisplayFlag();
    var _a3 = inactiveDisplayFlags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectDisplayFlag();
    var _a4 = activeCalloutLabelFlags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag();
    var _a5 = inactiveCalloutLabelFlags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag();
    var _a6 = calloutLabelDisplayMode._copyFromDartTo_CRouteMapObjectCalloutLabelDisplayMode();
    var _a7 = activePermanentDisplayFlags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag();
    var _a8 = inactivePermanentDisplayFlags._copyFromDartTo_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag();
    _CRouteEditorSource res = _CRouteEditorSource_C_createWith_CContext_CRouteEditor_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_CRouteMapObjectCalloutLabelDisplayMode_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8);
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    return RouteEditorSource._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteEditorSource &&
    other.runtimeType == runtimeType &&
    _CRouteEditorSource_cg_objectIdentifier(this._self) == _CRouteEditorSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRouteEditorSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RouteEditorSource: Methods

  /** Включить или выключить отображение маршрутов на карте. */
  void setRoutesVisible(
    bool visible
  )  {
    void res = _CRouteEditorSource_setRoutesVisible_bool(_CRouteEditorSourceMakeDefault().._impl=_self, visible);
    return res;
  }

  /** Отображать на карте все маршруты (false) или только текущий активный маршрут (true). */
  void setShowOnlyActiveRoute(
    bool showOnlyActiveRoute
  )  {
    void res = _CRouteEditorSource_setShowOnlyActiveRoute_bool(_CRouteEditorSourceMakeDefault().._impl=_self, showOnlyActiveRoute);
    return res;
  }

  /** Изменить способ визуализации расстояния, пройденного вдоль маршрута. */
  void setPassedDistanceVisualization(
    RouteMapObjectPassedDistanceVisualization passedDistanceVisualization
  )  {
    var _a1 = passedDistanceVisualization._copyFromDartTo_CRouteMapObjectPassedDistanceVisualization();
    void res = _CRouteEditorSource_setPassedDistanceVisualization_CRouteMapObjectPassedDistanceVisualization(_CRouteEditorSourceMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - RouteEditorSource <-> CRouteEditorSource

final class _CRouteEditorSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRouteEditorSourceBasicFunctions on _CRouteEditorSource {
  void _releaseIntermediate() {
    _CRouteEditorSource_release(_impl);
  }

  _CRouteEditorSource _retain() {
    return _CRouteEditorSource_retain(_impl);
  }
}

extension _CRouteEditorSourceToDart on _CRouteEditorSource {
  RouteEditorSource _toDart() {
    return RouteEditorSource._create(_retain()._impl);
  }
}


extension _DartToCRouteEditorSource on RouteEditorSource {
  _CRouteEditorSource _copyFromDartTo_CRouteEditorSource() {
    return (_CRouteEditorSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<RouteMapObject> <-> _CArray_CRouteMapObject

final class _CArray_CRouteMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRouteMapObjectToDart on _CArray_CRouteMapObject {
  List<RouteMapObject> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRouteMapObject on List<RouteMapObject> {
  _CArray_CRouteMapObject _copyFromDartTo_CArray_CRouteMapObject() {
    final cArray = _CArray_CRouteMapObjectmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRouteMapObject();
        _CArray_CRouteMapObjectaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CRouteMapObjectBasicFunctions on _CArray_CRouteMapObject {
  void _releaseIntermediate() {
    _CArray_CRouteMapObject_release(this);
  }

  static final _listToFill = <RouteMapObject>[];

  static void _iterate(_CRouteMapObject item) {
    _listToFill.add(item._toDart());
  }

  List<RouteMapObject> _fillFromC() {
    _forEach_CArray_CRouteMapObject(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRouteMapObject)>(_iterate));
    final result = List<RouteMapObject>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RouteEditor

/**
 Интерфейс для редактора маршрута. Редактор маршрута получает точки начала и конца
 маршрута, строит маршруты и через каналы оповещает об их обновлениях и перестроениях.

 - Note: Все методы этого интерфейса вызываются из одного потока.
*/
class RouteEditor implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Канал, через который можно следить за обновлениями информации о маршрутах,
   которыми оперирует редактор.
  */
  StatefulChannel<RouteEditorRoutesInfo> get routesInfoChannel {
    _CStatefulChannel_CRouteEditorRoutesInfo res = _CRouteEditor_routesInfoChannel(_CRouteEditorMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Канал, через который можно следить за обновлениями информации о маршрутах,
   которыми оперирует редактор.
  */
  RouteEditorRoutesInfo get routesInfo {
    _CRouteEditorRoutesInfo res = _CRouteEditor_routesInfo(_CRouteEditorMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Канал, через который можно следить за обновлениями индекса активного маршрута.
   В случае отсутствия маршрутов в этот канал помещается null.
  */
  StatefulChannel<RouteIndex?> get activeRouteIndexChannel {
    _CStatefulChannel_COptional_CRouteIndex res = _CRouteEditor_activeRouteIndexChannel(_CRouteEditorMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Канал, через который можно следить за обновлениями индекса активного маршрута.
   В случае отсутствия маршрутов в этот канал помещается null.
  */
  RouteIndex? get activeRouteIndex {
    _COptional_CRouteIndex res = _CRouteEditor_activeRouteIndex(_CRouteEditorMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CRouteEditor_releasePtr);

  RouteEditor._raw(this._self);
  factory RouteEditor._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RouteEditor._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Функция создания редактора маршрута.
  
   - Throws: Exception, если невозможно получить зависимости из контекста
  */
  factory RouteEditor(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CRouteEditor res = _CRouteEditor_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return RouteEditor._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteEditor &&
    other.runtimeType == runtimeType &&
    _CRouteEditor_cg_objectIdentifier(this._self) == _CRouteEditor_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRouteEditor_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RouteEditor: Methods

  /**
   Установка параметров редактора маршрута. Запускает поиск нового
   маршрута согласно переданным параметрам.
  */
  void setRouteParams(
    RouteEditorRouteParams routeParams
  )  {
    var _a1 = routeParams._copyFromDartTo_CRouteEditorRouteParams();
    void res = _CRouteEditor_setRouteParams_CRouteEditorRouteParams(_CRouteEditorMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Установка индекса активного маршрута.
  
   - Throws: Exception если передаётся значение за пределами размера
   текущего массива маршрутов
  */
  void setActiveRouteIndex(
    RouteIndex index
  )  {
    var _a1 = index._copyFromDartTo_CRouteIndex();
    void res = _CRouteEditor_setActiveRouteIndex_CRouteIndex(_CRouteEditorMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - RouteEditor <-> CRouteEditor

final class _CRouteEditor extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRouteEditorBasicFunctions on _CRouteEditor {
  void _releaseIntermediate() {
    _CRouteEditor_release(_impl);
  }

  _CRouteEditor _retain() {
    return _CRouteEditor_retain(_impl);
  }
}

extension _CRouteEditorToDart on _CRouteEditor {
  RouteEditor _toDart() {
    return RouteEditor._create(_retain()._impl);
  }
}


extension _DartToCRouteEditor on RouteEditor {
  _CRouteEditor _copyFromDartTo_CRouteEditor() {
    return (_CRouteEditorMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<RouteEditorRoutesInfo> <-> _CStatefulChannel_CRouteEditorRoutesInfo

class _CStatefulChannel_CRouteEditorRoutesInfoImpl extends StatefulChannel<RouteEditorRoutesInfo> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RouteEditorRoutesInfo>>{};

  final _CStatefulChannel_CRouteEditorRoutesInfo _channel;

  _CStatefulChannel_CRouteEditorRoutesInfoImpl(this._channel);

  @override
  RouteEditorRoutesInfo get value {
    return this._channel._getter();
  }

  static void valueFunction(_CRouteEditorRoutesInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<RouteEditorRoutesInfo> listen(void onData(RouteEditorRoutesInfo event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CRouteEditorRoutesInfo, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RouteEditorRoutesInfo>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CRouteEditorRoutesInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CRouteEditorRoutesInfoBasicFunctions on _CStatefulChannel_CRouteEditorRoutesInfo {
  void _releaseIntermediate() {
    _CStatefulChannel_CRouteEditorRoutesInfo_release(this);
  }

  _CStatefulChannel_CRouteEditorRoutesInfo _retain() {
    return _CStatefulChannel_CRouteEditorRoutesInfo_retain(this);
  }

  RouteEditorRoutesInfo _getter() {
    final cValue = _CStatefulChannel_CRouteEditorRoutesInfoGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CRouteEditorRoutesInfo, ffi.Int64)> callback) {
    return _CStatefulChannel_CRouteEditorRoutesInfoConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CRouteEditorRoutesInfoToDart on _CStatefulChannel_CRouteEditorRoutesInfo {
  StatefulChannel<RouteEditorRoutesInfo> _toDart() {
    return _CStatefulChannel_CRouteEditorRoutesInfoImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CRouteEditorRoutesInfo on StatefulChannel<RouteEditorRoutesInfo> {
  _CStatefulChannel_CRouteEditorRoutesInfo _copyFromDartTo_CStatefulChannel_CRouteEditorRoutesInfo() {
    return _CStatefulChannel_CRouteEditorRoutesInfoMakeDefault();
  }
}
	
// MARK: - List<TrafficRoute> <-> _CArray_CTrafficRoute

final class _CArray_CTrafficRoute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CTrafficRouteToDart on _CArray_CTrafficRoute {
  List<TrafficRoute> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CTrafficRoute on List<TrafficRoute> {
  _CArray_CTrafficRoute _copyFromDartTo_CArray_CTrafficRoute() {
    final cArray = _CArray_CTrafficRoutemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CTrafficRoute();
        _CArray_CTrafficRouteaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CTrafficRouteBasicFunctions on _CArray_CTrafficRoute {
  void _releaseIntermediate() {
    _CArray_CTrafficRoute_release(this);
  }

  static final _listToFill = <TrafficRoute>[];

  static void _iterate(_CTrafficRoute item) {
    _listToFill.add(item._toDart());
  }

  List<TrafficRoute> _fillFromC() {
    _forEach_CArray_CTrafficRoute(this, ffi.Pointer.fromFunction<ffi.Void Function(_CTrafficRoute)>(_iterate));
    final result = List<TrafficRoute>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<RouteSearchPoint> <-> _CArray_CRouteSearchPoint

final class _CArray_CRouteSearchPoint extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRouteSearchPointToDart on _CArray_CRouteSearchPoint {
  List<RouteSearchPoint> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRouteSearchPoint on List<RouteSearchPoint> {
  _CArray_CRouteSearchPoint _copyFromDartTo_CArray_CRouteSearchPoint() {
    final cArray = _CArray_CRouteSearchPointmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRouteSearchPoint();
        _CArray_CRouteSearchPointaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CRouteSearchPointBasicFunctions on _CArray_CRouteSearchPoint {
  void _releaseIntermediate() {
    _CArray_CRouteSearchPoint_release(this);
  }

  static final _listToFill = <RouteSearchPoint>[];

  static void _iterate(_CRouteSearchPoint item) {
    _listToFill.add(item._toDart());
  }

  List<RouteSearchPoint> _fillFromC() {
    _forEach_CArray_CRouteSearchPoint(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRouteSearchPoint)>(_iterate));
    final result = List<RouteSearchPoint>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RouteEditorRouteParams

/** Информация о параметрах маршрута. */
class RouteEditorRouteParams {
  final RouteSearchPoint startPoint;
  final RouteSearchPoint finishPoint;
  final RouteSearchOptions routeSearchOptions;
  final List<RouteSearchPoint> intermediatePoints;

  const RouteEditorRouteParams({
    required this.startPoint,
    required this.finishPoint,
    required this.routeSearchOptions,
    this.intermediatePoints = const []
  });

  RouteEditorRouteParams copyWith({
    RouteSearchPoint? startPoint,
    RouteSearchPoint? finishPoint,
    RouteSearchOptions? routeSearchOptions,
    List<RouteSearchPoint>? intermediatePoints
  }) {
    return RouteEditorRouteParams(
      startPoint: startPoint ?? this.startPoint,
      finishPoint: finishPoint ?? this.finishPoint,
      routeSearchOptions: routeSearchOptions ?? this.routeSearchOptions,
      intermediatePoints: intermediatePoints ?? this.intermediatePoints
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteEditorRouteParams &&
    other.runtimeType == runtimeType &&
    other.startPoint == startPoint &&
    other.finishPoint == finishPoint &&
    other.routeSearchOptions == routeSearchOptions &&
    other.intermediatePoints == intermediatePoints;

  @override
  int get hashCode {
    return Object.hash(startPoint, finishPoint, routeSearchOptions, intermediatePoints);
  }

}
final class _CRouteEditorRouteParams extends ffi.Struct {
  external _CRouteSearchPoint startPoint;

  external _CRouteSearchPoint finishPoint;

  external _CRouteSearchOptions routeSearchOptions;

  external _CArray_CRouteSearchPoint intermediatePoints;

}
// MARK: - RouteEditorRouteParams <-> _CRouteEditorRouteParams

extension _CRouteEditorRouteParamsToDart on _CRouteEditorRouteParams {
  RouteEditorRouteParams _toDart() {
    return RouteEditorRouteParams(
      startPoint: this.startPoint._toDart(),
      finishPoint: this.finishPoint._toDart(),
      routeSearchOptions: this.routeSearchOptions._toDart(),
      intermediatePoints: this.intermediatePoints._toDart()
    );
  }
}

extension _DartTo_CRouteEditorRouteParams on RouteEditorRouteParams {
  _CRouteEditorRouteParams _copyFromDartTo_CRouteEditorRouteParams() {
    final res = _CRouteEditorRouteParamsMakeDefault();
    res.startPoint = this.startPoint._copyFromDartTo_CRouteSearchPoint();
    res.finishPoint = this.finishPoint._copyFromDartTo_CRouteSearchPoint();
    res.routeSearchOptions = this.routeSearchOptions._copyFromDartTo_CRouteSearchOptions();
    res.intermediatePoints = this.intermediatePoints._copyFromDartTo_CArray_CRouteSearchPoint();
    return res;
  }
}
extension _CRouteEditorRouteParamsRelease on _CRouteEditorRouteParams {
  void _releaseIntermediate() {
    routeSearchOptions._releaseIntermediate();
    intermediatePoints._releaseIntermediate();
  }
}

// MARK: - RouteEditorRoutesInfo

/** Информация о маршрутах, которыми оперирует редактор. */
class RouteEditorRoutesInfo {
  /**
   При обновлении списка маршрутов активным будет первый маршрут,
   если список маршрутов непустой.
  */
  final List<TrafficRoute> routes;
  /**
   Параметры маршрута, для которых выполнялся поиск. Могут отличаться
   от параметров, переданных редактору, если маршруты были найдены уже
   после изменения параметров в редакторе.
  */
  final RouteEditorRouteParams routeParams;

  const RouteEditorRoutesInfo({
    required this.routes,
    required this.routeParams
  });

  RouteEditorRoutesInfo copyWith({
    List<TrafficRoute>? routes,
    RouteEditorRouteParams? routeParams
  }) {
    return RouteEditorRoutesInfo(
      routes: routes ?? this.routes,
      routeParams: routeParams ?? this.routeParams
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteEditorRoutesInfo &&
    other.runtimeType == runtimeType &&
    other.routes == routes &&
    other.routeParams == routeParams;

  @override
  int get hashCode {
    return Object.hash(routes, routeParams);
  }

}
final class _CRouteEditorRoutesInfo extends ffi.Struct {
  external _CArray_CTrafficRoute routes;

  external _CRouteEditorRouteParams routeParams;

}
// MARK: - RouteEditorRoutesInfo <-> _CRouteEditorRoutesInfo

extension _CRouteEditorRoutesInfoToDart on _CRouteEditorRoutesInfo {
  RouteEditorRoutesInfo _toDart() {
    return RouteEditorRoutesInfo(
      routes: this.routes._toDart(),
      routeParams: this.routeParams._toDart()
    );
  }
}

extension _DartTo_CRouteEditorRoutesInfo on RouteEditorRoutesInfo {
  _CRouteEditorRoutesInfo _copyFromDartTo_CRouteEditorRoutesInfo() {
    final res = _CRouteEditorRoutesInfoMakeDefault();
    res.routes = this.routes._copyFromDartTo_CArray_CTrafficRoute();
    res.routeParams = this.routeParams._copyFromDartTo_CRouteEditorRouteParams();
    return res;
  }
}
extension _CRouteEditorRoutesInfoRelease on _CRouteEditorRoutesInfo {
  void _releaseIntermediate() {
    routes._releaseIntermediate();
    routeParams._releaseIntermediate();
  }
}

// MARK: - StatefulChannel<RouteIndex?> <-> _CStatefulChannel_COptional_CRouteIndex

class _CStatefulChannel_COptional_CRouteIndexImpl extends StatefulChannel<RouteIndex?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RouteIndex?>>{};

  final _CStatefulChannel_COptional_CRouteIndex _channel;

  _CStatefulChannel_COptional_CRouteIndexImpl(this._channel);

  @override
  RouteIndex? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CRouteIndex cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<RouteIndex?> listen(void onData(RouteIndex? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CRouteIndex, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RouteIndex?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CRouteIndex extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CRouteIndexBasicFunctions on _CStatefulChannel_COptional_CRouteIndex {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CRouteIndex_release(this);
  }

  _CStatefulChannel_COptional_CRouteIndex _retain() {
    return _CStatefulChannel_COptional_CRouteIndex_retain(this);
  }

  RouteIndex? _getter() {
    final cValue = _CStatefulChannel_COptional_CRouteIndexGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CRouteIndex, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CRouteIndexConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CRouteIndexToDart on _CStatefulChannel_COptional_CRouteIndex {
  StatefulChannel<RouteIndex?> _toDart() {
    return _CStatefulChannel_COptional_CRouteIndexImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CRouteIndex on StatefulChannel<RouteIndex?> {
  _CStatefulChannel_COptional_CRouteIndex _copyFromDartTo_CStatefulChannel_COptional_CRouteIndex() {
    return _CStatefulChannel_COptional_CRouteIndexMakeDefault();
  }
}
	
// MARK: - RouteIndex? <-> _COptional_CRouteIndex

final class _COptional_CRouteIndex extends ffi.Struct {
  
  external _CRouteIndex value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRouteIndexBasicFunctions on _COptional_CRouteIndex {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CRouteIndexToDart on _COptional_CRouteIndex {
  RouteIndex? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRouteIndex on RouteIndex? {
  _COptional_CRouteIndex _copyFromDartTo_COptional_CRouteIndex() {
    final cOptional = _COptional_CRouteIndexMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRouteIndex();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - RouteVisualizationType

/** Тип визуализации маршрута. */
enum RouteVisualizationType {
  /** Стандартная визуализация - используется в редакторе маршрута. */
  normal(0),
  /** Визуализация для режима навигации - используется в навигаторе. */
  navigation(1),
  ;

  const RouteVisualizationType(this.rawValue);
  final int rawValue;

  static RouteVisualizationType getByValue(int value) {
    return RouteVisualizationType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouteVisualizationType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouteVisualizationTypeBasicFunctions on _CRouteVisualizationType {
  void _releaseIntermediate() {
  }
}

extension _CRouteVisualizationTypeToDart on _CRouteVisualizationType {
  RouteVisualizationType _toDart() {
    return RouteVisualizationType.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouteVisualizationType on RouteVisualizationType {
  _CRouteVisualizationType _copyFromDartTo_CRouteVisualizationType() {
    return _CRouteVisualizationTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RouteMapObjectSource

/** Источник объектов маршрута на карте. */
class RouteMapObjectSource extends Source implements ffi.Finalizable {
  /** Объекты маршрута. */
  List<RouteMapObject> get objects {
    _CArray_CRouteMapObject res = _CRouteMapObjectSource_objects(_CRouteMapObjectSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Настройка отображения объектов в источнике. */
  RouteSourceSettings get routeSourceSettings {
    _CRouteSourceSettings res = _CRouteMapObjectSource_routeSourceSettings(_CRouteMapObjectSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRouteMapObjectSource_releasePtr);

  RouteMapObjectSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RouteMapObjectSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RouteMapObjectSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Функция создания IRouteMapObjectSource.
  
   - Throws: Exception если невозможно получить зависимости IRouteMapObjectSource
   из контекста
  */
  factory RouteMapObjectSource(
    Context context,
    [RouteVisualizationType routeVisualizationType = RouteVisualizationType.normal
    ]) {
    var _a0 = context._copyFromDartTo_CContext();
    var _a1 = routeVisualizationType._copyFromDartTo_CRouteVisualizationType();
    _CRouteMapObjectSource res = _CRouteMapObjectSource_C_createWith_CContext_CRouteVisualizationType(_a0, _a1);
    _a0._releaseIntermediate();
    return RouteMapObjectSource._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteMapObjectSource &&
    other.runtimeType == runtimeType &&
    _CRouteMapObjectSource_cg_objectIdentifier(this._self) == _CRouteMapObjectSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRouteMapObjectSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RouteMapObjectSource: Methods

  /** Добавление объекта маршрута в источник. */
  void addObject(
    RouteMapObject item
  )  {
    var _a1 = item._copyFromDartTo_CRouteMapObject();
    void res = _CRouteMapObjectSource_addObject_CRouteMapObject(_CRouteMapObjectSourceMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаление объекта маршрута из источника. */
  void removeObject(
    RouteMapObject item
  )  {
    var _a1 = item._copyFromDartTo_CRouteMapObject();
    void res = _CRouteMapObjectSource_removeObject_CRouteMapObject(_CRouteMapObjectSourceMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Замена одного объекта маршрута в источнике на другой. В отличие от удаления и добавления
   объектов маршрута через последовательные вызовы remove_object и add_object замена одного
   маршрута на другой выполняется атомарно - старый маршрут удаляется, а новый появляется
   на карте одновременно.
  
   - Note: Если старый маршрут не найден в источнике, то вызов эквивалентен вызову add_object.
  */
  void replaceObject(
    RouteMapObject oldObject,
    RouteMapObject newObject
  )  {
    var _a1 = oldObject._copyFromDartTo_CRouteMapObject();
    var _a2 = newObject._copyFromDartTo_CRouteMapObject();
    void res = _CRouteMapObjectSource_replaceObject_CRouteMapObject_CRouteMapObject(_CRouteMapObjectSourceMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаление всех объектов маршрута из источника. */
  void clear()  {
    void res = _CRouteMapObjectSource_clear(_CRouteMapObjectSourceMakeDefault().._impl=_self);
    return res;
  }

  /**
   Замена всех ранее добавленных в источник объектов на передаваемый список объектов.
   В отличие от удаления и добавления объектов по одному замена выполняется атомарно -
   старые маршруты удаляются, а новые маршруты появляются на карте одновременно.
  */
  void replaceAllObjects(
    List<RouteMapObject> objects
  )  {
    var _a1 = objects._copyFromDartTo_CArray_CRouteMapObject();
    void res = _CRouteMapObjectSource_replaceAllObjects_CArray_CRouteMapObject(_CRouteMapObjectSourceMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - RouteMapObjectSource <-> CRouteMapObjectSource

final class _CRouteMapObjectSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRouteMapObjectSourceBasicFunctions on _CRouteMapObjectSource {
  void _releaseIntermediate() {
    _CRouteMapObjectSource_release(_impl);
  }

  _CRouteMapObjectSource _retain() {
    return _CRouteMapObjectSource_retain(_impl);
  }
}

extension _CRouteMapObjectSourceToDart on _CRouteMapObjectSource {
  RouteMapObjectSource _toDart() {
    return RouteMapObjectSource._create(_retain()._impl);
  }
}


extension _DartToCRouteMapObjectSource on RouteMapObjectSource {
  _CRouteMapObjectSource _copyFromDartTo_CRouteMapObjectSource() {
    return (_CRouteMapObjectSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RouteInfoCalloutMapObject

/** Объект бабла с информацией о длине и/или длительности маршрута на карте. */
class RouteInfoCalloutMapObject extends MapObject implements ffi.Finalizable {
  /** Маршрут, часть которого представляет данный объект бабла. */
  TrafficRoute get route {
    _CTrafficRoute res = _CRouteInfoCalloutMapObject_route(_CRouteInfoCalloutMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Индекс маршрута. */
  RouteIndex get routeIndex {
    _CRouteIndex res = _CRouteInfoCalloutMapObject_routeIndex(_CRouteInfoCalloutMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Позиция на маршруте, на которой расположен бабл. */
  RoutePoint get routePoint {
    _CRoutePoint res = _CRouteInfoCalloutMapObject_routePoint(_CRouteInfoCalloutMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CRouteInfoCalloutMapObject_releasePtr);

  RouteInfoCalloutMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RouteInfoCalloutMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RouteInfoCalloutMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteInfoCalloutMapObject &&
    other.runtimeType == runtimeType &&
    _CRouteInfoCalloutMapObject_cg_objectIdentifier(this._self) == _CRouteInfoCalloutMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRouteInfoCalloutMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - RouteInfoCalloutMapObject <-> CRouteInfoCalloutMapObject

final class _CRouteInfoCalloutMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRouteInfoCalloutMapObjectBasicFunctions on _CRouteInfoCalloutMapObject {
  void _releaseIntermediate() {
    _CRouteInfoCalloutMapObject_release(_impl);
  }

  _CRouteInfoCalloutMapObject _retain() {
    return _CRouteInfoCalloutMapObject_retain(_impl);
  }
}

extension _CRouteInfoCalloutMapObjectToDart on _CRouteInfoCalloutMapObject {
  RouteInfoCalloutMapObject _toDart() {
    return RouteInfoCalloutMapObject._create(_retain()._impl);
  }
}


extension _DartToCRouteInfoCalloutMapObject on RouteInfoCalloutMapObject {
  _CRouteInfoCalloutMapObject _copyFromDartTo_CRouteInfoCalloutMapObject() {
    return (_CRouteInfoCalloutMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoutePointKind

/** Тип точечного объекта маршрута на карте. */
enum RoutePointKind {
  /** Начальная точка маршрута. */
  start(0),
  /** Конечная точка маршрута. */
  finish(1),
  /** Промежуточная точка маршрута. */
  intermediate(2),
  /** Камера. */
  camera(3),
  /** ДТП. */
  accident(4),
  /** Дорожные работы. */
  roadWork(5),
  /** Комментарий. */
  comment(6),
  /** Перекрытие дорожного движения. */
  roadRestriction(7),
  /** Событие "Другое". */
  otherEvent(8),
  /** Начало и конец платной дороги. */
  tollRoad(9),
  /**
   Точкa соединения отрезков маршрута (кроме маршрутов на общественном транспорте).
   Например, точка в месте соединения пешеходного и автомобильного отрезка.
  */
  transportConnectionPoint(10),
  /** Искуcственная неровность. */
  hump(11),
  /** Ворота или шлагбаум. */
  gate(12),
  /** Перекрытие дороги. */
  barrier(13),
  /** Лестница. */
  stairway(14),
  /**
   Инструкция в здании.
   Перемещение на лифте, эскалаторе и т.д.
  */
  indoorInstruction(15),
  /** Плохая дорога. */
  badRoad(16),
  /** Платформа общественного транспорта. */
  publicTransportPlatform(17),
  /** Начало и конец грунтового покрытия. */
  ground(18),
  /** Начало и конец гравийного покрытия. */
  gravel(19),
  /** Начало и конец автомобильного участка дороги (для маршрутов на велосипедах/самокатах). */
  carRoad(20),
  /** Начало и конец велодорожки. */
  bicycleRoad(21),
  /** Начало и конец велополосы. */
  bicycleLane(22),
  /** Светофор. */
  trafficLight(23),
  ;

  const RoutePointKind(this.rawValue);
  final int rawValue;

  static RoutePointKind getByValue(int value) {
    return RoutePointKind.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoutePointKind extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoutePointKindBasicFunctions on _CRoutePointKind {
  void _releaseIntermediate() {
  }
}

extension _CRoutePointKindToDart on _CRoutePointKind {
  RoutePointKind _toDart() {
    return RoutePointKind.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoutePointKind on RoutePointKind {
  _CRoutePointKind _copyFromDartTo_CRoutePointKind() {
    return _CRoutePointKindMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RoutePointMapObject

/** Точечный объект, являющийся частью маршрута на карте (например, точка начала или конца маршрута). */
class RoutePointMapObject extends MapObject implements ffi.Finalizable {
  /** Маршрут, часть которого представляет данный точечный объект. */
  TrafficRoute get route {
    _CTrafficRoute res = _CRoutePointMapObject_route(_CRoutePointMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Индекс маршрута. */
  RouteIndex get routeIndex {
    _CRouteIndex res = _CRoutePointMapObject_routeIndex(_CRoutePointMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Тип точечного объекта маршрута. */
  RoutePointKind get kind {
    _CRoutePointKind res = _CRoutePointMapObject_kind(_CRoutePointMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Позиция на маршруте, соответствующая данному точечному объекту. */
  RoutePoint get routePoint {
    _CRoutePoint res = _CRoutePointMapObject_routePoint(_CRoutePointMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Географические координаты, в которых находится данный точечный объект. */
  StatefulChannel<GeoPoint> get pointChannel {
    _CStatefulChannel_CGeoPoint res = _CRoutePointMapObject_pointChannel(_CRoutePointMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Географические координаты, в которых находится данный точечный объект. */
  GeoPoint get point {
    _CGeoPoint res = _CRoutePointMapObject_point(_CRoutePointMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set point(GeoPoint point) {
    var _a1 = point._copyFromDartTo_CGeoPoint();
    void res = _CRoutePointMapObject_setPoint_CGeoPoint(_CRoutePointMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoutePointMapObject_releasePtr);

  RoutePointMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RoutePointMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoutePointMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoutePointMapObject &&
    other.runtimeType == runtimeType &&
    _CRoutePointMapObject_cg_objectIdentifier(this._self) == _CRoutePointMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoutePointMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - RoutePointMapObject <-> CRoutePointMapObject

final class _CRoutePointMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoutePointMapObjectBasicFunctions on _CRoutePointMapObject {
  void _releaseIntermediate() {
    _CRoutePointMapObject_release(_impl);
  }

  _CRoutePointMapObject _retain() {
    return _CRoutePointMapObject_retain(_impl);
  }
}

extension _CRoutePointMapObjectToDart on _CRoutePointMapObject {
  RoutePointMapObject _toDart() {
    return RoutePointMapObject._create(_retain()._impl);
  }
}


extension _DartToCRoutePointMapObject on RoutePointMapObject {
  _CRoutePointMapObject _copyFromDartTo_CRoutePointMapObject() {
    return (_CRoutePointMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<GeoPoint> <-> _CStatefulChannel_CGeoPoint

class _CStatefulChannel_CGeoPointImpl extends StatefulChannel<GeoPoint> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<GeoPoint>>{};

  final _CStatefulChannel_CGeoPoint _channel;

  _CStatefulChannel_CGeoPointImpl(this._channel);

  @override
  GeoPoint get value {
    return this._channel._getter();
  }

  static void valueFunction(_CGeoPoint cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<GeoPoint> listen(void onData(GeoPoint event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CGeoPoint, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<GeoPoint>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CGeoPoint extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CGeoPointBasicFunctions on _CStatefulChannel_CGeoPoint {
  void _releaseIntermediate() {
    _CStatefulChannel_CGeoPoint_release(this);
  }

  _CStatefulChannel_CGeoPoint _retain() {
    return _CStatefulChannel_CGeoPoint_retain(this);
  }

  GeoPoint _getter() {
    final cValue = _CStatefulChannel_CGeoPointGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CGeoPoint, ffi.Int64)> callback) {
    return _CStatefulChannel_CGeoPointConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CGeoPointToDart on _CStatefulChannel_CGeoPoint {
  StatefulChannel<GeoPoint> _toDart() {
    return _CStatefulChannel_CGeoPointImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CGeoPoint on StatefulChannel<GeoPoint> {
  _CStatefulChannel_CGeoPoint _copyFromDartTo_CStatefulChannel_CGeoPoint() {
    return _CStatefulChannel_CGeoPointMakeDefault();
  }
}
	
// MARK: - Fps

/** Frames per second, частота кадров. */
class Fps {
  final int value;

  const Fps([this.value = 0]);

  Fps copyWith({
    int? value
  }) {
    return Fps(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Fps &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CFps extends ffi.Struct {
  @ffi.Uint32()
  external int value;

}
// MARK: - Fps <-> _CFps

extension _CFpsToDart on _CFps {
  Fps _toDart() {
    return Fps(
      this.value
    );
  }
}

extension _DartTo_CFps on Fps {
  _CFps _copyFromDartTo_CFps() {
    final res = _CFpsMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CFpsRelease on _CFps {
  void _releaseIntermediate() {
  }
}

// MARK: - MapSurfaceProvider

/** Передача нативной поверхности от платформы для рендеринга карты. */
@internal
class MapSurfaceProvider implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Идентификатор нативной поверхности. */
  int get id {
    int res = _CMapSurfaceProvider_id(_CMapSurfaceProviderMakeDefault().._impl=_self);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapSurfaceProvider_releasePtr);

  MapSurfaceProvider._raw(this._self);
  factory MapSurfaceProvider._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapSurfaceProvider._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapSurfaceProvider &&
    other.runtimeType == runtimeType &&
    _CMapSurfaceProvider_cg_objectIdentifier(this._self) == _CMapSurfaceProvider_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapSurfaceProvider_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CMapSurfaceProvider: Static Methods

  static MapSurfaceProvider create(
    Map map
  )  {
    var _a0 = map._copyFromDartTo_CMap();
    _CMapSurfaceProvider res = _CMapSurfaceProvider_S_create_CMap(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: MapSurfaceProvider: Methods

  /**
   Установить внеэкранную поверхность.
  
   Может использоваться для получения результата рендеринга в виде изображения.
   Можно вызывать лишь с render-потока.
  */
  void setOffscreenSurface(
    ScreenSize size
  )  {
    var _a1 = size._copyFromDartTo_CScreenSize();
    void res = _CMapSurfaceProvider_setOffscreenSurface_CScreenSize(_CMapSurfaceProviderMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Удалить С++-представление поверхности.
  
   Может надолго заблокировать вызывающий поток, так как дожидается завершения рендеринга.
  */
  void destroySurface()  {
    void res = _CMapSurfaceProvider_destroySurface(_CMapSurfaceProviderMakeDefault().._impl=_self);
    return res;
  }

  /** Асинхронно удалить С++-представление поверхности. */
  CancelableOperation<bool> destroySurfaceAsync()  {
    _CFuture_bool res = _CMapSurfaceProvider_destroySurfaceAsync(_CMapSurfaceProviderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Изменить размер поверхности. */
  void resizeSurface(
    ScreenSize size
  )  {
    var _a1 = size._copyFromDartTo_CScreenSize();
    void res = _CMapSurfaceProvider_resizeSurface_CScreenSize(_CMapSurfaceProviderMakeDefault().._impl=_self, _a1);
    return res;
  }

  /** Установить активна ли поверхность (приложение не свернуто, не в спящем режиме). */
  void setActive(
    bool active
  )  {
    void res = _CMapSurfaceProvider_setActive_bool(_CMapSurfaceProviderMakeDefault().._impl=_self, active);
    return res;
  }

}

// MARK: - MapSurfaceProvider <-> CMapSurfaceProvider

final class _CMapSurfaceProvider extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapSurfaceProviderBasicFunctions on _CMapSurfaceProvider {
  void _releaseIntermediate() {
    _CMapSurfaceProvider_release(_impl);
  }

  _CMapSurfaceProvider _retain() {
    return _CMapSurfaceProvider_retain(_impl);
  }
}

extension _CMapSurfaceProviderToDart on _CMapSurfaceProvider {
  MapSurfaceProvider _toDart() {
    return MapSurfaceProvider._create(_retain()._impl);
  }
}


extension _DartToCMapSurfaceProvider on MapSurfaceProvider {
  _CMapSurfaceProvider _copyFromDartTo_CMapSurfaceProvider() {
    return (_CMapSurfaceProviderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<bool> <-> _CFuture_bool

final class _CFuture_bool extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_bool_Cancellable {
  final Completer<bool> completer;
  final _CFuture_bool _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(ffi.Bool, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_bool_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_boolBasicFunctions on _CFuture_bool {
  void _releaseIntermediate() {
    _CFuture_bool_release(this);
  }

  _CFuture_bool _retain() {
    return _CFuture_bool_retain(this);
  }
}

extension _CFuture_boolToDart on _CFuture_bool {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_bool_Cancellable>{};

  static void valueFunction(bool cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue);
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<bool> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<bool>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Bool, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_boolReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_bool_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_bool on CancelableOperation<bool> {
  _CFuture_bool _copyFromDartTo_CFuture_bool() {
    return _CFuture_boolMakeDefault();
  }
}
	
// MARK: - MapRenderer

/** Создание этого объекта приводит к началу рисования карты. */
@internal
class MapRenderer implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  Fps? get maxFps {
    _COptional_CFps res = _CMapRenderer_maxFps(_CMapRendererMakeDefault().._impl=_self);
    return res._toDart();
  }
  Fps? get powerSavingMaxFps {
    _COptional_CFps res = _CMapRenderer_powerSavingMaxFps(_CMapRendererMakeDefault().._impl=_self);
    return res._toDart();
  }
  StatefulChannel<Fps> get fpsChannel {
    _CStatefulChannel_CFps res = _CMapRenderer_fpsChannel(_CMapRendererMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Fps get fps {
    _CFps res = _CMapRenderer_fps(_CMapRendererMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapRenderer_releasePtr);

  MapRenderer._raw(this._self);
  factory MapRenderer._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapRenderer._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapRenderer &&
    other.runtimeType == runtimeType &&
    _CMapRenderer_cg_objectIdentifier(this._self) == _CMapRenderer_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapRenderer_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CMapRenderer: Static Methods

  static MapRenderer create(
    Map map
  )  {
    var _a0 = map._copyFromDartTo_CMap();
    _CMapRenderer res = _CMapRenderer_S_create_CMap(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: MapRenderer: Methods

  void setMaxFps(
    Fps? maxFps,
    Fps? powerSavingMaxFps
  )  {
    var _a1 = maxFps._copyFromDartTo_COptional_CFps();
    var _a2 = powerSavingMaxFps._copyFromDartTo_COptional_CFps();
    void res = _CMapRenderer_setMaxFps_COptional_CFps_COptional_CFps(_CMapRendererMakeDefault().._impl=_self, _a1, _a2);
    return res;
  }

  CancelableOperation<bool> waitForLoading()  {
    _CFuture_bool res = _CMapRenderer_waitForLoading(_CMapRendererMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  CancelableOperation<bool> waitForRendering()  {
    _CFuture_bool res = _CMapRenderer_waitForRendering(_CMapRendererMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  CancelableOperation<ImageData> takeSnapshot(
    Alignment copyrightAlign
  )  {
    var _a1 = copyrightAlign._copyFromDartTo_CAlignment();
    _CFuture_CImageData res = _CMapRenderer_takeSnapshot_CAlignment(_CMapRendererMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - MapRenderer <-> CMapRenderer

final class _CMapRenderer extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapRendererBasicFunctions on _CMapRenderer {
  void _releaseIntermediate() {
    _CMapRenderer_release(_impl);
  }

  _CMapRenderer _retain() {
    return _CMapRenderer_retain(_impl);
  }
}

extension _CMapRendererToDart on _CMapRenderer {
  MapRenderer _toDart() {
    return MapRenderer._create(_retain()._impl);
  }
}


extension _DartToCMapRenderer on MapRenderer {
  _CMapRenderer _copyFromDartTo_CMapRenderer() {
    return (_CMapRendererMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Fps? <-> _COptional_CFps

final class _COptional_CFps extends ffi.Struct {
  
  external _CFps value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CFpsBasicFunctions on _COptional_CFps {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CFpsToDart on _COptional_CFps {
  Fps? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CFps on Fps? {
  _COptional_CFps _copyFromDartTo_COptional_CFps() {
    final cOptional = _COptional_CFpsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CFps();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - StatefulChannel<Fps> <-> _CStatefulChannel_CFps

class _CStatefulChannel_CFpsImpl extends StatefulChannel<Fps> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Fps>>{};

  final _CStatefulChannel_CFps _channel;

  _CStatefulChannel_CFpsImpl(this._channel);

  @override
  Fps get value {
    return this._channel._getter();
  }

  static void valueFunction(_CFps cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<Fps> listen(void onData(Fps event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CFps, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Fps>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CFps extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CFpsBasicFunctions on _CStatefulChannel_CFps {
  void _releaseIntermediate() {
    _CStatefulChannel_CFps_release(this);
  }

  _CStatefulChannel_CFps _retain() {
    return _CStatefulChannel_CFps_retain(this);
  }

  Fps _getter() {
    final cValue = _CStatefulChannel_CFpsGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CFps, ffi.Int64)> callback) {
    return _CStatefulChannel_CFpsConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CFpsToDart on _CStatefulChannel_CFps {
  StatefulChannel<Fps> _toDart() {
    return _CStatefulChannel_CFpsImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CFps on StatefulChannel<Fps> {
  _CStatefulChannel_CFps _copyFromDartTo_CStatefulChannel_CFps() {
    return _CStatefulChannel_CFpsMakeDefault();
  }
}
	
// MARK: - CancelableOperation<ImageData> <-> _CFuture_CImageData

final class _CFuture_CImageData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CImageData_Cancellable {
  final Completer<ImageData> completer;
  final _CFuture_CImageData _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CImageData, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CImageData_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CImageDataBasicFunctions on _CFuture_CImageData {
  void _releaseIntermediate() {
    _CFuture_CImageData_release(this);
  }

  _CFuture_CImageData _retain() {
    return _CFuture_CImageData_retain(this);
  }
}

extension _CFuture_CImageDataToDart on _CFuture_CImageData {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CImageData_Cancellable>{};

  static void valueFunction(_CImageData cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<ImageData> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<ImageData>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CImageData, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CImageDataReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CImageData_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CImageData on CancelableOperation<ImageData> {
  _CFuture_CImageData _copyFromDartTo_CFuture_CImageData() {
    return _CFuture_CImageDataMakeDefault();
  }
}
	
// MARK: - MapBuilder

@internal
class MapBuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CMapBuilder_releasePtr);

  MapBuilder._raw(this._self);
  factory MapBuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapBuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapBuilder() {
    _CMapBuilder res = _CMapBuilder_C_create();
    return MapBuilder._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapBuilder &&
    other.runtimeType == runtimeType &&
    _CMapBuilder_cg_objectIdentifier(this._self) == _CMapBuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapBuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: MapBuilder: Methods

  MapBuilder setSize(
    ScreenSize size
  )  {
    var _a1 = size._copyFromDartTo_CScreenSize();
    _CMapBuilder res = _CMapBuilder_setSize_CScreenSize(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setDevicePpi(
    DevicePpi devicePpi,
    DeviceDensity deviceDensity
  )  {
    var _a1 = devicePpi._copyFromDartTo_CDevicePpi();
    var _a2 = deviceDensity._copyFromDartTo_CDeviceDensity();
    _CMapBuilder res = _CMapBuilder_setDevicePpi_CDevicePpi_CDeviceDensity(_CMapBuilderMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setFontIconSizeMultiplier(
    double fontIconSizeMultiplier
  )  {
    _CMapBuilder res = _CMapBuilder_setFontIconSizeMultiplier_float(_CMapBuilderMakeDefault().._impl=_self, fontIconSizeMultiplier);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setSystemFontIconSizeMultiplier(
    double fontIconSizeMultiplier
  )  {
    _CMapBuilder res = _CMapBuilder_setSystemFontIconSizeMultiplier_float(_CMapBuilderMakeDefault().._impl=_self, fontIconSizeMultiplier);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setStyle(
    Style style
  )  {
    var _a1 = style._copyFromDartTo_CStyle();
    _CMapBuilder res = _CMapBuilder_setStyle_CStyle(_CMapBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setStyleFromFile(
    Context context,
    File file
  )  {
    var _a1 = context._copyFromDartTo_CContext();
    var _a2 = file._copyFromDartTo_CFile();
    _CMapBuilder res = _CMapBuilder_setStyleFromFile_CContext_CFile(_CMapBuilderMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setPosition(
    CameraPosition position
  )  {
    var _a1 = position._copyFromDartTo_CCameraPosition();
    _CMapBuilder res = _CMapBuilder_setPosition_CCameraPosition(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setZoomRestrictions(
    CameraZoomRestrictions zoomRestrictions
  )  {
    var _a1 = zoomRestrictions._copyFromDartTo_CCameraZoomRestrictions();
    _CMapBuilder res = _CMapBuilder_setZoomRestrictions_CCameraZoomRestrictions(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setPositionPoint(
    CameraPositionPoint positionPoint
  )  {
    var _a1 = positionPoint._copyFromDartTo_CCameraPositionPoint();
    _CMapBuilder res = _CMapBuilder_setPositionPoint_CCameraPositionPoint(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setBehaviour(
    CameraBehaviour behaviour
  )  {
    var _a1 = behaviour._copyFromDartTo_CCameraBehaviour();
    _CMapBuilder res = _CMapBuilder_setBehaviour_CCameraBehaviour(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setFollowController(
    FollowController followController
  )  {
    var _a1 = followController._copyFromDartTo_CFollowController();
    _CMapBuilder res = _CMapBuilder_setFollowController_CFollowController(_CMapBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setAttribute(
    String name,
    AttributeValue value
  )  {
    var _a1 = name._copyFromDartTo_CString();
    var _a2 = value._copyFromDartTo_CAttributeValue();
    _CMapBuilder res = _CMapBuilder_setAttribute_CString_CAttributeValue(_CMapBuilderMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setAttributes(
    core.Map<String, AttributeValue> values
  )  {
    var _a1 = values._copyFromDartTo_CDictionary_CString_CAttributeValue();
    _CMapBuilder res = _CMapBuilder_setAttributes_CDictionary_CString_CAttributeValue(_CMapBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setBackgroundColor(
    Color color
  )  {
    var _a1 = color._copyFromDartTo_CColor();
    _CMapBuilder res = _CMapBuilder_setBackgroundColor_CColor(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setVisibilityState(
    MapVisibilityState state
  )  {
    var _a1 = state._copyFromDartTo_CMapVisibilityState();
    _CMapBuilder res = _CMapBuilder_setVisibilityState_CMapVisibilityState(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setGraphicsPreset(
    GraphicsPreset graphicPreset
  )  {
    var _a1 = graphicPreset._copyFromDartTo_CGraphicsPreset();
    _CMapBuilder res = _CMapBuilder_setGraphicsPreset_CGraphicsPreset(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder addSource(
    Source source
  )  {
    var _a1 = source._copyFromDartTo_CSource();
    _CMapBuilder res = _CMapBuilder_addSource_CSource(_CMapBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  CancelableOperation<Map> createMap(
    Context context
  )  {
    var _a1 = context._copyFromDartTo_CContext();
    _CFuture_CMap res = _CMapBuilder_createMap_CContext(_CMapBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - MapBuilder <-> CMapBuilder

final class _CMapBuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapBuilderBasicFunctions on _CMapBuilder {
  void _releaseIntermediate() {
    _CMapBuilder_release(_impl);
  }

  _CMapBuilder _retain() {
    return _CMapBuilder_retain(_impl);
  }
}

extension _CMapBuilderToDart on _CMapBuilder {
  MapBuilder _toDart() {
    return MapBuilder._create(_retain()._impl);
  }
}


extension _DartToCMapBuilder on MapBuilder {
  _CMapBuilder _copyFromDartTo_CMapBuilder() {
    return (_CMapBuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<Map> <-> _CFuture_CMap

final class _CFuture_CMap extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CMap_Cancellable {
  final Completer<Map> completer;
  final _CFuture_CMap _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CMap, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CMap_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CMapBasicFunctions on _CFuture_CMap {
  void _releaseIntermediate() {
    _CFuture_CMap_release(this);
  }

  _CFuture_CMap _retain() {
    return _CFuture_CMap_retain(this);
  }
}

extension _CFuture_CMapToDart on _CFuture_CMap {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CMap_Cancellable>{};

  static void valueFunction(_CMap cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<Map> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<Map>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CMap, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CMapReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CMap_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CMap on CancelableOperation<Map> {
  _CFuture_CMap _copyFromDartTo_CFuture_CMap() {
    return _CFuture_CMapMakeDefault();
  }
}
	
// MARK: - StyleBuilder

/** Конструктор стилей. */
class StyleBuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CStyleBuilder_releasePtr);

  StyleBuilder._raw(this._self);
  factory StyleBuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = StyleBuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory StyleBuilder(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CStyleBuilder res = _CStyleBuilder_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return StyleBuilder._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is StyleBuilder &&
    other.runtimeType == runtimeType &&
    _CStyleBuilder_cg_objectIdentifier(this._self) == _CStyleBuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CStyleBuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: StyleBuilder: Methods

  StyleBuilder setStyleAttribute(
    String name,
    AttributeValue value
  )  {
    var _a1 = name._copyFromDartTo_CString();
    var _a2 = value._copyFromDartTo_CAttributeValue();
    _CStyleBuilder res = _CStyleBuilder_setStyleAttribute_CString_CAttributeValue(_CStyleBuilderMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Получение предустановленного стиля. */
  CancelableOperation<Style> getDefaultStyle()  {
    _CFuture_CStyle res = _CStyleBuilder_getDefaultStyle(_CStyleBuilderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Загрузка пользовательского стиля. */
  CancelableOperation<Style> loadStyle(
    File file
  )  {
    var _a1 = file._copyFromDartTo_CFile();
    _CFuture_CStyle res = _CStyleBuilder_loadStyle_CFile(_CStyleBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - StyleBuilder <-> CStyleBuilder

final class _CStyleBuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStyleBuilderBasicFunctions on _CStyleBuilder {
  void _releaseIntermediate() {
    _CStyleBuilder_release(_impl);
  }

  _CStyleBuilder _retain() {
    return _CStyleBuilder_retain(_impl);
  }
}

extension _CStyleBuilderToDart on _CStyleBuilder {
  StyleBuilder _toDart() {
    return StyleBuilder._create(_retain()._impl);
  }
}


extension _DartToCStyleBuilder on StyleBuilder {
  _CStyleBuilder _copyFromDartTo_CStyleBuilder() {
    return (_CStyleBuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<Style> <-> _CFuture_CStyle

final class _CFuture_CStyle extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CStyle_Cancellable {
  final Completer<Style> completer;
  final _CFuture_CStyle _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CStyle, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CStyle_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CStyleBasicFunctions on _CFuture_CStyle {
  void _releaseIntermediate() {
    _CFuture_CStyle_release(this);
  }

  _CFuture_CStyle _retain() {
    return _CFuture_CStyle_retain(this);
  }
}

extension _CFuture_CStyleToDart on _CFuture_CStyle {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CStyle_Cancellable>{};

  static void valueFunction(_CStyle cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<Style> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<Style>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CStyle, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CStyleReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CStyle_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CStyle on CancelableOperation<Style> {
  _CFuture_CStyle _copyFromDartTo_CFuture_CStyle() {
    return _CFuture_CStyleMakeDefault();
  }
}
	
// MARK: - RotationCenter

/** Задает правило обработки событий вращения карты. */
enum RotationCenter {
  /** Вращать относительно геометрического центра множества точек постановки пальцев. */
  eventCenter(0),
  /** Вращать относительно точки позиции карты. */
  mapPosition(1),
  /**
   Вращать относительно геопозиции.
   Геопозиция устанавливается через метод set_target_geo_point.
   Если геопозиция не указана, то вращение производится относительно точки позиции карты.
  */
  geoPosition(2),
  ;

  const RotationCenter(this.rawValue);
  final int rawValue;

  static RotationCenter getByValue(int value) {
    return RotationCenter.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRotationCenter extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRotationCenterBasicFunctions on _CRotationCenter {
  void _releaseIntermediate() {
  }
}

extension _CRotationCenterToDart on _CRotationCenter {
  RotationCenter _toDart() {
    return RotationCenter.getByValue(this.rawValue);
  }
}

extension _DartTo_CRotationCenter on RotationCenter {
  _CRotationCenter _copyFromDartTo_CRotationCenter() {
    return _CRotationCenterMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ScalingCenter

/** Задает правило обработки событий масштабирования карты. */
enum ScalingCenter {
  /** Масштабировать относительно геометрического центра множества точек постановки пальцев. */
  eventCenter(0),
  /** Масштабировать относительно точки позиции карты. */
  mapPosition(1),
  /**
   Масштабировать относительно геопозиции.
   Геопозиция устанавливается через метод set_target_geo_point.
   Если геопозиция не указана, то масштабирование производится относительно точки позиции карты.
  */
  geoPosition(2),
  ;

  const ScalingCenter(this.rawValue);
  final int rawValue;

  static ScalingCenter getByValue(int value) {
    return ScalingCenter.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CScalingCenter extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CScalingCenterBasicFunctions on _CScalingCenter {
  void _releaseIntermediate() {
  }
}

extension _CScalingCenterToDart on _CScalingCenter {
  ScalingCenter _toDart() {
    return ScalingCenter.getByValue(this.rawValue);
  }
}

extension _DartTo_CScalingCenter on ScalingCenter {
  _CScalingCenter _copyFromDartTo_CScalingCenter() {
    return _CScalingCenterMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - EventsProcessingSettings

class EventsProcessingSettings {
  /** Точка, относительно которой производится вращение карты. */
  final RotationCenter rotationCenter;
  /** Точка, относительно которой производится масштабирование карты. */
  final ScalingCenter scalingCenter;

  const EventsProcessingSettings({
    required this.rotationCenter,
    required this.scalingCenter
  });

  EventsProcessingSettings copyWith({
    RotationCenter? rotationCenter,
    ScalingCenter? scalingCenter
  }) {
    return EventsProcessingSettings(
      rotationCenter: rotationCenter ?? this.rotationCenter,
      scalingCenter: scalingCenter ?? this.scalingCenter
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is EventsProcessingSettings &&
    other.runtimeType == runtimeType &&
    other.rotationCenter == rotationCenter &&
    other.scalingCenter == scalingCenter;

  @override
  int get hashCode {
    return Object.hash(rotationCenter, scalingCenter);
  }

}
final class _CEventsProcessingSettings extends ffi.Struct {
  external _CRotationCenter rotationCenter;

  external _CScalingCenter scalingCenter;

}
// MARK: - EventsProcessingSettings <-> _CEventsProcessingSettings

extension _CEventsProcessingSettingsToDart on _CEventsProcessingSettings {
  EventsProcessingSettings _toDart() {
    return EventsProcessingSettings(
      rotationCenter: this.rotationCenter._toDart(),
      scalingCenter: this.scalingCenter._toDart()
    );
  }
}

extension _DartTo_CEventsProcessingSettings on EventsProcessingSettings {
  _CEventsProcessingSettings _copyFromDartTo_CEventsProcessingSettings() {
    final res = _CEventsProcessingSettingsMakeDefault();
    res.rotationCenter = this.rotationCenter._copyFromDartTo_CRotationCenter();
    res.scalingCenter = this.scalingCenter._copyFromDartTo_CScalingCenter();
    return res;
  }
}
extension _CEventsProcessingSettingsRelease on _CEventsProcessingSettings {
  void _releaseIntermediate() {
  }
}

// MARK: - DragBeginData

/** Данные о начале перетаскивания: точка старта перемещения и перемещаемый объект. */
class DragBeginData {
  final ScreenPoint point;
  final RenderedObject item;

  const DragBeginData({
    required this.point,
    required this.item
  });

  DragBeginData copyWith({
    ScreenPoint? point,
    RenderedObject? item
  }) {
    return DragBeginData(
      point: point ?? this.point,
      item: item ?? this.item
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DragBeginData &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.item == item;

  @override
  int get hashCode {
    return Object.hash(point, item);
  }

}
final class _CDragBeginData extends ffi.Struct {
  external _CScreenPoint point;

  external _CRenderedObject item;

}
// MARK: - DragBeginData <-> _CDragBeginData

extension _CDragBeginDataToDart on _CDragBeginData {
  DragBeginData _toDart() {
    return DragBeginData(
      point: this.point._toDart(),
      item: this.item._toDart()
    );
  }
}

extension _DartTo_CDragBeginData on DragBeginData {
  _CDragBeginData _copyFromDartTo_CDragBeginData() {
    final res = _CDragBeginDataMakeDefault();
    res.point = this.point._copyFromDartTo_CScreenPoint();
    res.item = this.item._copyFromDartTo_CRenderedObject();
    return res;
  }
}
extension _CDragBeginDataRelease on _CDragBeginData {
  void _releaseIntermediate() {
    item._releaseIntermediate();
  }
}

// MARK: - Gesture

enum Gesture {
  shift(1),
  scaling(2),
  rotation(4),
  multiTouchShift(8),
  tilt(16),
  ;

  const Gesture(this.rawValue);
  final int rawValue;

  static Gesture getByValue(int value) {
    return Gesture.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CGesture extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CGestureBasicFunctions on _CGesture {
  void _releaseIntermediate() {
  }
}

extension _CGestureToDart on _CGesture {
  Gesture _toDart() {
    return Gesture.getByValue(this.rawValue);
  }
}

extension _DartTo_CGesture on Gesture {
  _CGesture _copyFromDartTo_CGesture() {
    return _CGestureMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ScalingSettings

class ScalingSettings {
  /**
   Порог коэффицента масштабирования, по достижению которого начнёт отправляться событие масштабирования.
   Используется, если вращение неактивно. Множитель должен выйти за пределы
   (1 / scale_ratio_threshold, scale_ratio_threshold).
  */
  final double scaleRatioThreshold;
  /**
   Порог коэффицента масштабирования, по достижению которого начнёт отправляться сообщения масштабирования.
   Используется, если вращение активно. Множитель должен выйти за пределы
   (1 / scale_ratio_threshold_in_rotation, scale_ratio_threshold_in_rotation).
  */
  final double scaleRatioThresholdInRotation;

  const ScalingSettings({
    required this.scaleRatioThreshold,
    required this.scaleRatioThresholdInRotation
  });

  ScalingSettings copyWith({
    double? scaleRatioThreshold,
    double? scaleRatioThresholdInRotation
  }) {
    return ScalingSettings(
      scaleRatioThreshold: scaleRatioThreshold ?? this.scaleRatioThreshold,
      scaleRatioThresholdInRotation: scaleRatioThresholdInRotation ?? this.scaleRatioThresholdInRotation
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScalingSettings &&
    other.runtimeType == runtimeType &&
    other.scaleRatioThreshold == scaleRatioThreshold &&
    other.scaleRatioThresholdInRotation == scaleRatioThresholdInRotation;

  @override
  int get hashCode {
    return Object.hash(scaleRatioThreshold, scaleRatioThresholdInRotation);
  }

}
final class _CScalingSettings extends ffi.Struct {
  @ffi.Float()
  external double scaleRatioThreshold;

  @ffi.Float()
  external double scaleRatioThresholdInRotation;

}
// MARK: - ScalingSettings <-> _CScalingSettings

extension _CScalingSettingsToDart on _CScalingSettings {
  ScalingSettings _toDart() {
    return ScalingSettings(
      scaleRatioThreshold: this.scaleRatioThreshold,
      scaleRatioThresholdInRotation: this.scaleRatioThresholdInRotation
    );
  }
}

extension _DartTo_CScalingSettings on ScalingSettings {
  _CScalingSettings _copyFromDartTo_CScalingSettings() {
    final res = _CScalingSettingsMakeDefault();
    res.scaleRatioThreshold = this.scaleRatioThreshold;
    res.scaleRatioThresholdInRotation = this.scaleRatioThresholdInRotation;
    return res;
  }
}
extension _CScalingSettingsRelease on _CScalingSettings {
  void _releaseIntermediate() {
  }
}

// MARK: - RotationSettings

/** Настройки обработки вращения карты. */
class RotationSettings {
  /**
   Порог изменения угла, в градусах, по достижению которого начнёт отправлять сообщения вращения.
   Используется, если масштабирование неактивно.
  */
  final double angleDiffDeg;
  /**
   Порог среднего радиального сдвига точек, в миллиметрах, по достижению которого начнёт отправлять
   сообщения вращения. Используется, если масштабирование неактивно.
  */
  final double distanceDiffMm;
  /**
   Порог изменения угла, в градусах, по достижению которого начнёт отправлять сообщения вращения.
   Используется, если масштабирование активно.
  */
  final double angleDiffInScalingDeg;
  /**
   Порог среднего радиального сдвига точек, в миллиметрах, по достижению которого начнёт отправлять
   сообщения вращения. Используется, если масштабирование активно.
  */
  final double distanceDiffInScalingMm;

  const RotationSettings({
    required this.angleDiffDeg,
    required this.distanceDiffMm,
    required this.angleDiffInScalingDeg,
    required this.distanceDiffInScalingMm
  });

  RotationSettings copyWith({
    double? angleDiffDeg,
    double? distanceDiffMm,
    double? angleDiffInScalingDeg,
    double? distanceDiffInScalingMm
  }) {
    return RotationSettings(
      angleDiffDeg: angleDiffDeg ?? this.angleDiffDeg,
      distanceDiffMm: distanceDiffMm ?? this.distanceDiffMm,
      angleDiffInScalingDeg: angleDiffInScalingDeg ?? this.angleDiffInScalingDeg,
      distanceDiffInScalingMm: distanceDiffInScalingMm ?? this.distanceDiffInScalingMm
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RotationSettings &&
    other.runtimeType == runtimeType &&
    other.angleDiffDeg == angleDiffDeg &&
    other.distanceDiffMm == distanceDiffMm &&
    other.angleDiffInScalingDeg == angleDiffInScalingDeg &&
    other.distanceDiffInScalingMm == distanceDiffInScalingMm;

  @override
  int get hashCode {
    return Object.hash(angleDiffDeg, distanceDiffMm, angleDiffInScalingDeg, distanceDiffInScalingMm);
  }

}
final class _CRotationSettings extends ffi.Struct {
  @ffi.Float()
  external double angleDiffDeg;

  @ffi.Float()
  external double distanceDiffMm;

  @ffi.Float()
  external double angleDiffInScalingDeg;

  @ffi.Float()
  external double distanceDiffInScalingMm;

}
// MARK: - RotationSettings <-> _CRotationSettings

extension _CRotationSettingsToDart on _CRotationSettings {
  RotationSettings _toDart() {
    return RotationSettings(
      angleDiffDeg: this.angleDiffDeg,
      distanceDiffMm: this.distanceDiffMm,
      angleDiffInScalingDeg: this.angleDiffInScalingDeg,
      distanceDiffInScalingMm: this.distanceDiffInScalingMm
    );
  }
}

extension _DartTo_CRotationSettings on RotationSettings {
  _CRotationSettings _copyFromDartTo_CRotationSettings() {
    final res = _CRotationSettingsMakeDefault();
    res.angleDiffDeg = this.angleDiffDeg;
    res.distanceDiffMm = this.distanceDiffMm;
    res.angleDiffInScalingDeg = this.angleDiffInScalingDeg;
    res.distanceDiffInScalingMm = this.distanceDiffInScalingMm;
    return res;
  }
}
extension _CRotationSettingsRelease on _CRotationSettings {
  void _releaseIntermediate() {
  }
}

// MARK: - MultiTouchShiftSettings

/** Настройки обработки сдвига при касании несколькими пальцами. */
class MultiTouchShiftSettings {
  /**
   Порог сдвига взвешенного среднего точек постановки пальцев, в миллиметрах, по достижению которого начинают
   генерироваться события смещения несколькими пальцами
  */
  final double thresholdMm;

  const MultiTouchShiftSettings(this.thresholdMm);

  MultiTouchShiftSettings copyWith({
    double? thresholdMm
  }) {
    return MultiTouchShiftSettings(
      thresholdMm ?? this.thresholdMm
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MultiTouchShiftSettings &&
    other.runtimeType == runtimeType &&
    other.thresholdMm == thresholdMm;

  @override
  int get hashCode {
    return thresholdMm.hashCode;
  }

}
final class _CMultiTouchShiftSettings extends ffi.Struct {
  @ffi.Float()
  external double thresholdMm;

}
// MARK: - MultiTouchShiftSettings <-> _CMultiTouchShiftSettings

extension _CMultiTouchShiftSettingsToDart on _CMultiTouchShiftSettings {
  MultiTouchShiftSettings _toDart() {
    return MultiTouchShiftSettings(
      this.thresholdMm
    );
  }
}

extension _DartTo_CMultiTouchShiftSettings on MultiTouchShiftSettings {
  _CMultiTouchShiftSettings _copyFromDartTo_CMultiTouchShiftSettings() {
    final res = _CMultiTouchShiftSettingsMakeDefault();
    res.thresholdMm = this.thresholdMm;
    return res;
  }
}
extension _CMultiTouchShiftSettingsRelease on _CMultiTouchShiftSettings {
  void _releaseIntermediate() {
  }
}

// MARK: - TiltSettings

class TiltSettings {
  /**
   Расстояние, в мм, на которое нужно сдвинуть пальцы по экрану, чтобы изменить угол наклона камеры на 1 градус.
   Отрицательное значение прведет к инверсии направления. значение 0 недопустимо.
  */
  final double lenOnDegreeMm;
  /**
   Максимальный допустимый угол отклонения линии постановки пальцев от горизонта для вертикального свайпа.
   В градусах.
  */
  final double horizontalSwerveDeg;
  /** Максимально допустимый угол отклонения направления свайпа от вертикальной линии. Измеряется в градусах */
  final double verticalSwerveDeg;
  /** Порог сдвига взвешенного среднего точек в миллиметрах. Если сдвиг не превысит порог, то событие не отправляется. */
  final double thresholdMm;
  /**
   Максимально допустимый угол между векторами, до достижения которого они считаются сонаправленными во время
   распознавания жеста наклона.
  */
  final double maxParallelsDeviationDeg;

  const TiltSettings({
    required this.lenOnDegreeMm,
    required this.horizontalSwerveDeg,
    required this.verticalSwerveDeg,
    required this.thresholdMm,
    required this.maxParallelsDeviationDeg
  });

  TiltSettings copyWith({
    double? lenOnDegreeMm,
    double? horizontalSwerveDeg,
    double? verticalSwerveDeg,
    double? thresholdMm,
    double? maxParallelsDeviationDeg
  }) {
    return TiltSettings(
      lenOnDegreeMm: lenOnDegreeMm ?? this.lenOnDegreeMm,
      horizontalSwerveDeg: horizontalSwerveDeg ?? this.horizontalSwerveDeg,
      verticalSwerveDeg: verticalSwerveDeg ?? this.verticalSwerveDeg,
      thresholdMm: thresholdMm ?? this.thresholdMm,
      maxParallelsDeviationDeg: maxParallelsDeviationDeg ?? this.maxParallelsDeviationDeg
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TiltSettings &&
    other.runtimeType == runtimeType &&
    other.lenOnDegreeMm == lenOnDegreeMm &&
    other.horizontalSwerveDeg == horizontalSwerveDeg &&
    other.verticalSwerveDeg == verticalSwerveDeg &&
    other.thresholdMm == thresholdMm &&
    other.maxParallelsDeviationDeg == maxParallelsDeviationDeg;

  @override
  int get hashCode {
    return Object.hash(lenOnDegreeMm, horizontalSwerveDeg, verticalSwerveDeg, thresholdMm, maxParallelsDeviationDeg);
  }

}
final class _CTiltSettings extends ffi.Struct {
  @ffi.Float()
  external double lenOnDegreeMm;

  @ffi.Float()
  external double horizontalSwerveDeg;

  @ffi.Float()
  external double verticalSwerveDeg;

  @ffi.Float()
  external double thresholdMm;

  @ffi.Float()
  external double maxParallelsDeviationDeg;

}
// MARK: - TiltSettings <-> _CTiltSettings

extension _CTiltSettingsToDart on _CTiltSettings {
  TiltSettings _toDart() {
    return TiltSettings(
      lenOnDegreeMm: this.lenOnDegreeMm,
      horizontalSwerveDeg: this.horizontalSwerveDeg,
      verticalSwerveDeg: this.verticalSwerveDeg,
      thresholdMm: this.thresholdMm,
      maxParallelsDeviationDeg: this.maxParallelsDeviationDeg
    );
  }
}

extension _DartTo_CTiltSettings on TiltSettings {
  _CTiltSettings _copyFromDartTo_CTiltSettings() {
    final res = _CTiltSettingsMakeDefault();
    res.lenOnDegreeMm = this.lenOnDegreeMm;
    res.horizontalSwerveDeg = this.horizontalSwerveDeg;
    res.verticalSwerveDeg = this.verticalSwerveDeg;
    res.thresholdMm = this.thresholdMm;
    res.maxParallelsDeviationDeg = this.maxParallelsDeviationDeg;
    return res;
  }
}
extension _CTiltSettingsRelease on _CTiltSettings {
  void _releaseIntermediate() {
  }
}

// MARK: - GestureManager

/** Класс для управления обработкой жестов. */
class GestureManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  GestureEnumSet get enabledGestures {
    _COptionSet_CGesture res = _CGestureManager_enabledGestures(_CGestureManagerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set enabledGestures(GestureEnumSet flags) {
    var _a1 = flags._copyFromDartTo_COptionSet_CGesture();
    void res = _CGestureManager_setEnabledGestures_COptionSet_CGesture(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }
  ScalingSettings get scalingSettings {
    _CScalingSettings res = _CGestureManager_scalingSettings(_CGestureManagerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set scalingSettings(ScalingSettings settings) {
    var _a1 = settings._copyFromDartTo_CScalingSettings();
    void res = _CGestureManager_setScalingSettings_CScalingSettings(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }
  RotationSettings get rotationSettings {
    _CRotationSettings res = _CGestureManager_rotationSettings(_CGestureManagerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set rotationSettings(RotationSettings settings) {
    var _a1 = settings._copyFromDartTo_CRotationSettings();
    void res = _CGestureManager_setRotationSettings_CRotationSettings(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }
  MultiTouchShiftSettings get multitouchShiftSettings {
    _CMultiTouchShiftSettings res = _CGestureManager_multitouchShiftSettings(_CGestureManagerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set multitouchShiftSettings(MultiTouchShiftSettings settings) {
    var _a1 = settings._copyFromDartTo_CMultiTouchShiftSettings();
    void res = _CGestureManager_setMultitouchShiftSettings_CMultiTouchShiftSettings(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }
  TiltSettings get tiltSettings {
    _CTiltSettings res = _CGestureManager_tiltSettings(_CGestureManagerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set tiltSettings(TiltSettings settings) {
    var _a1 = settings._copyFromDartTo_CTiltSettings();
    void res = _CGestureManager_setTiltSettings_CTiltSettings(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CGestureManager_releasePtr);

  GestureManager._raw(this._self);
  factory GestureManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GestureManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GestureManager &&
    other.runtimeType == runtimeType &&
    _CGestureManager_cg_objectIdentifier(this._self) == _CGestureManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGestureManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: GestureManager: Methods

  void enableGesture(
    Gesture gesture
  )  {
    var _a1 = gesture._copyFromDartTo_CGesture();
    void res = _CGestureManager_enableGesture_CGesture(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

  void disableGesture(
    Gesture gesture
  )  {
    var _a1 = gesture._copyFromDartTo_CGesture();
    void res = _CGestureManager_disableGesture_CGesture(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

  bool gestureEnabled(
    Gesture gesture
  )  {
    var _a1 = gesture._copyFromDartTo_CGesture();
    bool res = _CGestureManager_gestureEnabled_CGesture(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Настройка точки, относительно которой происходит масштабирование и поворот.
  
   - Parameter settings: настройки обработки событий.
   - Note: при вызове функции происходит пересоздание инструментов распознавания жестов.
  */
  void setSettingsAboutMapPositionPoint(
    EventsProcessingSettings settings
  )  {
    var _a1 = settings._copyFromDartTo_CEventsProcessingSettings();
    void res = _CGestureManager_setSettingsAboutMapPositionPoint_CEventsProcessingSettings(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

  /** Установка геопозиции, относительно которой происходит масштабирование и поворот. */
  void setTargetGeoPoint(
    GeoPoint? geoPoint
  )  {
    var _a1 = geoPoint._copyFromDartTo_COptional_CGeoPoint();
    void res = _CGestureManager_setTargetGeoPoint_COptional_CGeoPoint(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Установка списка правил исключения одновременного срабатывания нескольких жестов.
  
   - Note: К переданному списку правил добавляются правила по умолчанию, которые не позволяют жесту управления наклоном
   срабатывать одновременно с другими жестами.
   Каждое правило представляет собой перечень жестов, которые не могут срабатывать одновременно
   Например, если в правиле указать жесты Scaling и Rotation то эти жесты не будут работать одновременно
   В случае одновременного выполнения жестов из правила, сработает жест с большим приоритетом
   Порядок приоритета жестов (по убыванию): (Shift ->) Tilt -> Scaling -> Rotation -> MultiTouchShift
  */
  void setMutuallyExclusiveGestures(
    List<GestureEnumSet> rules
  )  {
    var _a1 = rules._copyFromDartTo_CArray_COptionSet_CGesture();
    void res = _CGestureManager_setMutuallyExclusiveGestures_CArray_COptionSet_CGesture(_CGestureManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - GestureManager <-> CGestureManager

final class _CGestureManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGestureManagerBasicFunctions on _CGestureManager {
  void _releaseIntermediate() {
    _CGestureManager_release(_impl);
  }

  _CGestureManager _retain() {
    return _CGestureManager_retain(_impl);
  }
}

extension _CGestureManagerToDart on _CGestureManager {
  GestureManager _toDart() {
    return GestureManager._create(_retain()._impl);
  }
}


extension _DartToCGestureManager on GestureManager {
  _CGestureManager _copyFromDartTo_CGestureManager() {
    return (_CGestureManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GestureEnumSet

class GestureEnumSet extends EnumSet<Gesture> {
  GestureEnumSet() : super();

  factory GestureEnumSet.fromRawValue(int rawValue) {
    GestureEnumSet enumSet = GestureEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory GestureEnumSet.of(Iterable<Gesture> elements) {
    GestureEnumSet enumSet = GestureEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory GestureEnumSet.all() {
    GestureEnumSet enumSet = GestureEnumSet();
    enumSet.addAll(Gesture.values);
    return enumSet;
  }

  @override
  bool contains(Gesture value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<Gesture> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(Gesture value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<Gesture> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(Gesture value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<Gesture> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<Gesture> intersection(EnumSet<Gesture> other) =>
      GestureEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<Gesture> union(EnumSet<Gesture> other) =>
      GestureEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<Gesture> difference(EnumSet<Gesture> other) =>
      GestureEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<Gesture> toSet() {
    Set<Gesture> result = {};
    Gesture.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    Gesture.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CGesture extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CGestureBasicFunctions on _COptionSet_CGesture {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CGestureToDart on _COptionSet_CGesture {
  GestureEnumSet _toDart() {
    return GestureEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CGesture on GestureEnumSet {
  _COptionSet_CGesture _copyFromDartTo_COptionSet_CGesture() {
    return _COptionSet_CGestureMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - List<GestureEnumSet> <-> _CArray_COptionSet_CGesture

final class _CArray_COptionSet_CGesture extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_COptionSet_CGestureToDart on _CArray_COptionSet_CGesture {
  List<GestureEnumSet> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_COptionSet_CGesture on List<GestureEnumSet> {
  _CArray_COptionSet_CGesture _copyFromDartTo_CArray_COptionSet_CGesture() {
    final cArray = _CArray_COptionSet_CGesturemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_COptionSet_CGesture();
        _CArray_COptionSet_CGestureaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_COptionSet_CGestureBasicFunctions on _CArray_COptionSet_CGesture {
  void _releaseIntermediate() {
    _CArray_COptionSet_CGesture_release(this);
  }

  static final _listToFill = <GestureEnumSet>[];

  static void _iterate(_COptionSet_CGesture item) {
    _listToFill.add(item._toDart());
  }

  List<GestureEnumSet> _fillFromC() {
    _forEach_CArray_COptionSet_CGesture(this, ffi.Pointer.fromFunction<ffi.Void Function(_COptionSet_CGesture)>(_iterate));
    final result = List<GestureEnumSet>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - TouchPointState

enum TouchPointState {
  pressed(0),
  released(1),
  moved(2),
  endThisEnum(3),
  ;

  const TouchPointState(this.rawValue);
  final int rawValue;

  static TouchPointState getByValue(int value) {
    return TouchPointState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CTouchPointState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CTouchPointStateBasicFunctions on _CTouchPointState {
  void _releaseIntermediate() {
  }
}

extension _CTouchPointStateToDart on _CTouchPointState {
  TouchPointState _toDart() {
    return TouchPointState.getByValue(this.rawValue);
  }
}

extension _DartTo_CTouchPointState on TouchPointState {
  _CTouchPointState _copyFromDartTo_CTouchPointState() {
    return _CTouchPointStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - MapGestureRecognizer

/**
 Принимает информацию о нажатиях и преобразует их в жесты карты.
 Обработка происходит в два этапа:
 * Добавляется несколько точек - add_touch_point
 * Точки обрабатываются - process_touch_event
*/
@internal
class MapGestureRecognizer implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  Channel<DragBeginData> get dragBegin {
    _CChannel_CDragBeginData res = _CMapGestureRecognizer_dragBegin(_CMapGestureRecognizerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Channel<bool> get dragEnd {
    _CChannel_bool res = _CMapGestureRecognizer_dragEnd(_CMapGestureRecognizerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Channel<ScreenPoint> get dragMove {
    _CChannel_CScreenPoint res = _CMapGestureRecognizer_dragMove(_CMapGestureRecognizerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Channel<ScreenPoint> get tap {
    _CChannel_CScreenPoint res = _CMapGestureRecognizer_tap(_CMapGestureRecognizerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Channel<ScreenPoint> get longTouch {
    _CChannel_CScreenPoint res = _CMapGestureRecognizer_longTouch(_CMapGestureRecognizerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  GestureManager? get gestureManager {
    _COptional_CGestureManager res = _CMapGestureRecognizer_gestureManager(_CMapGestureRecognizerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapGestureRecognizer_releasePtr);

  MapGestureRecognizer._raw(this._self);
  factory MapGestureRecognizer._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapGestureRecognizer._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapGestureRecognizer &&
    other.runtimeType == runtimeType &&
    _CMapGestureRecognizer_cg_objectIdentifier(this._self) == _CMapGestureRecognizer_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapGestureRecognizer_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CMapGestureRecognizer: Static Methods

  static MapGestureRecognizer create(
    Map map
  )  {
    var _a0 = map._copyFromDartTo_CMap();
    _CMapGestureRecognizer res = _CMapGestureRecognizer_S_create_CMap(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: MapGestureRecognizer: Methods

  void addTouchPoint(
    ScreenPoint point,
    TouchPointState state,
    int id
  )  {
    var _a1 = point._copyFromDartTo_CScreenPoint();
    var _a2 = state._copyFromDartTo_CTouchPointState();
    void res = _CMapGestureRecognizer_addTouchPoint_CScreenPoint_CTouchPointState_uint64_t(_CMapGestureRecognizerMakeDefault().._impl=_self, _a1, _a2, id);
    return res;
  }

  bool processTouchEvent(
    Duration timestamp
  )  {
    var _a1 = timestamp._copyFromDartTo_CTimeInterval();
    bool res = _CMapGestureRecognizer_processTouchEvent_CTimeInterval(_CMapGestureRecognizerMakeDefault().._impl=_self, _a1);
    return res;
  }

  void cancel()  {
    void res = _CMapGestureRecognizer_cancel(_CMapGestureRecognizerMakeDefault().._impl=_self);
    return res;
  }

  void onDevicePpiChanged(
    DevicePpi devicePpi
  )  {
    var _a1 = devicePpi._copyFromDartTo_CDevicePpi();
    void res = _CMapGestureRecognizer_onDevicePpiChanged_CDevicePpi(_CMapGestureRecognizerMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - MapGestureRecognizer <-> CMapGestureRecognizer

final class _CMapGestureRecognizer extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapGestureRecognizerBasicFunctions on _CMapGestureRecognizer {
  void _releaseIntermediate() {
    _CMapGestureRecognizer_release(_impl);
  }

  _CMapGestureRecognizer _retain() {
    return _CMapGestureRecognizer_retain(_impl);
  }
}

extension _CMapGestureRecognizerToDart on _CMapGestureRecognizer {
  MapGestureRecognizer _toDart() {
    return MapGestureRecognizer._create(_retain()._impl);
  }
}


extension _DartToCMapGestureRecognizer on MapGestureRecognizer {
  _CMapGestureRecognizer _copyFromDartTo_CMapGestureRecognizer() {
    return (_CMapGestureRecognizerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Channel<DragBeginData> <-> _CChannel_CDragBeginData

class _CChannel_CDragBeginDataImpl extends Channel<DragBeginData> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<DragBeginData>>{};

  final _CChannel_CDragBeginData _channel;

  _CChannel_CDragBeginDataImpl(this._channel);

  static void valueFunction(_CDragBeginData cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<DragBeginData> listen(void onData(DragBeginData event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CDragBeginData, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<DragBeginData>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CChannel_CDragBeginData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CChannel_CDragBeginDataBasicFunctions on _CChannel_CDragBeginData {
  void _releaseIntermediate() {
    _CChannel_CDragBeginData_release(this);
  }

  _CChannel_CDragBeginData _retain() {
    return _CChannel_CDragBeginData_retain(this);
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CDragBeginData, ffi.Int64)> callback) {
    return _CChannel_CDragBeginDataConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CChannel_CDragBeginDataToDart on _CChannel_CDragBeginData {
  Channel<DragBeginData> _toDart() {
    return _CChannel_CDragBeginDataImpl(this._retain());
  }
}

extension _DartTo_CChannel_CDragBeginData on Channel<DragBeginData> {
  _CChannel_CDragBeginData _copyFromDartTo_CChannel_CDragBeginData() {
    return _CChannel_CDragBeginDataMakeDefault();
  }
}
	
// MARK: - Channel<ScreenPoint> <-> _CChannel_CScreenPoint

class _CChannel_CScreenPointImpl extends Channel<ScreenPoint> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<ScreenPoint>>{};

  final _CChannel_CScreenPoint _channel;

  _CChannel_CScreenPointImpl(this._channel);

  static void valueFunction(_CScreenPoint cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<ScreenPoint> listen(void onData(ScreenPoint event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CScreenPoint, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<ScreenPoint>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CChannel_CScreenPoint extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CChannel_CScreenPointBasicFunctions on _CChannel_CScreenPoint {
  void _releaseIntermediate() {
    _CChannel_CScreenPoint_release(this);
  }

  _CChannel_CScreenPoint _retain() {
    return _CChannel_CScreenPoint_retain(this);
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CScreenPoint, ffi.Int64)> callback) {
    return _CChannel_CScreenPointConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CChannel_CScreenPointToDart on _CChannel_CScreenPoint {
  Channel<ScreenPoint> _toDart() {
    return _CChannel_CScreenPointImpl(this._retain());
  }
}

extension _DartTo_CChannel_CScreenPoint on Channel<ScreenPoint> {
  _CChannel_CScreenPoint _copyFromDartTo_CChannel_CScreenPoint() {
    return _CChannel_CScreenPointMakeDefault();
  }
}
	
// MARK: - GestureManager? <-> _COptional_CGestureManager

final class _COptional_CGestureManager extends ffi.Struct {
  
  external _CGestureManager value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGestureManagerBasicFunctions on _COptional_CGestureManager {
  void _releaseIntermediate() {
    _COptional_CGestureManager_release(this);
  }
}

extension _COptional_CGestureManagerToDart on _COptional_CGestureManager {
  GestureManager? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGestureManager on GestureManager? {
  _COptional_CGestureManager _copyFromDartTo_COptional_CGestureManager() {
    final cOptional = _COptional_CGestureManagerMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGestureManager();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - IndoorDetector

/** Детектор, который определяет находится ли пользователь в помещении. */
class IndoorDetector implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Канал, который оповещает о нахождении пользователя в помещении. */
  StatefulChannel<bool> get indoorChannel {
    _CStatefulChannel_bool res = _CIndoorDetector_indoorChannel(_CIndoorDetectorMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Канал, который оповещает о нахождении пользователя в помещении. */
  bool get indoor {
    bool res = _CIndoorDetector_indoor(_CIndoorDetectorMakeDefault().._impl=_self);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CIndoorDetector_releasePtr);

  IndoorDetector._raw(this._self);
  factory IndoorDetector._create(ffi.Pointer<ffi.Void> self) {
    final classObject = IndoorDetector._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IndoorDetector &&
    other.runtimeType == runtimeType &&
    _CIndoorDetector_cg_objectIdentifier(this._self) == _CIndoorDetector_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CIndoorDetector_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - IndoorDetector <-> CIndoorDetector

final class _CIndoorDetector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CIndoorDetectorBasicFunctions on _CIndoorDetector {
  void _releaseIntermediate() {
    _CIndoorDetector_release(_impl);
  }

  _CIndoorDetector _retain() {
    return _CIndoorDetector_retain(_impl);
  }
}

extension _CIndoorDetectorToDart on _CIndoorDetector {
  IndoorDetector _toDart() {
    return IndoorDetector._create(_retain()._impl);
  }
}


extension _DartToCIndoorDetector on IndoorDetector {
  _CIndoorDetector _copyFromDartTo_CIndoorDetector() {
    return (_CIndoorDetectorMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - NavigationFollowController

/** Интерфейс для управления слежением карты за маркером геопозиции в навигаторе. */
class NavigationFollowController implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Таймаут, через который карта автоматически вернется в режим слежения за маркером геопозиции после того,
   как пользователь подвигал её.
   0 - автоматический возврат в режим слежения за маркером геопозиции отключен.
  */
  Duration get followReturnDelay {
    _CTimeInterval res = _CNavigationFollowController_followReturnDelay(_CNavigationFollowControllerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set followReturnDelay(Duration delay) {
    var _a1 = delay._copyFromDartTo_CTimeInterval();
    void res = _CNavigationFollowController_setFollowReturnDelay_CTimeInterval(_CNavigationFollowControllerMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Режим слежения камеры за маркером геопозиции в навигаторе. */
  CameraBehaviour get cameraBehaviour {
    _CCameraBehaviour res = _CNavigationFollowController_cameraBehaviour(_CNavigationFollowControllerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set cameraBehaviour(CameraBehaviour cameraBehaviour) {
    var _a1 = cameraBehaviour._copyFromDartTo_CCameraBehaviour();
    void res = _CNavigationFollowController_setCameraBehaviour_CCameraBehaviour(_CNavigationFollowControllerMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CNavigationFollowController_releasePtr);

  NavigationFollowController._raw(this._self);
  factory NavigationFollowController._create(ffi.Pointer<ffi.Void> self) {
    final classObject = NavigationFollowController._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is NavigationFollowController &&
    other.runtimeType == runtimeType &&
    _CNavigationFollowController_cg_objectIdentifier(this._self) == _CNavigationFollowController_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CNavigationFollowController_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: NavigationFollowController: Methods

  /** Немедленно включает либо отключает режим слежения карты за маркером геопозиции. */
  void setFollow(
    bool follow
  )  {
    void res = _CNavigationFollowController_setFollow_bool(_CNavigationFollowControllerMakeDefault().._impl=_self, follow);
    return res;
  }

}

// MARK: - NavigationFollowController <-> CNavigationFollowController

final class _CNavigationFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CNavigationFollowControllerBasicFunctions on _CNavigationFollowController {
  void _releaseIntermediate() {
    _CNavigationFollowController_release(_impl);
  }

  _CNavigationFollowController _retain() {
    return _CNavigationFollowController_retain(_impl);
  }
}

extension _CNavigationFollowControllerToDart on _CNavigationFollowController {
  NavigationFollowController _toDart() {
    return NavigationFollowController._create(_retain()._impl);
  }
}


extension _DartToCNavigationFollowController on NavigationFollowController {
  _CNavigationFollowController _copyFromDartTo_CNavigationFollowController() {
    return (_CNavigationFollowControllerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapLocationController

/** Контроллер для управления позиционированием карты в навигаторе. */
class MapLocationController implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Включена ли принудительная ориентация карты на север. */
  bool get mapToNorthOrientation {
    bool res = _CMapLocationController_mapToNorthOrientation(_CMapLocationControllerMakeDefault().._impl=_self);
    return res;
  }
  set mapToNorthOrientation(bool enable) {
    void res = _CMapLocationController_setMapToNorthOrientation_bool(_CMapLocationControllerMakeDefault().._impl=_self, enable);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapLocationController_releasePtr);

  MapLocationController._raw(this._self);
  factory MapLocationController._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapLocationController._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapLocationController &&
    other.runtimeType == runtimeType &&
    _CMapLocationController_cg_objectIdentifier(this._self) == _CMapLocationController_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapLocationController_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapLocationController <-> CMapLocationController

final class _CMapLocationController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapLocationControllerBasicFunctions on _CMapLocationController {
  void _releaseIntermediate() {
    _CMapLocationController_release(_impl);
  }

  _CMapLocationController _retain() {
    return _CMapLocationController_retain(_impl);
  }
}

extension _CMapLocationControllerToDart on _CMapLocationController {
  MapLocationController _toDart() {
    return MapLocationController._create(_retain()._impl);
  }
}


extension _DartToCMapLocationController on MapLocationController {
  _CMapLocationController _copyFromDartTo_CMapLocationController() {
    return (_CMapLocationControllerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapManager

/** Интерфейс, позволяющий добавлять карты в навигатор и убирать их из него. */
class MapManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CMapManager_releasePtr);

  MapManager._raw(this._self);
  factory MapManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapManager &&
    other.runtimeType == runtimeType &&
    _CMapManager_cg_objectIdentifier(this._self) == _CMapManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: MapManager: Methods

  void addMap(
    Map map
  )  {
    var _a1 = map._copyFromDartTo_CMap();
    void res = _CMapManager_addMap_CMap(_CMapManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  void removeMap(
    Map map
  )  {
    var _a1 = map._copyFromDartTo_CMap();
    void res = _CMapManager_removeMap_CMap(_CMapManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - MapManager <-> CMapManager

final class _CMapManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapManagerBasicFunctions on _CMapManager {
  void _releaseIntermediate() {
    _CMapManager_release(_impl);
  }

  _CMapManager _retain() {
    return _CMapManager_retain(_impl);
  }
}

extension _CMapManagerToDart on _CMapManager {
  MapManager _toDart() {
    return MapManager._create(_retain()._impl);
  }
}


extension _DartToCMapManager on MapManager {
  _CMapManager _copyFromDartTo_CMapManager() {
    return (_CMapManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SpeedRange

/** Интервал скоростей. Скорости задаются в метрах в секунду. */
class SpeedRange {
  final double minSpeed;
  final double maxSpeed;

  const SpeedRange({
    this.minSpeed = 0,
    this.maxSpeed = 0
  });

  SpeedRange copyWith({
    double? minSpeed,
    double? maxSpeed
  }) {
    return SpeedRange(
      minSpeed: minSpeed ?? this.minSpeed,
      maxSpeed: maxSpeed ?? this.maxSpeed
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SpeedRange &&
    other.runtimeType == runtimeType &&
    other.minSpeed == minSpeed &&
    other.maxSpeed == maxSpeed;

  @override
  int get hashCode {
    return Object.hash(minSpeed, maxSpeed);
  }

}
final class _CSpeedRange extends ffi.Struct {
  @ffi.Double()
  external double minSpeed;

  @ffi.Double()
  external double maxSpeed;

}
// MARK: - SpeedRange <-> _CSpeedRange

extension _CSpeedRangeToDart on _CSpeedRange {
  SpeedRange _toDart() {
    return SpeedRange(
      minSpeed: this.minSpeed,
      maxSpeed: this.maxSpeed
    );
  }
}

extension _DartTo_CSpeedRange on SpeedRange {
  _CSpeedRange _copyFromDartTo_CSpeedRange() {
    final res = _CSpeedRangeMakeDefault();
    res.minSpeed = this.minSpeed;
    res.maxSpeed = this.maxSpeed;
    return res;
  }
}
extension _CSpeedRangeRelease on _CSpeedRange {
  void _releaseIntermediate() {
  }
}

// MARK: - SpeedRangeToStyleZoom

/** Соответствие интервала скоростей и стилевого уровня масштабирования. */
class SpeedRangeToStyleZoom {
  /** Интервал скоростей. */
  final SpeedRange range;
  /**
   Минимальное расстояние до манёвра, при котором должна включаться логика
   плавного увеличения уровня зума.
  */
  final RouteDistance minDistanceToManeuver;
  /**
   Максимальное расстояние после манёвра, при котором плавное уменьшение уровня
   зума должно завершиться.
  */
  final RouteDistance maxDistanceToManeuver;
  /** Стилевой уровень масштабирования. */
  final StyleZoom styleZoom;

  const SpeedRangeToStyleZoom({
    required this.range,
    required this.minDistanceToManeuver,
    required this.maxDistanceToManeuver,
    required this.styleZoom
  });

  SpeedRangeToStyleZoom copyWith({
    SpeedRange? range,
    RouteDistance? minDistanceToManeuver,
    RouteDistance? maxDistanceToManeuver,
    StyleZoom? styleZoom
  }) {
    return SpeedRangeToStyleZoom(
      range: range ?? this.range,
      minDistanceToManeuver: minDistanceToManeuver ?? this.minDistanceToManeuver,
      maxDistanceToManeuver: maxDistanceToManeuver ?? this.maxDistanceToManeuver,
      styleZoom: styleZoom ?? this.styleZoom
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SpeedRangeToStyleZoom &&
    other.runtimeType == runtimeType &&
    other.range == range &&
    other.minDistanceToManeuver == minDistanceToManeuver &&
    other.maxDistanceToManeuver == maxDistanceToManeuver &&
    other.styleZoom == styleZoom;

  @override
  int get hashCode {
    return Object.hash(range, minDistanceToManeuver, maxDistanceToManeuver, styleZoom);
  }

}
final class _CSpeedRangeToStyleZoom extends ffi.Struct {
  external _CSpeedRange range;

  external _CRouteDistance minDistanceToManeuver;

  external _CRouteDistance maxDistanceToManeuver;

  external _CStyleZoom styleZoom;

}
// MARK: - SpeedRangeToStyleZoom <-> _CSpeedRangeToStyleZoom

extension _CSpeedRangeToStyleZoomToDart on _CSpeedRangeToStyleZoom {
  SpeedRangeToStyleZoom _toDart() {
    return SpeedRangeToStyleZoom(
      range: this.range._toDart(),
      minDistanceToManeuver: this.minDistanceToManeuver._toDart(),
      maxDistanceToManeuver: this.maxDistanceToManeuver._toDart(),
      styleZoom: this.styleZoom._toDart()
    );
  }
}

extension _DartTo_CSpeedRangeToStyleZoom on SpeedRangeToStyleZoom {
  _CSpeedRangeToStyleZoom _copyFromDartTo_CSpeedRangeToStyleZoom() {
    final res = _CSpeedRangeToStyleZoomMakeDefault();
    res.range = this.range._copyFromDartTo_CSpeedRange();
    res.minDistanceToManeuver = this.minDistanceToManeuver._copyFromDartTo_CRouteDistance();
    res.maxDistanceToManeuver = this.maxDistanceToManeuver._copyFromDartTo_CRouteDistance();
    res.styleZoom = this.styleZoom._copyFromDartTo_CStyleZoom();
    return res;
  }
}
extension _CSpeedRangeToStyleZoomRelease on _CSpeedRangeToStyleZoom {
  void _releaseIntermediate() {
  }
}

// MARK: - ZoomFollowSettings

/**
 Интерфейс, позволяющий управлять настройками масштабирования карты во время ведения.

 Во время ведения масштаб зависит от скорости движения, от наличия манёвров впереди и позади на маршруте и от типа
 дороги.

 При отсутствии манёвров впереди и позади, либо на дорогах низкого значения (неглавные улицы населённых пунктов,
 шоссе, междугородние или федеральные трассы) значение масштаба выбирается на основании значений
 SpeedRangeToStyleZoom, которые хранятся в последовательности speed_range_to_style_zoom_sequence. Последовательность
 speed_range_to_style_zoom_sequence должна содержать интервалы скоростей, отсортированные по возрастанию значений
 min_speed, при этом должны выполняться условия:
 max_speed[i] > min_speed[i + 1]
 &
 &
 max_speed[i]
 <
 = min_speed[i + 2]
 &
 &
 max_speed[i]
 <
 max_speed[i + 1].
 То есть интервалы скоростей должны соприкасаться или даже пересекаться, но значение скорости не должно попадать более
 чем в два интервала. При этом минимальное значение скорости не считается попадающим в интервал, т.е. одно и то же
 значение скорости может находиться быть максимальной скоростью для одного интервала, минимальной скоростью для
 другого и находиться внутри интервала для третьего интервала. Исключение - первый интервал скоростей, который должен
 содержать значение min_speed == 0.

 Масштаб карты выбирается из последовательности speed_range_to_style_zoom_sequence по алгоритму:
 1. На старте ведения выбирается элемент последовательности с index == 0.
 2. Во время движение происходит проверка на то, не вышло ли текущее значение скорости за пределы интервала
 скоростей, указанных в элементе последовательности с индексом index. Если скорость вышла за пределы интервала,
 то происходит поиск соседнего интервала, в который попадает значение скорости, и запоминается его индекс.
 3. Происходит проверка, не проезжаем ли мы маневр. Считается, что мы проезжаем маневр, если есть маневр по ходу
 движения и дистанция до маневра не превышает указанной в SpeedRangeToStyleZoom, или мы проехали маневр, но не
 отдалились от него на дистанцию больше указанной в SpeedRangeToStyleZoom.
 Если мы проезжаем маневр, то выбирается масштаб, соответствующий элементу последовательности с index == 0,
 иначе выбирается масштаб, соответствующий элементу index.

 При приближении к маневру на текущей скорости масштаб будет плавно увеличиваться. Время увеличения зависит от
 скорости и расстояния до манёвра. При увеличении скорости время анимации увеличивается, при снижении скорости -
 уменьшается. Увеличение уровня зума завершается на некотором расстоянии до манёвра.

 После проезда манёвра уровень зума плавно уменьшается.
*/
class ZoomFollowSettings implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Последовательность интервалов скоростей и соответствующих им масштабов.
   Используется для автоматического изменения масштаба в навигаторе в зависимости от скорости.
  */
  List<SpeedRangeToStyleZoom> get speedRangeToStyleZoomSequence {
    _CArray_CSpeedRangeToStyleZoom res = _CZoomFollowSettings_getSpeedRangeToStyleZoomSequence(_CZoomFollowSettingsMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set speedRangeToStyleZoomSequence(List<SpeedRangeToStyleZoom> sequence) {
    var _a1 = sequence._copyFromDartTo_CArray_CSpeedRangeToStyleZoom();
    void res = _CZoomFollowSettings_setSpeedRangeToStyleZoomSequence_CArray_CSpeedRangeToStyleZoom(_CZoomFollowSettingsMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /**
   Последовательность интервалов скоростей и соответствующих им масштабов при ведении в режиме FreeRoam.
   Используется для автоматического изменения масштаба в навигаторе в зависимости от скорости.
  */
  List<SpeedRangeToStyleZoom> get speedRangeToStyleZoomFreeRoamSequence {
    _CArray_CSpeedRangeToStyleZoom res = _CZoomFollowSettings_getSpeedRangeToStyleZoomFreeRoamSequence(_CZoomFollowSettingsMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set speedRangeToStyleZoomFreeRoamSequence(List<SpeedRangeToStyleZoom> sequence) {
    var _a1 = sequence._copyFromDartTo_CArray_CSpeedRangeToStyleZoom();
    void res = _CZoomFollowSettings_setSpeedRangeToStyleZoomFreeRoamSequence_CArray_CSpeedRangeToStyleZoom(_CZoomFollowSettingsMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /**
   Длительность плавного изменения масштаба в режиме ведения при изменении скорости
   при отсутствии манёвров впереди/позади на достаточно близком расстоянии, либо на дорогах
   низкого значения.
  */
  Duration get styleZoomSpeedRangesAnimationDuration {
    _CTimeInterval res = _CZoomFollowSettings_getStyleZoomSpeedRangesAnimationDuration(_CZoomFollowSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set styleZoomSpeedRangesAnimationDuration(Duration duration) {
    var _a1 = duration._copyFromDartTo_CTimeInterval();
    void res = _CZoomFollowSettings_setStyleZoomSpeedRangesAnimationDuration_CTimeInterval(_CZoomFollowSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Длительность плавного увеличения уровня зума при приближении к манёвру.
   Используется только если скорость ниже, чем в get_min_speed_to_consider_in_zoom_in_before_maneuver_animation.
  */
  Duration get zoomInBeforeManeuverAnimationDuration {
    _CTimeInterval res = _CZoomFollowSettings_getZoomInBeforeManeuverAnimationDuration(_CZoomFollowSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set zoomInBeforeManeuverAnimationDuration(Duration duration) {
    var _a1 = duration._copyFromDartTo_CTimeInterval();
    void res = _CZoomFollowSettings_setZoomInBeforeManeuverAnimationDuration_CTimeInterval(_CZoomFollowSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Длительность плавного уменьшения уровня масштабирования после проезда манёвра. */
  Duration get zoomOutAfterManeuverAnimationDuration {
    _CTimeInterval res = _CZoomFollowSettings_getZoomOutAfterManeuverAnimationDuration(_CZoomFollowSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set zoomOutAfterManeuverAnimationDuration(Duration duration) {
    var _a1 = duration._copyFromDartTo_CTimeInterval();
    void res = _CZoomFollowSettings_setZoomOutAfterManeuverAnimationDuration_CTimeInterval(_CZoomFollowSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Минимальная скорость движения в м/с, при которой длительность плавного изменения уровня зума
   будет рассчитываться с учётом не только близости к манёвру, но и с учётом текущей скорости.
   Должна быть не меньше 0.1 м/с, значения меньше будут игнорироваться.
  */
  double get minSpeedToConsiderInZoomInBeforeManeuverAnimation {
    double res = _CZoomFollowSettings_getMinSpeedToConsiderInZoomInBeforeManeuverAnimation(_CZoomFollowSettingsMakeDefault().._impl=_self);
    return res;
  }
  set minSpeedToConsiderInZoomInBeforeManeuverAnimation(double speed) {
    void res = _CZoomFollowSettings_setMinSpeedToConsiderInZoomInBeforeManeuverAnimation_double(_CZoomFollowSettingsMakeDefault().._impl=_self, speed);
    return res;
  }
  /**
   Коэффициент ускорения анимации увеличения уровня зума при приближении к манёвру. Должен быть не меньше 1,
   значения меньше будут игнорироваться.
  */
  double get zoomInBeforeManeuverAnimationAcceleration {
    double res = _CZoomFollowSettings_getZoomInBeforeManeuverAnimationAcceleration(_CZoomFollowSettingsMakeDefault().._impl=_self);
    return res;
  }
  set zoomInBeforeManeuverAnimationAcceleration(double acceleration) {
    void res = _CZoomFollowSettings_setZoomInBeforeManeuverAnimationAcceleration_double(_CZoomFollowSettingsMakeDefault().._impl=_self, acceleration);
    return res;
  }
  /**
   Расстояние до манёвра, при достижении которого анимация плавного увеличения уровня зума должна
   быть завершена, чтобы во время манёвра зум не менялся.
   Например, если до маневра 300 м, то анимация с плавным увеличением уровня зума
   должна быть завершена за 50 м до начала маневра.
   Должно быть не меньше 1 м, значения меньше будут игнорироваться.
  */
  RouteDistance get distanceGapToManeuver {
    _CRouteDistance res = _CZoomFollowSettings_getDistanceGapToManeuver(_CZoomFollowSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set distanceGapToManeuver(RouteDistance distance) {
    var _a1 = distance._copyFromDartTo_CRouteDistance();
    void res = _CZoomFollowSettings_setDistanceGapToManeuver_CRouteDistance(_CZoomFollowSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Минимальное время анимации. Используется для предотвращения резких изменений уровня зума при анимации.
   Должно быть не меньше 200, значения меньше будут игнорироваться.
  */
  Duration get minAnimationDuration {
    _CTimeInterval res = _CZoomFollowSettings_getMinAnimationDuration(_CZoomFollowSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set minAnimationDuration(Duration duration) {
    var _a1 = duration._copyFromDartTo_CTimeInterval();
    void res = _CZoomFollowSettings_setMinAnimationDuration_CTimeInterval(_CZoomFollowSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CZoomFollowSettings_releasePtr);

  ZoomFollowSettings._raw(this._self);
  factory ZoomFollowSettings._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ZoomFollowSettings._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ZoomFollowSettings &&
    other.runtimeType == runtimeType &&
    _CZoomFollowSettings_cg_objectIdentifier(this._self) == _CZoomFollowSettings_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CZoomFollowSettings_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ZoomFollowSettings <-> CZoomFollowSettings

final class _CZoomFollowSettings extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CZoomFollowSettingsBasicFunctions on _CZoomFollowSettings {
  void _releaseIntermediate() {
    _CZoomFollowSettings_release(_impl);
  }

  _CZoomFollowSettings _retain() {
    return _CZoomFollowSettings_retain(_impl);
  }
}

extension _CZoomFollowSettingsToDart on _CZoomFollowSettings {
  ZoomFollowSettings _toDart() {
    return ZoomFollowSettings._create(_retain()._impl);
  }
}


extension _DartToCZoomFollowSettings on ZoomFollowSettings {
  _CZoomFollowSettings _copyFromDartTo_CZoomFollowSettings() {
    return (_CZoomFollowSettingsMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<SpeedRangeToStyleZoom> <-> _CArray_CSpeedRangeToStyleZoom

final class _CArray_CSpeedRangeToStyleZoom extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSpeedRangeToStyleZoomToDart on _CArray_CSpeedRangeToStyleZoom {
  List<SpeedRangeToStyleZoom> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSpeedRangeToStyleZoom on List<SpeedRangeToStyleZoom> {
  _CArray_CSpeedRangeToStyleZoom _copyFromDartTo_CArray_CSpeedRangeToStyleZoom() {
    final cArray = _CArray_CSpeedRangeToStyleZoommakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSpeedRangeToStyleZoom();
        _CArray_CSpeedRangeToStyleZoomaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CSpeedRangeToStyleZoomBasicFunctions on _CArray_CSpeedRangeToStyleZoom {
  void _releaseIntermediate() {
    _CArray_CSpeedRangeToStyleZoom_release(this);
  }

  static final _listToFill = <SpeedRangeToStyleZoom>[];

  static void _iterate(_CSpeedRangeToStyleZoom item) {
    _listToFill.add(item._toDart());
  }

  List<SpeedRangeToStyleZoom> _fillFromC() {
    _forEach_CArray_CSpeedRangeToStyleZoom(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSpeedRangeToStyleZoom)>(_iterate));
    final result = List<SpeedRangeToStyleZoom>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RouteMapSettings

/** Настройки отображения маршрута на карте. */
class RouteMapSettings implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Флаги отображения маршрута на карте для режима ведения по маршруту.
   По умолчанию включены все флаги, за исключением флага InactiveFloors.
  */
  RouteMapObjectDisplayFlagEnumSet get onRouteDisplayFlags {
    _COptionSet_CRouteMapObjectDisplayFlag res = _CRouteMapSettings_onRouteDisplayFlags(_CRouteMapSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set onRouteDisplayFlags(RouteMapObjectDisplayFlagEnumSet displayFlags) {
    var _a1 = displayFlags._copyFromDartTo_COptionSet_CRouteMapObjectDisplayFlag();
    void res = _CRouteMapSettings_setOnRouteDisplayFlags_COptionSet_CRouteMapObjectDisplayFlag(_CRouteMapSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Флаги отображения маршрута на карте для режима free roam.
   По умолчанию включены флаги Cameras, Humps, Accidents, RoadWorks, Comments, RoadRestrictions, OtherEvents.
  */
  RouteMapObjectDisplayFlagEnumSet get freeRoamDisplayFlags {
    _COptionSet_CRouteMapObjectDisplayFlag res = _CRouteMapSettings_freeRoamDisplayFlags(_CRouteMapSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set freeRoamDisplayFlags(RouteMapObjectDisplayFlagEnumSet displayFlags) {
    var _a1 = displayFlags._copyFromDartTo_COptionSet_CRouteMapObjectDisplayFlag();
    void res = _CRouteMapSettings_setFreeRoamDisplayFlags_COptionSet_CRouteMapObjectDisplayFlag(_CRouteMapSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Флаги, исключающие скрытие различных составных частей маршрута с карты при обновлении пройденного вдоль
   маршрута расстояния для режима ведения по маршруту. По умолчанию скрываются все элементы маршрута.
  */
  RouteMapObjectPermanentDisplayFlagEnumSet get onRoutePermanentDisplayFlags {
    _COptionSet_CRouteMapObjectPermanentDisplayFlag res = _CRouteMapSettings_onRoutePermanentDisplayFlags(_CRouteMapSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set onRoutePermanentDisplayFlags(RouteMapObjectPermanentDisplayFlagEnumSet flags) {
    var _a1 = flags._copyFromDartTo_COptionSet_CRouteMapObjectPermanentDisplayFlag();
    void res = _CRouteMapSettings_setOnRoutePermanentDisplayFlags_COptionSet_CRouteMapObjectPermanentDisplayFlag(_CRouteMapSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Флаги, исключающие скрытие различных составных частей маршрута с карты при обновлении пройденного вдоль
   маршрута расстояния для режима free roam. По умолчанию скрываются все элементы маршрута.
  */
  RouteMapObjectPermanentDisplayFlagEnumSet get freeRoamPermanentDisplayFlags {
    _COptionSet_CRouteMapObjectPermanentDisplayFlag res = _CRouteMapSettings_freeRoamPermanentDisplayFlags(_CRouteMapSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set freeRoamPermanentDisplayFlags(RouteMapObjectPermanentDisplayFlagEnumSet flags) {
    var _a1 = flags._copyFromDartTo_COptionSet_CRouteMapObjectPermanentDisplayFlag();
    void res = _CRouteMapSettings_setFreeRoamPermanentDisplayFlags_COptionSet_CRouteMapObjectPermanentDisplayFlag(_CRouteMapSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRouteMapSettings_releasePtr);

  RouteMapSettings._raw(this._self);
  factory RouteMapSettings._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RouteMapSettings._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteMapSettings &&
    other.runtimeType == runtimeType &&
    _CRouteMapSettings_cg_objectIdentifier(this._self) == _CRouteMapSettings_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRouteMapSettings_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - RouteMapSettings <-> CRouteMapSettings

final class _CRouteMapSettings extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRouteMapSettingsBasicFunctions on _CRouteMapSettings {
  void _releaseIntermediate() {
    _CRouteMapSettings_release(_impl);
  }

  _CRouteMapSettings _retain() {
    return _CRouteMapSettings_retain(_impl);
  }
}

extension _CRouteMapSettingsToDart on _CRouteMapSettings {
  RouteMapSettings _toDart() {
    return RouteMapSettings._create(_retain()._impl);
  }
}


extension _DartToCRouteMapSettings on RouteMapSettings {
  _CRouteMapSettings _copyFromDartTo_CRouteMapSettings() {
    return (_CRouteMapSettingsMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RouteMapObjectsProvider

/** Интерфейс для получения объектов маршрута на карте. */
class RouteMapObjectsProvider implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Объекты маршрута на карте. */
  StatefulChannel<List<RouteMapObject>> get objectsChannel {
    _CStatefulChannel_CArray_CRouteMapObject res = _CRouteMapObjectsProvider_objectsChannel(_CRouteMapObjectsProviderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Объекты маршрута на карте. */
  List<RouteMapObject> get objects {
    _CArray_CRouteMapObject res = _CRouteMapObjectsProvider_objects(_CRouteMapObjectsProviderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRouteMapObjectsProvider_releasePtr);

  RouteMapObjectsProvider._raw(this._self);
  factory RouteMapObjectsProvider._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RouteMapObjectsProvider._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteMapObjectsProvider &&
    other.runtimeType == runtimeType &&
    _CRouteMapObjectsProvider_cg_objectIdentifier(this._self) == _CRouteMapObjectsProvider_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRouteMapObjectsProvider_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - RouteMapObjectsProvider <-> CRouteMapObjectsProvider

final class _CRouteMapObjectsProvider extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRouteMapObjectsProviderBasicFunctions on _CRouteMapObjectsProvider {
  void _releaseIntermediate() {
    _CRouteMapObjectsProvider_release(_impl);
  }

  _CRouteMapObjectsProvider _retain() {
    return _CRouteMapObjectsProvider_retain(_impl);
  }
}

extension _CRouteMapObjectsProviderToDart on _CRouteMapObjectsProvider {
  RouteMapObjectsProvider _toDart() {
    return RouteMapObjectsProvider._create(_retain()._impl);
  }
}


extension _DartToCRouteMapObjectsProvider on RouteMapObjectsProvider {
  _CRouteMapObjectsProvider _copyFromDartTo_CRouteMapObjectsProvider() {
    return (_CRouteMapObjectsProviderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<List<RouteMapObject>> <-> _CStatefulChannel_CArray_CRouteMapObject

class _CStatefulChannel_CArray_CRouteMapObjectImpl extends StatefulChannel<List<RouteMapObject>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<RouteMapObject>>>{};

  final _CStatefulChannel_CArray_CRouteMapObject _channel;

  _CStatefulChannel_CArray_CRouteMapObjectImpl(this._channel);

  @override
  List<RouteMapObject> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CArray_CRouteMapObject cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<RouteMapObject>> listen(void onData(List<RouteMapObject> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CRouteMapObject, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<RouteMapObject>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CArray_CRouteMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CArray_CRouteMapObjectBasicFunctions on _CStatefulChannel_CArray_CRouteMapObject {
  void _releaseIntermediate() {
    _CStatefulChannel_CArray_CRouteMapObject_release(this);
  }

  _CStatefulChannel_CArray_CRouteMapObject _retain() {
    return _CStatefulChannel_CArray_CRouteMapObject_retain(this);
  }

  List<RouteMapObject> _getter() {
    final cValue = _CStatefulChannel_CArray_CRouteMapObjectGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CRouteMapObject, ffi.Int64)> callback) {
    return _CStatefulChannel_CArray_CRouteMapObjectConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CArray_CRouteMapObjectToDart on _CStatefulChannel_CArray_CRouteMapObject {
  StatefulChannel<List<RouteMapObject>> _toDart() {
    return _CStatefulChannel_CArray_CRouteMapObjectImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CArray_CRouteMapObject on StatefulChannel<List<RouteMapObject>> {
  _CStatefulChannel_CArray_CRouteMapObject _copyFromDartTo_CStatefulChannel_CArray_CRouteMapObject() {
    return _CStatefulChannel_CArray_CRouteMapObjectMakeDefault();
  }
}
	
// MARK: - SimulationConstantSpeed

/** Структура для задания режима движения с постоянной скоростью. */
class SimulationConstantSpeed {
  /** Скорость движения в м/с. Допустимы значения только >= 0. */
  final double speed;

  const SimulationConstantSpeed([this.speed = 0]);

  SimulationConstantSpeed copyWith({
    double? speed
  }) {
    return SimulationConstantSpeed(
      speed ?? this.speed
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SimulationConstantSpeed &&
    other.runtimeType == runtimeType &&
    other.speed == speed;

  @override
  int get hashCode {
    return speed.hashCode;
  }

}
final class _CSimulationConstantSpeed extends ffi.Struct {
  @ffi.Double()
  external double speed;

}
// MARK: - SimulationConstantSpeed <-> _CSimulationConstantSpeed

extension _CSimulationConstantSpeedToDart on _CSimulationConstantSpeed {
  SimulationConstantSpeed _toDart() {
    return SimulationConstantSpeed(
      this.speed
    );
  }
}

extension _DartTo_CSimulationConstantSpeed on SimulationConstantSpeed {
  _CSimulationConstantSpeed _copyFromDartTo_CSimulationConstantSpeed() {
    final res = _CSimulationConstantSpeedMakeDefault();
    res.speed = this.speed;
    return res;
  }
}
extension _CSimulationConstantSpeedRelease on _CSimulationConstantSpeed {
  void _releaseIntermediate() {
  }
}

// MARK: - SimulationAutoWithOverSpeed

/** Структура для задания режима движения с учетом максимальной скорости на ребре маршрута. */
class SimulationAutoWithOverSpeed {
  /** Используемое превышение скорости в м/с. Допустимы значения только >= 0. */
  final double overSpeed;

  const SimulationAutoWithOverSpeed([this.overSpeed = 0]);

  SimulationAutoWithOverSpeed copyWith({
    double? overSpeed
  }) {
    return SimulationAutoWithOverSpeed(
      overSpeed ?? this.overSpeed
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SimulationAutoWithOverSpeed &&
    other.runtimeType == runtimeType &&
    other.overSpeed == overSpeed;

  @override
  int get hashCode {
    return overSpeed.hashCode;
  }

}
final class _CSimulationAutoWithOverSpeed extends ffi.Struct {
  @ffi.Double()
  external double overSpeed;

}
// MARK: - SimulationAutoWithOverSpeed <-> _CSimulationAutoWithOverSpeed

extension _CSimulationAutoWithOverSpeedToDart on _CSimulationAutoWithOverSpeed {
  SimulationAutoWithOverSpeed _toDart() {
    return SimulationAutoWithOverSpeed(
      this.overSpeed
    );
  }
}

extension _DartTo_CSimulationAutoWithOverSpeed on SimulationAutoWithOverSpeed {
  _CSimulationAutoWithOverSpeed _copyFromDartTo_CSimulationAutoWithOverSpeed() {
    final res = _CSimulationAutoWithOverSpeedMakeDefault();
    res.overSpeed = this.overSpeed;
    return res;
  }
}
extension _CSimulationAutoWithOverSpeedRelease on _CSimulationAutoWithOverSpeed {
  void _releaseIntermediate() {
  }
}

// MARK: - SimulationSpeedMode

final class SimulationSpeedMode {
  final Object? _value;
  final int _index;

  SimulationSpeedMode._raw(this._value, this._index);

  SimulationSpeedMode.speed(SimulationConstantSpeed value) : this._raw(value, 0);
  SimulationSpeedMode.overSpeed(SimulationAutoWithOverSpeed value) : this._raw(value, 1);

  bool get isSpeed => this._index == 0;
  SimulationConstantSpeed? get asSpeed => this.isSpeed ? this._value as SimulationConstantSpeed : null;

  bool get isOverSpeed => this._index == 1;
  SimulationAutoWithOverSpeed? get asOverSpeed => this.isOverSpeed ? this._value as SimulationAutoWithOverSpeed : null;

  T match<T>({
    required T Function(SimulationConstantSpeed value) speed,
    required T Function(SimulationAutoWithOverSpeed value) overSpeed,
  }) {
    return switch (this._index) {
      0 => speed(this._value as SimulationConstantSpeed),
      1 => overSpeed(this._value as SimulationAutoWithOverSpeed),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "SimulationSpeedMode(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SimulationSpeedMode &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CSimulationSpeedModeImpl extends ffi.Union {
  external _CSimulationConstantSpeed _speed;
  external _CSimulationAutoWithOverSpeed _overSpeed;
}

final class _CSimulationSpeedMode extends ffi.Struct {
  external _CSimulationSpeedModeImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CSimulationSpeedModeBasicFunctions on _CSimulationSpeedMode {
  void _releaseIntermediate() {
    _CSimulationSpeedMode_release(this);
  }
}
	
// MARK: - SimulationSpeedMode <-> CSimulationSpeedMode

extension _CSimulationSpeedModeToDart on _CSimulationSpeedMode {
  SimulationSpeedMode _toDart() {
    return switch (this._index) {
      0 => SimulationSpeedMode.speed(this._impl._speed._toDart()),
      1 => SimulationSpeedMode.overSpeed(this._impl._overSpeed._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CSimulationSpeedMode on SimulationSpeedMode {
  _CSimulationSpeedMode _copyFromDartTo_CSimulationSpeedMode() {
    var res = _CSimulationSpeedModeMakeDefault();
    this.match<void>(
      speed: (SimulationConstantSpeed value) {
        res._impl._speed = value._copyFromDartTo_CSimulationConstantSpeed();
        res._index = 0;
      },
      overSpeed: (SimulationAutoWithOverSpeed value) {
        res._impl._overSpeed = value._copyFromDartTo_CSimulationAutoWithOverSpeed();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - SimulationSettings

/** Настройки симуляции ведения по маршруту. */
class SimulationSettings implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Режим работы симулятора. */
  SimulationSpeedMode get speedMode {
    _CSimulationSpeedMode res = _CSimulationSettings_speedMode(_CSimulationSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set speedMode(SimulationSpeedMode mode) {
    var _a1 = mode._copyFromDartTo_CSimulationSpeedMode();
    void res = _CSimulationSettings_setSpeedMode_CSimulationSpeedMode(_CSimulationSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSimulationSettings_releasePtr);

  SimulationSettings._raw(this._self);
  factory SimulationSettings._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SimulationSettings._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SimulationSettings &&
    other.runtimeType == runtimeType &&
    _CSimulationSettings_cg_objectIdentifier(this._self) == _CSimulationSettings_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSimulationSettings_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SimulationSettings <-> CSimulationSettings

final class _CSimulationSettings extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSimulationSettingsBasicFunctions on _CSimulationSettings {
  void _releaseIntermediate() {
    _CSimulationSettings_release(_impl);
  }

  _CSimulationSettings _retain() {
    return _CSimulationSettings_retain(_impl);
  }
}

extension _CSimulationSettingsToDart on _CSimulationSettings {
  SimulationSettings _toDart() {
    return SimulationSettings._create(_retain()._impl);
  }
}


extension _DartToCSimulationSettings on SimulationSettings {
  _CSimulationSettings _copyFromDartTo_CSimulationSettings() {
    return (_CSimulationSettingsMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - NavigationVoice

/** Голос для использования в навигаторе. */
class NavigationVoice implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CNavigationVoice_releasePtr);

  NavigationVoice._raw(this._self);
  factory NavigationVoice._create(ffi.Pointer<ffi.Void> self) {
    final classObject = NavigationVoice._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is NavigationVoice &&
    other.runtimeType == runtimeType &&
    _CNavigationVoice_cg_objectIdentifier(this._self) == _CNavigationVoice_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CNavigationVoice_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - NavigationVoice <-> CNavigationVoice

final class _CNavigationVoice extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CNavigationVoiceBasicFunctions on _CNavigationVoice {
  void _releaseIntermediate() {
    _CNavigationVoice_release(_impl);
  }

  _CNavigationVoice _retain() {
    return _CNavigationVoice_retain(_impl);
  }
}

extension _CNavigationVoiceToDart on _CNavigationVoice {
  NavigationVoice _toDart() {
    return NavigationVoice._create(_retain()._impl);
  }
}


extension _DartToCNavigationVoice on NavigationVoice {
  _CNavigationVoice _copyFromDartTo_CNavigationVoice() {
    return (_CNavigationVoiceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - VoiceSelector

/** Управляет голосовыми пакетами в текущей сессии навигатора. */
class VoiceSelector implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Голосовой пакет, с помощью которого воспроизводятся голосовые оповещения в текущей сессии навигатора. */
  NavigationVoice? get voice {
    _COptional_CNavigationVoice res = _CVoiceSelector_voice(_CVoiceSelectorMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set voice(NavigationVoice? voice) {
    var _a1 = voice._copyFromDartTo_COptional_CNavigationVoice();
    void res = _CVoiceSelector_setVoice_COptional_CNavigationVoice(_CVoiceSelectorMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CVoiceSelector_releasePtr);

  VoiceSelector._raw(this._self);
  factory VoiceSelector._create(ffi.Pointer<ffi.Void> self) {
    final classObject = VoiceSelector._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is VoiceSelector &&
    other.runtimeType == runtimeType &&
    _CVoiceSelector_cg_objectIdentifier(this._self) == _CVoiceSelector_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CVoiceSelector_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - VoiceSelector <-> CVoiceSelector

final class _CVoiceSelector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CVoiceSelectorBasicFunctions on _CVoiceSelector {
  void _releaseIntermediate() {
    _CVoiceSelector_release(_impl);
  }

  _CVoiceSelector _retain() {
    return _CVoiceSelector_retain(_impl);
  }
}

extension _CVoiceSelectorToDart on _CVoiceSelector {
  VoiceSelector _toDart() {
    return VoiceSelector._create(_retain()._impl);
  }
}


extension _DartToCVoiceSelector on VoiceSelector {
  _CVoiceSelector _copyFromDartTo_CVoiceSelector() {
    return (_CVoiceSelectorMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - NavigationVoice? <-> _COptional_CNavigationVoice

final class _COptional_CNavigationVoice extends ffi.Struct {
  
  external _CNavigationVoice value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CNavigationVoiceBasicFunctions on _COptional_CNavigationVoice {
  void _releaseIntermediate() {
    _COptional_CNavigationVoice_release(this);
  }
}

extension _COptional_CNavigationVoiceToDart on _COptional_CNavigationVoice {
  NavigationVoice? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CNavigationVoice on NavigationVoice? {
  _COptional_CNavigationVoice _copyFromDartTo_COptional_CNavigationVoice() {
    final cOptional = _COptional_CNavigationVoiceMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CNavigationVoice();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ExceedSpeedLimitSettings

/** Настройки обнаружения превышения максимальной разрешённой скорости. */
class ExceedSpeedLimitSettings implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Включение/выключение детектирования превышения максимальной разрешённой скорости. */
  bool get exceedSpeedNotificationEnabled {
    bool res = _CExceedSpeedLimitSettings_exceedSpeedNotificationEnabled(_CExceedSpeedLimitSettingsMakeDefault().._impl=_self);
    return res;
  }
  set exceedSpeedNotificationEnabled(bool enabled) {
    void res = _CExceedSpeedLimitSettings_setExceedSpeedNotificationEnabled_bool(_CExceedSpeedLimitSettingsMakeDefault().._impl=_self, enabled);
    return res;
  }
  /** Разрешённое превышение скорости в м/с, по умолчанию равно 0. */
  double get allowableSpeedExcess {
    double res = _CExceedSpeedLimitSettings_allowableSpeedExcess(_CExceedSpeedLimitSettingsMakeDefault().._impl=_self);
    return res;
  }
  set allowableSpeedExcess(double excess) {
    void res = _CExceedSpeedLimitSettings_setAllowableSpeedExcess_float(_CExceedSpeedLimitSettingsMakeDefault().._impl=_self, excess);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CExceedSpeedLimitSettings_releasePtr);

  ExceedSpeedLimitSettings._raw(this._self);
  factory ExceedSpeedLimitSettings._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ExceedSpeedLimitSettings._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ExceedSpeedLimitSettings &&
    other.runtimeType == runtimeType &&
    _CExceedSpeedLimitSettings_cg_objectIdentifier(this._self) == _CExceedSpeedLimitSettings_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CExceedSpeedLimitSettings_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ExceedSpeedLimitSettings <-> CExceedSpeedLimitSettings

final class _CExceedSpeedLimitSettings extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CExceedSpeedLimitSettingsBasicFunctions on _CExceedSpeedLimitSettings {
  void _releaseIntermediate() {
    _CExceedSpeedLimitSettings_release(_impl);
  }

  _CExceedSpeedLimitSettings _retain() {
    return _CExceedSpeedLimitSettings_retain(_impl);
  }
}

extension _CExceedSpeedLimitSettingsToDart on _CExceedSpeedLimitSettings {
  ExceedSpeedLimitSettings _toDart() {
    return ExceedSpeedLimitSettings._create(_retain()._impl);
  }
}


extension _DartToCExceedSpeedLimitSettings on ExceedSpeedLimitSettings {
  _CExceedSpeedLimitSettings _copyFromDartTo_CExceedSpeedLimitSettings() {
    return (_CExceedSpeedLimitSettingsMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DynamicRouteInfoSettings

/** Настройки получения динамических данных о маршруте. */
class DynamicRouteInfoSettings implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Периодичность, с которой должны обновляться динамические данные о маршруте. */
  Duration get updatePeriod {
    _CTimeInterval res = _CDynamicRouteInfoSettings_updatePeriod(_CDynamicRouteInfoSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set updatePeriod(Duration period) {
    var _a1 = period._copyFromDartTo_CTimeInterval();
    void res = _CDynamicRouteInfoSettings_setUpdatePeriod_CTimeInterval(_CDynamicRouteInfoSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CDynamicRouteInfoSettings_releasePtr);

  DynamicRouteInfoSettings._raw(this._self);
  factory DynamicRouteInfoSettings._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DynamicRouteInfoSettings._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DynamicRouteInfoSettings &&
    other.runtimeType == runtimeType &&
    _CDynamicRouteInfoSettings_cg_objectIdentifier(this._self) == _CDynamicRouteInfoSettings_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDynamicRouteInfoSettings_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DynamicRouteInfoSettings <-> CDynamicRouteInfoSettings

final class _CDynamicRouteInfoSettings extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDynamicRouteInfoSettingsBasicFunctions on _CDynamicRouteInfoSettings {
  void _releaseIntermediate() {
    _CDynamicRouteInfoSettings_release(_impl);
  }

  _CDynamicRouteInfoSettings _retain() {
    return _CDynamicRouteInfoSettings_retain(_impl);
  }
}

extension _CDynamicRouteInfoSettingsToDart on _CDynamicRouteInfoSettings {
  DynamicRouteInfoSettings _toDart() {
    return DynamicRouteInfoSettings._create(_retain()._impl);
  }
}


extension _DartToCDynamicRouteInfoSettings on DynamicRouteInfoSettings {
  _CDynamicRouteInfoSettings _copyFromDartTo_CDynamicRouteInfoSettings() {
    return (_CDynamicRouteInfoSettingsMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SoundCategory

/** Категории звуковых оповещений. */
enum SoundCategory {
  /** Камеры контроля перекрёстка. */
  crossroadCameras(1),
  /** Камеры, фиксирующие движение по выделенной полосе для общественного транспорта. */
  laneCameras(4),
  /** Камеры контроля остановки. */
  noStoppingControlCameras(8),
  /** Камеры контроля разметки. */
  roadMarkingCameras(16),
  /** Камеры контроля средней скорости. */
  averageSpeedCameras(32),
  /** Камеры контроля мгновенной скорости. */
  maxSpeedCameras(64),
  /** Аварии. */
  accidents(128),
  /** Дорожные работы. */
  roadWorks(256),
  /** Платные дороги. */
  tolls(512),
  /** Превышения максимально разрешённой скорости. */
  exceedSpeedLimits(1024),
  /** Промежуточные точки на маршруте. */
  intermediatePoints(2048),
  /** Маршрут перестроен. */
  routeRebuild(4096),
  /** Инструкции (манёвры) на маршруте. */
  instructions(8192),
  /** Препятствия. */
  obstacles(16384),
  /** Подтипы дорог. */
  roadSubtypes(32768),
  /** Потерян сигнал GPS. */
  lostLocation(65536),
  /** Завершение маршрута. */
  routeEnd(131072),
  ;

  const SoundCategory(this.rawValue);
  final int rawValue;

  static SoundCategory getByValue(int value) {
    return SoundCategory.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSoundCategory extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSoundCategoryBasicFunctions on _CSoundCategory {
  void _releaseIntermediate() {
  }
}

extension _CSoundCategoryToDart on _CSoundCategory {
  SoundCategory _toDart() {
    return SoundCategory.getByValue(this.rawValue);
  }
}

extension _DartTo_CSoundCategory on SoundCategory {
  _CSoundCategory _copyFromDartTo_CSoundCategory() {
    return _CSoundCategoryMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SoundNotificationSettings

/**
 Настройки звуковых оповещений в навигаторе
 По умолчанию все значения категорий звуков оповещений включены. Пользователь может
 менять значения во время работы с навигатором.
*/
class SoundNotificationSettings implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Набор флагов для звуковых оповещений. */
  SoundCategoryEnumSet get enabledSoundCategories {
    _COptionSet_CSoundCategory res = _CSoundNotificationSettings_enabledSoundCategories(_CSoundNotificationSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set enabledSoundCategories(SoundCategoryEnumSet soundCategories) {
    var _a1 = soundCategories._copyFromDartTo_COptionSet_CSoundCategory();
    void res = _CSoundNotificationSettings_setEnabledSoundCategories_COptionSet_CSoundCategory(_CSoundNotificationSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSoundNotificationSettings_releasePtr);

  SoundNotificationSettings._raw(this._self);
  factory SoundNotificationSettings._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SoundNotificationSettings._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SoundNotificationSettings &&
    other.runtimeType == runtimeType &&
    _CSoundNotificationSettings_cg_objectIdentifier(this._self) == _CSoundNotificationSettings_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSoundNotificationSettings_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SoundNotificationSettings <-> CSoundNotificationSettings

final class _CSoundNotificationSettings extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSoundNotificationSettingsBasicFunctions on _CSoundNotificationSettings {
  void _releaseIntermediate() {
    _CSoundNotificationSettings_release(_impl);
  }

  _CSoundNotificationSettings _retain() {
    return _CSoundNotificationSettings_retain(_impl);
  }
}

extension _CSoundNotificationSettingsToDart on _CSoundNotificationSettings {
  SoundNotificationSettings _toDart() {
    return SoundNotificationSettings._create(_retain()._impl);
  }
}


extension _DartToCSoundNotificationSettings on SoundNotificationSettings {
  _CSoundNotificationSettings _copyFromDartTo_CSoundNotificationSettings() {
    return (_CSoundNotificationSettingsMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SoundCategoryEnumSet

class SoundCategoryEnumSet extends EnumSet<SoundCategory> {
  SoundCategoryEnumSet() : super();

  factory SoundCategoryEnumSet.fromRawValue(int rawValue) {
    SoundCategoryEnumSet enumSet = SoundCategoryEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory SoundCategoryEnumSet.of(Iterable<SoundCategory> elements) {
    SoundCategoryEnumSet enumSet = SoundCategoryEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory SoundCategoryEnumSet.all() {
    SoundCategoryEnumSet enumSet = SoundCategoryEnumSet();
    enumSet.addAll(SoundCategory.values);
    return enumSet;
  }

  @override
  bool contains(SoundCategory value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<SoundCategory> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(SoundCategory value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<SoundCategory> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(SoundCategory value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<SoundCategory> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<SoundCategory> intersection(EnumSet<SoundCategory> other) =>
      SoundCategoryEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<SoundCategory> union(EnumSet<SoundCategory> other) =>
      SoundCategoryEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<SoundCategory> difference(EnumSet<SoundCategory> other) =>
      SoundCategoryEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<SoundCategory> toSet() {
    Set<SoundCategory> result = {};
    SoundCategory.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    SoundCategory.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CSoundCategory extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CSoundCategoryBasicFunctions on _COptionSet_CSoundCategory {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CSoundCategoryToDart on _COptionSet_CSoundCategory {
  SoundCategoryEnumSet _toDart() {
    return SoundCategoryEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CSoundCategory on SoundCategoryEnumSet {
  _COptionSet_CSoundCategory _copyFromDartTo_COptionSet_CSoundCategory() {
    return _COptionSet_CSoundCategoryMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - FreeRoamSettings

class FreeRoamSettings implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Тайлы дорожного графа загружаются в http-кэш во время ведения по маршруту,
   если они соответствуют участку маршрута от текущей позиции до указанного расстояния.
   Значение по умолчанию - 5 км.
  
   - Note: Загрузка тайлов в http-кэш не выполняется, если параметр соответствует нулевому или отрицательному расстоянию.
  */
  RouteDistance get onRoutePrefetchLength {
    _CRouteDistance res = _CFreeRoamSettings_onRoutePrefetchLength(_CFreeRoamSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set onRoutePrefetchLength(RouteDistance length) {
    var _a1 = length._copyFromDartTo_CRouteDistance();
    void res = _CFreeRoamSettings_setOnRoutePrefetchLength_CRouteDistance(_CFreeRoamSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   При кэшировании тайлов дорожного графа во время ведения по маршруту тайлы
   загружаются в http-кэш, если оказываются ближе заданного расстояния в метрах
   от линии маршрута.
   Значение по умолчанию - 1 км.
  
   - Note: Загрузка тайлов в http-кэш не выполняется, если параметр соответствует нулевому или отрицательному расстоянию.
  */
  double get onRoutePrefetchRadiusMeters {
    double res = _CFreeRoamSettings_onRoutePrefetchRadiusMeters(_CFreeRoamSettingsMakeDefault().._impl=_self);
    return res;
  }
  set onRoutePrefetchRadiusMeters(double radius) {
    void res = _CFreeRoamSettings_setOnRoutePrefetchRadiusMeters_double(_CFreeRoamSettingsMakeDefault().._impl=_self, radius);
    return res;
  }
  /**
   Тайлы дорожного графа загружаются в http-кэш если оказываются ближе заданного расстояния в метрах от текущей
   позиции.
   Значение по умолчанию - 2 км.
  
   - Note: Загрузка тайлов в http-кэш не выполняется, если параметр соответствует нулевому или отрицательному расстоянию.
  */
  double get prefetchRadiusMeters {
    double res = _CFreeRoamSettings_prefetchRadiusMeters(_CFreeRoamSettingsMakeDefault().._impl=_self);
    return res;
  }
  set prefetchRadiusMeters(double radius) {
    void res = _CFreeRoamSettings_setPrefetchRadiusMeters_double(_CFreeRoamSettingsMakeDefault().._impl=_self, radius);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CFreeRoamSettings_releasePtr);

  FreeRoamSettings._raw(this._self);
  factory FreeRoamSettings._create(ffi.Pointer<ffi.Void> self) {
    final classObject = FreeRoamSettings._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FreeRoamSettings &&
    other.runtimeType == runtimeType &&
    _CFreeRoamSettings_cg_objectIdentifier(this._self) == _CFreeRoamSettings_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CFreeRoamSettings_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - FreeRoamSettings <-> CFreeRoamSettings

final class _CFreeRoamSettings extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CFreeRoamSettingsBasicFunctions on _CFreeRoamSettings {
  void _releaseIntermediate() {
    _CFreeRoamSettings_release(_impl);
  }

  _CFreeRoamSettings _retain() {
    return _CFreeRoamSettings_retain(_impl);
  }
}

extension _CFreeRoamSettingsToDart on _CFreeRoamSettings {
  FreeRoamSettings _toDart() {
    return FreeRoamSettings._create(_retain()._impl);
  }
}


extension _DartToCFreeRoamSettings on FreeRoamSettings {
  _CFreeRoamSettings _copyFromDartTo_CFreeRoamSettings() {
    return (_CFreeRoamSettingsMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RouterType

/** Тип поисковика маршрута. */
enum RouterType {
  /** Онлайн поисковик маршрута. */
  online(0),
  /** Оффлайн поисковик маршрута. */
  offline(1),
  /** Гибридный онлайн/оффлайн поисковик маршрута. */
  hybrid(2),
  ;

  const RouterType(this.rawValue);
  final int rawValue;

  static RouterType getByValue(int value) {
    return RouterType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRouterType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRouterTypeBasicFunctions on _CRouterType {
  void _releaseIntermediate() {
  }
}

extension _CRouterTypeToDart on _CRouterType {
  RouterType _toDart() {
    return RouterType.getByValue(this.rawValue);
  }
}

extension _DartTo_CRouterType on RouterType {
  _CRouterType _copyFromDartTo_CRouterType() {
    return _CRouterTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - AlternativeRoutesProviderSettings

/** Настройки поиска альтернативных маршрутов и маршрута лучше. */
class AlternativeRoutesProviderSettings implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Флаг включения/выключения предложения альтернативных маршрутов. По умолчанию
   предложение альтернативных маршрутов включено.
  */
  bool get alternativeRoutesEnabled {
    bool res = _CAlternativeRoutesProviderSettings_alternativeRoutesEnabled(_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self);
    return res;
  }
  set alternativeRoutesEnabled(bool enabled) {
    void res = _CAlternativeRoutesProviderSettings_setAlternativeRoutesEnabled_bool(_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self, enabled);
    return res;
  }
  /**
   Флаг включения/выключения предложения маршрута лучше. По умолчанию предложение
   маршрута лучше включено.
  */
  bool get betterRouteEnabled {
    bool res = _CAlternativeRoutesProviderSettings_betterRouteEnabled(_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self);
    return res;
  }
  set betterRouteEnabled(bool enabled) {
    void res = _CAlternativeRoutesProviderSettings_setBetterRouteEnabled_bool(_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self, enabled);
    return res;
  }
  /**
   Задержка перед поиском альтернативных маршрутов при старте поездки по маршруту или после
   перехода на какой-либо другой маршрут. Должна быть не меньше 5 секунд. По умолчанию 20 секунд.
  */
  Duration get routeSearchDelay {
    _CTimeInterval res = _CAlternativeRoutesProviderSettings_routeSearchDelay(_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set routeSearchDelay(Duration delay) {
    var _a1 = delay._copyFromDartTo_CTimeInterval();
    void res = _CAlternativeRoutesProviderSettings_setRouteSearchDelay_CTimeInterval(_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Минимальная разница во времени движения между исходным маршрутом и альтернативным
   маршрутом, при которой альтернативный маршрут считается маршрутом лучше.
  */
  Duration get betterRouteTimeCostThreshold {
    _CTimeInterval res = _CAlternativeRoutesProviderSettings_betterRouteTimeCostThreshold(_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set betterRouteTimeCostThreshold(Duration threshold) {
    var _a1 = threshold._copyFromDartTo_CTimeInterval();
    void res = _CAlternativeRoutesProviderSettings_setBetterRouteTimeCostThreshold_CTimeInterval(_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Минимальная суммарная длина рёбер маршрута, которые отличаются между исходным маршрутом
   и альтернативным маршрутом, при которой альтернативный маршрут считается маршрутом лучше.
  */
  RouteDistance get betterRouteLengthThreshold {
    _CRouteDistance res = _CAlternativeRoutesProviderSettings_betterRouteLengthThreshold(_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set betterRouteLengthThreshold(RouteDistance threshold) {
    var _a1 = threshold._copyFromDartTo_CRouteDistance();
    void res = _CAlternativeRoutesProviderSettings_setBetterRouteLengthThreshold_CRouteDistance(_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Тип поисковика для поиска альтернативных маршрутов. */
  RouterType get routerType {
    _CRouterType res = _CAlternativeRoutesProviderSettings_routerType(_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set routerType(RouterType routerType) {
    var _a1 = routerType._copyFromDartTo_CRouterType();
    void res = _CAlternativeRoutesProviderSettings_setRouterType_CRouterType(_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CAlternativeRoutesProviderSettings_releasePtr);

  AlternativeRoutesProviderSettings._raw(this._self);
  factory AlternativeRoutesProviderSettings._create(ffi.Pointer<ffi.Void> self) {
    final classObject = AlternativeRoutesProviderSettings._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AlternativeRoutesProviderSettings &&
    other.runtimeType == runtimeType &&
    _CAlternativeRoutesProviderSettings_cg_objectIdentifier(this._self) == _CAlternativeRoutesProviderSettings_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CAlternativeRoutesProviderSettings_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - AlternativeRoutesProviderSettings <-> CAlternativeRoutesProviderSettings

final class _CAlternativeRoutesProviderSettings extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CAlternativeRoutesProviderSettingsBasicFunctions on _CAlternativeRoutesProviderSettings {
  void _releaseIntermediate() {
    _CAlternativeRoutesProviderSettings_release(_impl);
  }

  _CAlternativeRoutesProviderSettings _retain() {
    return _CAlternativeRoutesProviderSettings_retain(_impl);
  }
}

extension _CAlternativeRoutesProviderSettingsToDart on _CAlternativeRoutesProviderSettings {
  AlternativeRoutesProviderSettings _toDart() {
    return AlternativeRoutesProviderSettings._create(_retain()._impl);
  }
}


extension _DartToCAlternativeRoutesProviderSettings on AlternativeRoutesProviderSettings {
  _CAlternativeRoutesProviderSettings _copyFromDartTo_CAlternativeRoutesProviderSettings() {
    return (_CAlternativeRoutesProviderSettingsMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - AlternativeRouteSelector

/** Выбор альтернативного маршрута. */
class AlternativeRouteSelector implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CAlternativeRouteSelector_releasePtr);

  AlternativeRouteSelector._raw(this._self);
  factory AlternativeRouteSelector._create(ffi.Pointer<ffi.Void> self) {
    final classObject = AlternativeRouteSelector._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AlternativeRouteSelector &&
    other.runtimeType == runtimeType &&
    _CAlternativeRouteSelector_cg_objectIdentifier(this._self) == _CAlternativeRouteSelector_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CAlternativeRouteSelector_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: AlternativeRouteSelector: Methods

  /**
   Выбор альтернативного маршрута.
   Если переданный маршрут не соответствует одному из актуальных альтернативных маршрутов,
   ничего не происходит. В противном случае соответствующий альтернативный маршрут
   становится текущим активным маршрутом.
  
   - Parameter trafficRoute: Альтернативный маршрут, который должен быть выбран
   в качестве текущего активного маршрута.
  */
  void selectAlternativeRoute(
    TrafficRoute trafficRoute
  )  {
    var _a1 = trafficRoute._copyFromDartTo_CTrafficRoute();
    void res = _CAlternativeRouteSelector_selectAlternativeRoute_CTrafficRoute(_CAlternativeRouteSelectorMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - AlternativeRouteSelector <-> CAlternativeRouteSelector

final class _CAlternativeRouteSelector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CAlternativeRouteSelectorBasicFunctions on _CAlternativeRouteSelector {
  void _releaseIntermediate() {
    _CAlternativeRouteSelector_release(_impl);
  }

  _CAlternativeRouteSelector _retain() {
    return _CAlternativeRouteSelector_retain(_impl);
  }
}

extension _CAlternativeRouteSelectorToDart on _CAlternativeRouteSelector {
  AlternativeRouteSelector _toDart() {
    return AlternativeRouteSelector._create(_retain()._impl);
  }
}


extension _DartToCAlternativeRouteSelector on AlternativeRouteSelector {
  _CAlternativeRouteSelector _copyFromDartTo_CAlternativeRouteSelector() {
    return (_CAlternativeRouteSelectorMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MyLocationMapObjectSourceProvider

/** Провайдер, предоставляющий источник маркера геопозиции. */
class MyLocationMapObjectSourceProvider implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Источник, содержащий маркер геопозиции. */
  MyLocationMapObjectSource get myLocationMapObjectSource {
    _CMyLocationMapObjectSource res = _CMyLocationMapObjectSourceProvider_myLocationMapObjectSource(_CMyLocationMapObjectSourceProviderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMyLocationMapObjectSourceProvider_releasePtr);

  MyLocationMapObjectSourceProvider._raw(this._self);
  factory MyLocationMapObjectSourceProvider._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MyLocationMapObjectSourceProvider._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MyLocationMapObjectSourceProvider &&
    other.runtimeType == runtimeType &&
    _CMyLocationMapObjectSourceProvider_cg_objectIdentifier(this._self) == _CMyLocationMapObjectSourceProvider_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMyLocationMapObjectSourceProvider_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MyLocationMapObjectSourceProvider <-> CMyLocationMapObjectSourceProvider

final class _CMyLocationMapObjectSourceProvider extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMyLocationMapObjectSourceProviderBasicFunctions on _CMyLocationMapObjectSourceProvider {
  void _releaseIntermediate() {
    _CMyLocationMapObjectSourceProvider_release(_impl);
  }

  _CMyLocationMapObjectSourceProvider _retain() {
    return _CMyLocationMapObjectSourceProvider_retain(_impl);
  }
}

extension _CMyLocationMapObjectSourceProviderToDart on _CMyLocationMapObjectSourceProvider {
  MyLocationMapObjectSourceProvider _toDart() {
    return MyLocationMapObjectSourceProvider._create(_retain()._impl);
  }
}


extension _DartToCMyLocationMapObjectSourceProvider on MyLocationMapObjectSourceProvider {
  _CMyLocationMapObjectSourceProvider _copyFromDartTo_CMyLocationMapObjectSourceProvider() {
    return (_CMyLocationMapObjectSourceProviderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RouteRebuilder

/** Контроллер поиска нового маршрута при сходе с текущего маршрута. */
class RouteRebuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  bool get enabled {
    bool res = _CRouteRebuilder_enabled(_CRouteRebuilderMakeDefault().._impl=_self);
    return res;
  }
  set enabled(bool enable) {
    void res = _CRouteRebuilder_setEnabled_bool(_CRouteRebuilderMakeDefault().._impl=_self, enable);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRouteRebuilder_releasePtr);

  RouteRebuilder._raw(this._self);
  factory RouteRebuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RouteRebuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RouteRebuilder &&
    other.runtimeType == runtimeType &&
    _CRouteRebuilder_cg_objectIdentifier(this._self) == _CRouteRebuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRouteRebuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - RouteRebuilder <-> CRouteRebuilder

final class _CRouteRebuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRouteRebuilderBasicFunctions on _CRouteRebuilder {
  void _releaseIntermediate() {
    _CRouteRebuilder_release(_impl);
  }

  _CRouteRebuilder _retain() {
    return _CRouteRebuilder_retain(_impl);
  }
}

extension _CRouteRebuilderToDart on _CRouteRebuilder {
  RouteRebuilder _toDart() {
    return RouteRebuilder._create(_retain()._impl);
  }
}


extension _DartToCRouteRebuilder on RouteRebuilder {
  _CRouteRebuilder _copyFromDartTo_CRouteRebuilder() {
    return (_CRouteRebuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - FreeRoamSelector

/** Контроллер перевода навигатора в режим FreeRoam при слишком долгом перестроении маршрута. */
class FreeRoamSelector implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  bool get enabled {
    bool res = _CFreeRoamSelector_enabled(_CFreeRoamSelectorMakeDefault().._impl=_self);
    return res;
  }
  set enabled(bool enable) {
    void res = _CFreeRoamSelector_setEnabled_bool(_CFreeRoamSelectorMakeDefault().._impl=_self, enable);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CFreeRoamSelector_releasePtr);

  FreeRoamSelector._raw(this._self);
  factory FreeRoamSelector._create(ffi.Pointer<ffi.Void> self) {
    final classObject = FreeRoamSelector._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FreeRoamSelector &&
    other.runtimeType == runtimeType &&
    _CFreeRoamSelector_cg_objectIdentifier(this._self) == _CFreeRoamSelector_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CFreeRoamSelector_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - FreeRoamSelector <-> CFreeRoamSelector

final class _CFreeRoamSelector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CFreeRoamSelectorBasicFunctions on _CFreeRoamSelector {
  void _releaseIntermediate() {
    _CFreeRoamSelector_release(_impl);
  }

  _CFreeRoamSelector _retain() {
    return _CFreeRoamSelector_retain(_impl);
  }
}

extension _CFreeRoamSelectorToDart on _CFreeRoamSelector {
  FreeRoamSelector _toDart() {
    return FreeRoamSelector._create(_retain()._impl);
  }
}


extension _DartToCFreeRoamSelector on FreeRoamSelector {
  _CFreeRoamSelector _copyFromDartTo_CFreeRoamSelector() {
    return (_CFreeRoamSelectorMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - NavigationManager

/** Корневой публичный интерфейс навигатора. */
class NavigationManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Модель навигатора, предназначенная для отображения в UI. */
  Model get uiModel {
    _CModel res = _CNavigationManager_uiModel(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Навигация внутри помещений. */
  IndoorDetector get indoorDetector {
    _CIndoorDetector res = _CNavigationManager_indoorDetector(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Управление автоматическим возвратом карты к слежению за маркером геопозиции. */
  NavigationFollowController get mapFollowController {
    _CNavigationFollowController res = _CNavigationManager_mapFollowController(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Контроллер для управления позиционированием карты в навигаторе. */
  MapLocationController get mapLocationController {
    _CMapLocationController res = _CNavigationManager_mapLocationController(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Менеджер карт навигатора. */
  MapManager get mapManager {
    _CMapManager res = _CNavigationManager_mapManager(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Настройки масштабирования карты во время режима ведения. */
  ZoomFollowSettings get zoomFollowSettings {
    _CZoomFollowSettings res = _CNavigationManager_zoomFollowSettings(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Настройки отображения маршрута на карте. */
  RouteMapSettings get routeMapSettings {
    _CRouteMapSettings res = _CNavigationManager_routeMapSettings(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Настройки источника, используемого для отображения маршрута на карте. */
  RouteSourceSettings get routeSourceSettings {
    _CRouteSourceSettings res = _CNavigationManager_routeSourceSettings(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Провайдер объектов маршрутов на карте. */
  RouteMapObjectsProvider get routeMapObjectsProvider {
    _CRouteMapObjectsProvider res = _CNavigationManager_routeMapObjectsProvider(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Настройки симуляции ведения по маршруту. */
  SimulationSettings get simulationSettings {
    _CSimulationSettings res = _CNavigationManager_simulationSettings(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Управление голосовыми пакетами в текущей сессии навигатора. */
  VoiceSelector get voiceSelector {
    _CVoiceSelector res = _CNavigationManager_voiceSelector(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Настройки детектирования превышения скорости. */
  ExceedSpeedLimitSettings get exceedSpeedLimitSettings {
    _CExceedSpeedLimitSettings res = _CNavigationManager_exceedSpeedLimitSettings(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Настройки получения и обновления динамических данных о маршруте. */
  DynamicRouteInfoSettings get dynamicRouteInfoSettings {
    _CDynamicRouteInfoSettings res = _CNavigationManager_dynamicRouteInfoSettings(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Настройки звуковых оповещений в текущей сессии навигатора. */
  SoundNotificationSettings get soundNotificationSettings {
    _CSoundNotificationSettings res = _CNavigationManager_soundNotificationSettings(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Настройки ведения без маршрута в режиме free roam. */
  FreeRoamSettings get freeRoamSettings {
    _CFreeRoamSettings res = _CNavigationManager_freeRoamSettings(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Настройки поиска альтернативных маршрутов в режиме ведения. */
  AlternativeRoutesProviderSettings get alternativeRoutesProviderSettings {
    _CAlternativeRoutesProviderSettings res = _CNavigationManager_alternativeRoutesProviderSettings(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Выбор альтернативного маршрута. */
  AlternativeRouteSelector get alternativeRouteSelector {
    _CAlternativeRouteSelector res = _CNavigationManager_alternativeRouteSelector(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Провайдер, предоставляющий источник маркера геопозиции. */
  MyLocationMapObjectSourceProvider get myLocationMapObjectSourceProvider {
    _CMyLocationMapObjectSourceProvider res = _CNavigationManager_myLocationMapObjectSourceProvider(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Контроллер поиска нового маршрута при сходе с текущего маршрута. */
  RouteRebuilder get routeRebuilder {
    _CRouteRebuilder res = _CNavigationManager_routeRebuilder(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Контроллер перевода навигатора в режим FreeRoam при слишком долгом перестроении маршрута. */
  FreeRoamSelector get freeRoamSelector {
    _CFreeRoamSelector res = _CNavigationManager_freeRoamSelector(_CNavigationManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CNavigationManager_releasePtr);

  NavigationManager._raw(this._self);
  factory NavigationManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = NavigationManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Точка входа в API навигатора, используемая в SDK по умолчанию.
  
   - Returns: Объект менеджера навигатора.
   - Throws: Exception В случае ошибки в параметрах.
   - Throws: Exception В случае, если объект создать не удалось.
  */
  factory NavigationManager(
    Context platformContext
  ) {
    var _a0 = platformContext._copyFromDartTo_CContext();
    _CResult_CNavigationManager res = _CNavigationManager_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return NavigationManager._create(res._toCDart()._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is NavigationManager &&
    other.runtimeType == runtimeType &&
    _CNavigationManager_cg_objectIdentifier(this._self) == _CNavigationManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CNavigationManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: NavigationManager: Methods

  /**
   Запускает ведение в режиме без маршрута (free roam).
   В этом режиме маршрут отсутствует, а навигатор сообщает об объектах,
   находящихся на дороге рядом с пользователем.
  
   - Throws: NotAllowed если отсутствует лицензия на запуск навигатора.
  */
  void startFreeRoam()  {
    _CResult_CEmpty res = _CNavigationManager_startFreeRoam(_CNavigationManagerMakeDefault().._impl=_self);
    res._toDart();
    res._releaseIntermediate();
  }

  /**
   Запускает ведение по маршруту.
  
   - Parameter routeBuildOptions: Параметры, с которыми навигатор будет перестраивать маршрут.
   - Parameter trafficRoute: Маршрут, по которому запускается ведение.
   Если значение не задано, то навигатор построит маршрут от текущей геопозиции.
   - Throws: NotAllowed если отсутствует лицензия на запуск навигатора.
   - Throws: NotSupported если делается попытка запустить ведение по маршруту на общественном транспорте.
  */
  void start(
    RouteBuildOptions routeBuildOptions,
    [TrafficRoute? trafficRoute = null
    ])  {
    var _a1 = routeBuildOptions._copyFromDartTo_CRouteBuildOptions();
    var _a2 = trafficRoute._copyFromDartTo_COptional_CTrafficRoute();
    _CResult_CEmpty res = _CNavigationManager_start_CRouteBuildOptions_COptional_CTrafficRoute(_CNavigationManagerMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    res._toDart();
    res._releaseIntermediate();
  }

  /**
   Запускает симуляцию ведения по маршруту.
  
   - Parameter routeBuildOptions: Параметры, с которыми навигатор будет перестраивать маршрут.
   - Parameter trafficRoute: Маршрут, по которому запускается симуляция.
   - Throws: NotAllowed если отсутствует лицензия на запуск навигатора.
   - Throws: NotSupported если делается попытка запустить симуляцию ведения по маршруту на общественном транспорте.
  */
  void startSimulation(
    RouteBuildOptions routeBuildOptions,
    TrafficRoute trafficRoute
  )  {
    var _a1 = routeBuildOptions._copyFromDartTo_CRouteBuildOptions();
    var _a2 = trafficRoute._copyFromDartTo_CTrafficRoute();
    _CResult_CEmpty res = _CNavigationManager_startSimulation_CRouteBuildOptions_CTrafficRoute(_CNavigationManagerMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    res._toDart();
    res._releaseIntermediate();
  }

  /** Останавливает работу навигатора. */
  void stop()  {
    void res = _CNavigationManager_stop(_CNavigationManagerMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - NavigationManager <-> CNavigationManager

final class _CNavigationManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CNavigationManagerBasicFunctions on _CNavigationManager {
  void _releaseIntermediate() {
    _CNavigationManager_release(_impl);
  }

  _CNavigationManager _retain() {
    return _CNavigationManager_retain(_impl);
  }
}

extension _CNavigationManagerToDart on _CNavigationManager {
  NavigationManager _toDart() {
    return NavigationManager._create(_retain()._impl);
  }
}


extension _DartToCNavigationManager on NavigationManager {
  _CNavigationManager _copyFromDartTo_CNavigationManager() {
    return (_CNavigationManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - TrafficRoute? <-> _COptional_CTrafficRoute

final class _COptional_CTrafficRoute extends ffi.Struct {
  
  external _CTrafficRoute value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CTrafficRouteBasicFunctions on _COptional_CTrafficRoute {
  void _releaseIntermediate() {
    _COptional_CTrafficRoute_release(this);
  }
}

extension _COptional_CTrafficRouteToDart on _COptional_CTrafficRoute {
  TrafficRoute? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CTrafficRoute on TrafficRoute? {
  _COptional_CTrafficRoute _copyFromDartTo_COptional_CTrafficRoute() {
    final cOptional = _COptional_CTrafficRouteMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CTrafficRoute();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - NavigationManager <-> _CResult_CNavigationManager

final class _CResult_CNavigationManagerImpl extends ffi.Union {
  
  external _CNavigationManager _value;
  external _CError _error;
}

final class _CResult_CNavigationManager extends ffi.Struct {
  external _CResult_CNavigationManagerImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CNavigationManagerBasicFunctions on _CResult_CNavigationManager {
  void _releaseIntermediate() {
    _CResult_CNavigationManager_release(this);
  }
}

extension _CResult_CNavigationManagerToDart on _CResult_CNavigationManager {
  NavigationManager _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CNavigationManager _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - InstructionManeuver

/** Манёвр, который необходимо совершить для движения по маршруту. */
enum InstructionManeuver {
  /** Отсутствие манёвра. */
  none(0),
  /** Начало движения. */
  start(1),
  /** Окончание движения. */
  finish(2),
  /** Движение через перекрёсток прямо. */
  crossroadStraight(3),
  /** Движение через перекрёсток слегка налево. */
  crossroadSlightlyLeft(4),
  /** Движение через перекрёсток налево. */
  crossroadLeft(5),
  /** Движение через перекрёсток круто налево. */
  crossroadSharplyLeft(6),
  /** Движение через перекрёсток слегка направо. */
  crossroadSlightlyRight(7),
  /** Движение через перекрёсток направо. */
  crossroadRight(8),
  /** Движение через перекрёсток круто направо. */
  crossroadSharplyRight(9),
  /** Движение через перекрёсток - держитесь левее. */
  crossroadKeepLeft(10),
  /** Движение через перекрёсток - держитесь правее. */
  crossroadKeepRight(11),
  /** Разворот на перекрёстке. */
  crossroadUTurn(12),
  /** Движение через перекрёсток с круговым движением прямо. */
  roundaboutForward(13),
  /** Движение через перекрёсток с круговым движением слегка налево. */
  roundaboutLeft45(14),
  /** Движение через перекрёсток с круговым движением налево. */
  roundaboutLeft90(15),
  /** Движение через перекрёсток с круговым движением круто налево. */
  roundaboutLeft135(16),
  /** Движение через перекрёсток с круговым движением слегка направо. */
  roundaboutRight45(17),
  /** Движение через перекрёсток с круговым движением направо. */
  roundaboutRight90(18),
  /** Движение через перекрёсток с круговым движением круто направо. */
  roundaboutRight135(19),
  /** Движение через перекрёсток с круговым движением в обратном направлении. */
  roundaboutBackward(20),
  /** Съезд с перекрёстка с круговым движением. */
  roundaboutExit(21),
  /** Разворот. */
  uTurn(22),
  /** Составной манёвр на перекрёстке (например, пересечение двух дорог на перекрёстке для пешеходного маршрута) */
  roadCrossing(23),
  ;

  const InstructionManeuver(this.rawValue);
  final int rawValue;

  static InstructionManeuver getByValue(int value) {
    return InstructionManeuver.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CInstructionManeuver extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CInstructionManeuverBasicFunctions on _CInstructionManeuver {
  void _releaseIntermediate() {
  }
}

extension _CInstructionManeuverToDart on _CInstructionManeuver {
  InstructionManeuver _toDart() {
    return InstructionManeuver.getByValue(this.rawValue);
  }
}

extension _DartTo_CInstructionManeuver on InstructionManeuver {
  _CInstructionManeuver _copyFromDartTo_CInstructionManeuver() {
    return _CInstructionManeuverMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - getInstructionManeuver

/** Получить манёвр, который необходимо совершить для движения по маршруту. */
InstructionManeuver getInstructionManeuver(
  ExtraInstructionInfo extraInstructionInfo
){
  var _a0 = extraInstructionInfo._copyFromDartTo_CExtraInstructionInfo();
  _CInstructionManeuver res = _CFunction_G_getInstructionManeuver_With_CExtraInstructionInfo(_a0);
  _a0._releaseIntermediate();
  return res._toDart();
}

// MARK: - getLanesControlImages

/**
 Получить список изображений для отображения в контроле полосности.
 Количество изображений (без учета разделителей и многоточий) ограничено maxCount,
 если оно превышено, изображения с одной или обеих сторон обрезаются таким образом, чтобы
 осталось как можно больше изображений активных маневров. На стороне, где произошло удаление,
 отображается многоточие.
 В случае, если параметр ignoreActiveManeuver равен true, активный манёвр будет проигнорирован,
 и будет возвращено изображение, соответствующее всем разрешенным направлениям движения.
*/
List<LanesControlImage> getLanesControlImages(
  RouteLaneSign laneSign,
  int maxCount,
  bool ignoreActiveManeuver
){
  var _a0 = laneSign._copyFromDartTo_CRouteLaneSign();
  _CArray_CLanesControlImage res = _CFunction_G_getLanesControlImages_With_CRouteLaneSign_uint32_t_bool(_a0, maxCount, ignoreActiveManeuver);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - LanesControlImage

/** Представление иконки манёвра в UI навигатора. */
enum LanesControlImage {
  /** Многоточие с левой стороны. */
  dotsLeft(0),
  /** Многоточие с правой стороны. */
  dotsRight(1),
  /** Нет подходящей иконки для отображения манёвра. */
  nonInformation(2),
  /** Разделитель. */
  separator(3),
  /** Движение запрещено, без подсветки. */
  prohibited_0(4),
  /** Движение запрещено, с подсветкой. */
  prohibited_1(5),
  /** Полоса общественного транспорта, без подсветки. */
  publicTransport_0(6),
  /** Полоса общественного транспорта, с подсветкой. */
  publicTransport_1(7),
  /** Налево, без подсветки. */
  left_0(8),
  /** Налево, с подсветкой. */
  left_1(9),
  /** Комбинированный манёвр - налево или направо, без подсветки. */
  left_Right_0_0(10),
  /** Комбинированный манёвр - налево или направо, направо подсвечено. */
  left_Right_0_1(11),
  /** Комбинированный манёвр - налево или направо, налево подсвечено. */
  left_Right_1_0(12),
  /** Комбинированный манёвр - налево или направо, оба варианта подсвечены. */
  left_Right_1_1(13),
  /** Комбинированный манёвр - налево или слегка налево, без подсветки. */
  left_SlightlyLeft_0_0(14),
  /** Комбинированный манёвр - налево или слегка налево, слегка налево подсвечено. */
  left_SlightlyLeft_0_1(15),
  /** Комбинированный манёвр - налево или слегка налево, налево подсвечено. */
  left_SlightlyLeft_1_0(16),
  /** Комбинированный манёвр - налево или слегка налево, оба варианта подсвечены. */
  left_SlightlyLeft_1_1(17),
  /** Комбинированный манёвр - налево или слегка направо, без подсветки. */
  left_SlightlyRight_0_0(18),
  /** Комбинированный манёвр - налево или слегка направо, слегка направо подсвечено. */
  left_SlightlyRight_0_1(19),
  /** Комбинированный манёвр - налево или слегка направо, направо подсвечено. */
  left_SlightlyRight_1_0(20),
  /** Комбинированный манёвр - налево или слегка направо, оба варианта подсвечены. */
  left_SlightlyRight_1_1(21),
  /** Комбинированный манёвр - налево или прямо, без подсветки. */
  left_Forward_0_0(22),
  /** Комбинированный манёвр - налево или прямо, прямо подсвечено. */
  left_Forward_0_1(23),
  /** Комбинированный манёвр - налево или прямо, налево подсвечено. */
  left_Forward_1_0(24),
  /** Комбинированный манёвр - налево или прямо, оба варианта подсвечены. */
  left_Forward_1_1(25),
  /** Комбинированный манёвр - налево, прямо или направо, без подсветки. */
  left_Forward_Right_0_0_0(26),
  /** Комбинированный манёвр - налево, прямо или направо, направо подсвечено. */
  left_Forward_Right_0_0_1(27),
  /** Комбинированный манёвр - налево, прямо или направо, прямо подсвечено. */
  left_Forward_Right_0_1_0(28),
  /** Комбинированный манёвр - налево, прямо или направо, налево подсвечено. */
  left_Forward_Right_1_0_0(29),
  /** Комбинированный манёвр - налево, прямо или направо, все варианты подсвечены. */
  left_Forward_Right_1_1_1(30),
  /** Направо с поворотом налево, без подсветки. */
  rightWithLeftTurn_0(31),
  /** Направо с поворотом налево, с подсветкой. */
  rightWithLeftTurn_1(32),
  /** Направо, без подсветки. */
  right_0(33),
  /** Направо, с подсветкой. */
  right_1(34),
  /** Комбинированный манёвр - направо или круто направо, без подсветки. */
  right_SharplyRight_0_0(35),
  /** Комбинированный манёвр - направо или круто направо, круто направо подсвечено. */
  right_SharplyRight_0_1(36),
  /** Комбинированный манёвр - направо или круто направо, направо подсвечено. */
  right_SharplyRight_1_0(37),
  /** Комбинированный манёвр - направо или круто направо, оба варианта подсвечены. */
  right_SharplyRight_1_1(38),
  /** Круто налево, без подсветки. */
  sharplyLeft_0(39),
  /** Круто налево, с подсветкой. */
  sharplyLeft_1(40),
  /** Комбинированный манёвр - круто налево или налево, без подсветки. */
  sharplyLeft_Left_0_0(41),
  /** Комбинированный манёвр - круто налево или налево, налево подсвечено. */
  sharplyLeft_Left_0_1(42),
  /** Комбинированный манёвр - круто налево или налево, круто налево подсвечено. */
  sharplyLeft_Left_1_0(43),
  /** Комбинированный манёвр - круто налево или налево, оба варианта подсвечены. */
  sharplyLeft_Left_1_1(44),
  /** Комбинированный манёвр - круто налево или слегка налево, без подсветки. */
  sharplyLeft_SlightlyLeft_0_0(45),
  /** Комбинированный манёвр - круто налево или слегка налево, слегка налево подсвечено. */
  sharplyLeft_SlightlyLeft_0_1(46),
  /** Комбинированный манёвр - круто налево или слегка налево, круто налево подсвечено. */
  sharplyLeft_SlightlyLeft_1_0(47),
  /** Комбинированный манёвр - круто налево или слегка налево, оба варианта подсвечены. */
  sharplyLeft_SlightlyLeft_1_1(48),
  /** Комбинированный манёвр - круто налево или слегка направо, без подсветки. */
  sharplyLeft_SlightlyRight_0_0(49),
  /** Комбинированный манёвр - круто налево или слегка направо, слегка направо подсвечено. */
  sharplyLeft_SlightlyRight_0_1(50),
  /** Комбинированный манёвр - круто налево или слегка направо, круто налево подсвечено. */
  sharplyLeft_SlightlyRight_1_0(51),
  /** Комбинированный манёвр - круто налево или слегка направо, оба варианта подсвечены. */
  sharplyLeft_SlightlyRight_1_1(52),
  /** Комбинированный манёвр - круто налево или прямо, без подсветки. */
  sharplyLeft_Forward_0_0(53),
  /** Комбинированный манёвр - круто налево или прямо, прямо подсвечено. */
  sharplyLeft_Forward_0_1(54),
  /** Комбинированный манёвр - круто налево или прямо, круто налево подсвечено. */
  sharplyLeft_Forward_1_0(55),
  /** Комбинированный манёвр - круто налево или прямо, оба варианта подсвечены. */
  sharplyLeft_Forward_1_1(56),
  /** Круто направо, без подсветки. */
  sharplyRight_0(57),
  /** Круто направо, с подсветкой. */
  sharplyRight_1(58),
  /** Слегка налево, без подсветки. */
  slightlyLeft_0(59),
  /** Слегка налево, с подсветкой. */
  slightlyLeft_1(60),
  /** Комбинированный манёвр - слегка налево или направо, без подсветки. */
  slightlyLeft_Right_0_0(61),
  /** Комбинированный манёвр - слегка налево или направо, направо подсвечено. */
  slightlyLeft_Right_0_1(62),
  /** Комбинированный манёвр - слегка налево или направо, слегка налево подсвечено. */
  slightlyLeft_Right_1_0(63),
  /** Комбинированный манёвр - слегка налево или направо, оба варианта подсвечены. */
  slightlyLeft_Right_1_1(64),
  /** Комбинированный манёвр - слегка налево или круто направо, без подсветки. */
  slightlyLeft_SharplyRight_0_0(65),
  /** Комбинированный манёвр - слегка налево или круто направо, круто направо подсвечено. */
  slightlyLeft_SharplyRight_0_1(66),
  /** Комбинированный манёвр - слегка налево или круто направо, слегка налево подсвечено. */
  slightlyLeft_SharplyRight_1_0(67),
  /** Комбинированный манёвр - слегка налево или круто направо, оба варианта подсвечены. */
  slightlyLeft_SharplyRight_1_1(68),
  /** Комбинированный манёвр - слегка налево или слегка направо, без подсветки. */
  slightlyLeft_SlightlyRight_0_0(69),
  /** Комбинированный манёвр - слегка налево или слегка направо, слегка направо подсвечено. */
  slightlyLeft_SlightlyRight_0_1(70),
  /** Комбинированный манёвр - слегка налево или слегка направо, слегка налево подсвечено. */
  slightlyLeft_SlightlyRight_1_0(71),
  /** Комбинированный манёвр - слегка налево или слегка направо, оба варианта подсвечены. */
  slightlyLeft_SlightlyRight_1_1(72),
  /** Комбинированный манёвр - слегка налево или прямо, без подсветки. */
  slightlyLeft_Forward_0_0(73),
  /** Комбинированный манёвр - слегка налево или прямо, прямо подсвечено. */
  slightlyLeft_Forward_0_1(74),
  /** Комбинированный манёвр - слегка налево или прямо, слегка налево подсвечено. */
  slightlyLeft_Forward_1_0(75),
  /** Комбинированный манёвр - слегка налево или прямо, оба варианта подсвечены. */
  slightlyLeft_Forward_1_1(76),
  /** Слегка направо, без подсветки. */
  slightlyRight_0(77),
  /** Слегка направо, с подсветкой. */
  slightlyRight_1(78),
  /** Комбинированный манёвр - слегка направо или направо, без подсветки. */
  slightlyRight_Right_0_0(79),
  /** Комбинированный манёвр - слегка направо или направо, направо подсвечено. */
  slightlyRight_Right_0_1(80),
  /** Комбинированный манёвр - слегка направо или направо, слегка направо подсвечено. */
  slightlyRight_Right_1_0(81),
  /** Комбинированный манёвр - слегка направо или направо, оба варианта подсвечены. */
  slightlyRight_Right_1_1(82),
  /** Комбинированный манёвр - слегка направо или круто направо, без подсветки. */
  slightlyRight_SharplyRight_0_0(83),
  /** Комбинированный манёвр - слегка направо или круто направо, круто направо подсвечено. */
  slightlyRight_SharplyRight_0_1(84),
  /** Комбинированный манёвр - слегка направо или круто направо, слегка направо подсвечено. */
  slightlyRight_SharplyRight_1_0(85),
  /** Комбинированный манёвр - слегка направо или круто направо, оба варианта подсвечены. */
  slightlyRight_SharplyRight_1_1(86),
  /** Прямо, без подсветки. */
  forward_0(87),
  /** Прямо, с подсветкой. */
  forward_1(88),
  /** Комбинированный манёвр - прямо или направо с поворотом налево, без подсветки. */
  forward_RightWithLeftTurn_0_0(89),
  /** Комбинированный манёвр - прямо или направо с поворотом налево, направо с поворотом налево подсвечено. */
  forward_RightWithLeftTurn_0_1(90),
  /** Комбинированный манёвр - прямо или направо с поворотом налево, прямо подсвечено. */
  forward_RightWithLeftTurn_1_0(91),
  /** Комбинированный манёвр - прямо или направо с поворотом налево, оба варианта подсвечены. */
  forward_RightWithLeftTurn_1_1(92),
  /** Комбинированный манёвр - прямо или направо, без подсветки. */
  forward_Right_0_0(93),
  /** Комбинированный манёвр - прямо или направо, направо подсвечено. */
  forward_Right_0_1(94),
  /** Комбинированный манёвр - прямо или направо, прямо подсвечено. */
  forward_Right_1_0(95),
  /** Комбинированный манёвр - прямо или направо, оба варианта подсвечены. */
  forward_Right_1_1(96),
  /** Комбинированный манёвр - прямо или круто направо, без подсветки. */
  forward_SharplyRight_0_0(97),
  /** Комбинированный манёвр - прямо или круто направо, круто направо подсвечено. */
  forward_SharplyRight_0_1(98),
  /** Комбинированный манёвр - прямо или круто направо, прямо подсвечено. */
  forward_SharplyRight_1_0(99),
  /** Комбинированный манёвр - прямо или круто направо, оба варианта подсвечены. */
  forward_SharplyRight_1_1(100),
  /** Комбинированный манёвр - прямо или слегка направо, без подсветки. */
  forward_SlightlyRight_0_0(101),
  /** Комбинированный манёвр - прямо или слегка направо, слегка направо подсвечено. */
  forward_SlightlyRight_0_1(102),
  /** Комбинированный манёвр - прямо или слегка направо, прямо подсвечено. */
  forward_SlightlyRight_1_0(103),
  /** Комбинированный манёвр - прямо или слегка направо, оба варианта подсвечены. */
  forward_SlightlyRight_1_1(104),
  /** Разворот, без подсветки. */
  turnover_0(105),
  /** Разворот, с подсветкой. */
  turnover_1(106),
  ;

  const LanesControlImage(this.rawValue);
  final int rawValue;

  static LanesControlImage getByValue(int value) {
    return LanesControlImage.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CLanesControlImage extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CLanesControlImageBasicFunctions on _CLanesControlImage {
  void _releaseIntermediate() {
  }
}

extension _CLanesControlImageToDart on _CLanesControlImage {
  LanesControlImage _toDart() {
    return LanesControlImage.getByValue(this.rawValue);
  }
}

extension _DartTo_CLanesControlImage on LanesControlImage {
  _CLanesControlImage _copyFromDartTo_CLanesControlImage() {
    return _CLanesControlImageMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - List<LanesControlImage> <-> _CArray_CLanesControlImage

final class _CArray_CLanesControlImage extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CLanesControlImageToDart on _CArray_CLanesControlImage {
  List<LanesControlImage> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CLanesControlImage on List<LanesControlImage> {
  _CArray_CLanesControlImage _copyFromDartTo_CArray_CLanesControlImage() {
    final cArray = _CArray_CLanesControlImagemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CLanesControlImage();
        _CArray_CLanesControlImageaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CLanesControlImageBasicFunctions on _CArray_CLanesControlImage {
  void _releaseIntermediate() {
    _CArray_CLanesControlImage_release(this);
  }

  static final _listToFill = <LanesControlImage>[];

  static void _iterate(_CLanesControlImage item) {
    _listToFill.add(item._toDart());
  }

  List<LanesControlImage> _fillFromC() {
    _forEach_CArray_CLanesControlImage(this, ffi.Pointer.fromFunction<ffi.Void Function(_CLanesControlImage)>(_iterate));
    final result = List<LanesControlImage>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - getVoiceManager

/** Получение объекта для управления голосами из контекста. */
VoiceManager getVoiceManager(
  Context context
){
  var _a0 = context._copyFromDartTo_CContext();
  _CVoiceManager res = _CFunction_G_getVoiceManager_With_CContext(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - VoiceManager

/** Интерфейс для взаимодействия со списком голосовых пакетов навигатора. */
class VoiceManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Канал со списком всех известных голосовых пакетов.
   Обновляется в случае изменения информации о хотя бы об одном из голосов, либо об изменении состава списка.
   Содержимое канала является подмножеством общего списка пакетов.
   Во избежание рассинхронизации описаний пакетов, не следует использовать данные, получаемые одновременно
   из нескольких каналов, содержащих подмножества общего списка пакетов.
  */
  StatefulChannel<List<Voice>> get voicesChannel {
    _CStatefulChannel_CArray_CVoice res = _CVoiceManager_voicesChannel(_CVoiceManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Канал со списком всех известных голосовых пакетов.
   Обновляется в случае изменения информации о хотя бы об одном из голосов, либо об изменении состава списка.
   Содержимое канала является подмножеством общего списка пакетов.
   Во избежание рассинхронизации описаний пакетов, не следует использовать данные, получаемые одновременно
   из нескольких каналов, содержащих подмножества общего списка пакетов.
  */
  List<Voice> get voices {
    _CArray_CVoice res = _CVoiceManager_voices(_CVoiceManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CVoiceManager_releasePtr);

  VoiceManager._raw(this._self);
  factory VoiceManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = VoiceManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is VoiceManager &&
    other.runtimeType == runtimeType &&
    _CVoiceManager_cg_objectIdentifier(this._self) == _CVoiceManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CVoiceManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - VoiceManager <-> CVoiceManager

final class _CVoiceManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CVoiceManagerBasicFunctions on _CVoiceManager {
  void _releaseIntermediate() {
    _CVoiceManager_release(_impl);
  }

  _CVoiceManager _retain() {
    return _CVoiceManager_retain(_impl);
  }
}

extension _CVoiceManagerToDart on _CVoiceManager {
  VoiceManager _toDart() {
    return VoiceManager._create(_retain()._impl);
  }
}


extension _DartToCVoiceManager on VoiceManager {
  _CVoiceManager _copyFromDartTo_CVoiceManager() {
    return (_CVoiceManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<List<Voice>> <-> _CStatefulChannel_CArray_CVoice

class _CStatefulChannel_CArray_CVoiceImpl extends StatefulChannel<List<Voice>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<Voice>>>{};

  final _CStatefulChannel_CArray_CVoice _channel;

  _CStatefulChannel_CArray_CVoiceImpl(this._channel);

  @override
  List<Voice> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CArray_CVoice cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<Voice>> listen(void onData(List<Voice> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CVoice, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<Voice>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CArray_CVoice extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CArray_CVoiceBasicFunctions on _CStatefulChannel_CArray_CVoice {
  void _releaseIntermediate() {
    _CStatefulChannel_CArray_CVoice_release(this);
  }

  _CStatefulChannel_CArray_CVoice _retain() {
    return _CStatefulChannel_CArray_CVoice_retain(this);
  }

  List<Voice> _getter() {
    final cValue = _CStatefulChannel_CArray_CVoiceGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CVoice, ffi.Int64)> callback) {
    return _CStatefulChannel_CArray_CVoiceConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CArray_CVoiceToDart on _CStatefulChannel_CArray_CVoice {
  StatefulChannel<List<Voice>> _toDart() {
    return _CStatefulChannel_CArray_CVoiceImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CArray_CVoice on StatefulChannel<List<Voice>> {
  _CStatefulChannel_CArray_CVoice _copyFromDartTo_CStatefulChannel_CArray_CVoice() {
    return _CStatefulChannel_CArray_CVoiceMakeDefault();
  }
}
	
// MARK: - List<Voice> <-> _CArray_CVoice

final class _CArray_CVoice extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CVoiceToDart on _CArray_CVoice {
  List<Voice> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CVoice on List<Voice> {
  _CArray_CVoice _copyFromDartTo_CArray_CVoice() {
    final cArray = _CArray_CVoicemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CVoice();
        _CArray_CVoiceaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CVoiceBasicFunctions on _CArray_CVoice {
  void _releaseIntermediate() {
    _CArray_CVoice_release(this);
  }

  static final _listToFill = <Voice>[];

  static void _iterate(_CVoice item) {
    _listToFill.add(item._toDart());
  }

  List<Voice> _fillFromC() {
    _forEach_CArray_CVoice(this, ffi.Pointer.fromFunction<ffi.Void Function(_CVoice)>(_iterate));
    final result = List<Voice>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - Voice

/** Голосовой пакет с озвучкой навигатора. */
class Voice extends Package implements ffi.Finalizable {
  /** Получение голоса для использования в навигаторе. */
  NavigationVoice get navigationVoice {
    _CNavigationVoice res = _CVoice_navigationVoice(_CVoiceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Язык озвучки в формате ISO 639-1. */
  String get language {
    _CString res = _CVoice_language(_CVoiceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CVoice_releasePtr);

  Voice._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Voice._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Voice._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Voice &&
    other.runtimeType == runtimeType &&
    _CVoice_cg_objectIdentifier(this._self) == _CVoice_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CVoice_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Voice: Methods

  /**
   Воспроизвести образец голоса.
  
   - Returns: future, который становится готовым, когда проигрывание сэмпла завершается.
  */
  CancelableOperation<void> playWelcome()  {
    _CFuture_void res = _CVoice_playWelcome(_CVoiceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - Voice <-> CVoice

final class _CVoice extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CVoiceBasicFunctions on _CVoice {
  void _releaseIntermediate() {
    _CVoice_release(_impl);
  }

  _CVoice _retain() {
    return _CVoice_retain(_impl);
  }
}

extension _CVoiceToDart on _CVoice {
  Voice _toDart() {
    return Voice._create(_retain()._impl);
  }
}


extension _DartToCVoice on Voice {
  _CVoice _copyFromDartTo_CVoice() {
    return (_CVoiceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<void> <-> _CFuture_void

final class _CFuture_void extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_void_Cancellable {
  final Completer<void> completer;
  final _CFuture_void _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_void_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_voidBasicFunctions on _CFuture_void {
  void _releaseIntermediate() {
    _CFuture_void_release(this);
  }

  _CFuture_void _retain() {
    return _CFuture_void_retain(this);
  }
}

extension _CFuture_voidToDart on _CFuture_void {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_void_Cancellable>{};

  static void valueFunction(int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete();
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<void> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<void>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_voidReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_void_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_void on CancelableOperation<void> {
  _CFuture_void _copyFromDartTo_CFuture_void() {
    return _CFuture_voidMakeDefault();
  }
}
	
// MARK: - ActivityTracker

class ActivityTracker implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Флаг, активное состояние которого указывает на то, что навигатор необходимо остановить.
   Если в состоянии Finished навигация прекращается,
   т.е. движение останавливается или его скорость становится ниже порогового значения,
   и если такое состояние сохраняется некоторое время, то устанавливается флаг устанавливается в true,
   в противном случае он имеет значение false.
  */
  StatefulChannel<bool> get stopChannel {
    _CStatefulChannel_bool res = _CActivityTracker_stopChannel(_CActivityTrackerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Флаг, активное состояние которого указывает на то, что навигатор необходимо остановить.
   Если в состоянии Finished навигация прекращается,
   т.е. движение останавливается или его скорость становится ниже порогового значения,
   и если такое состояние сохраняется некоторое время, то устанавливается флаг устанавливается в true,
   в противном случае он имеет значение false.
  */
  bool get stop {
    bool res = _CActivityTracker_stop(_CActivityTrackerMakeDefault().._impl=_self);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CActivityTracker_releasePtr);

  ActivityTracker._raw(this._self);
  factory ActivityTracker._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ActivityTracker._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Расширение навигатора, которое отслеживает активность пользователя и выдает сигнал,
   когда пользователь перестал пользоваться навигатором и его можно выключить.
  
   - Parameter platformContext: Контекст.
   - Parameter model: Модель навигатора, состояние которого отслеживается.
   - Parameter speedBound: Верхняя граница скорости в м/с, при превышении которой в состоянии Finished навигатора считается,
   что навигатор активен, т.е. движение продолжается.
   - Parameter timeThreshold: Время, в течение которого в состоянии Finished навигатора отслеживается скорость
   движения ниже пороговой для определения состояния неактивности навигатора.
   Если в течение этого времени скорость движения меньше установленного порога или
   нет данных о локации и скорости, навигатор считается неактивным.
   - Returns: Объект трекера активности пользователя навигатора.
   - Throws: Exception В случае ошибки в параметрах.
   - Throws: Exception В случае, если объект создать не удалось.
  */
  factory ActivityTracker(
    Context platformContext,
    Model model,
    [double speedBound = 4.2,
    Duration timeThreshold = const Duration(milliseconds: 20000)
    ]) {
    var _a0 = platformContext._copyFromDartTo_CContext();
    var _a1 = model._copyFromDartTo_CModel();
    var _a3 = timeThreshold._copyFromDartTo_CTimeInterval();
    _CActivityTracker res = _CActivityTracker_C_createWith_CContext_CModel_double_CTimeInterval(_a0, _a1, speedBound, _a3);
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    return ActivityTracker._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ActivityTracker &&
    other.runtimeType == runtimeType &&
    _CActivityTracker_cg_objectIdentifier(this._self) == _CActivityTracker_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CActivityTracker_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ActivityTracker <-> CActivityTracker

final class _CActivityTracker extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CActivityTrackerBasicFunctions on _CActivityTracker {
  void _releaseIntermediate() {
    _CActivityTracker_release(_impl);
  }

  _CActivityTracker _retain() {
    return _CActivityTracker_retain(_impl);
  }
}

extension _CActivityTrackerToDart on _CActivityTracker {
  ActivityTracker _toDart() {
    return ActivityTracker._create(_retain()._impl);
  }
}


extension _DartToCActivityTracker on ActivityTracker {
  _CActivityTracker _copyFromDartTo_CActivityTracker() {
    return (_CActivityTrackerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CameraProgressInfo

/** Информация о прогрессе прохождения зоны камеры. */
class CameraProgressInfo {
  /** Камера, для зоны действия которой отслеживается прогресс. */
  final RouteCamera camera;
  /** Позиция камеры на маршруте. */
  final RoutePoint position;
  /** Прогресс прохождения зоны действия камеры, [0, 1]. */
  final double progress;

  const CameraProgressInfo({
    required this.camera,
    required this.position,
    this.progress = 0
  });

  CameraProgressInfo copyWith({
    RouteCamera? camera,
    RoutePoint? position,
    double? progress
  }) {
    return CameraProgressInfo(
      camera: camera ?? this.camera,
      position: position ?? this.position,
      progress: progress ?? this.progress
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraProgressInfo &&
    other.runtimeType == runtimeType &&
    other.camera == camera &&
    other.position == position &&
    other.progress == progress;

  @override
  int get hashCode {
    return Object.hash(camera, position, progress);
  }

}
final class _CCameraProgressInfo extends ffi.Struct {
  external _CRouteCamera camera;

  external _CRoutePoint position;

  @ffi.Float()
  external double progress;

}
// MARK: - CameraProgressInfo <-> _CCameraProgressInfo

extension _CCameraProgressInfoToDart on _CCameraProgressInfo {
  CameraProgressInfo _toDart() {
    return CameraProgressInfo(
      camera: this.camera._toDart(),
      position: this.position._toDart(),
      progress: this.progress
    );
  }
}

extension _DartTo_CCameraProgressInfo on CameraProgressInfo {
  _CCameraProgressInfo _copyFromDartTo_CCameraProgressInfo() {
    final res = _CCameraProgressInfoMakeDefault();
    res.camera = this.camera._copyFromDartTo_CRouteCamera();
    res.position = this.position._copyFromDartTo_CRoutePoint();
    res.progress = this.progress;
    return res;
  }
}
extension _CCameraProgressInfoRelease on _CCameraProgressInfo {
  void _releaseIntermediate() {
  }
}

// MARK: - CameraNotifier

/** Предупреждает о попадании в зону действия дорожной камеры. */
class CameraNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Прогресс прохождения зоны действия дорожной камеры. */
  StatefulChannel<CameraProgressInfo?> get cameraProgressChannel {
    _CStatefulChannel_COptional_CCameraProgressInfo res = _CCameraNotifier_cameraProgressChannel(_CCameraNotifierMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Прогресс прохождения зоны действия дорожной камеры. */
  CameraProgressInfo? get cameraProgress {
    _COptional_CCameraProgressInfo res = _CCameraNotifier_cameraProgress(_CCameraNotifierMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CCameraNotifier_releasePtr);

  CameraNotifier._raw(this._self);
  factory CameraNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CameraNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Расширение навигатора, которое предупреждает о попадании в зону действия дорожной камеры.
  
   - Parameter model: Модель навигатора, состояние которого отслеживается.
   - Returns: Объект трекера активности пользователя навигатора.
  */
  factory CameraNotifier(
    Model model
  ) {
    var _a0 = model._copyFromDartTo_CModel();
    _CCameraNotifier res = _CCameraNotifier_C_createWith_CModel(_a0);
    _a0._releaseIntermediate();
    return CameraNotifier._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraNotifier &&
    other.runtimeType == runtimeType &&
    _CCameraNotifier_cg_objectIdentifier(this._self) == _CCameraNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCameraNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - CameraNotifier <-> CCameraNotifier

final class _CCameraNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCameraNotifierBasicFunctions on _CCameraNotifier {
  void _releaseIntermediate() {
    _CCameraNotifier_release(_impl);
  }

  _CCameraNotifier _retain() {
    return _CCameraNotifier_retain(_impl);
  }
}

extension _CCameraNotifierToDart on _CCameraNotifier {
  CameraNotifier _toDart() {
    return CameraNotifier._create(_retain()._impl);
  }
}


extension _DartToCCameraNotifier on CameraNotifier {
  _CCameraNotifier _copyFromDartTo_CCameraNotifier() {
    return (_CCameraNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<CameraProgressInfo?> <-> _CStatefulChannel_COptional_CCameraProgressInfo

class _CStatefulChannel_COptional_CCameraProgressInfoImpl extends StatefulChannel<CameraProgressInfo?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraProgressInfo?>>{};

  final _CStatefulChannel_COptional_CCameraProgressInfo _channel;

  _CStatefulChannel_COptional_CCameraProgressInfoImpl(this._channel);

  @override
  CameraProgressInfo? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CCameraProgressInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraProgressInfo?> listen(void onData(CameraProgressInfo? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CCameraProgressInfo, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraProgressInfo?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CCameraProgressInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CCameraProgressInfoBasicFunctions on _CStatefulChannel_COptional_CCameraProgressInfo {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CCameraProgressInfo_release(this);
  }

  _CStatefulChannel_COptional_CCameraProgressInfo _retain() {
    return _CStatefulChannel_COptional_CCameraProgressInfo_retain(this);
  }

  CameraProgressInfo? _getter() {
    final cValue = _CStatefulChannel_COptional_CCameraProgressInfoGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CCameraProgressInfo, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CCameraProgressInfoConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CCameraProgressInfoToDart on _CStatefulChannel_COptional_CCameraProgressInfo {
  StatefulChannel<CameraProgressInfo?> _toDart() {
    return _CStatefulChannel_COptional_CCameraProgressInfoImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CCameraProgressInfo on StatefulChannel<CameraProgressInfo?> {
  _CStatefulChannel_COptional_CCameraProgressInfo _copyFromDartTo_CStatefulChannel_COptional_CCameraProgressInfo() {
    return _CStatefulChannel_COptional_CCameraProgressInfoMakeDefault();
  }
}
	
// MARK: - CameraProgressInfo? <-> _COptional_CCameraProgressInfo

final class _COptional_CCameraProgressInfo extends ffi.Struct {
  
  external _CCameraProgressInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CCameraProgressInfoBasicFunctions on _COptional_CCameraProgressInfo {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CCameraProgressInfoToDart on _COptional_CCameraProgressInfo {
  CameraProgressInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CCameraProgressInfo on CameraProgressInfo? {
  _COptional_CCameraProgressInfo _copyFromDartTo_COptional_CCameraProgressInfo() {
    final cOptional = _COptional_CCameraProgressInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CCameraProgressInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Locale

/** Локаль. */
class Locale {
  /** Код языка, описанный в стандарте ISO 639-1, */
  final String language;
  /** Код страны, описанный в стандарте ISO 3166-1. */
  final String region;

  const Locale({
    required this.language,
    required this.region
  });

  // MARK: CLocale: Static Methods

  /** Создать локаль по строковому представлению в виде LanguageTag или POSIX. */
  static Locale? makeLocale(
    String localeStr
  )  {
    var _a0 = localeStr._copyFromDartTo_CString();
    _COptional_CLocale res = _CFunction_G_makeLocale_With_CString(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  Locale copyWith({
    String? language,
    String? region
  }) {
    return Locale(
      language: language ?? this.language,
      region: region ?? this.region
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Locale &&
    other.runtimeType == runtimeType &&
    other.language == language &&
    other.region == region;

  @override
  int get hashCode {
    return Object.hash(language, region);
  }

}
final class _CLocale extends ffi.Struct {
  external _CString language;

  external _CString region;

}
// MARK: - Locale <-> _CLocale

extension _CLocaleToDart on _CLocale {
  Locale _toDart() {
    return Locale(
      language: this.language._toDart(),
      region: this.region._toDart()
    );
  }
}

extension _DartTo_CLocale on Locale {
  _CLocale _copyFromDartTo_CLocale() {
    final res = _CLocaleMakeDefault();
    res.language = this.language._copyFromDartTo_CString();
    res.region = this.region._copyFromDartTo_CString();
    return res;
  }
}
extension _CLocaleRelease on _CLocale {
  void _releaseIntermediate() {
    language._releaseIntermediate();
    region._releaseIntermediate();
  }
}

// MARK: - ApplicationState

/** Состояние приложения, использующего SDK */
@internal
enum ApplicationState {
  /**
   Приложение может быть в любой момент быть выгружено (закрыто) системой.
  
   Следует прекратить работу и сохранить данные для возобновления обработки после восстановления.
  */
  suspended(0),
  /**
   Приложение свёрнуто/скрыто, не виден UI.
  
   - Todo: удалить. Это состояние необходимо получать из видимости Viewport.
  */
  hidden(1),
  /**
   Приложение частично или полностью перекрыто другими приложениями.
  
   - Todo: удалить. Это состояние необходимо получать из видимости Viewport.
  */
  inactive(2),
  /** Приложение активно */
  active(3),
  ;

  const ApplicationState(this.rawValue);
  final int rawValue;

  static ApplicationState getByValue(int value) {
    return ApplicationState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CApplicationState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CApplicationStateBasicFunctions on _CApplicationState {
  void _releaseIntermediate() {
  }
}

extension _CApplicationStateToDart on _CApplicationState {
  ApplicationState _toDart() {
    return ApplicationState.getByValue(this.rawValue);
  }
}

extension _DartTo_CApplicationState on ApplicationState {
  _CApplicationState _copyFromDartTo_CApplicationState() {
    return _CApplicationStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - HttpCacheManager

/** Интерфейс управления HTTP-кешем. */
class HttpCacheManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Текущий размер HTTP-кеша */
  int get currentSize {
    int res = _CHttpCacheManager_getCurrentSize(_CHttpCacheManagerMakeDefault().._impl=_self);
    return res;
  }
  /** Максимальный размер HTTP-кеша */
  int get maxSize {
    int res = _CHttpCacheManager_getMaxSize(_CHttpCacheManagerMakeDefault().._impl=_self);
    return res;
  }
  set maxSize(int size) {
    void res = _CHttpCacheManager_setMaxSize_uint64_t(_CHttpCacheManagerMakeDefault().._impl=_self, size);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CHttpCacheManager_releasePtr);

  HttpCacheManager._raw(this._self);
  factory HttpCacheManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = HttpCacheManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is HttpCacheManager &&
    other.runtimeType == runtimeType &&
    _CHttpCacheManager_cg_objectIdentifier(this._self) == _CHttpCacheManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CHttpCacheManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: HttpCacheManager: Methods

  /** Очистка содержимого HTTP-кеша. */
  void clear()  {
    void res = _CHttpCacheManager_clear(_CHttpCacheManagerMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - HttpCacheManager <-> CHttpCacheManager

final class _CHttpCacheManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CHttpCacheManagerBasicFunctions on _CHttpCacheManager {
  void _releaseIntermediate() {
    _CHttpCacheManager_release(_impl);
  }

  _CHttpCacheManager _retain() {
    return _CHttpCacheManager_retain(_impl);
  }
}

extension _CHttpCacheManagerToDart on _CHttpCacheManager {
  HttpCacheManager _toDart() {
    return HttpCacheManager._create(_retain()._impl);
  }
}


extension _DartToCHttpCacheManager on HttpCacheManager {
  _CHttpCacheManager _copyFromDartTo_CHttpCacheManager() {
    return (_CHttpCacheManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - LocaleChangeNotifier

@internal
class LocaleChangeNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CLocaleChangeNotifier_releasePtr);

  LocaleChangeNotifier._raw(this._self);
  factory LocaleChangeNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = LocaleChangeNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocaleChangeNotifier &&
    other.runtimeType == runtimeType &&
    _CLocaleChangeNotifier_cg_objectIdentifier(this._self) == _CLocaleChangeNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLocaleChangeNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: LocaleChangeNotifier: Methods

  void changed(
    List<Locale> locales
  )  {
    var _a1 = locales._copyFromDartTo_CArray_CLocale();
    void res = _CLocaleChangeNotifier_changed_CArray_CLocale(_CLocaleChangeNotifierMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - LocaleChangeNotifier <-> CLocaleChangeNotifier

final class _CLocaleChangeNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLocaleChangeNotifierBasicFunctions on _CLocaleChangeNotifier {
  void _releaseIntermediate() {
    _CLocaleChangeNotifier_release(_impl);
  }

  _CLocaleChangeNotifier _retain() {
    return _CLocaleChangeNotifier_retain(_impl);
  }
}

extension _CLocaleChangeNotifierToDart on _CLocaleChangeNotifier {
  LocaleChangeNotifier _toDart() {
    return LocaleChangeNotifier._create(_retain()._impl);
  }
}


extension _DartToCLocaleChangeNotifier on LocaleChangeNotifier {
  _CLocaleChangeNotifier _copyFromDartTo_CLocaleChangeNotifier() {
    return (_CLocaleChangeNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<Locale> <-> _CArray_CLocale

final class _CArray_CLocale extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CLocaleToDart on _CArray_CLocale {
  List<Locale> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CLocale on List<Locale> {
  _CArray_CLocale _copyFromDartTo_CArray_CLocale() {
    final cArray = _CArray_CLocalemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CLocale();
        _CArray_CLocaleaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CLocaleBasicFunctions on _CArray_CLocale {
  void _releaseIntermediate() {
    _CArray_CLocale_release(this);
  }

  static final _listToFill = <Locale>[];

  static void _iterate(_CLocale item) {
    _listToFill.add(item._toDart());
  }

  List<Locale> _fillFromC() {
    _forEach_CArray_CLocale(this, ffi.Pointer.fromFunction<ffi.Void Function(_CLocale)>(_iterate));
    final result = List<Locale>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - LocaleManager

/** Менеджер региональных настроек приложения. */
class LocaleManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Локали приложения, если заданы, иначе - локали, заданные пользователем в ОС. */
  StatefulChannel<List<Locale>> get localesChannel {
    _CStatefulChannel_CArray_CLocale res = _CLocaleManager_localesChannel(_CLocaleManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Локали приложения, если заданы, иначе - локали, заданные пользователем в ОС. */
  List<Locale> get locales {
    _CArray_CLocale res = _CLocaleManager_locales(_CLocaleManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение локалей, предоставляемых ОС.
  
   Локали ОС в порядке, заданном пользователем (в порядке от более приоритетной
   к менее приоритетной).
  */
  StatefulChannel<List<Locale>> get systemLocalesChannel {
    _CStatefulChannel_CArray_CLocale res = _CLocaleManager_systemLocalesChannel(_CLocaleManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение локалей, предоставляемых ОС.
  
   Локали ОС в порядке, заданном пользователем (в порядке от более приоритетной
   к менее приоритетной).
  */
  List<Locale> get systemLocales {
    _CArray_CLocale res = _CLocaleManager_systemLocales(_CLocaleManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CLocaleManager_releasePtr);

  LocaleManager._raw(this._self);
  factory LocaleManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = LocaleManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocaleManager &&
    other.runtimeType == runtimeType &&
    _CLocaleManager_cg_objectIdentifier(this._self) == _CLocaleManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLocaleManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: LocaleManager: Methods

  /** Установка списка локалей приложения */
  void overrideLocales(
    List<Locale> locales
  )  {
    var _a1 = locales._copyFromDartTo_CArray_CLocale();
    void res = _CLocaleManager_overrideLocales_CArray_CLocale(_CLocaleManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - LocaleManager <-> CLocaleManager

final class _CLocaleManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLocaleManagerBasicFunctions on _CLocaleManager {
  void _releaseIntermediate() {
    _CLocaleManager_release(_impl);
  }

  _CLocaleManager _retain() {
    return _CLocaleManager_retain(_impl);
  }
}

extension _CLocaleManagerToDart on _CLocaleManager {
  LocaleManager _toDart() {
    return LocaleManager._create(_retain()._impl);
  }
}


extension _DartToCLocaleManager on LocaleManager {
  _CLocaleManager _copyFromDartTo_CLocaleManager() {
    return (_CLocaleManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<List<Locale>> <-> _CStatefulChannel_CArray_CLocale

class _CStatefulChannel_CArray_CLocaleImpl extends StatefulChannel<List<Locale>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<Locale>>>{};

  final _CStatefulChannel_CArray_CLocale _channel;

  _CStatefulChannel_CArray_CLocaleImpl(this._channel);

  @override
  List<Locale> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CArray_CLocale cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<Locale>> listen(void onData(List<Locale> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CLocale, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<Locale>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CArray_CLocale extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CArray_CLocaleBasicFunctions on _CStatefulChannel_CArray_CLocale {
  void _releaseIntermediate() {
    _CStatefulChannel_CArray_CLocale_release(this);
  }

  _CStatefulChannel_CArray_CLocale _retain() {
    return _CStatefulChannel_CArray_CLocale_retain(this);
  }

  List<Locale> _getter() {
    final cValue = _CStatefulChannel_CArray_CLocaleGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CLocale, ffi.Int64)> callback) {
    return _CStatefulChannel_CArray_CLocaleConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CArray_CLocaleToDart on _CStatefulChannel_CArray_CLocale {
  StatefulChannel<List<Locale>> _toDart() {
    return _CStatefulChannel_CArray_CLocaleImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CArray_CLocale on StatefulChannel<List<Locale>> {
  _CStatefulChannel_CArray_CLocale _copyFromDartTo_CStatefulChannel_CArray_CLocale() {
    return _CStatefulChannel_CArray_CLocaleMakeDefault();
  }
}
	
// MARK: - _PlatformLocaleManagerCpp

/** Класс для платформенной реализации LocaleManager. */
class _PlatformLocaleManagerCpp extends PlatformLocaleManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CPlatformLocaleManagerCpp_releasePtr);

  _PlatformLocaleManagerCpp._raw(this._self);
  factory _PlatformLocaleManagerCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _PlatformLocaleManagerCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _PlatformLocaleManagerCpp &&
    other.runtimeType == runtimeType &&
    _CPlatformLocaleManagerCpp_cg_objectIdentifier(this._self) == _CPlatformLocaleManagerCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPlatformLocaleManagerCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _PlatformLocaleManagerCpp: Methods

  List<Locale> locales()  {
    _CArray_CLocale res = _CPlatformLocaleManagerCpp_locales(_CPlatformLocaleManagerCppMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  void setLocalesChangeNotifier(
    LocaleChangeNotifier notifier
  )  {
    var _a1 = notifier._copyFromDartTo_CLocaleChangeNotifier();
    void res = _CPlatformLocaleManagerCpp_setLocalesChangeNotifier_CLocaleChangeNotifier(_CPlatformLocaleManagerCppMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  List<Locale> systemLocales()  {
    _CArray_CLocale res = _CPlatformLocaleManagerCpp_systemLocales(_CPlatformLocaleManagerCppMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  void setSystemLocalesChangeNotifier(
    LocaleChangeNotifier notifier
  )  {
    var _a1 = notifier._copyFromDartTo_CLocaleChangeNotifier();
    void res = _CPlatformLocaleManagerCpp_setSystemLocalesChangeNotifier_CLocaleChangeNotifier(_CPlatformLocaleManagerCppMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  void overrideLocales(
    List<Locale> locales
  )  {
    var _a1 = locales._copyFromDartTo_CArray_CLocale();
    void res = _CPlatformLocaleManagerCpp_overrideLocales_CArray_CLocale(_CPlatformLocaleManagerCppMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - _PlatformLocaleManagerCpp <-> CPlatformLocaleManagerCpp

final class _CPlatformLocaleManagerCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPlatformLocaleManagerCppBasicFunctions on _CPlatformLocaleManagerCpp {
  void _releaseIntermediate() {
    _CPlatformLocaleManagerCpp_release(_impl);
  }

  _CPlatformLocaleManagerCpp _retain() {
    return _CPlatformLocaleManagerCpp_retain(_impl);
  }
}

extension _CPlatformLocaleManagerCppToDart on _CPlatformLocaleManagerCpp {
  _PlatformLocaleManagerCpp _toDart() {
    return _PlatformLocaleManagerCpp._create(_retain()._impl);
  }
}


extension _DartToCPlatformLocaleManagerCpp on _PlatformLocaleManagerCpp {
  _CPlatformLocaleManagerCpp _copyFromDartTo_CPlatformLocaleManagerCpp() {
    return (_CPlatformLocaleManagerCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PlatformLocaleManager

/** Класс для платформенной реализации LocaleManager. */
@internal
abstract class PlatformLocaleManager {
  List<Locale> locales();
  void setLocalesChangeNotifier(
    LocaleChangeNotifier notifier
  );
  List<Locale> systemLocales();
  void setSystemLocalesChangeNotifier(
    LocaleChangeNotifier notifier
  );
  void overrideLocales(
    List<Locale> locales
  );
}

class _PlatformLocaleManager {
  final PlatformLocaleManager object;
  int refCounter = 1;

  _PlatformLocaleManager(this.object);
}

final class _CPlatformLocaleManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>>)>> _locales;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CLocaleChangeNotifier)>> _setLocalesChangeNotifier_CLocaleChangeNotifier;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>>)>> _systemLocales;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CLocaleChangeNotifier)>> _setSystemLocalesChangeNotifier_CLocaleChangeNotifier;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CArray_CLocale)>> _overrideLocales_CArray_CLocale;
}

extension _CPlatformLocaleManagerBasicFunctions on _CPlatformLocaleManager {
  void _releaseIntermediate() {
    _CPlatformLocaleManager_release(this);
  }
}

int _CPlatformLocaleManagerInstanceCounter = 1;
final _CPlatformLocaleManagerInstanceMap = <int, _PlatformLocaleManager>{};

extension _CPlatformLocaleManagerToDart on _CPlatformLocaleManager {
  PlatformLocaleManager _toDart() {
    late PlatformLocaleManager? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CPlatformLocaleManagerInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CPlatformLocaleManagerCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CPlatformLocaleManager");
    }
    return result;
  }
}

extension _DartTo_CPlatformLocaleManager on PlatformLocaleManager {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CPlatformLocaleManagerInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CPlatformLocaleManagerInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CPlatformLocaleManagerInstanceMap.remove(platformValue.address);
  }

  _CPlatformLocaleManager _copyFromDartTo_CPlatformLocaleManager() {
    var res = _CPlatformLocaleManagerMakeDefault();
    if (this is _PlatformLocaleManagerCpp) {
      final cppValue = this as _PlatformLocaleManagerCpp;
      res._cppValue = cppValue._copyFromDartTo_CPlatformLocaleManagerCpp()._impl;
      return res;
    }
    final instanceId = _CPlatformLocaleManagerInstanceCounter;
    _CPlatformLocaleManagerInstanceCounter += 1;
    _CPlatformLocaleManagerInstanceMap[instanceId] = _PlatformLocaleManager(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final localesFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>>)>.listener(localesFunction);
    res._locales = localesFunctionCallable.nativeFunction;
    final setLocalesChangeNotifier_CLocaleChangeNotifierFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CLocaleChangeNotifier)>.listener(setLocalesChangeNotifier_CLocaleChangeNotifierFunction);
    res._setLocalesChangeNotifier_CLocaleChangeNotifier = setLocalesChangeNotifier_CLocaleChangeNotifierFunctionCallable.nativeFunction;
    final systemLocalesFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>>)>.listener(systemLocalesFunction);
    res._systemLocales = systemLocalesFunctionCallable.nativeFunction;
    final setSystemLocalesChangeNotifier_CLocaleChangeNotifierFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CLocaleChangeNotifier)>.listener(setSystemLocalesChangeNotifier_CLocaleChangeNotifierFunction);
    res._setSystemLocalesChangeNotifier_CLocaleChangeNotifier = setSystemLocalesChangeNotifier_CLocaleChangeNotifierFunctionCallable.nativeFunction;
    final overrideLocales_CArray_CLocaleFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CArray_CLocale)>.listener(overrideLocales_CArray_CLocaleFunction);
    res._overrideLocales_CArray_CLocale = overrideLocales_CArray_CLocaleFunctionCallable.nativeFunction;
    return res;
  }

  static void localesFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }
    final platformObject = _CPlatformLocaleManagerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }

    final res = platformObject.object.locales();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>();
    callbackFunction(context, res._copyFromDartTo_CArray_CLocale());
  }

  static void setLocalesChangeNotifier_CLocaleChangeNotifierFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _CLocaleChangeNotifier notifier) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }
    final platformObject = _CPlatformLocaleManagerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }

    final notifierDart = notifier._toDart();
    platformObject.object.setLocalesChangeNotifier(notifierDart);
    notifier._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }

  static void systemLocalesFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }
    final platformObject = _CPlatformLocaleManagerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }

    final res = platformObject.object.systemLocales();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>();
    callbackFunction(context, res._copyFromDartTo_CArray_CLocale());
  }

  static void setSystemLocalesChangeNotifier_CLocaleChangeNotifierFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _CLocaleChangeNotifier notifier) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }
    final platformObject = _CPlatformLocaleManagerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }

    final notifierDart = notifier._toDart();
    platformObject.object.setSystemLocalesChangeNotifier(notifierDart);
    notifier._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }

  static void overrideLocales_CArray_CLocaleFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _CArray_CLocale locales) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }
    final platformObject = _CPlatformLocaleManagerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }

    final localesDart = locales._toDart();
    platformObject.object.overrideLocales(localesDart);
    locales._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }


}

// MARK: - getHttpCacheManager

/** Интерфейс управления HTTP-кешем. Null, если HTTP кэш не используется. */
HttpCacheManager? getHttpCacheManager(
  Context context
){
  var _a0 = context._copyFromDartTo_CContext();
  _COptional_CHttpCacheManager res = _CFunction_G_getHttpCacheManager_With_CContext(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - HttpCacheManager? <-> _COptional_CHttpCacheManager

final class _COptional_CHttpCacheManager extends ffi.Struct {
  
  external _CHttpCacheManager value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CHttpCacheManagerBasicFunctions on _COptional_CHttpCacheManager {
  void _releaseIntermediate() {
    _COptional_CHttpCacheManager_release(this);
  }
}

extension _COptional_CHttpCacheManagerToDart on _COptional_CHttpCacheManager {
  HttpCacheManager? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CHttpCacheManager on HttpCacheManager? {
  _COptional_CHttpCacheManager _copyFromDartTo_COptional_CHttpCacheManager() {
    final cOptional = _COptional_CHttpCacheManagerMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CHttpCacheManager();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - getLocaleManager

/** Интерфейс управления локалями приложения. */
LocaleManager getLocaleManager(
  Context context
){
  var _a0 = context._copyFromDartTo_CContext();
  _CLocaleManager res = _CFunction_G_getLocaleManager_With_CContext(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - toLocaleManager

@internal
LocaleManager toLocaleManager(
  PlatformLocaleManager platformLocaleManager
){
  var _a0 = platformLocaleManager._copyFromDartTo_CPlatformLocaleManager();
  _CLocaleManager res = _CFunction_G_toLocaleManager_With_CPlatformLocaleManager(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - Locale? <-> _COptional_CLocale

final class _COptional_CLocale extends ffi.Struct {
  
  external _CLocale value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocaleBasicFunctions on _COptional_CLocale {
  void _releaseIntermediate() {
    _COptional_CLocale_release(this);
  }
}

extension _COptional_CLocaleToDart on _COptional_CLocale {
  Locale? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocale on Locale? {
  _COptional_CLocale _copyFromDartTo_COptional_CLocale() {
    final cOptional = _COptional_CLocaleMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocale();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Locale

extension LocaleToLocalePosix on Locale {
  String toLocalePosix()  {
    var _a0 = this._copyFromDartTo_CLocale();
    _CString res = _CFunction_G_toLocalePosix_With_CLocale(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}
// MARK: - getAudioSettings

AudioSettings? getAudioSettings(
  Context context
){
  var _a0 = context._copyFromDartTo_CContext();
  _COptional_CAudioSettings res = _CFunction_G_getAudioSettings_With_CContext(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - AudioFocusPolicy

/**
 Политика приложения по отношению к воспроизводимым звукам других приложений
 при воспроизведении звука в нашем приложении.
*/
enum AudioFocusPolicy {
  /** Игнорируем существование других приложений. */
  ignore(0),
  /** Отключаем звуки других приложений при воспроизведении. */
  mute(1),
  /** Приглушаем звуки других приложений при воспроизведении. */
  duck(2),
  ;

  const AudioFocusPolicy(this.rawValue);
  final int rawValue;

  static AudioFocusPolicy getByValue(int value) {
    return AudioFocusPolicy.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CAudioFocusPolicy extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CAudioFocusPolicyBasicFunctions on _CAudioFocusPolicy {
  void _releaseIntermediate() {
  }
}

extension _CAudioFocusPolicyToDart on _CAudioFocusPolicy {
  AudioFocusPolicy _toDart() {
    return AudioFocusPolicy.getByValue(this.rawValue);
  }
}

extension _DartTo_CAudioFocusPolicy on AudioFocusPolicy {
  _CAudioFocusPolicy _copyFromDartTo_CAudioFocusPolicy() {
    return _CAudioFocusPolicyMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - AudioSettings

/**
 Класс для управления звуком.

 - Note: Все методы могут вызываться из любого потока.
*/
class AudioSettings implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Уровень громкости звука (0-100). */
  int get volume {
    int res = _CAudioSettings_volume(_CAudioSettingsMakeDefault().._impl=_self);
    return res;
  }
  set volume(int value) {
    void res = _CAudioSettings_setVolume_uint32_t(_CAudioSettingsMakeDefault().._impl=_self, value);
    return res;
  }
  /** Проигрывание звука отключено. */
  bool get mute {
    bool res = _CAudioSettings_mute(_CAudioSettingsMakeDefault().._impl=_self);
    return res;
  }
  set mute(bool value) {
    void res = _CAudioSettings_setMute_bool(_CAudioSettingsMakeDefault().._impl=_self, value);
    return res;
  }
  /** Поведения звуков других приложений при запрошенном фокусе. */
  AudioFocusPolicy get audioFocusPolicy {
    _CAudioFocusPolicy res = _CAudioSettings_audioFocusPolicy(_CAudioSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set audioFocusPolicy(AudioFocusPolicy audioFocusPolicy) {
    var _a1 = audioFocusPolicy._copyFromDartTo_CAudioFocusPolicy();
    void res = _CAudioSettings_setAudioFocusPolicy_CAudioFocusPolicy(_CAudioSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CAudioSettings_releasePtr);

  AudioSettings._raw(this._self);
  factory AudioSettings._create(ffi.Pointer<ffi.Void> self) {
    final classObject = AudioSettings._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AudioSettings &&
    other.runtimeType == runtimeType &&
    _CAudioSettings_cg_objectIdentifier(this._self) == _CAudioSettings_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CAudioSettings_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - AudioSettings <-> CAudioSettings

final class _CAudioSettings extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CAudioSettingsBasicFunctions on _CAudioSettings {
  void _releaseIntermediate() {
    _CAudioSettings_release(_impl);
  }

  _CAudioSettings _retain() {
    return _CAudioSettings_retain(_impl);
  }
}

extension _CAudioSettingsToDart on _CAudioSettings {
  AudioSettings _toDart() {
    return AudioSettings._create(_retain()._impl);
  }
}


extension _DartToCAudioSettings on AudioSettings {
  _CAudioSettings _copyFromDartTo_CAudioSettings() {
    return (_CAudioSettingsMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - AudioSettings? <-> _COptional_CAudioSettings

final class _COptional_CAudioSettings extends ffi.Struct {
  
  external _CAudioSettings value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CAudioSettingsBasicFunctions on _COptional_CAudioSettings {
  void _releaseIntermediate() {
    _COptional_CAudioSettings_release(this);
  }
}

extension _COptional_CAudioSettingsToDart on _COptional_CAudioSettings {
  AudioSettings? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CAudioSettings on AudioSettings? {
  _COptional_CAudioSettings _copyFromDartTo_COptional_CAudioSettings() {
    final cOptional = _COptional_CAudioSettingsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CAudioSettings();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - LocationService

/** Класс для работы с установленным при инициализации SDK источником. */
class LocationService implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CLocationService_releasePtr);

  LocationService._raw(this._self);
  factory LocationService._create(ffi.Pointer<ffi.Void> self) {
    final classObject = LocationService._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory LocationService(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CLocationService res = _CLocationService_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return LocationService._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocationService &&
    other.runtimeType == runtimeType &&
    _CLocationService_cg_objectIdentifier(this._self) == _CLocationService_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLocationService_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: LocationService: Methods

  /**
   Канал, который оповещает об изменении геопозиции.
  
   - Note: Возвращаемая в канале геопозиция может быть недостоверной.
   - Note: Если API платформы не предоставляет аналогичный по функциональности метод,
   то в канале всегда будет null.
  */
  StatefulChannel<Location?> lastLocation()  {
    _CStatefulChannel_COptional_CLocation res = _CLocationService_lastLocation(_CLocationServiceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Метод необходимо вызвать после получения разрешений на использование геопозиции.
  
   - Note: Этот метод актуален только для источника геопозиции по умолчанию.
  */
  void onPermissionGranted()  {
    void res = _CLocationService_onPermissionGranted(_CLocationServiceMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - LocationService <-> CLocationService

final class _CLocationService extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLocationServiceBasicFunctions on _CLocationService {
  void _releaseIntermediate() {
    _CLocationService_release(_impl);
  }

  _CLocationService _retain() {
    return _CLocationService_retain(_impl);
  }
}

extension _CLocationServiceToDart on _CLocationService {
  LocationService _toDart() {
    return LocationService._create(_retain()._impl);
  }
}


extension _DartToCLocationService on LocationService {
  _CLocationService _copyFromDartTo_CLocationService() {
    return (_CLocationServiceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - AddEventError

/** Тип ошибки добавления дорожного события. */
enum AddEventError {
  /** Сетевая ошибка. */
  networkError(0),
  /** Попытка добавить событие вне проектов 2ГИС. */
  territoryNotSupported(1),
  /**
   Неизвестна текущая позиция пользователя.
   Дорожные события разрешается добавлять только с известной позицией.
  */
  unknownUserLocation(2),
  /** Пользователь находится слишком далеко от места добавляемого события. */
  userLocationTooFarFromEvent(3),
  /** Попытка добавить анонимное событие на территории, где требуется обязательная авторизация пользователей. */
  notAuthorized(4),
  /** Пользователь отказался от сбора и отправки персональных данных. */
  noPersonalDataCollectionConsent(5),
  /** Пользователь заблокирован. */
  userBlocked(6),
  /** Пользователь слишком часто создаёт события. */
  tooManyRequests(7),
  ;

  const AddEventError(this.rawValue);
  final int rawValue;

  static AddEventError getByValue(int value) {
    return AddEventError.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CAddEventError extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CAddEventErrorBasicFunctions on _CAddEventError {
  void _releaseIntermediate() {
  }
}

extension _CAddEventErrorToDart on _CAddEventError {
  AddEventError _toDart() {
    return AddEventError.getByValue(this.rawValue);
  }
}

extension _DartTo_CAddEventError on AddEventError {
  _CAddEventError _copyFromDartTo_CAddEventError() {
    return _CAddEventErrorMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - AddEventResult

/** Результат добавления события (объект события или ошибка). */
final class AddEventResult {
  final Object? _value;
  final int _index;

  AddEventResult._raw(this._value, this._index);

  AddEventResult.event(RoadEvent value) : this._raw(value, 0);
  AddEventResult.error(AddEventError value) : this._raw(value, 1);

  bool get isEvent => this._index == 0;
  RoadEvent? get asEvent => this.isEvent ? this._value as RoadEvent : null;

  bool get isError => this._index == 1;
  AddEventError? get asError => this.isError ? this._value as AddEventError : null;

  T match<T>({
    required T Function(RoadEvent value) event,
    required T Function(AddEventError value) error,
  }) {
    return switch (this._index) {
      0 => event(this._value as RoadEvent),
      1 => error(this._value as AddEventError),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "AddEventResult(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AddEventResult &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CAddEventResultImpl extends ffi.Union {
  external _CRoadEvent _event;
  external _CAddEventError _error;
}

final class _CAddEventResult extends ffi.Struct {
  external _CAddEventResultImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CAddEventResultBasicFunctions on _CAddEventResult {
  void _releaseIntermediate() {
    _CAddEventResult_release(this);
  }
}
	
// MARK: - AddEventResult <-> CAddEventResult

extension _CAddEventResultToDart on _CAddEventResult {
  AddEventResult _toDart() {
    return switch (this._index) {
      0 => AddEventResult.event(this._impl._event._toDart()),
      1 => AddEventResult.error(this._impl._error._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CAddEventResult on AddEventResult {
  _CAddEventResult _copyFromDartTo_CAddEventResult() {
    var res = _CAddEventResultMakeDefault();
    this.match<void>(
      event: (RoadEvent value) {
        res._impl._event = value._copyFromDartTo_CRoadEvent();
        res._index = 0;
      },
      error: (AddEventError value) {
        res._impl._error = value._copyFromDartTo_CAddEventError();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - RoadEventManager

/** Объект для создания транспортных событий. */
class RoadEventManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CRoadEventManager_releasePtr);

  RoadEventManager._raw(this._self);
  factory RoadEventManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEventManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /** Получение объекта для создания дорожных событий. */
  factory RoadEventManager(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CRoadEventManager res = _CRoadEventManager_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return RoadEventManager._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventManager &&
    other.runtimeType == runtimeType &&
    _CRoadEventManager_cg_objectIdentifier(this._self) == _CRoadEventManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEventManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadEventManager: Methods

  /**
   Создание события "ДТП".
  
   - Parameter location: Местоположение события.
   - Parameter lanes: Полосы дороги, затрагиваемые событием.
   - Parameter description: Пользовательское описание события.
  */
  CancelableOperation<AddEventResult> createAccident(
    GeoPoint location,
    LaneEnumSet lanes,
    String description
  )  {
    var _a1 = location._copyFromDartTo_CGeoPoint();
    var _a2 = lanes._copyFromDartTo_COptionSet_CLane();
    var _a3 = description._copyFromDartTo_CString();
    _CFuture_CAddEventResult res = _CRoadEventManager_createAccident_CGeoPoint_COptionSet_CLane_CString(_CRoadEventManagerMakeDefault().._impl=_self, _a1, _a2, _a3);
    _a3._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создание события "Камера".
  
   - Parameter location: Местоположение события.
   - Parameter description: Пользовательское описание события.
  */
  CancelableOperation<AddEventResult> createCamera(
    GeoPoint location,
    String description
  )  {
    var _a1 = location._copyFromDartTo_CGeoPoint();
    var _a2 = description._copyFromDartTo_CString();
    _CFuture_CAddEventResult res = _CRoadEventManager_createCamera_CGeoPoint_CString(_CRoadEventManagerMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создание события "Перекрытие дорожного движения".
  
   - Parameter location: Местоположение события.
   - Parameter description: Пользовательское описание события.
  */
  CancelableOperation<AddEventResult> createRoadRestriction(
    GeoPoint location,
    String description
  )  {
    var _a1 = location._copyFromDartTo_CGeoPoint();
    var _a2 = description._copyFromDartTo_CString();
    _CFuture_CAddEventResult res = _CRoadEventManager_createRoadRestriction_CGeoPoint_CString(_CRoadEventManagerMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создание события "Комментарий".
  
   - Parameter location: Местоположение события.
   - Parameter description: Пользовательское описание события.
  */
  CancelableOperation<AddEventResult> createComment(
    GeoPoint location,
    String description
  )  {
    var _a1 = location._copyFromDartTo_CGeoPoint();
    var _a2 = description._copyFromDartTo_CString();
    _CFuture_CAddEventResult res = _CRoadEventManager_createComment_CGeoPoint_CString(_CRoadEventManagerMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создание события "Другое".
  
   - Parameter location: Местоположение события.
   - Parameter lanes: Полосы дороги, затрагиваемые событием.
   - Parameter description: Пользовательское описание события.
  */
  CancelableOperation<AddEventResult> createOther(
    GeoPoint location,
    LaneEnumSet lanes,
    String description
  )  {
    var _a1 = location._copyFromDartTo_CGeoPoint();
    var _a2 = lanes._copyFromDartTo_COptionSet_CLane();
    var _a3 = description._copyFromDartTo_CString();
    _CFuture_CAddEventResult res = _CRoadEventManager_createOther_CGeoPoint_COptionSet_CLane_CString(_CRoadEventManagerMakeDefault().._impl=_self, _a1, _a2, _a3);
    _a3._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создание события "Дорожные работы".
  
   - Parameter location: Местоположение события.
   - Parameter lanes: Полосы дороги, затрагиваемые событием.
   - Parameter description: Пользовательское описание события.
  */
  CancelableOperation<AddEventResult> createRoadWorks(
    GeoPoint location,
    LaneEnumSet lanes,
    String description
  )  {
    var _a1 = location._copyFromDartTo_CGeoPoint();
    var _a2 = lanes._copyFromDartTo_COptionSet_CLane();
    var _a3 = description._copyFromDartTo_CString();
    _CFuture_CAddEventResult res = _CRoadEventManager_createRoadWorks_CGeoPoint_COptionSet_CLane_CString(_CRoadEventManagerMakeDefault().._impl=_self, _a1, _a2, _a3);
    _a3._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadEventManager <-> CRoadEventManager

final class _CRoadEventManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventManagerBasicFunctions on _CRoadEventManager {
  void _releaseIntermediate() {
    _CRoadEventManager_release(_impl);
  }

  _CRoadEventManager _retain() {
    return _CRoadEventManager_retain(_impl);
  }
}

extension _CRoadEventManagerToDart on _CRoadEventManager {
  RoadEventManager _toDart() {
    return RoadEventManager._create(_retain()._impl);
  }
}


extension _DartToCRoadEventManager on RoadEventManager {
  _CRoadEventManager _copyFromDartTo_CRoadEventManager() {
    return (_CRoadEventManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<AddEventResult> <-> _CFuture_CAddEventResult

final class _CFuture_CAddEventResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CAddEventResult_Cancellable {
  final Completer<AddEventResult> completer;
  final _CFuture_CAddEventResult _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CAddEventResult, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CAddEventResult_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CAddEventResultBasicFunctions on _CFuture_CAddEventResult {
  void _releaseIntermediate() {
    _CFuture_CAddEventResult_release(this);
  }

  _CFuture_CAddEventResult _retain() {
    return _CFuture_CAddEventResult_retain(this);
  }
}

extension _CFuture_CAddEventResultToDart on _CFuture_CAddEventResult {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CAddEventResult_Cancellable>{};

  static void valueFunction(_CAddEventResult cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<AddEventResult> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<AddEventResult>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CAddEventResult, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CAddEventResultReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CAddEventResult_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CAddEventResult on CancelableOperation<AddEventResult> {
  _CFuture_CAddEventResult _copyFromDartTo_CFuture_CAddEventResult() {
    return _CFuture_CAddEventResultMakeDefault();
  }
}
	
// MARK: - IntRouteAttribute

/**
 Контейнер, который описывает точечный атрибут маршрута.
 Каждый элемент хранится в виде точки на маршруте, в которой этот элемент расположен и значения самого элемента.
*/
class IntRouteAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CIntRouteAttribute_size(_CIntRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CIntRouteAttribute_isEmpty(_CIntRouteAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  IntRouteEntry? get first {
    _COptional_CIntRouteEntry res = _CIntRouteAttribute_first(_CIntRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  IntRouteEntry? get last {
    _COptional_CIntRouteEntry res = _CIntRouteAttribute_last(_CIntRouteAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<IntRouteEntry> get entries {
    _CArray_CIntRouteEntry res = _CIntRouteAttribute_entries(_CIntRouteAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CIntRouteAttribute_releasePtr);

  IntRouteAttribute._raw(this._self);
  factory IntRouteAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = IntRouteAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IntRouteAttribute &&
    other.runtimeType == runtimeType &&
    _CIntRouteAttribute_cg_objectIdentifier(this._self) == _CIntRouteAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CIntRouteAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: IntRouteAttribute: Methods

  /**
   Элементы, попадающие в отрезок [begin, end).
  
   - Throws: Exception если begin > end.
  */
  List<IntRouteEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CIntRouteEntry res = _CIntRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CIntRouteAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Найти ближайший элемент, позиция которого
   <
   = point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  IntRouteEntry? findNearBackward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CIntRouteEntry res = _CIntRouteAttribute_findNearBackward_CRoutePoint(_CIntRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Найти ближайший элемент, позиция которого >= point.
  
   - Note: Сложность операции log2(N), где N = size.
  */
  IntRouteEntry? findNearForward(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CIntRouteEntry res = _CIntRouteAttribute_findNearForward_CRoutePoint(_CIntRouteAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

}

// MARK: - IntRouteAttribute <-> CIntRouteAttribute

final class _CIntRouteAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CIntRouteAttributeBasicFunctions on _CIntRouteAttribute {
  void _releaseIntermediate() {
    _CIntRouteAttribute_release(_impl);
  }

  _CIntRouteAttribute _retain() {
    return _CIntRouteAttribute_retain(_impl);
  }
}

extension _CIntRouteAttributeToDart on _CIntRouteAttribute {
  IntRouteAttribute _toDart() {
    return IntRouteAttribute._create(_retain()._impl);
  }
}


extension _DartToCIntRouteAttribute on IntRouteAttribute {
  _CIntRouteAttribute _copyFromDartTo_CIntRouteAttribute() {
    return (_CIntRouteAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - IntRouteEntry

/** Элемент маршрута - точка и значение в ней. */
class IntRouteEntry {
  final RoutePoint point;
  final int value;

  const IntRouteEntry({
    required this.point,
    required this.value
  });

  IntRouteEntry copyWith({
    RoutePoint? point,
    int? value
  }) {
    return IntRouteEntry(
      point: point ?? this.point,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IntRouteEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, value);
  }

}
final class _CIntRouteEntry extends ffi.Struct {
  external _CRoutePoint point;

  @ffi.Int32()
  external int value;

}
// MARK: - IntRouteEntry <-> _CIntRouteEntry

extension _CIntRouteEntryToDart on _CIntRouteEntry {
  IntRouteEntry _toDart() {
    return IntRouteEntry(
      point: this.point._toDart(),
      value: this.value
    );
  }
}

extension _DartTo_CIntRouteEntry on IntRouteEntry {
  _CIntRouteEntry _copyFromDartTo_CIntRouteEntry() {
    final res = _CIntRouteEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.value = this.value;
    return res;
  }
}
extension _CIntRouteEntryRelease on _CIntRouteEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - IntRouteEntry? <-> _COptional_CIntRouteEntry

final class _COptional_CIntRouteEntry extends ffi.Struct {
  
  external _CIntRouteEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CIntRouteEntryBasicFunctions on _COptional_CIntRouteEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CIntRouteEntryToDart on _COptional_CIntRouteEntry {
  IntRouteEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CIntRouteEntry on IntRouteEntry? {
  _COptional_CIntRouteEntry _copyFromDartTo_COptional_CIntRouteEntry() {
    final cOptional = _COptional_CIntRouteEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CIntRouteEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<IntRouteEntry> <-> _CArray_CIntRouteEntry

final class _CArray_CIntRouteEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CIntRouteEntryToDart on _CArray_CIntRouteEntry {
  List<IntRouteEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CIntRouteEntry on List<IntRouteEntry> {
  _CArray_CIntRouteEntry _copyFromDartTo_CArray_CIntRouteEntry() {
    final cArray = _CArray_CIntRouteEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CIntRouteEntry();
        _CArray_CIntRouteEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CIntRouteEntryBasicFunctions on _CArray_CIntRouteEntry {
  void _releaseIntermediate() {
    _CArray_CIntRouteEntry_release(this);
  }

  static final _listToFill = <IntRouteEntry>[];

  static void _iterate(_CIntRouteEntry item) {
    _listToFill.add(item._toDart());
  }

  List<IntRouteEntry> _fillFromC() {
    _forEach_CArray_CIntRouteEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CIntRouteEntry)>(_iterate));
    final result = List<IntRouteEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - ObstacleInfoRouteLongAttribute

/**
 Контейнер, который хранит протяженный атрибут маршрута.
 Каждый элемент хранится в виде пары, состоящей из точки и значения элемента атрибута.
 Действие атрибута начинается с данной точки и заканчивается в следущей точке,
 начиная с которой начинается действие атрибута следующего элемента.
*/
class ObstacleInfoRouteLongAttribute implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Количество элементов. */
  int get size {
    int res = _CObstacleInfoRouteLongAttribute_size(_CObstacleInfoRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Элементы отсутствуют. */
  bool get isEmpty {
    bool res = _CObstacleInfoRouteLongAttribute_isEmpty(_CObstacleInfoRouteLongAttributeMakeDefault().._impl=_self);
    return res;
  }
  /** Первый элемент. */
  ObstacleInfoRouteLongEntry? get first {
    _COptional_CObstacleInfoRouteLongEntry res = _CObstacleInfoRouteLongAttribute_first(_CObstacleInfoRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Последний элемент. */
  ObstacleInfoRouteLongEntry? get last {
    _COptional_CObstacleInfoRouteLongEntry res = _CObstacleInfoRouteLongAttribute_last(_CObstacleInfoRouteLongAttributeMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Все элементы. */
  List<ObstacleInfoRouteLongEntry> get entries {
    _CArray_CObstacleInfoRouteLongEntry res = _CObstacleInfoRouteLongAttribute_entries(_CObstacleInfoRouteLongAttributeMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CObstacleInfoRouteLongAttribute_releasePtr);

  ObstacleInfoRouteLongAttribute._raw(this._self);
  factory ObstacleInfoRouteLongAttribute._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ObstacleInfoRouteLongAttribute._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ObstacleInfoRouteLongAttribute &&
    other.runtimeType == runtimeType &&
    _CObstacleInfoRouteLongAttribute_cg_objectIdentifier(this._self) == _CObstacleInfoRouteLongAttribute_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CObstacleInfoRouteLongAttribute_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: ObstacleInfoRouteLongAttribute: Methods

  /** Элемент, в который попадает заданная точка. */
  ObstacleInfoRouteLongEntry? entry(
    RoutePoint point
  )  {
    var _a1 = point._copyFromDartTo_CRoutePoint();
    _COptional_CObstacleInfoRouteLongEntry res = _CObstacleInfoRouteLongAttribute_entry_CRoutePoint(_CObstacleInfoRouteLongAttributeMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Элементы, частично или полностью покрываемые отрезком [begin, end].
  
   - Throws: Exception если begin > end.
  */
  List<ObstacleInfoRouteLongEntry> entriesInRange(
    RoutePoint begin,
    RoutePoint end
  )  {
    var _a1 = begin._copyFromDartTo_CRoutePoint();
    var _a2 = end._copyFromDartTo_CRoutePoint();
    _CArray_CObstacleInfoRouteLongEntry res = _CObstacleInfoRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint(_CObstacleInfoRouteLongAttributeMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - ObstacleInfoRouteLongAttribute <-> CObstacleInfoRouteLongAttribute

final class _CObstacleInfoRouteLongAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CObstacleInfoRouteLongAttributeBasicFunctions on _CObstacleInfoRouteLongAttribute {
  void _releaseIntermediate() {
    _CObstacleInfoRouteLongAttribute_release(_impl);
  }

  _CObstacleInfoRouteLongAttribute _retain() {
    return _CObstacleInfoRouteLongAttribute_retain(_impl);
  }
}

extension _CObstacleInfoRouteLongAttributeToDart on _CObstacleInfoRouteLongAttribute {
  ObstacleInfoRouteLongAttribute _toDart() {
    return ObstacleInfoRouteLongAttribute._create(_retain()._impl);
  }
}


extension _DartToCObstacleInfoRouteLongAttribute on ObstacleInfoRouteLongAttribute {
  _CObstacleInfoRouteLongAttribute _copyFromDartTo_CObstacleInfoRouteLongAttribute() {
    return (_CObstacleInfoRouteLongAttributeMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ObstacleInfoRouteLongEntry

/** Протяженный элемент маршрута - отрезок и значение на нем. */
class ObstacleInfoRouteLongEntry {
  final RoutePoint point;
  final RouteDistance length;
  final ObstacleInfo value;

  const ObstacleInfoRouteLongEntry({
    required this.point,
    required this.length,
    required this.value
  });

  ObstacleInfoRouteLongEntry copyWith({
    RoutePoint? point,
    RouteDistance? length,
    ObstacleInfo? value
  }) {
    return ObstacleInfoRouteLongEntry(
      point: point ?? this.point,
      length: length ?? this.length,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ObstacleInfoRouteLongEntry &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.length == length &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(point, length, value);
  }

}
final class _CObstacleInfoRouteLongEntry extends ffi.Struct {
  external _CRoutePoint point;

  external _CRouteDistance length;

  external _CObstacleInfo value;

}
// MARK: - ObstacleInfoRouteLongEntry <-> _CObstacleInfoRouteLongEntry

extension _CObstacleInfoRouteLongEntryToDart on _CObstacleInfoRouteLongEntry {
  ObstacleInfoRouteLongEntry _toDart() {
    return ObstacleInfoRouteLongEntry(
      point: this.point._toDart(),
      length: this.length._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CObstacleInfoRouteLongEntry on ObstacleInfoRouteLongEntry {
  _CObstacleInfoRouteLongEntry _copyFromDartTo_CObstacleInfoRouteLongEntry() {
    final res = _CObstacleInfoRouteLongEntryMakeDefault();
    res.point = this.point._copyFromDartTo_CRoutePoint();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.value = this.value._copyFromDartTo_CObstacleInfo();
    return res;
  }
}
extension _CObstacleInfoRouteLongEntryRelease on _CObstacleInfoRouteLongEntry {
  void _releaseIntermediate() {
  }
}

// MARK: - ObstacleInfoRouteLongEntry? <-> _COptional_CObstacleInfoRouteLongEntry

final class _COptional_CObstacleInfoRouteLongEntry extends ffi.Struct {
  
  external _CObstacleInfoRouteLongEntry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CObstacleInfoRouteLongEntryBasicFunctions on _COptional_CObstacleInfoRouteLongEntry {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CObstacleInfoRouteLongEntryToDart on _COptional_CObstacleInfoRouteLongEntry {
  ObstacleInfoRouteLongEntry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CObstacleInfoRouteLongEntry on ObstacleInfoRouteLongEntry? {
  _COptional_CObstacleInfoRouteLongEntry _copyFromDartTo_COptional_CObstacleInfoRouteLongEntry() {
    final cOptional = _COptional_CObstacleInfoRouteLongEntryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CObstacleInfoRouteLongEntry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<ObstacleInfoRouteLongEntry> <-> _CArray_CObstacleInfoRouteLongEntry

final class _CArray_CObstacleInfoRouteLongEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CObstacleInfoRouteLongEntryToDart on _CArray_CObstacleInfoRouteLongEntry {
  List<ObstacleInfoRouteLongEntry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CObstacleInfoRouteLongEntry on List<ObstacleInfoRouteLongEntry> {
  _CArray_CObstacleInfoRouteLongEntry _copyFromDartTo_CArray_CObstacleInfoRouteLongEntry() {
    final cArray = _CArray_CObstacleInfoRouteLongEntrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CObstacleInfoRouteLongEntry();
        _CArray_CObstacleInfoRouteLongEntryaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CObstacleInfoRouteLongEntryBasicFunctions on _CArray_CObstacleInfoRouteLongEntry {
  void _releaseIntermediate() {
    _CArray_CObstacleInfoRouteLongEntry_release(this);
  }

  static final _listToFill = <ObstacleInfoRouteLongEntry>[];

  static void _iterate(_CObstacleInfoRouteLongEntry item) {
    _listToFill.add(item._toDart());
  }

  List<ObstacleInfoRouteLongEntry> _fillFromC() {
    _forEach_CArray_CObstacleInfoRouteLongEntry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CObstacleInfoRouteLongEntry)>(_iterate));
    final result = List<ObstacleInfoRouteLongEntry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - BicycleBriefRouteInfo

/** Базовая информация о велосипедном маршруте. */
class BicycleBriefRouteInfo {
  /** Длина маршрута. */
  final RouteDistance length;
  /** Ориентир. */
  final String landmark;

  const BicycleBriefRouteInfo({
    required this.length,
    required this.landmark
  });

  BicycleBriefRouteInfo copyWith({
    RouteDistance? length,
    String? landmark
  }) {
    return BicycleBriefRouteInfo(
      length: length ?? this.length,
      landmark: landmark ?? this.landmark
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BicycleBriefRouteInfo &&
    other.runtimeType == runtimeType &&
    other.length == length &&
    other.landmark == landmark;

  @override
  int get hashCode {
    return Object.hash(length, landmark);
  }

}
final class _CBicycleBriefRouteInfo extends ffi.Struct {
  external _CRouteDistance length;

  external _CString landmark;

}
// MARK: - BicycleBriefRouteInfo <-> _CBicycleBriefRouteInfo

extension _CBicycleBriefRouteInfoToDart on _CBicycleBriefRouteInfo {
  BicycleBriefRouteInfo _toDart() {
    return BicycleBriefRouteInfo(
      length: this.length._toDart(),
      landmark: this.landmark._toDart()
    );
  }
}

extension _DartTo_CBicycleBriefRouteInfo on BicycleBriefRouteInfo {
  _CBicycleBriefRouteInfo _copyFromDartTo_CBicycleBriefRouteInfo() {
    final res = _CBicycleBriefRouteInfoMakeDefault();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.landmark = this.landmark._copyFromDartTo_CString();
    return res;
  }
}
extension _CBicycleBriefRouteInfoRelease on _CBicycleBriefRouteInfo {
  void _releaseIntermediate() {
    landmark._releaseIntermediate();
  }
}

// MARK: - CarBriefRouteInfoTrafficSpeed

/** Скорость движения. */
enum CarBriefRouteInfoTrafficSpeed {
  /** Скорость неизвестна. */
  unknown(0),
  /** Низкая скорость движения. */
  slow(1),
  /** Нормальная скорость движения. */
  normal(2),
  /** Высокая скорость движения. */
  fast(3),
  ;

  const CarBriefRouteInfoTrafficSpeed(this.rawValue);
  final int rawValue;

  static CarBriefRouteInfoTrafficSpeed getByValue(int value) {
    return CarBriefRouteInfoTrafficSpeed.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCarBriefRouteInfoTrafficSpeed extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCarBriefRouteInfoTrafficSpeedBasicFunctions on _CCarBriefRouteInfoTrafficSpeed {
  void _releaseIntermediate() {
  }
}

extension _CCarBriefRouteInfoTrafficSpeedToDart on _CCarBriefRouteInfoTrafficSpeed {
  CarBriefRouteInfoTrafficSpeed _toDart() {
    return CarBriefRouteInfoTrafficSpeed.getByValue(this.rawValue);
  }
}

extension _DartTo_CCarBriefRouteInfoTrafficSpeed on CarBriefRouteInfoTrafficSpeed {
  _CCarBriefRouteInfoTrafficSpeed _copyFromDartTo_CCarBriefRouteInfoTrafficSpeed() {
    return _CCarBriefRouteInfoTrafficSpeedMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CarBriefRouteInfo

/** Базовая информация об автомобильном маршруте. */
class CarBriefRouteInfo {
  /** Длина маршрута. */
  final RouteDistance length;
  /** Ориентир. */
  final String landmark;
  /** Скорость движения. */
  final CarBriefRouteInfoTrafficSpeed trafficSpeed;

  const CarBriefRouteInfo({
    required this.length,
    required this.landmark,
    required this.trafficSpeed
  });

  CarBriefRouteInfo copyWith({
    RouteDistance? length,
    String? landmark,
    CarBriefRouteInfoTrafficSpeed? trafficSpeed
  }) {
    return CarBriefRouteInfo(
      length: length ?? this.length,
      landmark: landmark ?? this.landmark,
      trafficSpeed: trafficSpeed ?? this.trafficSpeed
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CarBriefRouteInfo &&
    other.runtimeType == runtimeType &&
    other.length == length &&
    other.landmark == landmark &&
    other.trafficSpeed == trafficSpeed;

  @override
  int get hashCode {
    return Object.hash(length, landmark, trafficSpeed);
  }

}
final class _CCarBriefRouteInfo extends ffi.Struct {
  external _CRouteDistance length;

  external _CString landmark;

  external _CCarBriefRouteInfoTrafficSpeed trafficSpeed;

}
// MARK: - CarBriefRouteInfo <-> _CCarBriefRouteInfo

extension _CCarBriefRouteInfoToDart on _CCarBriefRouteInfo {
  CarBriefRouteInfo _toDart() {
    return CarBriefRouteInfo(
      length: this.length._toDart(),
      landmark: this.landmark._toDart(),
      trafficSpeed: this.trafficSpeed._toDart()
    );
  }
}

extension _DartTo_CCarBriefRouteInfo on CarBriefRouteInfo {
  _CCarBriefRouteInfo _copyFromDartTo_CCarBriefRouteInfo() {
    final res = _CCarBriefRouteInfoMakeDefault();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.landmark = this.landmark._copyFromDartTo_CString();
    res.trafficSpeed = this.trafficSpeed._copyFromDartTo_CCarBriefRouteInfoTrafficSpeed();
    return res;
  }
}
extension _CCarBriefRouteInfoRelease on _CCarBriefRouteInfo {
  void _releaseIntermediate() {
    landmark._releaseIntermediate();
  }
}

// MARK: - PedestrianBriefRouteInfo

/** Базовая информация о пешеходном маршруте. */
class PedestrianBriefRouteInfo {
  /** Длина маршрута. */
  final RouteDistance length;
  /** Ориентир. */
  final String landmark;

  const PedestrianBriefRouteInfo({
    required this.length,
    required this.landmark
  });

  PedestrianBriefRouteInfo copyWith({
    RouteDistance? length,
    String? landmark
  }) {
    return PedestrianBriefRouteInfo(
      length: length ?? this.length,
      landmark: landmark ?? this.landmark
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PedestrianBriefRouteInfo &&
    other.runtimeType == runtimeType &&
    other.length == length &&
    other.landmark == landmark;

  @override
  int get hashCode {
    return Object.hash(length, landmark);
  }

}
final class _CPedestrianBriefRouteInfo extends ffi.Struct {
  external _CRouteDistance length;

  external _CString landmark;

}
// MARK: - PedestrianBriefRouteInfo <-> _CPedestrianBriefRouteInfo

extension _CPedestrianBriefRouteInfoToDart on _CPedestrianBriefRouteInfo {
  PedestrianBriefRouteInfo _toDart() {
    return PedestrianBriefRouteInfo(
      length: this.length._toDart(),
      landmark: this.landmark._toDart()
    );
  }
}

extension _DartTo_CPedestrianBriefRouteInfo on PedestrianBriefRouteInfo {
  _CPedestrianBriefRouteInfo _copyFromDartTo_CPedestrianBriefRouteInfo() {
    final res = _CPedestrianBriefRouteInfoMakeDefault();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.landmark = this.landmark._copyFromDartTo_CString();
    return res;
  }
}
extension _CPedestrianBriefRouteInfoRelease on _CPedestrianBriefRouteInfo {
  void _releaseIntermediate() {
    landmark._releaseIntermediate();
  }
}

// MARK: - PublicBriefRouteTransportInfo

/** Описание общественного транспортного средства. */
class PublicBriefRouteTransportInfo {
  /** Тип общественного транспортного средства. */
  final PublicTransportType type;
  /** Названия маршрутов общественного транспорта, на которых происходит проезд. */
  final List<String> names;
  /**
   Argb представление цвета, ассоциированного с данным видом общественного транспорта,
   например, цвет линии метро. При отсутствии информации о цвете в поле будет значение null.
  */
  final int? color;
  /** Идентификатор иконки для остановок маршрута. Пустая строка, если информация недоступна. Техническое поле. */
  final String routeLogo;

  const PublicBriefRouteTransportInfo({
    this.type = PublicTransportType.bus,
    required this.names,
    required this.color,
    required this.routeLogo
  });

  PublicBriefRouteTransportInfo copyWith({
    PublicTransportType? type,
    List<String>? names,
    Optional<int?>? color,
    String? routeLogo
  }) {
    return PublicBriefRouteTransportInfo(
      type: type ?? this.type,
      names: names ?? this.names,
      color: color != null ? color.value : this.color,
      routeLogo: routeLogo ?? this.routeLogo
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PublicBriefRouteTransportInfo &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.names == names &&
    other.color == color &&
    other.routeLogo == routeLogo;

  @override
  int get hashCode {
    return Object.hash(type, names, color, routeLogo);
  }

}
final class _CPublicBriefRouteTransportInfo extends ffi.Struct {
  external _CPublicTransportType type;

  external _CArray_CString names;

  external _COptional_uint32_t color;

  external _CString routeLogo;

}
// MARK: - PublicBriefRouteTransportInfo <-> _CPublicBriefRouteTransportInfo

extension _CPublicBriefRouteTransportInfoToDart on _CPublicBriefRouteTransportInfo {
  PublicBriefRouteTransportInfo _toDart() {
    return PublicBriefRouteTransportInfo(
      type: this.type._toDart(),
      names: this.names._toDart(),
      color: this.color._toDart(),
      routeLogo: this.routeLogo._toDart()
    );
  }
}

extension _DartTo_CPublicBriefRouteTransportInfo on PublicBriefRouteTransportInfo {
  _CPublicBriefRouteTransportInfo _copyFromDartTo_CPublicBriefRouteTransportInfo() {
    final res = _CPublicBriefRouteTransportInfoMakeDefault();
    res.type = this.type._copyFromDartTo_CPublicTransportType();
    res.names = this.names._copyFromDartTo_CArray_CString();
    res.color = this.color._copyFromDartTo_COptional_uint32_t();
    res.routeLogo = this.routeLogo._copyFromDartTo_CString();
    return res;
  }
}
extension _CPublicBriefRouteTransportInfoRelease on _CPublicBriefRouteTransportInfo {
  void _releaseIntermediate() {
    names._releaseIntermediate();
    routeLogo._releaseIntermediate();
  }
}

// MARK: - List<PublicBriefRouteTransportInfo> <-> _CArray_CPublicBriefRouteTransportInfo

final class _CArray_CPublicBriefRouteTransportInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CPublicBriefRouteTransportInfoToDart on _CArray_CPublicBriefRouteTransportInfo {
  List<PublicBriefRouteTransportInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CPublicBriefRouteTransportInfo on List<PublicBriefRouteTransportInfo> {
  _CArray_CPublicBriefRouteTransportInfo _copyFromDartTo_CArray_CPublicBriefRouteTransportInfo() {
    final cArray = _CArray_CPublicBriefRouteTransportInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CPublicBriefRouteTransportInfo();
        _CArray_CPublicBriefRouteTransportInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CPublicBriefRouteTransportInfoBasicFunctions on _CArray_CPublicBriefRouteTransportInfo {
  void _releaseIntermediate() {
    _CArray_CPublicBriefRouteTransportInfo_release(this);
  }

  static final _listToFill = <PublicBriefRouteTransportInfo>[];

  static void _iterate(_CPublicBriefRouteTransportInfo item) {
    _listToFill.add(item._toDart());
  }

  List<PublicBriefRouteTransportInfo> _fillFromC() {
    _forEach_CArray_CPublicBriefRouteTransportInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CPublicBriefRouteTransportInfo)>(_iterate));
    final result = List<PublicBriefRouteTransportInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - PublicBriefRouteInfo

/** Базовая информация о маршруте на общественном транспорте. */
class PublicBriefRouteInfo {
  /** Описание способов проезда на общественном транспорте. */
  final List<PublicBriefRouteTransportInfo> publicTransportInfos;

  const PublicBriefRouteInfo(this.publicTransportInfos);

  PublicBriefRouteInfo copyWith({
    List<PublicBriefRouteTransportInfo>? publicTransportInfos
  }) {
    return PublicBriefRouteInfo(
      publicTransportInfos ?? this.publicTransportInfos
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PublicBriefRouteInfo &&
    other.runtimeType == runtimeType &&
    other.publicTransportInfos == publicTransportInfos;

  @override
  int get hashCode {
    return publicTransportInfos.hashCode;
  }

}
final class _CPublicBriefRouteInfo extends ffi.Struct {
  external _CArray_CPublicBriefRouteTransportInfo publicTransportInfos;

}
// MARK: - PublicBriefRouteInfo <-> _CPublicBriefRouteInfo

extension _CPublicBriefRouteInfoToDart on _CPublicBriefRouteInfo {
  PublicBriefRouteInfo _toDart() {
    return PublicBriefRouteInfo(
      this.publicTransportInfos._toDart()
    );
  }
}

extension _DartTo_CPublicBriefRouteInfo on PublicBriefRouteInfo {
  _CPublicBriefRouteInfo _copyFromDartTo_CPublicBriefRouteInfo() {
    final res = _CPublicBriefRouteInfoMakeDefault();
    res.publicTransportInfos = this.publicTransportInfos._copyFromDartTo_CArray_CPublicBriefRouteTransportInfo();
    return res;
  }
}
extension _CPublicBriefRouteInfoRelease on _CPublicBriefRouteInfo {
  void _releaseIntermediate() {
    publicTransportInfos._releaseIntermediate();
  }
}

// MARK: - ScooterBriefRouteInfo

/** Базовая информация о маршруте на самокате. */
class ScooterBriefRouteInfo {
  /** Длина маршрута. */
  final RouteDistance length;
  /** Ориентир. */
  final String landmark;

  const ScooterBriefRouteInfo({
    required this.length,
    required this.landmark
  });

  ScooterBriefRouteInfo copyWith({
    RouteDistance? length,
    String? landmark
  }) {
    return ScooterBriefRouteInfo(
      length: length ?? this.length,
      landmark: landmark ?? this.landmark
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScooterBriefRouteInfo &&
    other.runtimeType == runtimeType &&
    other.length == length &&
    other.landmark == landmark;

  @override
  int get hashCode {
    return Object.hash(length, landmark);
  }

}
final class _CScooterBriefRouteInfo extends ffi.Struct {
  external _CRouteDistance length;

  external _CString landmark;

}
// MARK: - ScooterBriefRouteInfo <-> _CScooterBriefRouteInfo

extension _CScooterBriefRouteInfoToDart on _CScooterBriefRouteInfo {
  ScooterBriefRouteInfo _toDart() {
    return ScooterBriefRouteInfo(
      length: this.length._toDart(),
      landmark: this.landmark._toDart()
    );
  }
}

extension _DartTo_CScooterBriefRouteInfo on ScooterBriefRouteInfo {
  _CScooterBriefRouteInfo _copyFromDartTo_CScooterBriefRouteInfo() {
    final res = _CScooterBriefRouteInfoMakeDefault();
    res.length = this.length._copyFromDartTo_CRouteDistance();
    res.landmark = this.landmark._copyFromDartTo_CString();
    return res;
  }
}
extension _CScooterBriefRouteInfoRelease on _CScooterBriefRouteInfo {
  void _releaseIntermediate() {
    landmark._releaseIntermediate();
  }
}

// MARK: - BriefExtraRouteInfo

/** Дополнительная информация о маршруте для конкретного типа транспорта. */
final class BriefExtraRouteInfo {
  final Object? _value;
  final int _index;

  BriefExtraRouteInfo._raw(this._value, this._index);

  BriefExtraRouteInfo.bicycle(BicycleBriefRouteInfo value) : this._raw(value, 0);
  BriefExtraRouteInfo.car(CarBriefRouteInfo value) : this._raw(value, 1);
  BriefExtraRouteInfo.pedestrian(PedestrianBriefRouteInfo value) : this._raw(value, 2);
  BriefExtraRouteInfo.publicTransport(PublicBriefRouteInfo value) : this._raw(value, 3);
  BriefExtraRouteInfo.scooter(ScooterBriefRouteInfo value) : this._raw(value, 4);

  bool get isBicycle => this._index == 0;
  BicycleBriefRouteInfo? get asBicycle => this.isBicycle ? this._value as BicycleBriefRouteInfo : null;

  bool get isCar => this._index == 1;
  CarBriefRouteInfo? get asCar => this.isCar ? this._value as CarBriefRouteInfo : null;

  bool get isPedestrian => this._index == 2;
  PedestrianBriefRouteInfo? get asPedestrian => this.isPedestrian ? this._value as PedestrianBriefRouteInfo : null;

  bool get isPublicTransport => this._index == 3;
  PublicBriefRouteInfo? get asPublicTransport => this.isPublicTransport ? this._value as PublicBriefRouteInfo : null;

  bool get isScooter => this._index == 4;
  ScooterBriefRouteInfo? get asScooter => this.isScooter ? this._value as ScooterBriefRouteInfo : null;

  T match<T>({
    required T Function(BicycleBriefRouteInfo value) bicycle,
    required T Function(CarBriefRouteInfo value) car,
    required T Function(PedestrianBriefRouteInfo value) pedestrian,
    required T Function(PublicBriefRouteInfo value) publicTransport,
    required T Function(ScooterBriefRouteInfo value) scooter,
  }) {
    return switch (this._index) {
      0 => bicycle(this._value as BicycleBriefRouteInfo),
      1 => car(this._value as CarBriefRouteInfo),
      2 => pedestrian(this._value as PedestrianBriefRouteInfo),
      3 => publicTransport(this._value as PublicBriefRouteInfo),
      4 => scooter(this._value as ScooterBriefRouteInfo),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "BriefExtraRouteInfo(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BriefExtraRouteInfo &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CBriefExtraRouteInfoImpl extends ffi.Union {
  external _CBicycleBriefRouteInfo _bicycle;
  external _CCarBriefRouteInfo _car;
  external _CPedestrianBriefRouteInfo _pedestrian;
  external _CPublicBriefRouteInfo _publicTransport;
  external _CScooterBriefRouteInfo _scooter;
}

final class _CBriefExtraRouteInfo extends ffi.Struct {
  external _CBriefExtraRouteInfoImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CBriefExtraRouteInfoBasicFunctions on _CBriefExtraRouteInfo {
  void _releaseIntermediate() {
    _CBriefExtraRouteInfo_release(this);
  }
}
	
// MARK: - BriefExtraRouteInfo <-> CBriefExtraRouteInfo

extension _CBriefExtraRouteInfoToDart on _CBriefExtraRouteInfo {
  BriefExtraRouteInfo _toDart() {
    return switch (this._index) {
      0 => BriefExtraRouteInfo.bicycle(this._impl._bicycle._toDart()),
      1 => BriefExtraRouteInfo.car(this._impl._car._toDart()),
      2 => BriefExtraRouteInfo.pedestrian(this._impl._pedestrian._toDart()),
      3 => BriefExtraRouteInfo.publicTransport(this._impl._publicTransport._toDart()),
      4 => BriefExtraRouteInfo.scooter(this._impl._scooter._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CBriefExtraRouteInfo on BriefExtraRouteInfo {
  _CBriefExtraRouteInfo _copyFromDartTo_CBriefExtraRouteInfo() {
    var res = _CBriefExtraRouteInfoMakeDefault();
    this.match<void>(
      bicycle: (BicycleBriefRouteInfo value) {
        res._impl._bicycle = value._copyFromDartTo_CBicycleBriefRouteInfo();
        res._index = 0;
      },
      car: (CarBriefRouteInfo value) {
        res._impl._car = value._copyFromDartTo_CCarBriefRouteInfo();
        res._index = 1;
      },
      pedestrian: (PedestrianBriefRouteInfo value) {
        res._impl._pedestrian = value._copyFromDartTo_CPedestrianBriefRouteInfo();
        res._index = 2;
      },
      publicTransport: (PublicBriefRouteInfo value) {
        res._impl._publicTransport = value._copyFromDartTo_CPublicBriefRouteInfo();
        res._index = 3;
      },
      scooter: (ScooterBriefRouteInfo value) {
        res._impl._scooter = value._copyFromDartTo_CScooterBriefRouteInfo();
        res._index = 4;
      },
    );
    return res;
  }
}

// MARK: - BriefRouteInfo

/** Базовая информация о маршруте. */
class BriefRouteInfo {
  /** Время движения по маршруту. */
  final Duration duration;
  /** Дополнительная информация о маршруте для конкретного типа транспорта. */
  final BriefExtraRouteInfo extraInfo;

  const BriefRouteInfo({
    required this.duration,
    required this.extraInfo
  });

  BriefRouteInfo copyWith({
    Duration? duration,
    BriefExtraRouteInfo? extraInfo
  }) {
    return BriefRouteInfo(
      duration: duration ?? this.duration,
      extraInfo: extraInfo ?? this.extraInfo
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BriefRouteInfo &&
    other.runtimeType == runtimeType &&
    other.duration == duration &&
    other.extraInfo == extraInfo;

  @override
  int get hashCode {
    return Object.hash(duration, extraInfo);
  }

}
final class _CBriefRouteInfo extends ffi.Struct {
  external _CTimeInterval duration;

  external _CBriefExtraRouteInfo extraInfo;

}
// MARK: - BriefRouteInfo <-> _CBriefRouteInfo

extension _CBriefRouteInfoToDart on _CBriefRouteInfo {
  BriefRouteInfo _toDart() {
    return BriefRouteInfo(
      duration: this.duration._toDart(),
      extraInfo: this.extraInfo._toDart()
    );
  }
}

extension _DartTo_CBriefRouteInfo on BriefRouteInfo {
  _CBriefRouteInfo _copyFromDartTo_CBriefRouteInfo() {
    final res = _CBriefRouteInfoMakeDefault();
    res.duration = this.duration._copyFromDartTo_CTimeInterval();
    res.extraInfo = this.extraInfo._copyFromDartTo_CBriefExtraRouteInfo();
    return res;
  }
}
extension _CBriefRouteInfoRelease on _CBriefRouteInfo {
  void _releaseIntermediate() {
    extraInfo._releaseIntermediate();
  }
}

// MARK: - BriefRouteInfoSearchPoints

/** Точки для запроса поиска базовой информации о маршруте. */
class BriefRouteInfoSearchPoints {
  /** Начальная точка маршрута. */
  final RouteSearchPoint startPoint;
  /** Конечная точка маршрута. */
  final RouteSearchPoint finishPoint;

  const BriefRouteInfoSearchPoints({
    required this.startPoint,
    required this.finishPoint
  });

  BriefRouteInfoSearchPoints copyWith({
    RouteSearchPoint? startPoint,
    RouteSearchPoint? finishPoint
  }) {
    return BriefRouteInfoSearchPoints(
      startPoint: startPoint ?? this.startPoint,
      finishPoint: finishPoint ?? this.finishPoint
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BriefRouteInfoSearchPoints &&
    other.runtimeType == runtimeType &&
    other.startPoint == startPoint &&
    other.finishPoint == finishPoint;

  @override
  int get hashCode {
    return Object.hash(startPoint, finishPoint);
  }

}
final class _CBriefRouteInfoSearchPoints extends ffi.Struct {
  external _CRouteSearchPoint startPoint;

  external _CRouteSearchPoint finishPoint;

}
// MARK: - BriefRouteInfoSearchPoints <-> _CBriefRouteInfoSearchPoints

extension _CBriefRouteInfoSearchPointsToDart on _CBriefRouteInfoSearchPoints {
  BriefRouteInfoSearchPoints _toDart() {
    return BriefRouteInfoSearchPoints(
      startPoint: this.startPoint._toDart(),
      finishPoint: this.finishPoint._toDart()
    );
  }
}

extension _DartTo_CBriefRouteInfoSearchPoints on BriefRouteInfoSearchPoints {
  _CBriefRouteInfoSearchPoints _copyFromDartTo_CBriefRouteInfoSearchPoints() {
    final res = _CBriefRouteInfoSearchPointsMakeDefault();
    res.startPoint = this.startPoint._copyFromDartTo_CRouteSearchPoint();
    res.finishPoint = this.finishPoint._copyFromDartTo_CRouteSearchPoint();
    return res;
  }
}
extension _CBriefRouteInfoSearchPointsRelease on _CBriefRouteInfoSearchPoints {
  void _releaseIntermediate() {
  }
}

// MARK: - Set<TruckPassZoneId> <-> _CSet_CTruckPassZoneId

final class _CSet_CTruckPassZoneId extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSet_CTruckPassZoneIdToDart on _CSet_CTruckPassZoneId {
  Set<TruckPassZoneId> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CSet_CTruckPassZoneId on Set<TruckPassZoneId> {
  _CSet_CTruckPassZoneId _copyFromDartTo_CSet_CTruckPassZoneId() {
    final cSet = _CSet_CTruckPassZoneIdmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CTruckPassZoneId();
        _CSet_CTruckPassZoneIdaddElement(cSet, cItem);
        
    });
    return cSet;
  }
}

extension _CSet_CTruckPassZoneIdBasicFunctions on _CSet_CTruckPassZoneId {
  void _releaseIntermediate() {
    _CSet_CTruckPassZoneId_release(this);
  }

 static final _setToFill = <TruckPassZoneId>{};

  static void _iterate(_CTruckPassZoneId item) {
    _setToFill.add(item._toDart());
  }

  Set<TruckPassZoneId> _fillFromC() {
    _forEach_CSet_CTruckPassZoneId(this, ffi.Pointer.fromFunction<ffi.Void Function(_CTruckPassZoneId)>(_iterate));
    final result = Set<TruckPassZoneId>.from(_setToFill);
    _setToFill.clear();
    return result;
  }
}
	
// MARK: - TruckPassZonePass

/** Пропуск, разрешающий движение грузового транспорта в пропускных зонах. */
class TruckPassZonePass {
  /** Идентификатор пропуска. */
  final TruckPassZonePassId id;
  /** Название пропуска. */
  final String name;
  /** Идентификаторы пропускных зон, по которым разрешает движение данный пропуск */
  final Set<TruckPassZoneId> passZoneIds;

  const TruckPassZonePass({
    required this.id,
    required this.name,
    required this.passZoneIds
  });

  TruckPassZonePass copyWith({
    TruckPassZonePassId? id,
    String? name,
    Set<TruckPassZoneId>? passZoneIds
  }) {
    return TruckPassZonePass(
      id: id ?? this.id,
      name: name ?? this.name,
      passZoneIds: passZoneIds ?? this.passZoneIds
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TruckPassZonePass &&
    other.runtimeType == runtimeType &&
    other.id == id &&
    other.name == name &&
    other.passZoneIds == passZoneIds;

  @override
  int get hashCode {
    return Object.hash(id, name, passZoneIds);
  }

}
final class _CTruckPassZonePass extends ffi.Struct {
  external _CTruckPassZonePassId id;

  external _CString name;

  external _CSet_CTruckPassZoneId passZoneIds;

}
// MARK: - TruckPassZonePass <-> _CTruckPassZonePass

extension _CTruckPassZonePassToDart on _CTruckPassZonePass {
  TruckPassZonePass _toDart() {
    return TruckPassZonePass(
      id: this.id._toDart(),
      name: this.name._toDart(),
      passZoneIds: this.passZoneIds._toDart()
    );
  }
}

extension _DartTo_CTruckPassZonePass on TruckPassZonePass {
  _CTruckPassZonePass _copyFromDartTo_CTruckPassZonePass() {
    final res = _CTruckPassZonePassMakeDefault();
    res.id = this.id._copyFromDartTo_CTruckPassZonePassId();
    res.name = this.name._copyFromDartTo_CString();
    res.passZoneIds = this.passZoneIds._copyFromDartTo_CSet_CTruckPassZoneId();
    return res;
  }
}
extension _CTruckPassZonePassRelease on _CTruckPassZonePass {
  void _releaseIntermediate() {
    name._releaseIntermediate();
    passZoneIds._releaseIntermediate();
  }
}

// MARK: - TrafficRouter

/** Интерфейс для поиска маршрута с учетом пробочных данных. */
class TrafficRouter implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Возвращает список всех поддерживаемых пропусков, разрешающих движение грузового транспорта в пределах пропускных
   зон.
  
   - Returns: Future с пропусками для грузового транспорта, либо исключением Exception в случае ошибки.
  */
  CancelableOperation<List<TruckPassZonePass>> get truckPassZonePasses {
    _CFuture_CArray_CTruckPassZonePass res = _CTrafficRouter_truckPassZonePasses(_CTrafficRouterMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CTrafficRouter_releasePtr);

  TrafficRouter._raw(this._self);
  factory TrafficRouter._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TrafficRouter._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   - Throws: Exception, если отсутствует системный контекст или если из него
   невозможно получить ITrafficRouterPtr
  */
  factory TrafficRouter(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CTrafficRouter res = _CTrafficRouter_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return TrafficRouter._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficRouter &&
    other.runtimeType == runtimeType &&
    _CTrafficRouter_cg_objectIdentifier(this._self) == _CTrafficRouter_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTrafficRouter_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: TrafficRouter: Methods

  /**
   Ищет маршрут по заданным параметрам.
  
   - Parameter startPoint: Начальная точка маршрута.
   - Parameter finishPoint: Конечная точка маршрута.
   - Parameter routeSearchOptions: Параметры поиска маршрута.
   - Parameter intermediatePoints: Промежуточные точки для проезда в том же порядке,
   в котором точки заданы в векторе.
   - Returns: Future с набором найденных маршрутов, либо с исключением Exception в случае ошибки.
   - Note: Пустой набор маршрутов является валидным результатом - это означает, что маршрут,
   соответствующий указанным критериям поиска, не может быть найден.
   - Note: При поиске маршрутов для грузового транспорта возможен возврат маршрутов,
   проходящих через пропускные зоны, для которых не были предоставлены пропуска,
   в случае, если не удалось проложить маршрут только через пропускные зоны, для
   которых пропуска были предоставлены. Для проверки того, достаточен ли список
   пропусков для проезда по маршруту, следует использовать функцию route_matches_truck_pass_zone_passes.
  */
  CancelableOperation<List<TrafficRoute>> findRoute(
    RouteSearchPoint startPoint,
    RouteSearchPoint finishPoint,
    RouteSearchOptions routeSearchOptions,
    [List<RouteSearchPoint> intermediatePoints = const []
    ])  {
    var _a1 = startPoint._copyFromDartTo_CRouteSearchPoint();
    var _a2 = finishPoint._copyFromDartTo_CRouteSearchPoint();
    var _a3 = routeSearchOptions._copyFromDartTo_CRouteSearchOptions();
    var _a4 = intermediatePoints._copyFromDartTo_CArray_CRouteSearchPoint();
    _CFuture_CArray_CTrafficRoute res = _CTrafficRouter_findRoute_CRouteSearchPoint_CRouteSearchPoint_CRouteSearchOptions_CArray_CRouteSearchPoint(_CTrafficRouterMakeDefault().._impl=_self, _a1, _a2, _a3, _a4);
    _a4._releaseIntermediate();
    _a3._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Ищет маршрут по ранее сериализованным параметрам.
  
   - Parameter request: Сериализованные параметры запроса.
   - Parameter serverEndpoint: Тип искомого маршрута, выступает частью урла, по которому отсылается запрос: bicycle, carrouting, pedestrian, truck.
   - Returns: Future с набором найденных маршрутов, либо с исключением Exception в случае ошибки.
   - Note: Не подходит для поиска маршрутов общественного транспорта.
   - Note: При невозможности найти маршруты для грузового транспорта не пытается найти маршруты на легковом автомобиле без учёта грузовых данных.
  */
  CancelableOperation<List<TrafficRoute>> requestRoute(
    ByteData request,
    String serverEndpoint
  )  {
    var _a1 = request._copyFromDartTo_CData();
    var _a2 = serverEndpoint._copyFromDartTo_CString();
    _CFuture_CArray_CTrafficRoute res = _CTrafficRouter_requestRoute_CData_CString(_CTrafficRouterMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Ищет базовую информацию о маршрутах для соответствующего набора поисковых точек.
  
   - Parameter searchPoints: Набор точек для поиска базовой информации о маршруте.
   - Parameter routeSearchOptions: Параметры поиска маршрута.
   - Returns: Future с базовой информацией о наборе маршрутов, соответствующему набору точек поиска, либо исключением Exception в случае ошибки.
   - Note: Если базовая информация для каких-либо из пар точек не будет найдена, элемент с соответствующим индексом
   в возвращённом результате будет иметь значение null.
  */
  CancelableOperation<List<BriefRouteInfo?>> findBriefRouteInfos(
    List<BriefRouteInfoSearchPoints> searchPoints,
    RouteSearchOptions routeSearchOptions
  )  {
    var _a1 = searchPoints._copyFromDartTo_CArray_CBriefRouteInfoSearchPoints();
    var _a2 = routeSearchOptions._copyFromDartTo_CRouteSearchOptions();
    _CFuture_CArray_COptional_CBriefRouteInfo res = _CTrafficRouter_findBriefRouteInfos_CArray_CBriefRouteInfoSearchPoints_CRouteSearchOptions(_CTrafficRouterMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - TrafficRouter <-> CTrafficRouter

final class _CTrafficRouter extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTrafficRouterBasicFunctions on _CTrafficRouter {
  void _releaseIntermediate() {
    _CTrafficRouter_release(_impl);
  }

  _CTrafficRouter _retain() {
    return _CTrafficRouter_retain(_impl);
  }
}

extension _CTrafficRouterToDart on _CTrafficRouter {
  TrafficRouter _toDart() {
    return TrafficRouter._create(_retain()._impl);
  }
}


extension _DartToCTrafficRouter on TrafficRouter {
  _CTrafficRouter _copyFromDartTo_CTrafficRouter() {
    return (_CTrafficRouterMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<List<TrafficRoute>> <-> _CFuture_CArray_CTrafficRoute

final class _CFuture_CArray_CTrafficRoute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CArray_CTrafficRoute_Cancellable {
  final Completer<List<TrafficRoute>> completer;
  final _CFuture_CArray_CTrafficRoute _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CArray_CTrafficRoute, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CArray_CTrafficRoute_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CArray_CTrafficRouteBasicFunctions on _CFuture_CArray_CTrafficRoute {
  void _releaseIntermediate() {
    _CFuture_CArray_CTrafficRoute_release(this);
  }

  _CFuture_CArray_CTrafficRoute _retain() {
    return _CFuture_CArray_CTrafficRoute_retain(this);
  }
}

extension _CFuture_CArray_CTrafficRouteToDart on _CFuture_CArray_CTrafficRoute {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CArray_CTrafficRoute_Cancellable>{};

  static void valueFunction(_CArray_CTrafficRoute cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<List<TrafficRoute>> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<List<TrafficRoute>>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CTrafficRoute, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CArray_CTrafficRouteReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CArray_CTrafficRoute_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CArray_CTrafficRoute on CancelableOperation<List<TrafficRoute>> {
  _CFuture_CArray_CTrafficRoute _copyFromDartTo_CFuture_CArray_CTrafficRoute() {
    return _CFuture_CArray_CTrafficRouteMakeDefault();
  }
}
	
// MARK: - CancelableOperation<List<TruckPassZonePass>> <-> _CFuture_CArray_CTruckPassZonePass

final class _CFuture_CArray_CTruckPassZonePass extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CArray_CTruckPassZonePass_Cancellable {
  final Completer<List<TruckPassZonePass>> completer;
  final _CFuture_CArray_CTruckPassZonePass _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CArray_CTruckPassZonePass, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CArray_CTruckPassZonePass_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CArray_CTruckPassZonePassBasicFunctions on _CFuture_CArray_CTruckPassZonePass {
  void _releaseIntermediate() {
    _CFuture_CArray_CTruckPassZonePass_release(this);
  }

  _CFuture_CArray_CTruckPassZonePass _retain() {
    return _CFuture_CArray_CTruckPassZonePass_retain(this);
  }
}

extension _CFuture_CArray_CTruckPassZonePassToDart on _CFuture_CArray_CTruckPassZonePass {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CArray_CTruckPassZonePass_Cancellable>{};

  static void valueFunction(_CArray_CTruckPassZonePass cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<List<TruckPassZonePass>> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<List<TruckPassZonePass>>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CTruckPassZonePass, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CArray_CTruckPassZonePassReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CArray_CTruckPassZonePass_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CArray_CTruckPassZonePass on CancelableOperation<List<TruckPassZonePass>> {
  _CFuture_CArray_CTruckPassZonePass _copyFromDartTo_CFuture_CArray_CTruckPassZonePass() {
    return _CFuture_CArray_CTruckPassZonePassMakeDefault();
  }
}
	
// MARK: - List<TruckPassZonePass> <-> _CArray_CTruckPassZonePass

final class _CArray_CTruckPassZonePass extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CTruckPassZonePassToDart on _CArray_CTruckPassZonePass {
  List<TruckPassZonePass> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CTruckPassZonePass on List<TruckPassZonePass> {
  _CArray_CTruckPassZonePass _copyFromDartTo_CArray_CTruckPassZonePass() {
    final cArray = _CArray_CTruckPassZonePassmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CTruckPassZonePass();
        _CArray_CTruckPassZonePassaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CTruckPassZonePassBasicFunctions on _CArray_CTruckPassZonePass {
  void _releaseIntermediate() {
    _CArray_CTruckPassZonePass_release(this);
  }

  static final _listToFill = <TruckPassZonePass>[];

  static void _iterate(_CTruckPassZonePass item) {
    _listToFill.add(item._toDart());
  }

  List<TruckPassZonePass> _fillFromC() {
    _forEach_CArray_CTruckPassZonePass(this, ffi.Pointer.fromFunction<ffi.Void Function(_CTruckPassZonePass)>(_iterate));
    final result = List<TruckPassZonePass>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - CancelableOperation<List<BriefRouteInfo?>> <-> _CFuture_CArray_COptional_CBriefRouteInfo

final class _CFuture_CArray_COptional_CBriefRouteInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CArray_COptional_CBriefRouteInfo_Cancellable {
  final Completer<List<BriefRouteInfo?>> completer;
  final _CFuture_CArray_COptional_CBriefRouteInfo _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CArray_COptional_CBriefRouteInfo, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CArray_COptional_CBriefRouteInfo_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CArray_COptional_CBriefRouteInfoBasicFunctions on _CFuture_CArray_COptional_CBriefRouteInfo {
  void _releaseIntermediate() {
    _CFuture_CArray_COptional_CBriefRouteInfo_release(this);
  }

  _CFuture_CArray_COptional_CBriefRouteInfo _retain() {
    return _CFuture_CArray_COptional_CBriefRouteInfo_retain(this);
  }
}

extension _CFuture_CArray_COptional_CBriefRouteInfoToDart on _CFuture_CArray_COptional_CBriefRouteInfo {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CArray_COptional_CBriefRouteInfo_Cancellable>{};

  static void valueFunction(_CArray_COptional_CBriefRouteInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<List<BriefRouteInfo?>> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<List<BriefRouteInfo?>>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_COptional_CBriefRouteInfo, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CArray_COptional_CBriefRouteInfoReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CArray_COptional_CBriefRouteInfo_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CArray_COptional_CBriefRouteInfo on CancelableOperation<List<BriefRouteInfo?>> {
  _CFuture_CArray_COptional_CBriefRouteInfo _copyFromDartTo_CFuture_CArray_COptional_CBriefRouteInfo() {
    return _CFuture_CArray_COptional_CBriefRouteInfoMakeDefault();
  }
}
	
// MARK: - List<BriefRouteInfo?> <-> _CArray_COptional_CBriefRouteInfo

final class _CArray_COptional_CBriefRouteInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_COptional_CBriefRouteInfoToDart on _CArray_COptional_CBriefRouteInfo {
  List<BriefRouteInfo?> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_COptional_CBriefRouteInfo on List<BriefRouteInfo?> {
  _CArray_COptional_CBriefRouteInfo _copyFromDartTo_CArray_COptional_CBriefRouteInfo() {
    final cArray = _CArray_COptional_CBriefRouteInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_COptional_CBriefRouteInfo();
        _CArray_COptional_CBriefRouteInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_COptional_CBriefRouteInfoBasicFunctions on _CArray_COptional_CBriefRouteInfo {
  void _releaseIntermediate() {
    _CArray_COptional_CBriefRouteInfo_release(this);
  }

  static final _listToFill = <BriefRouteInfo?>[];

  static void _iterate(_COptional_CBriefRouteInfo item) {
    _listToFill.add(item._toDart());
  }

  List<BriefRouteInfo?> _fillFromC() {
    _forEach_CArray_COptional_CBriefRouteInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_COptional_CBriefRouteInfo)>(_iterate));
    final result = List<BriefRouteInfo?>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - BriefRouteInfo? <-> _COptional_CBriefRouteInfo

final class _COptional_CBriefRouteInfo extends ffi.Struct {
  
  external _CBriefRouteInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CBriefRouteInfoBasicFunctions on _COptional_CBriefRouteInfo {
  void _releaseIntermediate() {
    _COptional_CBriefRouteInfo_release(this);
  }
}

extension _COptional_CBriefRouteInfoToDart on _COptional_CBriefRouteInfo {
  BriefRouteInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CBriefRouteInfo on BriefRouteInfo? {
  _COptional_CBriefRouteInfo _copyFromDartTo_COptional_CBriefRouteInfo() {
    final cOptional = _COptional_CBriefRouteInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CBriefRouteInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<BriefRouteInfoSearchPoints> <-> _CArray_CBriefRouteInfoSearchPoints

final class _CArray_CBriefRouteInfoSearchPoints extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CBriefRouteInfoSearchPointsToDart on _CArray_CBriefRouteInfoSearchPoints {
  List<BriefRouteInfoSearchPoints> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CBriefRouteInfoSearchPoints on List<BriefRouteInfoSearchPoints> {
  _CArray_CBriefRouteInfoSearchPoints _copyFromDartTo_CArray_CBriefRouteInfoSearchPoints() {
    final cArray = _CArray_CBriefRouteInfoSearchPointsmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CBriefRouteInfoSearchPoints();
        _CArray_CBriefRouteInfoSearchPointsaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CBriefRouteInfoSearchPointsBasicFunctions on _CArray_CBriefRouteInfoSearchPoints {
  void _releaseIntermediate() {
    _CArray_CBriefRouteInfoSearchPoints_release(this);
  }

  static final _listToFill = <BriefRouteInfoSearchPoints>[];

  static void _iterate(_CBriefRouteInfoSearchPoints item) {
    _listToFill.add(item._toDart());
  }

  List<BriefRouteInfoSearchPoints> _fillFromC() {
    _forEach_CArray_CBriefRouteInfoSearchPoints(this, ffi.Pointer.fromFunction<ffi.Void Function(_CBriefRouteInfoSearchPoints)>(_iterate));
    final result = List<BriefRouteInfoSearchPoints>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - TerritoriesAlongRouteProvider

/** Интерфейс для поиска маршрута с учетом пробочных данных. */
class TerritoriesAlongRouteProvider implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CTerritoriesAlongRouteProvider_releasePtr);

  TerritoriesAlongRouteProvider._raw(this._self);
  factory TerritoriesAlongRouteProvider._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TerritoriesAlongRouteProvider._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TerritoriesAlongRouteProvider &&
    other.runtimeType == runtimeType &&
    _CTerritoriesAlongRouteProvider_cg_objectIdentifier(this._self) == _CTerritoriesAlongRouteProvider_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTerritoriesAlongRouteProvider_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: TerritoriesAlongRouteProvider: Methods

  /**
   Возвращает минимально необходимый список офлайн-территорий в порядке следования маршрута.
  
   - Returns: future с массивом территорий.
  */
  CancelableOperation<List<Territory>> getTerritories(
    Route route
  )  {
    var _a1 = route._copyFromDartTo_CRoute();
    _CFuture_CArray_CTerritory res = _CTerritoriesAlongRouteProvider_getTerritories_CRoute(_CTerritoriesAlongRouteProviderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - TerritoriesAlongRouteProvider <-> CTerritoriesAlongRouteProvider

final class _CTerritoriesAlongRouteProvider extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTerritoriesAlongRouteProviderBasicFunctions on _CTerritoriesAlongRouteProvider {
  void _releaseIntermediate() {
    _CTerritoriesAlongRouteProvider_release(_impl);
  }

  _CTerritoriesAlongRouteProvider _retain() {
    return _CTerritoriesAlongRouteProvider_retain(_impl);
  }
}

extension _CTerritoriesAlongRouteProviderToDart on _CTerritoriesAlongRouteProvider {
  TerritoriesAlongRouteProvider _toDart() {
    return TerritoriesAlongRouteProvider._create(_retain()._impl);
  }
}


extension _DartToCTerritoriesAlongRouteProvider on TerritoriesAlongRouteProvider {
  _CTerritoriesAlongRouteProvider _copyFromDartTo_CTerritoriesAlongRouteProvider() {
    return (_CTerritoriesAlongRouteProviderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<List<Territory>> <-> _CFuture_CArray_CTerritory

final class _CFuture_CArray_CTerritory extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CArray_CTerritory_Cancellable {
  final Completer<List<Territory>> completer;
  final _CFuture_CArray_CTerritory _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CArray_CTerritory, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CArray_CTerritory_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CArray_CTerritoryBasicFunctions on _CFuture_CArray_CTerritory {
  void _releaseIntermediate() {
    _CFuture_CArray_CTerritory_release(this);
  }

  _CFuture_CArray_CTerritory _retain() {
    return _CFuture_CArray_CTerritory_retain(this);
  }
}

extension _CFuture_CArray_CTerritoryToDart on _CFuture_CArray_CTerritory {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CArray_CTerritory_Cancellable>{};

  static void valueFunction(_CArray_CTerritory cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<List<Territory>> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<List<Territory>>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CTerritory, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CArray_CTerritoryReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CArray_CTerritory_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CArray_CTerritory on CancelableOperation<List<Territory>> {
  _CFuture_CArray_CTerritory _copyFromDartTo_CFuture_CArray_CTerritory() {
    return _CFuture_CArray_CTerritoryMakeDefault();
  }
}
	
// MARK: - List<Territory> <-> _CArray_CTerritory

final class _CArray_CTerritory extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CTerritoryToDart on _CArray_CTerritory {
  List<Territory> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CTerritory on List<Territory> {
  _CArray_CTerritory _copyFromDartTo_CArray_CTerritory() {
    final cArray = _CArray_CTerritorymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CTerritory();
        _CArray_CTerritoryaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CTerritoryBasicFunctions on _CArray_CTerritory {
  void _releaseIntermediate() {
    _CArray_CTerritory_release(this);
  }

  static final _listToFill = <Territory>[];

  static void _iterate(_CTerritory item) {
    _listToFill.add(item._toDart());
  }

  List<Territory> _fillFromC() {
    _forEach_CArray_CTerritory(this, ffi.Pointer.fromFunction<ffi.Void Function(_CTerritory)>(_iterate));
    final result = List<Territory>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - Territory

/**
 Территория.
 Данные в 2ГИС нарезаны на некоторые неделимые единицы, называемые сегментами.
 Но для более удобной и гибкой работы с данными для обновления используются не сами сегменты, а их наборы,
 называемые территориями. Наборы сегментов в двух территориях могут пересекаться, в том числе одна территория
 может быть целиком вложена в другую.
*/
class Territory extends Package implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CTerritory_releasePtr);

  Territory._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Territory._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Territory._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Territory &&
    other.runtimeType == runtimeType &&
    _CTerritory_cg_objectIdentifier(this._self) == _CTerritory_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTerritory_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Territory <-> CTerritory

final class _CTerritory extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTerritoryBasicFunctions on _CTerritory {
  void _releaseIntermediate() {
    _CTerritory_release(_impl);
  }

  _CTerritory _retain() {
    return _CTerritory_retain(_impl);
  }
}

extension _CTerritoryToDart on _CTerritory {
  Territory _toDart() {
    return Territory._create(_retain()._impl);
  }
}


extension _DartToCTerritory on Territory {
  _CTerritory _copyFromDartTo_CTerritory() {
    return (_CTerritoryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - remainingRouteGeometry

/**
 Вычисляет геометрию оставшейся части маршрута, т.е. геометрию, начинающуюся с точки,
 соответствующей текущей точке маршрута, и до конца маршрута. Если маршрут полностью
 пройден или текущая точка находится за пределами маршрута, возвращается
 пустая геометрия.

 - Parameter fullRouteGeometry: Полная геометрия всего маршрута.
 - Parameter currentRoutePoint: Текущая позиция на маршруте.
 - Returns: Геометрия оставшейся части маршрута
 - Note: Сложность операции O(N), где N = full_route_geometry.size()
*/
GeoPointRouteAttribute remainingRouteGeometry(
  GeoPointRouteAttribute fullRouteGeometry,
  RoutePoint currentRoutePoint
){
  var _a0 = fullRouteGeometry._copyFromDartTo_CGeoPointRouteAttribute();
  var _a1 = currentRoutePoint._copyFromDartTo_CRoutePoint();
  _CGeoPointRouteAttribute res = _CFunction_G_remainingRouteGeometry_With_CGeoPointRouteAttribute_CRoutePoint(_a0, _a1);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - routeMatchesTruckPassZonePasses

/**
 Проверяет, достаточен ли предоставленный список пропусков для проезда пропускных зон грузового транспорта,
 через которые проходит маршрут.

 - Note: Если маршрут не проходит через какие-либо пропускные зоны для грузового транспорта, функция возвращает true
 - Parameter truckPassZoneIds: Атрибут маршрута с идентификаторами пропускных зон для грузового транспорта.
 - Parameter passZonePasses: Пропуски для проезда пропускных зон грузового транспорта.
 - Returns: Признак достаточности пропусков для проезда по маршруту.
*/
bool routeMatchesTruckPassZonePasses(
  TruckPassZoneIdRouteLongAttribute truckPassZoneIds,
  List<TruckPassZonePass> passZonePasses
){
  var _a0 = truckPassZoneIds._copyFromDartTo_CTruckPassZoneIdRouteLongAttribute();
  var _a1 = passZonePasses._copyFromDartTo_CArray_CTruckPassZonePass();
  bool res = _CFunction_G_routeMatchesTruckPassZonePasses_With_CTruckPassZoneIdRouteLongAttribute_CArray_CTruckPassZonePass(_a0, _a1);
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  return res;
}

// MARK: - getRoadMacroGraph

/**
 Получение объекта для управления глобальным дорожным графом из контекста.

 - Throws: Exception, если невозможно получить зависимости из контекста
*/
RoadMacroGraph getRoadMacroGraph(
  Context context
){
  var _a0 = context._copyFromDartTo_CContext();
  _CRoadMacroGraph res = _CFunction_G_getRoadMacroGraph_With_CContext(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - RoadMacroGraph

/**
 Пакет глобального дорожного графа, используется
 для построения проезда между двумя загруженными offline-территориями.
*/
class RoadMacroGraph extends Package implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CRoadMacroGraph_releasePtr);

  RoadMacroGraph._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RoadMacroGraph._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadMacroGraph._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadMacroGraph &&
    other.runtimeType == runtimeType &&
    _CRoadMacroGraph_cg_objectIdentifier(this._self) == _CRoadMacroGraph_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadMacroGraph_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - RoadMacroGraph <-> CRoadMacroGraph

final class _CRoadMacroGraph extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadMacroGraphBasicFunctions on _CRoadMacroGraph {
  void _releaseIntermediate() {
    _CRoadMacroGraph_release(_impl);
  }

  _CRoadMacroGraph _retain() {
    return _CRoadMacroGraph_retain(_impl);
  }
}

extension _CRoadMacroGraphToDart on _CRoadMacroGraph {
  RoadMacroGraph _toDart() {
    return RoadMacroGraph._create(_retain()._impl);
  }
}


extension _DartToCRoadMacroGraph on RoadMacroGraph {
  _CRoadMacroGraph _copyFromDartTo_CRoadMacroGraph() {
    return (_CRoadMacroGraphMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - getTerritoriesAlongRouteProvider

/**
 Получение объекта для получения списка территорий вдоль маршрута из контекста.

 - Throws: Exception, если невозможно получить зависимости из контекста
*/
TerritoriesAlongRouteProvider getTerritoriesAlongRouteProvider(
  Context context
){
  var _a0 = context._copyFromDartTo_CContext();
  _CTerritoriesAlongRouteProvider res = _CFunction_G_getTerritoriesAlongRouteProvider_With_CContext(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - TrafficCollector

/**
 Интерфейс для управления сервисом сбора информации о транспортном трафике.

 - Note: Этот интерфейс является потокобезопасным.
*/
class TrafficCollector implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Функция определения состояния разрешения/запрета отправки информации о дорожном движении на сервер.
  
   - Returns: true - разрешено/ false - запрещено.
  */
  bool get trafficCollectingAllowed {
    bool res = _CTrafficCollector_trafficCollectingAllowed(_CTrafficCollectorMakeDefault().._impl=_self);
    return res;
  }
  set trafficCollectingAllowed(bool allowed) {
    void res = _CTrafficCollector_setTrafficCollectingAllowed_bool(_CTrafficCollectorMakeDefault().._impl=_self, allowed);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CTrafficCollector_releasePtr);

  TrafficCollector._raw(this._self);
  factory TrafficCollector._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TrafficCollector._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Функция создания сервиса сбора информации о транспортном трафике.
   Сервис сбора информации о транспортном трафике анализирует состояние трафика на дороге,
   по которой движется пользователь и отправляет результаты анализа в анонимизированном виде на сервер.
  
   - Parameter context: Контекст - окружение, необходимое для работы SDK.
   - Returns: Сервис сбора информации о дорожном движении.
   - Throws: Exception, если невозможно создать сервис сбора информации о дорожном движении.
  */
  factory TrafficCollector(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CTrafficCollector res = _CTrafficCollector_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return TrafficCollector._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficCollector &&
    other.runtimeType == runtimeType &&
    _CTrafficCollector_cg_objectIdentifier(this._self) == _CTrafficCollector_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTrafficCollector_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - TrafficCollector <-> CTrafficCollector

final class _CTrafficCollector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTrafficCollectorBasicFunctions on _CTrafficCollector {
  void _releaseIntermediate() {
    _CTrafficCollector_release(_impl);
  }

  _CTrafficCollector _retain() {
    return _CTrafficCollector_retain(_impl);
  }
}

extension _CTrafficCollectorToDart on _CTrafficCollector {
  TrafficCollector _toDart() {
    return TrafficCollector._create(_retain()._impl);
  }
}


extension _DartToCTrafficCollector on TrafficCollector {
  _CTrafficCollector _copyFromDartTo_CTrafficCollector() {
    return (_CTrafficCollectorMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - TrafficScoreState

/** Актуальность балла пробок. */
enum TrafficScoreState {
  /** Значение неизвестно, будет запрошено позднее. Начальное состояние. */
  pending(0),
  /** Значение актуально. */
  valid(1),
  /**
   Значение устарело. Состояние достигается, если данные не удалось
   обновить в течение определённого времени.
  */
  expired(2),
  ;

  const TrafficScoreState(this.rawValue);
  final int rawValue;

  static TrafficScoreState getByValue(int value) {
    return TrafficScoreState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CTrafficScoreState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CTrafficScoreStateBasicFunctions on _CTrafficScoreState {
  void _releaseIntermediate() {
  }
}

extension _CTrafficScoreStateToDart on _CTrafficScoreState {
  TrafficScoreState _toDart() {
    return TrafficScoreState.getByValue(this.rawValue);
  }
}

extension _DartTo_CTrafficScoreState on TrafficScoreState {
  _CTrafficScoreState _copyFromDartTo_CTrafficScoreState() {
    return _CTrafficScoreStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - TrafficScore

/** Оценка пробок. */
class TrafficScore {
  /** Актуальность значения. */
  final TrafficScoreState state;
  /**
   Значение в баллах. Как правило, значения находятся в диапазоне от 1 до 10.
   Пустое значение, если информация ещё не получена, либо уже устарела,
   либо недоступна для заданного местоположения.
  */
  final int? value;

  const TrafficScore({
    this.state = TrafficScoreState.pending,
    required this.value
  });

  TrafficScore copyWith({
    TrafficScoreState? state,
    Optional<int?>? value
  }) {
    return TrafficScore(
      state: state ?? this.state,
      value: value != null ? value.value : this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficScore &&
    other.runtimeType == runtimeType &&
    other.state == state &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(state, value);
  }

}
final class _CTrafficScore extends ffi.Struct {
  external _CTrafficScoreState state;

  external _COptional_uint32_t value;

}
// MARK: - TrafficScore <-> _CTrafficScore

extension _CTrafficScoreToDart on _CTrafficScore {
  TrafficScore _toDart() {
    return TrafficScore(
      state: this.state._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CTrafficScore on TrafficScore {
  _CTrafficScore _copyFromDartTo_CTrafficScore() {
    final res = _CTrafficScoreMakeDefault();
    res.state = this.state._copyFromDartTo_CTrafficScoreState();
    res.value = this.value._copyFromDartTo_COptional_uint32_t();
    return res;
  }
}
extension _CTrafficScoreRelease on _CTrafficScore {
  void _releaseIntermediate() {
  }
}

// MARK: - TrafficScoreProvider

/**
 Подписка на обновления информации о величине пробок.

 - Note: Этот интерфейс является потокобезопасным.
*/
class TrafficScoreProvider implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Текущее состояние пробок и их балл. */
  StatefulChannel<TrafficScore> get scoreChannel {
    _CStatefulChannel_CTrafficScore res = _CTrafficScoreProvider_scoreChannel(_CTrafficScoreProviderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Текущее состояние пробок и их балл. */
  TrafficScore get score {
    _CTrafficScore res = _CTrafficScoreProvider_score(_CTrafficScoreProviderMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CTrafficScoreProvider_releasePtr);

  TrafficScoreProvider._raw(this._self);
  factory TrafficScoreProvider._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TrafficScoreProvider._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory TrafficScoreProvider(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CTrafficScoreProvider res = _CTrafficScoreProvider_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return TrafficScoreProvider._create(res._impl);
  }

  factory TrafficScoreProvider.fromGeoPoint(
    Context context,
    GeoPoint point
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    var _a1 = point._copyFromDartTo_CGeoPoint();
    _CTrafficScoreProvider res = _CTrafficScoreProvider_C_createWith_CContext_CGeoPoint(_a0, _a1);
    _a0._releaseIntermediate();
    return TrafficScoreProvider._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficScoreProvider &&
    other.runtimeType == runtimeType &&
    _CTrafficScoreProvider_cg_objectIdentifier(this._self) == _CTrafficScoreProvider_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTrafficScoreProvider_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - TrafficScoreProvider <-> CTrafficScoreProvider

final class _CTrafficScoreProvider extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTrafficScoreProviderBasicFunctions on _CTrafficScoreProvider {
  void _releaseIntermediate() {
    _CTrafficScoreProvider_release(_impl);
  }

  _CTrafficScoreProvider _retain() {
    return _CTrafficScoreProvider_retain(_impl);
  }
}

extension _CTrafficScoreProviderToDart on _CTrafficScoreProvider {
  TrafficScoreProvider _toDart() {
    return TrafficScoreProvider._create(_retain()._impl);
  }
}


extension _DartToCTrafficScoreProvider on TrafficScoreProvider {
  _CTrafficScoreProvider _copyFromDartTo_CTrafficScoreProvider() {
    return (_CTrafficScoreProviderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<TrafficScore> <-> _CStatefulChannel_CTrafficScore

class _CStatefulChannel_CTrafficScoreImpl extends StatefulChannel<TrafficScore> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<TrafficScore>>{};

  final _CStatefulChannel_CTrafficScore _channel;

  _CStatefulChannel_CTrafficScoreImpl(this._channel);

  @override
  TrafficScore get value {
    return this._channel._getter();
  }

  static void valueFunction(_CTrafficScore cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<TrafficScore> listen(void onData(TrafficScore event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CTrafficScore, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<TrafficScore>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CTrafficScore extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CTrafficScoreBasicFunctions on _CStatefulChannel_CTrafficScore {
  void _releaseIntermediate() {
    _CStatefulChannel_CTrafficScore_release(this);
  }

  _CStatefulChannel_CTrafficScore _retain() {
    return _CStatefulChannel_CTrafficScore_retain(this);
  }

  TrafficScore _getter() {
    final cValue = _CStatefulChannel_CTrafficScoreGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CTrafficScore, ffi.Int64)> callback) {
    return _CStatefulChannel_CTrafficScoreConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CTrafficScoreToDart on _CStatefulChannel_CTrafficScore {
  StatefulChannel<TrafficScore> _toDart() {
    return _CStatefulChannel_CTrafficScoreImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CTrafficScore on StatefulChannel<TrafficScore> {
  _CStatefulChannel_CTrafficScore _copyFromDartTo_CStatefulChannel_CTrafficScore() {
    return _CStatefulChannel_CTrafficScoreMakeDefault();
  }
}
	
// MARK: - TrafficControlStatus

/** Статус элемента управления видимостью пробок. */
enum TrafficControlStatus {
  /**
   Контрол скрыт.
   Возникает, когда в регионе отсутствует информация о пробках.
  */
  hidden(0),
  /**
   Контрол в активном состоянии.
   Возникает, когда данные о пробках в актуальном состоянии,
   и на карте присутствует слой пробок.
  */
  enabled(1),
  /**
   Контрол в неактивном состоянии.
   Возникает, когда на карте отсутствует слой пробок.
  */
  disabled(2),
  /**
   Индикатор загрузки.
   Возникает, когда данные о пробках в неактуальном состоянии,
   и на карте присутствует слой пробок.
  */
  loading(3),
  ;

  const TrafficControlStatus(this.rawValue);
  final int rawValue;

  static TrafficControlStatus getByValue(int value) {
    return TrafficControlStatus.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CTrafficControlStatus extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CTrafficControlStatusBasicFunctions on _CTrafficControlStatus {
  void _releaseIntermediate() {
  }
}

extension _CTrafficControlStatusToDart on _CTrafficControlStatus {
  TrafficControlStatus _toDart() {
    return TrafficControlStatus.getByValue(this.rawValue);
  }
}

extension _DartTo_CTrafficControlStatus on TrafficControlStatus {
  _CTrafficControlStatus _copyFromDartTo_CTrafficControlStatus() {
    return _CTrafficControlStatusMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - TrafficControlState

/** Состояние элемента управления видимостью пробок. */
class TrafficControlState {
  /** Статус, в зависимости от которого меняется внешний вид элемента управления. */
  final TrafficControlStatus status;
  /**
   Балл пробок.
   Отображается в виде надписи на контроле.
   Если отсутствует, отображается иконка-заглушка.
  */
  final int? score;

  const TrafficControlState({
    this.status = TrafficControlStatus.hidden,
    required this.score
  });

  TrafficControlState copyWith({
    TrafficControlStatus? status,
    Optional<int?>? score
  }) {
    return TrafficControlState(
      status: status ?? this.status,
      score: score != null ? score.value : this.score
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficControlState &&
    other.runtimeType == runtimeType &&
    other.status == status &&
    other.score == score;

  @override
  int get hashCode {
    return Object.hash(status, score);
  }

}
final class _CTrafficControlState extends ffi.Struct {
  external _CTrafficControlStatus status;

  external _COptional_uint32_t score;

}
// MARK: - TrafficControlState <-> _CTrafficControlState

extension _CTrafficControlStateToDart on _CTrafficControlState {
  TrafficControlState _toDart() {
    return TrafficControlState(
      status: this.status._toDart(),
      score: this.score._toDart()
    );
  }
}

extension _DartTo_CTrafficControlState on TrafficControlState {
  _CTrafficControlState _copyFromDartTo_CTrafficControlState() {
    final res = _CTrafficControlStateMakeDefault();
    res.status = this.status._copyFromDartTo_CTrafficControlStatus();
    res.score = this.score._copyFromDartTo_COptional_uint32_t();
    return res;
  }
}
extension _CTrafficControlStateRelease on _CTrafficControlState {
  void _releaseIntermediate() {
  }
}

// MARK: - TrafficControlModel

/**
 Модель контрола пробок.

 - Note: Этот интерфейс является потокобезопасным.
*/
class TrafficControlModel implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Состояние элемента управления видимостью пробок. */
  StatefulChannel<TrafficControlState> get stateChannel {
    _CStatefulChannel_CTrafficControlState res = _CTrafficControlModel_stateChannel(_CTrafficControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Состояние элемента управления видимостью пробок. */
  TrafficControlState get state {
    _CTrafficControlState res = _CTrafficControlModel_state(_CTrafficControlModelMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CTrafficControlModel_releasePtr);

  TrafficControlModel._raw(this._self);
  factory TrafficControlModel._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TrafficControlModel._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Функция создания модели элемента управления пробками.
  
   - Parameter map: карта.
   - Returns: Модель элемента управления видимостью пробок для карты.
  */
  factory TrafficControlModel(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CTrafficControlModel res = _CTrafficControlModel_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return TrafficControlModel._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficControlModel &&
    other.runtimeType == runtimeType &&
    _CTrafficControlModel_cg_objectIdentifier(this._self) == _CTrafficControlModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTrafficControlModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: TrafficControlModel: Methods

  /**
   Действие при нажатии на контрол.
   Переключает видимость пробок на карте.
  */
  void onClicked()  {
    void res = _CTrafficControlModel_onClicked(_CTrafficControlModelMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - TrafficControlModel <-> CTrafficControlModel

final class _CTrafficControlModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTrafficControlModelBasicFunctions on _CTrafficControlModel {
  void _releaseIntermediate() {
    _CTrafficControlModel_release(_impl);
  }

  _CTrafficControlModel _retain() {
    return _CTrafficControlModel_retain(_impl);
  }
}

extension _CTrafficControlModelToDart on _CTrafficControlModel {
  TrafficControlModel _toDart() {
    return TrafficControlModel._create(_retain()._impl);
  }
}


extension _DartToCTrafficControlModel on TrafficControlModel {
  _CTrafficControlModel _copyFromDartTo_CTrafficControlModel() {
    return (_CTrafficControlModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<TrafficControlState> <-> _CStatefulChannel_CTrafficControlState

class _CStatefulChannel_CTrafficControlStateImpl extends StatefulChannel<TrafficControlState> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<TrafficControlState>>{};

  final _CStatefulChannel_CTrafficControlState _channel;

  _CStatefulChannel_CTrafficControlStateImpl(this._channel);

  @override
  TrafficControlState get value {
    return this._channel._getter();
  }

  static void valueFunction(_CTrafficControlState cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<TrafficControlState> listen(void onData(TrafficControlState event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CTrafficControlState, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<TrafficControlState>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CTrafficControlState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CTrafficControlStateBasicFunctions on _CStatefulChannel_CTrafficControlState {
  void _releaseIntermediate() {
    _CStatefulChannel_CTrafficControlState_release(this);
  }

  _CStatefulChannel_CTrafficControlState _retain() {
    return _CStatefulChannel_CTrafficControlState_retain(this);
  }

  TrafficControlState _getter() {
    final cValue = _CStatefulChannel_CTrafficControlStateGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CTrafficControlState, ffi.Int64)> callback) {
    return _CStatefulChannel_CTrafficControlStateConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CTrafficControlStateToDart on _CStatefulChannel_CTrafficControlState {
  StatefulChannel<TrafficControlState> _toDart() {
    return _CStatefulChannel_CTrafficControlStateImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CTrafficControlState on StatefulChannel<TrafficControlState> {
  _CStatefulChannel_CTrafficControlState _copyFromDartTo_CStatefulChannel_CTrafficControlState() {
    return _CStatefulChannel_CTrafficControlStateMakeDefault();
  }
}
	
// MARK: - PackageInfoError

/** Ошибки, которые могут произойти при загрузке и/или установке пакета. */
enum PackageInfoError {
  /** Отсутствует соединение с сетью. */
  noNetwork(0),
  /** Не осталось свободного места на устройстве для загрузки и/или установки пакета. */
  noFreeSpace(1),
  /** Ошибка загрузки. */
  downloadError(2),
  ;

  const PackageInfoError(this.rawValue);
  final int rawValue;

  static PackageInfoError getByValue(int value) {
    return PackageInfoError.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CPackageInfoError extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CPackageInfoErrorBasicFunctions on _CPackageInfoError {
  void _releaseIntermediate() {
  }
}

extension _CPackageInfoErrorToDart on _CPackageInfoError {
  PackageInfoError _toDart() {
    return PackageInfoError.getByValue(this.rawValue);
  }
}

extension _DartTo_CPackageInfoError on PackageInfoError {
  _CPackageInfoError _copyFromDartTo_CPackageInfoError() {
    return _CPackageInfoErrorMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - PackageUpdateStatus

/** Статус обновления пакета. */
enum PackageUpdateStatus {
  /** Для пакета нет более новой доступной версии. */
  notAvailable(0),
  /** Идёт процесс установки или обновления пакета до более новой доступной версии. */
  inProgress(1),
  /** Процесс обновления пакета до более новой доступной версии не запущен либо приостановлен. */
  paused(2),
  ;

  const PackageUpdateStatus(this.rawValue);
  final int rawValue;

  static PackageUpdateStatus getByValue(int value) {
    return PackageUpdateStatus.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CPackageUpdateStatus extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CPackageUpdateStatusBasicFunctions on _CPackageUpdateStatus {
  void _releaseIntermediate() {
  }
}

extension _CPackageUpdateStatusToDart on _CPackageUpdateStatus {
  PackageUpdateStatus _toDart() {
    return PackageUpdateStatus.getByValue(this.rawValue);
  }
}

extension _DartTo_CPackageUpdateStatus on PackageUpdateStatus {
  _CPackageUpdateStatus _copyFromDartTo_CPackageUpdateStatus() {
    return _CPackageUpdateStatusMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - PackageInfoError? <-> _COptional_CPackageInfoError

final class _COptional_CPackageInfoError extends ffi.Struct {
  
  external _CPackageInfoError value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CPackageInfoErrorBasicFunctions on _COptional_CPackageInfoError {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CPackageInfoErrorToDart on _COptional_CPackageInfoError {
  PackageInfoError? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CPackageInfoError on PackageInfoError? {
  _COptional_CPackageInfoError _copyFromDartTo_COptional_CPackageInfoError() {
    final cOptional = _COptional_CPackageInfoErrorMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CPackageInfoError();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - PackageInfo

/** Информация о пакете. См. IPackage. */
class PackageInfo {
  /** Локализованное название пакета. */
  final String name;
  /** Признак установки - true в случае, если пакет был выбран для установки. */
  final bool installed;
  /**
   Признак незавершенности установки - true, если нет полностью загруженной версии пакета (возможно, несовместимой
   с текущей версией SDK).
  */
  final bool incomplete;
  /**
   Признак предустановленных пакетов.
   Предустановленные пакеты всегда установлены и полностью загружены, и их нельзя удалить.
  */
  final bool preinstalled;
  /** Признак совместимости - true в случае, если загруженный пакет совместим с текущей версией SDK. */
  final bool compatible;
  /**
   Признак наличия обновления - true в случае наличия обновления для загруженного пакета.
   Возможна ситуация, когда во время процесса обновления до новой версии на сервере стала доступна ещё
   более новая версия пакета. В этом случае значение будет true как во время обновления, так и по его окончании.
  */
  final bool hasUpdate;
  /** Ошибка, произошедшая при попытке загрузки и/или установки пакета, или null, если ошибки нет. */
  final PackageInfoError? error;
  /** Статус обновления пакета. */
  final PackageUpdateStatus updateStatus;
  /**
   Размер территории в байтах, который она занимает на диске после установки.
   Неинициализированное значение означает, что территория не содержит файлов
   (информация получена на основе предустановленного файла состояния, в котором нет списка
   файлов для территории).
  */
  final int? finalSizeOnDisk;
  /** Размер в байтах, который занимают на данный момент уже установленные файлы территории. */
  final int currentSizeOnDisk;

  const PackageInfo({
    required this.name,
    this.installed = false,
    this.incomplete = true,
    this.preinstalled = false,
    this.compatible = false,
    this.hasUpdate = false,
    required this.error,
    this.updateStatus = PackageUpdateStatus.notAvailable,
    this.finalSizeOnDisk = null,
    this.currentSizeOnDisk = 0
  });

  PackageInfo copyWith({
    String? name,
    bool? installed,
    bool? incomplete,
    bool? preinstalled,
    bool? compatible,
    bool? hasUpdate,
    Optional<PackageInfoError?>? error,
    PackageUpdateStatus? updateStatus,
    Optional<int?>? finalSizeOnDisk,
    int? currentSizeOnDisk
  }) {
    return PackageInfo(
      name: name ?? this.name,
      installed: installed ?? this.installed,
      incomplete: incomplete ?? this.incomplete,
      preinstalled: preinstalled ?? this.preinstalled,
      compatible: compatible ?? this.compatible,
      hasUpdate: hasUpdate ?? this.hasUpdate,
      error: error != null ? error.value : this.error,
      updateStatus: updateStatus ?? this.updateStatus,
      finalSizeOnDisk: finalSizeOnDisk != null ? finalSizeOnDisk.value : this.finalSizeOnDisk,
      currentSizeOnDisk: currentSizeOnDisk ?? this.currentSizeOnDisk
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PackageInfo &&
    other.runtimeType == runtimeType &&
    other.name == name &&
    other.installed == installed &&
    other.incomplete == incomplete &&
    other.preinstalled == preinstalled &&
    other.compatible == compatible &&
    other.hasUpdate == hasUpdate &&
    other.error == error &&
    other.updateStatus == updateStatus &&
    other.finalSizeOnDisk == finalSizeOnDisk &&
    other.currentSizeOnDisk == currentSizeOnDisk;

  @override
  int get hashCode {
    return Object.hash(name, installed, incomplete, preinstalled, compatible, hasUpdate, error, updateStatus, finalSizeOnDisk, currentSizeOnDisk);
  }

}
final class _CPackageInfo extends ffi.Struct {
  external _CString name;

  @ffi.Bool()
  external bool installed;

  @ffi.Bool()
  external bool incomplete;

  @ffi.Bool()
  external bool preinstalled;

  @ffi.Bool()
  external bool compatible;

  @ffi.Bool()
  external bool hasUpdate;

  external _COptional_CPackageInfoError error;

  external _CPackageUpdateStatus updateStatus;

  external _COptional_uint64_t finalSizeOnDisk;

  @ffi.Uint64()
  external int currentSizeOnDisk;

}
// MARK: - PackageInfo <-> _CPackageInfo

extension _CPackageInfoToDart on _CPackageInfo {
  PackageInfo _toDart() {
    return PackageInfo(
      name: this.name._toDart(),
      installed: this.installed,
      incomplete: this.incomplete,
      preinstalled: this.preinstalled,
      compatible: this.compatible,
      hasUpdate: this.hasUpdate,
      error: this.error._toDart(),
      updateStatus: this.updateStatus._toDart(),
      finalSizeOnDisk: this.finalSizeOnDisk._toDart(),
      currentSizeOnDisk: this.currentSizeOnDisk
    );
  }
}

extension _DartTo_CPackageInfo on PackageInfo {
  _CPackageInfo _copyFromDartTo_CPackageInfo() {
    final res = _CPackageInfoMakeDefault();
    res.name = this.name._copyFromDartTo_CString();
    res.installed = this.installed;
    res.incomplete = this.incomplete;
    res.preinstalled = this.preinstalled;
    res.compatible = this.compatible;
    res.hasUpdate = this.hasUpdate;
    res.error = this.error._copyFromDartTo_COptional_CPackageInfoError();
    res.updateStatus = this.updateStatus._copyFromDartTo_CPackageUpdateStatus();
    res.finalSizeOnDisk = this.finalSizeOnDisk._copyFromDartTo_COptional_uint64_t();
    res.currentSizeOnDisk = this.currentSizeOnDisk;
    return res;
  }
}
extension _CPackageInfoRelease on _CPackageInfo {
  void _releaseIntermediate() {
    name._releaseIntermediate();
  }
}

// MARK: - Package

/**
 Пакет.
 Для удобства работы с данными (установки, обновления, удаления), данные в 2ГИС SDK группируются в наборы по
 функционально-логическому назначению. Набор сгруппированных данных называется пакетом.
 В пределах одного пакета функциональное назначение данных уникально. Однако, множества данных пакетов
 с единым функциональным назначением могут пересекаться, то есть, возможна ситуация, когда данные нескольких
 пакетов имеют общие файлы. При операциях с группой таких пакетов общие данные будут обрабатываться (скачиваться,
 распаковываться, удаляться) только один раз.
*/
class Package implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Стабильный технический идентификатор пакета. */
  String get id {
    _CString res = _CPackage_id(_CPackageMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о пакете. */
  StatefulChannel<PackageInfo> get infoChannel {
    _CStatefulChannel_CPackageInfo res = _CPackage_infoChannel(_CPackageMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о пакете. */
  PackageInfo get info {
    _CPackageInfo res = _CPackage_info(_CPackageMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Прогресс операции установки или обновления пакета в процентах.
   Если пакет не установлен локально, канал содержит значение 0.
   Если пакет установлен локально, независимо от актуальности данных и их совместимости с текущей версией SDK,
   канал содержит значение 100.
   Если пакет находится на этапе установки или обновления, канал содержит обновляемое значение
   в диапазоне [0, 100].
  */
  StatefulChannel<int> get progressChannel {
    _CStatefulChannel_uint8_t res = _CPackage_progressChannel(_CPackageMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Прогресс операции установки или обновления пакета в процентах.
   Если пакет не установлен локально, канал содержит значение 0.
   Если пакет установлен локально, независимо от актуальности данных и их совместимости с текущей версией SDK,
   канал содержит значение 100.
   Если пакет находится на этапе установки или обновления, канал содержит обновляемое значение
   в диапазоне [0, 100].
  */
  int get progress {
    int res = _CPackage_progress(_CPackageMakeDefault().._impl=_self);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPackage_releasePtr);

  Package._raw(this._self);
  factory Package._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Package._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Package &&
    other.runtimeType == runtimeType &&
    _CPackage_cg_objectIdentifier(this._self) == _CPackage_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPackage_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Package: Methods

  /** Запуск операции установки либо обновления пакета. */
  void install()  {
    void res = _CPackage_install(_CPackageMakeDefault().._impl=_self);
    return res;
  }

  /** Запуск операции удаления пакета. */
  void uninstall()  {
    void res = _CPackage_uninstall(_CPackageMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - Package <-> CPackage

final class _CPackage extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPackageBasicFunctions on _CPackage {
  void _releaseIntermediate() {
    _CPackage_release(_impl);
  }

  _CPackage _retain() {
    return _CPackage_retain(_impl);
  }
}

extension _CPackageToDart on _CPackage {
  Package _toDart() {
    final selector = _CPackage_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = Package._create(_retain()._impl);
        return res;
      case 1:
        final res = Territory._create(_retain()._impl);
        return res;
      case 2:
        final res = RoadMacroGraph._create(_retain()._impl);
        return res;
      case 3:
        final res = Voice._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCPackage on Package {
  _CPackage _copyFromDartTo_CPackage() {
    return (_CPackageMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<PackageInfo> <-> _CStatefulChannel_CPackageInfo

class _CStatefulChannel_CPackageInfoImpl extends StatefulChannel<PackageInfo> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<PackageInfo>>{};

  final _CStatefulChannel_CPackageInfo _channel;

  _CStatefulChannel_CPackageInfoImpl(this._channel);

  @override
  PackageInfo get value {
    return this._channel._getter();
  }

  static void valueFunction(_CPackageInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<PackageInfo> listen(void onData(PackageInfo event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CPackageInfo, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<PackageInfo>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CPackageInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CPackageInfoBasicFunctions on _CStatefulChannel_CPackageInfo {
  void _releaseIntermediate() {
    _CStatefulChannel_CPackageInfo_release(this);
  }

  _CStatefulChannel_CPackageInfo _retain() {
    return _CStatefulChannel_CPackageInfo_retain(this);
  }

  PackageInfo _getter() {
    final cValue = _CStatefulChannel_CPackageInfoGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CPackageInfo, ffi.Int64)> callback) {
    return _CStatefulChannel_CPackageInfoConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CPackageInfoToDart on _CStatefulChannel_CPackageInfo {
  StatefulChannel<PackageInfo> _toDart() {
    return _CStatefulChannel_CPackageInfoImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CPackageInfo on StatefulChannel<PackageInfo> {
  _CStatefulChannel_CPackageInfo _copyFromDartTo_CStatefulChannel_CPackageInfo() {
    return _CStatefulChannel_CPackageInfoMakeDefault();
  }
}
	
// MARK: - StatefulChannel<int> <-> _CStatefulChannel_uint8_t

class _CStatefulChannel_uint8_tImpl extends StatefulChannel<int> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<int>>{};

  final _CStatefulChannel_uint8_t _channel;

  _CStatefulChannel_uint8_tImpl(this._channel);

  @override
  int get value {
    return this._channel._getter();
  }

  static void valueFunction(int cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue);
    }
    
  }

  @override
  StreamSubscription<int> listen(void onData(int event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Uint8, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<int>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_uint8_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_uint8_tBasicFunctions on _CStatefulChannel_uint8_t {
  void _releaseIntermediate() {
    _CStatefulChannel_uint8_t_release(this);
  }

  _CStatefulChannel_uint8_t _retain() {
    return _CStatefulChannel_uint8_t_retain(this);
  }

  int _getter() {
    final cValue = _CStatefulChannel_uint8_tGetCurrentValue(this);
    final res = cValue;
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(ffi.Uint8, ffi.Int64)> callback) {
    return _CStatefulChannel_uint8_tConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_uint8_tToDart on _CStatefulChannel_uint8_t {
  StatefulChannel<int> _toDart() {
    return _CStatefulChannel_uint8_tImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_uint8_t on StatefulChannel<int> {
  _CStatefulChannel_uint8_t _copyFromDartTo_CStatefulChannel_uint8_t() {
    return _CStatefulChannel_uint8_tMakeDefault();
  }
}
	
// MARK: - PackageManager

/**
 Интерфейс для централизованной работы с пакетами:
 * Управления автообновлением и получением его статуса;
 * Принудительной проверкой обновлений;
 * Запуском и остановкой установки/обновления всех доступных пакетов.
 * Подпиской на изменения информации о пакетах;
 * Подпиской на изменения информации о всеобщем прогрессе установки пакетов.
*/
class PackageManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Статус (включено/выключено) автообновления. */
  bool get autoupdateEnabled {
    bool res = _CPackageManager_autoupdateEnabled(_CPackageManagerMakeDefault().._impl=_self);
    return res;
  }
  set autoupdateEnabled(bool enabled) {
    void res = _CPackageManager_setAutoupdateEnabled_bool(_CPackageManagerMakeDefault().._impl=_self, enabled);
    return res;
  }
  /**
   Канал со списком всех известных пакетов.
   Обновляется в случае изменения информации о хотя бы об одном из пакетов, либо при изменении состава списка.
  */
  StatefulChannel<List<Package>> get packagesChannel {
    _CStatefulChannel_CArray_CPackage res = _CPackageManager_packagesChannel(_CPackageManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Канал со списком всех известных пакетов.
   Обновляется в случае изменения информации о хотя бы об одном из пакетов, либо при изменении состава списка.
  */
  List<Package> get packages {
    _CArray_CPackage res = _CPackageManager_packages(_CPackageManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPackageManager_releasePtr);

  PackageManager._raw(this._self);
  factory PackageManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PackageManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PackageManager &&
    other.runtimeType == runtimeType &&
    _CPackageManager_cg_objectIdentifier(this._self) == _CPackageManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPackageManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: PackageManager: Methods

  /** Принудительная проверка на наличие обновлений. */
  void checkForUpdates()  {
    void res = _CPackageManager_checkForUpdates(_CPackageManagerMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - PackageManager <-> CPackageManager

final class _CPackageManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPackageManagerBasicFunctions on _CPackageManager {
  void _releaseIntermediate() {
    _CPackageManager_release(_impl);
  }

  _CPackageManager _retain() {
    return _CPackageManager_retain(_impl);
  }
}

extension _CPackageManagerToDart on _CPackageManager {
  PackageManager _toDart() {
    return PackageManager._create(_retain()._impl);
  }
}


extension _DartToCPackageManager on PackageManager {
  _CPackageManager _copyFromDartTo_CPackageManager() {
    return (_CPackageManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<List<Package>> <-> _CStatefulChannel_CArray_CPackage

class _CStatefulChannel_CArray_CPackageImpl extends StatefulChannel<List<Package>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<Package>>>{};

  final _CStatefulChannel_CArray_CPackage _channel;

  _CStatefulChannel_CArray_CPackageImpl(this._channel);

  @override
  List<Package> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CArray_CPackage cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<Package>> listen(void onData(List<Package> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CPackage, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<Package>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CArray_CPackage extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CArray_CPackageBasicFunctions on _CStatefulChannel_CArray_CPackage {
  void _releaseIntermediate() {
    _CStatefulChannel_CArray_CPackage_release(this);
  }

  _CStatefulChannel_CArray_CPackage _retain() {
    return _CStatefulChannel_CArray_CPackage_retain(this);
  }

  List<Package> _getter() {
    final cValue = _CStatefulChannel_CArray_CPackageGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CPackage, ffi.Int64)> callback) {
    return _CStatefulChannel_CArray_CPackageConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CArray_CPackageToDart on _CStatefulChannel_CArray_CPackage {
  StatefulChannel<List<Package>> _toDart() {
    return _CStatefulChannel_CArray_CPackageImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CArray_CPackage on StatefulChannel<List<Package>> {
  _CStatefulChannel_CArray_CPackage _copyFromDartTo_CStatefulChannel_CArray_CPackage() {
    return _CStatefulChannel_CArray_CPackageMakeDefault();
  }
}
	
// MARK: - List<Package> <-> _CArray_CPackage

final class _CArray_CPackage extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CPackageToDart on _CArray_CPackage {
  List<Package> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CPackage on List<Package> {
  _CArray_CPackage _copyFromDartTo_CArray_CPackage() {
    final cArray = _CArray_CPackagemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CPackage();
        _CArray_CPackageaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CPackageBasicFunctions on _CArray_CPackage {
  void _releaseIntermediate() {
    _CArray_CPackage_release(this);
  }

  static final _listToFill = <Package>[];

  static void _iterate(_CPackage item) {
    _listToFill.add(item._toDart());
  }

  List<Package> _fillFromC() {
    _forEach_CArray_CPackage(this, ffi.Pointer.fromFunction<ffi.Void Function(_CPackage)>(_iterate));
    final result = List<Package>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - getPackageManager

/** Получение объекта для работы с пакетами из контекста. */
PackageManager getPackageManager(
  Context context
){
  var _a0 = context._copyFromDartTo_CContext();
  _CPackageManager res = _CFunction_G_getPackageManager_With_CContext(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - getTerritoryManager

/** Получение объекта для работы с территориями из контекста. */
TerritoryManager getTerritoryManager(
  Context context
){
  var _a0 = context._copyFromDartTo_CContext();
  _CTerritoryManager res = _CFunction_G_getTerritoryManager_With_CContext(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - TerritoryManager

/**
 Интерфейс для взаимодействия со списком территорий:
 Подписки на изменения информации о территориях;
 Поиска территорий по координатам и геометриям;
 Подписки на изменения информации о всеобщем прогрессе установки/обновления территорий;
 Приостановки и возобновления процесса установки/обновления территорий.
*/
class TerritoryManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Канал со списком всех известных территорий.
   Обновляется при изменении информации о хотя бы одной из территорий, либо при изменении состава списка.
   Содержимое канала является подмножеством общего списка пакетов, получаемого из IPackageManager::packages.
   Во избежание рассинхронизации описаний пакетов, не следует использовать данные, получаемые одновременно
   из нескольких каналов, содержащих подмножества общего списка пакетов.
  */
  StatefulChannel<List<Territory>> get territoriesChannel {
    _CStatefulChannel_CArray_CTerritory res = _CTerritoryManager_territoriesChannel(_CTerritoryManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Канал со списком всех известных территорий.
   Обновляется при изменении информации о хотя бы одной из территорий, либо при изменении состава списка.
   Содержимое канала является подмножеством общего списка пакетов, получаемого из IPackageManager::packages.
   Во избежание рассинхронизации описаний пакетов, не следует использовать данные, получаемые одновременно
   из нескольких каналов, содержащих подмножества общего списка пакетов.
  */
  List<Territory> get territories {
    _CArray_CTerritory res = _CTerritoryManager_territories(_CTerritoryManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CTerritoryManager_releasePtr);

  TerritoryManager._raw(this._self);
  factory TerritoryManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TerritoryManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TerritoryManager &&
    other.runtimeType == runtimeType &&
    _CTerritoryManager_cg_objectIdentifier(this._self) == _CTerritoryManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTerritoryManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: TerritoryManager: Methods

  /**
   Поиск территорий, которым принадлежит заданная точка.
   Бросает исключение в случае передачи некорректных координат точки.
   Возвращает пустой список в случае ошибки, а именно:
   * Координаты точки находятся за пределами проекции;
   * Произошла внутренняя ошибка при обработке списка территорий.
  */
  List<Territory> findByPoint(
    GeoPoint geoPoint
  )  {
    var _a1 = geoPoint._copyFromDartTo_CGeoPoint();
    _CArray_CTerritory res = _CTerritoryManager_findByPoint_CGeoPoint(_CTerritoryManagerMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Поиск территорий, которым принадлежит заданная геометрия.
   Бросает исключение в случае попытки использования неподдерживаемой геометрии.
   Возвращает пустой список, если геометрия находится за пределами проекции.
   Возвращает пустой список в случае внутренней ошибки при обработке списка территорий.
  */
  List<Territory> findByRect(
    GeoRect rect
  )  {
    var _a1 = rect._copyFromDartTo_CGeoRect();
    _CArray_CTerritory res = _CTerritoryManager_findByRect_CGeoRect(_CTerritoryManagerMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Приостановка всех запущенных операций установки либо обновления территорий. */
  void pause()  {
    void res = _CTerritoryManager_pause(_CTerritoryManagerMakeDefault().._impl=_self);
    return res;
  }

  /** Возобновление всех приостановленных операций установки либо обновления территорий. */
  void resume()  {
    void res = _CTerritoryManager_resume(_CTerritoryManagerMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - TerritoryManager <-> CTerritoryManager

final class _CTerritoryManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTerritoryManagerBasicFunctions on _CTerritoryManager {
  void _releaseIntermediate() {
    _CTerritoryManager_release(_impl);
  }

  _CTerritoryManager _retain() {
    return _CTerritoryManager_retain(_impl);
  }
}

extension _CTerritoryManagerToDart on _CTerritoryManager {
  TerritoryManager _toDart() {
    return TerritoryManager._create(_retain()._impl);
  }
}


extension _DartToCTerritoryManager on TerritoryManager {
  _CTerritoryManager _copyFromDartTo_CTerritoryManager() {
    return (_CTerritoryManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<List<Territory>> <-> _CStatefulChannel_CArray_CTerritory

class _CStatefulChannel_CArray_CTerritoryImpl extends StatefulChannel<List<Territory>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<Territory>>>{};

  final _CStatefulChannel_CArray_CTerritory _channel;

  _CStatefulChannel_CArray_CTerritoryImpl(this._channel);

  @override
  List<Territory> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CArray_CTerritory cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<Territory>> listen(void onData(List<Territory> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CTerritory, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<Territory>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CArray_CTerritory extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CArray_CTerritoryBasicFunctions on _CStatefulChannel_CArray_CTerritory {
  void _releaseIntermediate() {
    _CStatefulChannel_CArray_CTerritory_release(this);
  }

  _CStatefulChannel_CArray_CTerritory _retain() {
    return _CStatefulChannel_CArray_CTerritory_retain(this);
  }

  List<Territory> _getter() {
    final cValue = _CStatefulChannel_CArray_CTerritoryGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CTerritory, ffi.Int64)> callback) {
    return _CStatefulChannel_CArray_CTerritoryConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CArray_CTerritoryToDart on _CStatefulChannel_CArray_CTerritory {
  StatefulChannel<List<Territory>> _toDart() {
    return _CStatefulChannel_CArray_CTerritoryImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CArray_CTerritory on StatefulChannel<List<Territory>> {
  _CStatefulChannel_CArray_CTerritory _copyFromDartTo_CStatefulChannel_CArray_CTerritory() {
    return _CStatefulChannel_CArray_CTerritoryMakeDefault();
  }
}
	
// MARK: Private functions and pointers


late final _CBuildingIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBuildingId Function()>>('CBuildingIdMakeDefault');
late final _CBuildingIdMakeDefault = _CBuildingIdMakeDefaultPtr.asFunction<_CBuildingId Function()>();


late final _CDayTimeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDayTime Function()>>('CDayTimeMakeDefault');
late final _CDayTimeMakeDefault = _CDayTimeMakeDefaultPtr.asFunction<_CDayTime Function()>();


late final _CDgisObjectIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDgisObjectId Function()>>('CDgisObjectIdMakeDefault');
late final _CDgisObjectIdMakeDefault = _CDgisObjectIdMakeDefaultPtr.asFunction<_CDgisObjectId Function()>();


late final _CContext_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CContext_cg_objectIdentifier');
late final _CContext_cg_objectIdentifier = _CContext_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CContext_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CContext_release');
late final _CContext_release = _CContext_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CContext_retainPtr = _lookup<ffi.NativeFunction<_CContext Function(ffi.Pointer<ffi.Void>)>>('CContext_retain');
late final _CContext_retain = _CContext_retainPtr.asFunction<_CContext Function(ffi.Pointer<ffi.Void>)>();
late final _CContextMakeDefaultPtr = _lookup<ffi.NativeFunction<_CContext Function()>>('CContextMakeDefault');
late final _CContextMakeDefault = _CContextMakeDefaultPtr.asFunction<_CContext Function()>();


late final _CSystemMemoryManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSystemMemoryManager_cg_objectIdentifier');
late final _CSystemMemoryManager_cg_objectIdentifier = _CSystemMemoryManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSystemMemoryManager_reduceMemoryUsagePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSystemMemoryManager)>>('CSystemMemoryManager_reduceMemoryUsage');
late final _CSystemMemoryManager_reduceMemoryUsage = _CSystemMemoryManager_reduceMemoryUsagePtr.asFunction<void Function(_CSystemMemoryManager)>();

late final _CSystemMemoryManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSystemMemoryManager_release');
late final _CSystemMemoryManager_release = _CSystemMemoryManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSystemMemoryManager_retainPtr = _lookup<ffi.NativeFunction<_CSystemMemoryManager Function(ffi.Pointer<ffi.Void>)>>('CSystemMemoryManager_retain');
late final _CSystemMemoryManager_retain = _CSystemMemoryManager_retainPtr.asFunction<_CSystemMemoryManager Function(ffi.Pointer<ffi.Void>)>();
late final _CSystemMemoryManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSystemMemoryManager Function()>>('CSystemMemoryManagerMakeDefault');
late final _CSystemMemoryManagerMakeDefault = _CSystemMemoryManagerMakeDefaultPtr.asFunction<_CSystemMemoryManager Function()>();


late final _CLevelIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLevelId Function()>>('CLevelIdMakeDefault');
late final _CLevelIdMakeDefault = _CLevelIdMakeDefaultPtr.asFunction<_CLevelId Function()>();


late final _CStringCreateWithDataPtr = _lookup<ffi.NativeFunction<_CString Function(ffi.Size size, ffi.Pointer<ffi_package.Utf8>)>>('CString_createWithData');
late final _CStringCreateWithDataPrivate = _CStringCreateWithDataPtr.asFunction<_CString Function(int, ffi.Pointer<ffi_package.Utf8>)>();
late final _GetSizeWith_CStringPtr = _lookup<ffi.NativeFunction<ffi.Size Function(_CString)>>('CString_getSize');
late final _GetSizeWith_CString = _GetSizeWith_CStringPtr.asFunction<int Function(_CString)>();
late final _GetDataWith_CStringPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi_package.Utf8> Function(_CString)>>('CString_getData');
late final _GetDataWith_CString = _GetDataWith_CStringPtr.asFunction<ffi.Pointer<ffi_package.Utf8> Function(_CString)>();
late final _CString_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CString)>>('CString_release');
late final _CString_release = _CString_releasePtr.asFunction<void Function(_CString)>();

late final _CLevelInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLevelInfo Function()>>('CLevelInfoMakeDefault');
late final _CLevelInfoMakeDefault = _CLevelInfoMakeDefaultPtr.asFunction<_CLevelInfo Function()>();


late final _CMeterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMeter Function()>>('CMeterMakeDefault');
late final _CMeterMakeDefault = _CMeterMakeDefaultPtr.asFunction<_CMeter Function()>();


late final _CPersonalDataCollectionConsentMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPersonalDataCollectionConsent Function()>>('CPersonalDataCollectionConsentMakeDefault');
late final _CPersonalDataCollectionConsentMakeDefault = _CPersonalDataCollectionConsentMakeDefaultPtr.asFunction<_CPersonalDataCollectionConsent Function()>();

late final _CScreenSizeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScreenSize Function()>>('CScreenSizeMakeDefault');
late final _CScreenSizeMakeDefault = _CScreenSizeMakeDefaultPtr.asFunction<_CScreenSize Function()>();


late final _CWeekDayMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWeekDay Function()>>('CWeekDayMakeDefault');
late final _CWeekDayMakeDefault = _CWeekDayMakeDefaultPtr.asFunction<_CWeekDay Function()>();

late final _CWeekTimeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWeekTime Function()>>('CWeekTimeMakeDefault');
late final _CWeekTimeMakeDefault = _CWeekTimeMakeDefaultPtr.asFunction<_CWeekTime Function()>();


late final _CWeekTimeIntervalMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWeekTimeInterval Function()>>('CWeekTimeIntervalMakeDefault');
late final _CWeekTimeIntervalMakeDefault = _CWeekTimeIntervalMakeDefaultPtr.asFunction<_CWeekTimeInterval Function()>();

late final _CFunction_G_getSystemMemoryManager_With_CContextPtr = _lookup<ffi.NativeFunction<_CSystemMemoryManager Function(_CContext)>>('CFunction_G_getSystemMemoryManager_With_CContext');
late final _CFunction_G_getSystemMemoryManager_With_CContext = _CFunction_G_getSystemMemoryManager_With_CContextPtr.asFunction<_CSystemMemoryManager Function(_CContext)>();
late final _CFunction_G_makeSystemContext_With_CKeySource_CHttpOptions_CLogOptions_CPersonalDataCollectionConsent_CVendorConfig_COptional_CLocationProvider_COptional_CHeadingProviderPtr = _lookup<ffi.NativeFunction<_CContext Function(_CKeySource, _CHttpOptions, _CLogOptions, _CPersonalDataCollectionConsent, _CVendorConfig, _COptional_CLocationProvider, _COptional_CHeadingProvider)>>('CFunction_G_makeSystemContext_With_CKeySource_CHttpOptions_CLogOptions_CPersonalDataCollectionConsent_CVendorConfig_COptional_CLocationProvider_COptional_CHeadingProvider');
late final _CFunction_G_makeSystemContext_With_CKeySource_CHttpOptions_CLogOptions_CPersonalDataCollectionConsent_CVendorConfig_COptional_CLocationProvider_COptional_CHeadingProvider = _CFunction_G_makeSystemContext_With_CKeySource_CHttpOptions_CLogOptions_CPersonalDataCollectionConsent_CVendorConfig_COptional_CLocationProvider_COptional_CHeadingProviderPtr.asFunction<_CContext Function(_CKeySource, _CHttpOptions, _CLogOptions, _CPersonalDataCollectionConsent, _CVendorConfig, _COptional_CLocationProvider, _COptional_CHeadingProvider)>();

late final _CKeyFromAssetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CKeyFromAsset Function()>>('CKeyFromAssetMakeDefault');
late final _CKeyFromAssetMakeDefault = _CKeyFromAssetMakeDefaultPtr.asFunction<_CKeyFromAsset Function()>();


late final _CKeyFromFileMakeDefaultPtr = _lookup<ffi.NativeFunction<_CKeyFromFile Function()>>('CKeyFromFileMakeDefault');
late final _CKeyFromFileMakeDefault = _CKeyFromFileMakeDefaultPtr.asFunction<_CKeyFromFile Function()>();


late final _CKeyFromStringMakeDefaultPtr = _lookup<ffi.NativeFunction<_CKeyFromString Function()>>('CKeyFromStringMakeDefault');
late final _CKeyFromStringMakeDefault = _CKeyFromStringMakeDefaultPtr.asFunction<_CKeyFromString Function()>();


late final _CKeySource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CKeySource)>>('CKeySource_release');
late final _CKeySource_release = _CKeySource_releasePtr.asFunction<void Function(_CKeySource)>();
late final _CKeySourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CKeySource Function()>>('CKeySourceMakeDefault');
late final _CKeySourceMakeDefault = _CKeySourceMakeDefaultPtr.asFunction<_CKeySource Function()>();

late final _CTimeIntervalMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function()>>('CTimeIntervalMakeDefault');
late final _CTimeIntervalMakeDefault = _CTimeIntervalMakeDefaultPtr.asFunction<_CTimeInterval Function()>();

late final _COptional_CStringMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CString Function()>>('COptional_CStringMakeDefault');
late final _COptional_CStringMakeDefault = _COptional_CStringMakeDefaultPtr.asFunction<_COptional_CString Function()>();

late final _COptional_CString_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CString)>>('COptional_CString_release');
late final _COptional_CString_release = _COptional_CString_releasePtr.asFunction<void Function(_COptional_CString)>();

late final _COptional_uint64_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_uint64_t Function()>>('COptional_uint64_tMakeDefault');
late final _COptional_uint64_tMakeDefault = _COptional_uint64_tMakeDefaultPtr.asFunction<_COptional_uint64_t Function()>();

late final _CHttpOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CHttpOptions Function()>>('CHttpOptionsMakeDefault');
late final _CHttpOptionsMakeDefault = _CHttpOptionsMakeDefaultPtr.asFunction<_CHttpOptions Function()>();


late final _CLogLevelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLogLevel Function()>>('CLogLevelMakeDefault');
late final _CLogLevelMakeDefault = _CLogLevelMakeDefaultPtr.asFunction<_CLogLevel Function()>();

late final _CLogSinkMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLogSink Function()>>('CLogSinkMakeDefault');
late final _CLogSinkMakeDefault = _CLogSinkMakeDefaultPtr.asFunction<_CLogSink Function()>();
late final _CLogSink_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLogSink)>>('CLogSink_release');
late final _CLogSink_release = _CLogSink_releasePtr.asFunction<void Function(_CLogSink)>();

late final _COptional_CLogSinkMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLogSink Function()>>('COptional_CLogSinkMakeDefault');
late final _COptional_CLogSinkMakeDefault = _COptional_CLogSinkMakeDefaultPtr.asFunction<_COptional_CLogSink Function()>();

late final _COptional_CLogSink_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CLogSink)>>('COptional_CLogSink_release');
late final _COptional_CLogSink_release = _COptional_CLogSink_releasePtr.asFunction<void Function(_COptional_CLogSink)>();

late final _CLogOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLogOptions Function()>>('CLogOptionsMakeDefault');
late final _CLogOptionsMakeDefault = _CLogOptionsMakeDefaultPtr.asFunction<_CLogOptions Function()>();


late final _CLogSinkCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLogSinkCpp_cg_objectIdentifier');
late final _CLogSinkCpp_cg_objectIdentifier = _CLogSinkCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLogSinkCpp_write_CLogMessagePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLogSinkCpp, _CLogMessage)>>('CLogSinkCpp_write_CLogMessage');
late final _CLogSinkCpp_write_CLogMessage = _CLogSinkCpp_write_CLogMessagePtr.asFunction<void Function(_CLogSinkCpp, _CLogMessage)>();

late final _CLogSinkCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLogSinkCpp_release');
late final _CLogSinkCpp_release = _CLogSinkCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLogSinkCpp_retainPtr = _lookup<ffi.NativeFunction<_CLogSinkCpp Function(ffi.Pointer<ffi.Void>)>>('CLogSinkCpp_retain');
late final _CLogSinkCpp_retain = _CLogSinkCpp_retainPtr.asFunction<_CLogSinkCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CLogSinkCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLogSinkCpp Function()>>('CLogSinkCppMakeDefault');
late final _CLogSinkCppMakeDefault = _CLogSinkCppMakeDefaultPtr.asFunction<_CLogSinkCpp Function()>();


late final _CLogMessageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLogMessage Function()>>('CLogMessageMakeDefault');
late final _CLogMessageMakeDefault = _CLogMessageMakeDefaultPtr.asFunction<_CLogMessage Function()>();


late final _CVendorConfigFromAssetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CVendorConfigFromAsset Function()>>('CVendorConfigFromAssetMakeDefault');
late final _CVendorConfigFromAssetMakeDefault = _CVendorConfigFromAssetMakeDefaultPtr.asFunction<_CVendorConfigFromAsset Function()>();


late final _CVendorConfigFromFileMakeDefaultPtr = _lookup<ffi.NativeFunction<_CVendorConfigFromFile Function()>>('CVendorConfigFromFileMakeDefault');
late final _CVendorConfigFromFileMakeDefault = _CVendorConfigFromFileMakeDefaultPtr.asFunction<_CVendorConfigFromFile Function()>();


late final _CVendorConfigFromStringMakeDefaultPtr = _lookup<ffi.NativeFunction<_CVendorConfigFromString Function()>>('CVendorConfigFromStringMakeDefault');
late final _CVendorConfigFromStringMakeDefault = _CVendorConfigFromStringMakeDefaultPtr.asFunction<_CVendorConfigFromString Function()>();


late final _CVendorConfig_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CVendorConfig)>>('CVendorConfig_release');
late final _CVendorConfig_release = _CVendorConfig_releasePtr.asFunction<void Function(_CVendorConfig)>();
late final _CVendorConfigMakeDefaultPtr = _lookup<ffi.NativeFunction<_CVendorConfig Function()>>('CVendorConfigMakeDefault');
late final _CVendorConfigMakeDefault = _CVendorConfigMakeDefaultPtr.asFunction<_CVendorConfig Function()>();

late final _CDesiredAccuracyMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDesiredAccuracy Function()>>('CDesiredAccuracyMakeDefault');
late final _CDesiredAccuracyMakeDefault = _CDesiredAccuracyMakeDefaultPtr.asFunction<_CDesiredAccuracy Function()>();

late final _CLocationProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationProvider Function()>>('CLocationProviderMakeDefault');
late final _CLocationProviderMakeDefault = _CLocationProviderMakeDefaultPtr.asFunction<_CLocationProvider Function()>();
late final _CLocationProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocationProvider)>>('CLocationProvider_release');
late final _CLocationProvider_release = _CLocationProvider_releasePtr.asFunction<void Function(_CLocationProvider)>();

late final _COptional_CLocationProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocationProvider Function()>>('COptional_CLocationProviderMakeDefault');
late final _COptional_CLocationProviderMakeDefault = _COptional_CLocationProviderMakeDefaultPtr.asFunction<_COptional_CLocationProvider Function()>();

late final _COptional_CLocationProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CLocationProvider)>>('COptional_CLocationProvider_release');
late final _COptional_CLocationProvider_release = _COptional_CLocationProvider_releasePtr.asFunction<void Function(_COptional_CLocationProvider)>();

late final _CLocationProviderCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLocationProviderCpp_cg_objectIdentifier');
late final _CLocationProviderCpp_cg_objectIdentifier = _CLocationProviderCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLocationProviderCpp_lastLocationPtr = _lookup<ffi.NativeFunction<_COptional_CLocation Function(_CLocationProviderCpp)>>('CLocationProviderCpp_lastLocation');
late final _CLocationProviderCpp_lastLocation = _CLocationProviderCpp_lastLocationPtr.asFunction<_COptional_CLocation Function(_CLocationProviderCpp)>();
late final _CLocationProviderCpp_setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifierPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocationProviderCpp, _COptional_CLocationNotifier, _COptional_CLocationAvailableNotifier)>>('CLocationProviderCpp_setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifier');
late final _CLocationProviderCpp_setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifier = _CLocationProviderCpp_setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifierPtr.asFunction<void Function(_CLocationProviderCpp, _COptional_CLocationNotifier, _COptional_CLocationAvailableNotifier)>();
late final _CLocationProviderCpp_setDesiredAccuracy_CDesiredAccuracyPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocationProviderCpp, _CDesiredAccuracy)>>('CLocationProviderCpp_setDesiredAccuracy_CDesiredAccuracy');
late final _CLocationProviderCpp_setDesiredAccuracy_CDesiredAccuracy = _CLocationProviderCpp_setDesiredAccuracy_CDesiredAccuracyPtr.asFunction<void Function(_CLocationProviderCpp, _CDesiredAccuracy)>();

late final _CLocationProviderCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLocationProviderCpp_release');
late final _CLocationProviderCpp_release = _CLocationProviderCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationProviderCpp_retainPtr = _lookup<ffi.NativeFunction<_CLocationProviderCpp Function(ffi.Pointer<ffi.Void>)>>('CLocationProviderCpp_retain');
late final _CLocationProviderCpp_retain = _CLocationProviderCpp_retainPtr.asFunction<_CLocationProviderCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationProviderCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationProviderCpp Function()>>('CLocationProviderCppMakeDefault');
late final _CLocationProviderCppMakeDefault = _CLocationProviderCppMakeDefaultPtr.asFunction<_CLocationProviderCpp Function()>();


late final _CLatitudeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLatitude Function()>>('CLatitudeMakeDefault');
late final _CLatitudeMakeDefault = _CLatitudeMakeDefaultPtr.asFunction<_CLatitude Function()>();


late final _CLongitudeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLongitude Function()>>('CLongitudeMakeDefault');
late final _CLongitudeMakeDefault = _CLongitudeMakeDefaultPtr.asFunction<_CLongitude Function()>();


late final _CGeoPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function()>>('CGeoPointMakeDefault');
late final _CGeoPointMakeDefault = _CGeoPointMakeDefaultPtr.asFunction<_CGeoPoint Function()>();


late final _CLocationCoordinatesMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationCoordinates Function()>>('CLocationCoordinatesMakeDefault');
late final _CLocationCoordinatesMakeDefault = _CLocationCoordinatesMakeDefaultPtr.asFunction<_CLocationCoordinates Function()>();


late final _COptional_doubleMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_double Function()>>('COptional_doubleMakeDefault');
late final _COptional_doubleMakeDefault = _COptional_doubleMakeDefaultPtr.asFunction<_COptional_double Function()>();

late final _CLocationFuzzyDoubleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationFuzzyDouble Function()>>('CLocationFuzzyDoubleMakeDefault');
late final _CLocationFuzzyDoubleMakeDefault = _CLocationFuzzyDoubleMakeDefaultPtr.asFunction<_CLocationFuzzyDouble Function()>();


late final _COptional_CLocationFuzzyDoubleMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocationFuzzyDouble Function()>>('COptional_CLocationFuzzyDoubleMakeDefault');
late final _COptional_CLocationFuzzyDoubleMakeDefault = _COptional_CLocationFuzzyDoubleMakeDefaultPtr.asFunction<_COptional_CLocationFuzzyDouble Function()>();

late final _CBearingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBearing Function()>>('CBearingMakeDefault');
late final _CBearingMakeDefault = _CBearingMakeDefaultPtr.asFunction<_CBearing Function()>();


late final _COptional_CBearingMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CBearing Function()>>('COptional_CBearingMakeDefault');
late final _COptional_CBearingMakeDefault = _COptional_CBearingMakeDefaultPtr.asFunction<_COptional_CBearing Function()>();

late final _CLocationCourseMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationCourse Function()>>('CLocationCourseMakeDefault');
late final _CLocationCourseMakeDefault = _CLocationCourseMakeDefaultPtr.asFunction<_CLocationCourse Function()>();


late final _COptional_CLocationCourseMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocationCourse Function()>>('COptional_CLocationCourseMakeDefault');
late final _COptional_CLocationCourseMakeDefault = _COptional_CLocationCourseMakeDefaultPtr.asFunction<_COptional_CLocationCourse Function()>();

late final _CLocationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocation Function()>>('CLocationMakeDefault');
late final _CLocationMakeDefault = _CLocationMakeDefaultPtr.asFunction<_CLocation Function()>();


late final _COptional_CLocationMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocation Function()>>('COptional_CLocationMakeDefault');
late final _COptional_CLocationMakeDefault = _COptional_CLocationMakeDefaultPtr.asFunction<_COptional_CLocation Function()>();

late final _CLocationNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLocationNotifier_cg_objectIdentifier');
late final _CLocationNotifier_cg_objectIdentifier = _CLocationNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLocationNotifier_send_CArray_CLocationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocationNotifier, _CArray_CLocation)>>('CLocationNotifier_send_CArray_CLocation');
late final _CLocationNotifier_send_CArray_CLocation = _CLocationNotifier_send_CArray_CLocationPtr.asFunction<void Function(_CLocationNotifier, _CArray_CLocation)>();

late final _CLocationNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLocationNotifier_release');
late final _CLocationNotifier_release = _CLocationNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationNotifier_retainPtr = _lookup<ffi.NativeFunction<_CLocationNotifier Function(ffi.Pointer<ffi.Void>)>>('CLocationNotifier_retain');
late final _CLocationNotifier_retain = _CLocationNotifier_retainPtr.asFunction<_CLocationNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationNotifier Function()>>('CLocationNotifierMakeDefault');
late final _CLocationNotifierMakeDefault = _CLocationNotifierMakeDefaultPtr.asFunction<_CLocationNotifier Function()>();


late final _COptional_CLocationNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocationNotifier Function()>>('COptional_CLocationNotifierMakeDefault');
late final _COptional_CLocationNotifierMakeDefault = _COptional_CLocationNotifierMakeDefaultPtr.asFunction<_COptional_CLocationNotifier Function()>();

late final _COptional_CLocationNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CLocationNotifier)>>('COptional_CLocationNotifier_release');
late final _COptional_CLocationNotifier_release = _COptional_CLocationNotifier_releasePtr.asFunction<void Function(_COptional_CLocationNotifier)>();

late final _CArray_CLocationmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CLocation Function()>>('CArray_CLocation_makeEmpty');
late final _CArray_CLocationmakeEmpty = _CArray_CLocationmakeEmptyPtr.asFunction<_CArray_CLocation Function()>();
late final _CArray_CLocationaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLocation, _CLocation)>>('CArray_CLocation_addElement');
late final _CArray_CLocationaddElement = _CArray_CLocationaddElementPtr.asFunction<void Function(_CArray_CLocation, _CLocation)>();
late final _forEach_CArray_CLocationPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CLocation, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLocation)>>)
>>('CArray_CLocation_forEachWithFunctionPointer');
late final _forEach_CArray_CLocation = _forEach_CArray_CLocationPtr.asFunction<
  void Function(_CArray_CLocation, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLocation)
>>)>();
late final _CArray_CLocation_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLocation)>>('CArray_CLocation_release');
late final _CArray_CLocation_release = _CArray_CLocation_releasePtr.asFunction<void Function(_CArray_CLocation)>();

late final _CLocationAvailableNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLocationAvailableNotifier_cg_objectIdentifier');
late final _CLocationAvailableNotifier_cg_objectIdentifier = _CLocationAvailableNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLocationAvailableNotifier_send_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocationAvailableNotifier, ffi.Bool)>>('CLocationAvailableNotifier_send_bool');
late final _CLocationAvailableNotifier_send_bool = _CLocationAvailableNotifier_send_boolPtr.asFunction<void Function(_CLocationAvailableNotifier, bool)>();

late final _CLocationAvailableNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLocationAvailableNotifier_release');
late final _CLocationAvailableNotifier_release = _CLocationAvailableNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationAvailableNotifier_retainPtr = _lookup<ffi.NativeFunction<_CLocationAvailableNotifier Function(ffi.Pointer<ffi.Void>)>>('CLocationAvailableNotifier_retain');
late final _CLocationAvailableNotifier_retain = _CLocationAvailableNotifier_retainPtr.asFunction<_CLocationAvailableNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationAvailableNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationAvailableNotifier Function()>>('CLocationAvailableNotifierMakeDefault');
late final _CLocationAvailableNotifierMakeDefault = _CLocationAvailableNotifierMakeDefaultPtr.asFunction<_CLocationAvailableNotifier Function()>();


late final _COptional_CLocationAvailableNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocationAvailableNotifier Function()>>('COptional_CLocationAvailableNotifierMakeDefault');
late final _COptional_CLocationAvailableNotifierMakeDefault = _COptional_CLocationAvailableNotifierMakeDefaultPtr.asFunction<_COptional_CLocationAvailableNotifier Function()>();

late final _COptional_CLocationAvailableNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CLocationAvailableNotifier)>>('COptional_CLocationAvailableNotifier_release');
late final _COptional_CLocationAvailableNotifier_release = _COptional_CLocationAvailableNotifier_releasePtr.asFunction<void Function(_COptional_CLocationAvailableNotifier)>();

late final _CHeadingProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CHeadingProvider Function()>>('CHeadingProviderMakeDefault');
late final _CHeadingProviderMakeDefault = _CHeadingProviderMakeDefaultPtr.asFunction<_CHeadingProvider Function()>();
late final _CHeadingProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CHeadingProvider)>>('CHeadingProvider_release');
late final _CHeadingProvider_release = _CHeadingProvider_releasePtr.asFunction<void Function(_CHeadingProvider)>();

late final _COptional_CHeadingProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CHeadingProvider Function()>>('COptional_CHeadingProviderMakeDefault');
late final _COptional_CHeadingProviderMakeDefault = _COptional_CHeadingProviderMakeDefaultPtr.asFunction<_COptional_CHeadingProvider Function()>();

late final _COptional_CHeadingProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CHeadingProvider)>>('COptional_CHeadingProvider_release');
late final _COptional_CHeadingProvider_release = _COptional_CHeadingProvider_releasePtr.asFunction<void Function(_COptional_CHeadingProvider)>();

late final _CHeadingProviderCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CHeadingProviderCpp_cg_objectIdentifier');
late final _CHeadingProviderCpp_cg_objectIdentifier = _CHeadingProviderCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CHeadingProviderCpp_setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifierPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CHeadingProviderCpp, _COptional_CHeadingNotifier, _COptional_CHeadingAvailableNotifier)>>('CHeadingProviderCpp_setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifier');
late final _CHeadingProviderCpp_setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifier = _CHeadingProviderCpp_setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifierPtr.asFunction<void Function(_CHeadingProviderCpp, _COptional_CHeadingNotifier, _COptional_CHeadingAvailableNotifier)>();

late final _CHeadingProviderCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CHeadingProviderCpp_release');
late final _CHeadingProviderCpp_release = _CHeadingProviderCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CHeadingProviderCpp_retainPtr = _lookup<ffi.NativeFunction<_CHeadingProviderCpp Function(ffi.Pointer<ffi.Void>)>>('CHeadingProviderCpp_retain');
late final _CHeadingProviderCpp_retain = _CHeadingProviderCpp_retainPtr.asFunction<_CHeadingProviderCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CHeadingProviderCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CHeadingProviderCpp Function()>>('CHeadingProviderCppMakeDefault');
late final _CHeadingProviderCppMakeDefault = _CHeadingProviderCppMakeDefaultPtr.asFunction<_CHeadingProviderCpp Function()>();


late final _CHeadingNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CHeadingNotifier_cg_objectIdentifier');
late final _CHeadingNotifier_cg_objectIdentifier = _CHeadingNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CHeadingNotifier_send_CPlatformHeadingPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CHeadingNotifier, _CPlatformHeading)>>('CHeadingNotifier_send_CPlatformHeading');
late final _CHeadingNotifier_send_CPlatformHeading = _CHeadingNotifier_send_CPlatformHeadingPtr.asFunction<void Function(_CHeadingNotifier, _CPlatformHeading)>();

late final _CHeadingNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CHeadingNotifier_release');
late final _CHeadingNotifier_release = _CHeadingNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CHeadingNotifier_retainPtr = _lookup<ffi.NativeFunction<_CHeadingNotifier Function(ffi.Pointer<ffi.Void>)>>('CHeadingNotifier_retain');
late final _CHeadingNotifier_retain = _CHeadingNotifier_retainPtr.asFunction<_CHeadingNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CHeadingNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CHeadingNotifier Function()>>('CHeadingNotifierMakeDefault');
late final _CHeadingNotifierMakeDefault = _CHeadingNotifierMakeDefaultPtr.asFunction<_CHeadingNotifier Function()>();


late final _COptional_CHeadingNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CHeadingNotifier Function()>>('COptional_CHeadingNotifierMakeDefault');
late final _COptional_CHeadingNotifierMakeDefault = _COptional_CHeadingNotifierMakeDefaultPtr.asFunction<_COptional_CHeadingNotifier Function()>();

late final _COptional_CHeadingNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CHeadingNotifier)>>('COptional_CHeadingNotifier_release');
late final _COptional_CHeadingNotifier_release = _COptional_CHeadingNotifier_releasePtr.asFunction<void Function(_COptional_CHeadingNotifier)>();

late final _CPlatformHeadingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPlatformHeading Function()>>('CPlatformHeadingMakeDefault');
late final _CPlatformHeadingMakeDefault = _CPlatformHeadingMakeDefaultPtr.asFunction<_CPlatformHeading Function()>();


late final _CHeadingAvailableNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CHeadingAvailableNotifier_cg_objectIdentifier');
late final _CHeadingAvailableNotifier_cg_objectIdentifier = _CHeadingAvailableNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CHeadingAvailableNotifier_send_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CHeadingAvailableNotifier, ffi.Bool)>>('CHeadingAvailableNotifier_send_bool');
late final _CHeadingAvailableNotifier_send_bool = _CHeadingAvailableNotifier_send_boolPtr.asFunction<void Function(_CHeadingAvailableNotifier, bool)>();

late final _CHeadingAvailableNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CHeadingAvailableNotifier_release');
late final _CHeadingAvailableNotifier_release = _CHeadingAvailableNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CHeadingAvailableNotifier_retainPtr = _lookup<ffi.NativeFunction<_CHeadingAvailableNotifier Function(ffi.Pointer<ffi.Void>)>>('CHeadingAvailableNotifier_retain');
late final _CHeadingAvailableNotifier_retain = _CHeadingAvailableNotifier_retainPtr.asFunction<_CHeadingAvailableNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CHeadingAvailableNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CHeadingAvailableNotifier Function()>>('CHeadingAvailableNotifierMakeDefault');
late final _CHeadingAvailableNotifierMakeDefault = _CHeadingAvailableNotifierMakeDefaultPtr.asFunction<_CHeadingAvailableNotifier Function()>();


late final _COptional_CHeadingAvailableNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CHeadingAvailableNotifier Function()>>('COptional_CHeadingAvailableNotifierMakeDefault');
late final _COptional_CHeadingAvailableNotifierMakeDefault = _COptional_CHeadingAvailableNotifierMakeDefaultPtr.asFunction<_COptional_CHeadingAvailableNotifier Function()>();

late final _COptional_CHeadingAvailableNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CHeadingAvailableNotifier)>>('COptional_CHeadingAvailableNotifier_release');
late final _COptional_CHeadingAvailableNotifier_release = _COptional_CHeadingAvailableNotifier_releasePtr.asFunction<void Function(_COptional_CHeadingAvailableNotifier)>();

late final _CFile_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CFile_cg_objectIdentifier');
late final _CFile_cg_objectIdentifier = _CFile_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CFile_S_fromString_CStringPtr = _lookup<ffi.NativeFunction<_CFile Function(_CString)>>('CFile_S_fromString_CString');
late final _CFile_S_fromString_CString = _CFile_S_fromString_CStringPtr.asFunction<_CFile Function(_CString)>();
late final _CFile_C_createWith_CStringPtr = _lookup<ffi.NativeFunction<_CFile Function(_CString)>>('CFile_C_createWith_CString');
late final _CFile_C_createWith_CString = _CFile_C_createWith_CStringPtr.asFunction<_CFile Function(_CString)>();

late final _CFile_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CFile_release');
late final _CFile_release = _CFile_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CFile_retainPtr = _lookup<ffi.NativeFunction<_CFile Function(ffi.Pointer<ffi.Void>)>>('CFile_retain');
late final _CFile_retain = _CFile_retainPtr.asFunction<_CFile Function(ffi.Pointer<ffi.Void>)>();
late final _CFileMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFile Function()>>('CFileMakeDefault');
late final _CFileMakeDefault = _CFileMakeDefaultPtr.asFunction<_CFile Function()>();


late final _CGeoRectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeoRect Function()>>('CGeoRectMakeDefault');
late final _CGeoRectMakeDefault = _CGeoRectMakeDefaultPtr.asFunction<_CGeoRect Function()>();

late final _CFunction_G_calculateBearing_With_CGeoPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<_CBearing Function(_CGeoPoint, _CGeoPoint)>>('CFunction_G_calculateBearing_With_CGeoPoint_CGeoPoint');
late final _CFunction_G_calculateBearing_With_CGeoPoint_CGeoPoint = _CFunction_G_calculateBearing_With_CGeoPoint_CGeoPointPtr.asFunction<_CBearing Function(_CGeoPoint, _CGeoPoint)>();
late final _CFunction_G_calculateDistance_With_CGeoPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Double Function(_CGeoPoint, _CGeoPoint)>>('CFunction_G_calculateDistance_With_CGeoPoint_CGeoPoint');
late final _CFunction_G_calculateDistance_With_CGeoPoint_CGeoPoint = _CFunction_G_calculateDistance_With_CGeoPoint_CGeoPointPtr.asFunction<double Function(_CGeoPoint, _CGeoPoint)>();
late final _CFunction_G_move_With_CGeoPoint_CBearing_doublePtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CGeoPoint, _CBearing, ffi.Double)>>('CFunction_G_move_With_CGeoPoint_CBearing_double');
late final _CFunction_G_move_With_CGeoPoint_CBearing_double = _CFunction_G_move_With_CGeoPoint_CBearing_doublePtr.asFunction<_CGeoPoint Function(_CGeoPoint, _CBearing, double)>();
late final _CFunction_G_isGeoPointValid_With_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoPoint)>>('CFunction_G_isGeoPointValid_With_CGeoPoint');
late final _CFunction_G_isGeoPointValid_With_CGeoPoint = _CFunction_G_isGeoPointValid_With_CGeoPointPtr.asFunction<bool Function(_CGeoPoint)>();
late final _CFunction_G_isGeoRectValid_With_CGeoRectPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoRect)>>('CFunction_G_isGeoRectValid_With_CGeoRect');
late final _CFunction_G_isGeoRectValid_With_CGeoRect = _CFunction_G_isGeoRectValid_With_CGeoRectPtr.asFunction<bool Function(_CGeoRect)>();
late final _CFunction_G_containsPoint_With_CGeoRect_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoRect, _CGeoPoint)>>('CFunction_G_containsPoint_With_CGeoRect_CGeoPoint');
late final _CFunction_G_containsPoint_With_CGeoRect_CGeoPoint = _CFunction_G_containsPoint_With_CGeoRect_CGeoPointPtr.asFunction<bool Function(_CGeoRect, _CGeoPoint)>();
late final _CFunction_G_containsRect_With_CGeoRect_CGeoRectPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoRect, _CGeoRect)>>('CFunction_G_containsRect_With_CGeoRect_CGeoRect');
late final _CFunction_G_containsRect_With_CGeoRect_CGeoRect = _CFunction_G_containsRect_With_CGeoRect_CGeoRectPtr.asFunction<bool Function(_CGeoRect, _CGeoRect)>();
late final _CFunction_G_expandPoint_With_CGeoRect_CGeoPointPtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CGeoRect, _CGeoPoint)>>('CFunction_G_expandPoint_With_CGeoRect_CGeoPoint');
late final _CFunction_G_expandPoint_With_CGeoRect_CGeoPoint = _CFunction_G_expandPoint_With_CGeoRect_CGeoPointPtr.asFunction<_CGeoRect Function(_CGeoRect, _CGeoPoint)>();
late final _CFunction_G_expandRect_With_CGeoRect_CGeoRectPtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CGeoRect, _CGeoRect)>>('CFunction_G_expandRect_With_CGeoRect_CGeoRect');
late final _CFunction_G_expandRect_With_CGeoRect_CGeoRect = _CFunction_G_expandRect_With_CGeoRect_CGeoRectPtr.asFunction<_CGeoRect Function(_CGeoRect, _CGeoRect)>();
late final _CFunction_G_isDegenerate_With_CGeoRectPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoRect)>>('CFunction_G_isDegenerate_With_CGeoRect');
late final _CFunction_G_isDegenerate_With_CGeoRect = _CFunction_G_isDegenerate_With_CGeoRectPtr.asFunction<bool Function(_CGeoRect)>();
late final _CFunction_G_intersects_With_CGeoRect_CGeoRectPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoRect, _CGeoRect)>>('CFunction_G_intersects_With_CGeoRect_CGeoRect');
late final _CFunction_G_intersects_With_CGeoRect_CGeoRect = _CFunction_G_intersects_With_CGeoRect_CGeoRectPtr.asFunction<bool Function(_CGeoRect, _CGeoRect)>();

late final _CApartmentRangeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CApartmentRange Function()>>('CApartmentRangeMakeDefault');
late final _CApartmentRangeMakeDefault = _CApartmentRangeMakeDefaultPtr.asFunction<_CApartmentRange Function()>();


late final _CAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAttribute Function()>>('CAttributeMakeDefault');
late final _CAttributeMakeDefault = _CAttributeMakeDefaultPtr.asFunction<_CAttribute Function()>();


late final _CPurposeCodeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPurposeCode Function()>>('CPurposeCodeMakeDefault');
late final _CPurposeCodeMakeDefault = _CPurposeCodeMakeDefaultPtr.asFunction<_CPurposeCode Function()>();


late final _CArray_CLevelInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CLevelInfo Function()>>('CArray_CLevelInfo_makeEmpty');
late final _CArray_CLevelInfomakeEmpty = _CArray_CLevelInfomakeEmptyPtr.asFunction<_CArray_CLevelInfo Function()>();
late final _CArray_CLevelInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLevelInfo, _CLevelInfo)>>('CArray_CLevelInfo_addElement');
late final _CArray_CLevelInfoaddElement = _CArray_CLevelInfoaddElementPtr.asFunction<void Function(_CArray_CLevelInfo, _CLevelInfo)>();
late final _forEach_CArray_CLevelInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CLevelInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLevelInfo)>>)
>>('CArray_CLevelInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CLevelInfo = _forEach_CArray_CLevelInfoPtr.asFunction<
  void Function(_CArray_CLevelInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLevelInfo)
>>)>();
late final _CArray_CLevelInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLevelInfo)>>('CArray_CLevelInfo_release');
late final _CArray_CLevelInfo_release = _CArray_CLevelInfo_releasePtr.asFunction<void Function(_CArray_CLevelInfo)>();

late final _CBuildingLevelsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBuildingLevels Function()>>('CBuildingLevelsMakeDefault');
late final _CBuildingLevelsMakeDefault = _CBuildingLevelsMakeDefaultPtr.asFunction<_CBuildingLevels Function()>();


late final _COptional_CPurposeCodeMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CPurposeCode Function()>>('COptional_CPurposeCodeMakeDefault');
late final _COptional_CPurposeCodeMakeDefault = _COptional_CPurposeCodeMakeDefaultPtr.asFunction<_COptional_CPurposeCode Function()>();

late final _COptional_CBuildingLevelsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CBuildingLevels Function()>>('COptional_CBuildingLevelsMakeDefault');
late final _COptional_CBuildingLevelsMakeDefault = _COptional_CBuildingLevelsMakeDefaultPtr.asFunction<_COptional_CBuildingLevels Function()>();

late final _COptional_CBuildingLevels_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CBuildingLevels)>>('COptional_CBuildingLevels_release');
late final _COptional_CBuildingLevels_release = _COptional_CBuildingLevels_releasePtr.asFunction<void Function(_COptional_CBuildingLevels)>();

late final _COptional_CBuildingIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CBuildingId Function()>>('COptional_CBuildingIdMakeDefault');
late final _COptional_CBuildingIdMakeDefault = _COptional_CBuildingIdMakeDefaultPtr.asFunction<_COptional_CBuildingId Function()>();

late final _CBuildingInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBuildingInfo Function()>>('CBuildingInfoMakeDefault');
late final _CBuildingInfoMakeDefault = _CBuildingInfoMakeDefaultPtr.asFunction<_CBuildingInfo Function()>();


late final _CContactInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CContactInfo Function()>>('CContactInfoMakeDefault');
late final _CContactInfoMakeDefault = _CContactInfoMakeDefaultPtr.asFunction<_CContactInfo Function()>();


late final _CIsOpenNowMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIsOpenNow Function()>>('CIsOpenNowMakeDefault');
late final _CIsOpenNowMakeDefault = _CIsOpenNowMakeDefaultPtr.asFunction<_CIsOpenNow Function()>();


late final _CWorkTimeFilter_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CWorkTimeFilter)>>('CWorkTimeFilter_release');
late final _CWorkTimeFilter_release = _CWorkTimeFilter_releasePtr.asFunction<void Function(_CWorkTimeFilter)>();
late final _CWorkTimeFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWorkTimeFilter Function()>>('CWorkTimeFilterMakeDefault');
late final _CWorkTimeFilterMakeDefault = _CWorkTimeFilterMakeDefaultPtr.asFunction<_CWorkTimeFilter Function()>();

late final _COptional_boolMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_bool Function()>>('COptional_boolMakeDefault');
late final _COptional_boolMakeDefault = _COptional_boolMakeDefaultPtr.asFunction<_COptional_bool Function()>();

late final _CFlagFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFlagFilter Function()>>('CFlagFilterMakeDefault');
late final _CFlagFilterMakeDefault = _CFlagFilterMakeDefaultPtr.asFunction<_CFlagFilter Function()>();


late final _CRangeFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRangeFilter Function()>>('CRangeFilterMakeDefault');
late final _CRangeFilterMakeDefault = _CRangeFilterMakeDefaultPtr.asFunction<_CRangeFilter Function()>();


late final _CSortingFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSortingFilter Function()>>('CSortingFilterMakeDefault');
late final _CSortingFilterMakeDefault = _CSortingFilterMakeDefaultPtr.asFunction<_CSortingFilter Function()>();


late final _CDynamicFilter_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDynamicFilter)>>('CDynamicFilter_release');
late final _CDynamicFilter_release = _CDynamicFilter_releasePtr.asFunction<void Function(_CDynamicFilter)>();
late final _CDynamicFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDynamicFilter Function()>>('CDynamicFilterMakeDefault');
late final _CDynamicFilterMakeDefault = _CDynamicFilterMakeDefaultPtr.asFunction<_CDynamicFilter Function()>();

late final _COptional_CWorkTimeFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CWorkTimeFilter Function()>>('COptional_CWorkTimeFilterMakeDefault');
late final _COptional_CWorkTimeFilterMakeDefault = _COptional_CWorkTimeFilterMakeDefaultPtr.asFunction<_COptional_CWorkTimeFilter Function()>();

late final _CArray_CDynamicFiltermakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CDynamicFilter Function()>>('CArray_CDynamicFilter_makeEmpty');
late final _CArray_CDynamicFiltermakeEmpty = _CArray_CDynamicFiltermakeEmptyPtr.asFunction<_CArray_CDynamicFilter Function()>();
late final _CArray_CDynamicFilteraddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDynamicFilter, _CDynamicFilter)>>('CArray_CDynamicFilter_addElement');
late final _CArray_CDynamicFilteraddElement = _CArray_CDynamicFilteraddElementPtr.asFunction<void Function(_CArray_CDynamicFilter, _CDynamicFilter)>();
late final _forEach_CArray_CDynamicFilterPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CDynamicFilter, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDynamicFilter)>>)
>>('CArray_CDynamicFilter_forEachWithFunctionPointer');
late final _forEach_CArray_CDynamicFilter = _forEach_CArray_CDynamicFilterPtr.asFunction<
  void Function(_CArray_CDynamicFilter, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDynamicFilter)
>>)>();
late final _CArray_CDynamicFilter_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDynamicFilter)>>('CArray_CDynamicFilter_release');
late final _CArray_CDynamicFilter_release = _CArray_CDynamicFilter_releasePtr.asFunction<void Function(_CArray_CDynamicFilter)>();

late final _CDirectoryFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectoryFilter Function()>>('CDirectoryFilterMakeDefault');
late final _CDirectoryFilterMakeDefault = _CDirectoryFilterMakeDefaultPtr.asFunction<_CDirectoryFilter Function()>();


late final _CArray_CGeoPointmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CGeoPoint Function()>>('CArray_CGeoPoint_makeEmpty');
late final _CArray_CGeoPointmakeEmpty = _CArray_CGeoPointmakeEmptyPtr.asFunction<_CArray_CGeoPoint Function()>();
late final _CArray_CGeoPointaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeoPoint, _CGeoPoint)>>('CArray_CGeoPoint_addElement');
late final _CArray_CGeoPointaddElement = _CArray_CGeoPointaddElementPtr.asFunction<void Function(_CArray_CGeoPoint, _CGeoPoint)>();
late final _forEach_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CGeoPoint, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeoPoint)>>)
>>('CArray_CGeoPoint_forEachWithFunctionPointer');
late final _forEach_CArray_CGeoPoint = _forEach_CArray_CGeoPointPtr.asFunction<
  void Function(_CArray_CGeoPoint, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeoPoint)
>>)>();
late final _CArray_CGeoPoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeoPoint)>>('CArray_CGeoPoint_release');
late final _CArray_CGeoPoint_release = _CArray_CGeoPoint_releasePtr.asFunction<void Function(_CArray_CGeoPoint)>();

late final _CArray_CArray_CGeoPointmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CArray_CGeoPoint Function()>>('CArray_CArray_CGeoPoint_makeEmpty');
late final _CArray_CArray_CGeoPointmakeEmpty = _CArray_CArray_CGeoPointmakeEmptyPtr.asFunction<_CArray_CArray_CGeoPoint Function()>();
late final _CArray_CArray_CGeoPointaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CArray_CGeoPoint, _CArray_CGeoPoint)>>('CArray_CArray_CGeoPoint_addElement');
late final _CArray_CArray_CGeoPointaddElement = _CArray_CArray_CGeoPointaddElementPtr.asFunction<void Function(_CArray_CArray_CGeoPoint, _CArray_CGeoPoint)>();
late final _forEach_CArray_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CArray_CGeoPoint, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CGeoPoint)>>)
>>('CArray_CArray_CGeoPoint_forEachWithFunctionPointer');
late final _forEach_CArray_CArray_CGeoPoint = _forEach_CArray_CArray_CGeoPointPtr.asFunction<
  void Function(_CArray_CArray_CGeoPoint, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CGeoPoint)
>>)>();
late final _CArray_CArray_CGeoPoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CArray_CGeoPoint)>>('CArray_CArray_CGeoPoint_release');
late final _CArray_CArray_CGeoPoint_release = _CArray_CArray_CGeoPoint_releasePtr.asFunction<void Function(_CArray_CArray_CGeoPoint)>();

late final _CEntranceGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CEntranceGeometry Function()>>('CEntranceGeometryMakeDefault');
late final _CEntranceGeometryMakeDefault = _CEntranceGeometryMakeDefaultPtr.asFunction<_CEntranceGeometry Function()>();


late final _CArray_CApartmentRangemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CApartmentRange Function()>>('CArray_CApartmentRange_makeEmpty');
late final _CArray_CApartmentRangemakeEmpty = _CArray_CApartmentRangemakeEmptyPtr.asFunction<_CArray_CApartmentRange Function()>();
late final _CArray_CApartmentRangeaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CApartmentRange, _CApartmentRange)>>('CArray_CApartmentRange_addElement');
late final _CArray_CApartmentRangeaddElement = _CArray_CApartmentRangeaddElementPtr.asFunction<void Function(_CArray_CApartmentRange, _CApartmentRange)>();
late final _forEach_CArray_CApartmentRangePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CApartmentRange, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CApartmentRange)>>)
>>('CArray_CApartmentRange_forEachWithFunctionPointer');
late final _forEach_CArray_CApartmentRange = _forEach_CArray_CApartmentRangePtr.asFunction<
  void Function(_CArray_CApartmentRange, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CApartmentRange)
>>)>();
late final _CArray_CApartmentRange_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CApartmentRange)>>('CArray_CApartmentRange_release');
late final _CArray_CApartmentRange_release = _CArray_CApartmentRange_releasePtr.asFunction<void Function(_CArray_CApartmentRange)>();

late final _COptional_CEntranceGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CEntranceGeometry Function()>>('COptional_CEntranceGeometryMakeDefault');
late final _COptional_CEntranceGeometryMakeDefault = _COptional_CEntranceGeometryMakeDefaultPtr.asFunction<_COptional_CEntranceGeometry Function()>();

late final _COptional_CEntranceGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CEntranceGeometry)>>('COptional_CEntranceGeometry_release');
late final _COptional_CEntranceGeometry_release = _COptional_CEntranceGeometry_releasePtr.asFunction<void Function(_COptional_CEntranceGeometry)>();

late final _CEntranceInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CEntranceInfo Function()>>('CEntranceInfoMakeDefault');
late final _CEntranceInfoMakeDefault = _CEntranceInfoMakeDefaultPtr.asFunction<_CEntranceInfo Function()>();


late final _CFilterTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFilterType Function()>>('CFilterTypeMakeDefault');
late final _CFilterTypeMakeDefault = _CFilterTypeMakeDefaultPtr.asFunction<_CFilterType Function()>();

late final _CFloorInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFloorInfo Function()>>('CFloorInfoMakeDefault');
late final _CFloorInfoMakeDefault = _CFloorInfoMakeDefaultPtr.asFunction<_CFloorInfo Function()>();


late final _CFormattedAddressMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFormattedAddress Function()>>('CFormattedAddressMakeDefault');
late final _CFormattedAddressMakeDefault = _CFormattedAddressMakeDefaultPtr.asFunction<_CFormattedAddress Function()>();


late final _CFormattingTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFormattingType Function()>>('CFormattingTypeMakeDefault');
late final _CFormattingTypeMakeDefault = _CFormattingTypeMakeDefaultPtr.asFunction<_CFormattingType Function()>();

late final _CAggregateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAggregate Function()>>('CAggregateMakeDefault');
late final _CAggregateMakeDefault = _CAggregateMakeDefaultPtr.asFunction<_CAggregate Function()>();


late final _CStatusTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatusType Function()>>('CStatusTypeMakeDefault');
late final _CStatusTypeMakeDefault = _CStatusTypeMakeDefaultPtr.asFunction<_CStatusType Function()>();

late final _CConnectorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CConnector Function()>>('CConnectorMakeDefault');
late final _CConnectorMakeDefault = _CConnectorMakeDefaultPtr.asFunction<_CConnector Function()>();


late final _CArray_CConnectormakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CConnector Function()>>('CArray_CConnector_makeEmpty');
late final _CArray_CConnectormakeEmpty = _CArray_CConnectormakeEmptyPtr.asFunction<_CArray_CConnector Function()>();
late final _CArray_CConnectoraddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CConnector, _CConnector)>>('CArray_CConnector_addElement');
late final _CArray_CConnectoraddElement = _CArray_CConnectoraddElementPtr.asFunction<void Function(_CArray_CConnector, _CConnector)>();
late final _forEach_CArray_CConnectorPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CConnector, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CConnector)>>)
>>('CArray_CConnector_forEachWithFunctionPointer');
late final _forEach_CArray_CConnector = _forEach_CArray_CConnectorPtr.asFunction<
  void Function(_CArray_CConnector, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CConnector)
>>)>();
late final _CArray_CConnector_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CConnector)>>('CArray_CConnector_release');
late final _CArray_CConnector_release = _CArray_CConnector_releasePtr.asFunction<void Function(_CArray_CConnector)>();

late final _CChargingStationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChargingStation Function()>>('CChargingStationMakeDefault');
late final _CChargingStationMakeDefault = _CChargingStationMakeDefaultPtr.asFunction<_CChargingStation Function()>();


late final _CRubricIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRubricId Function()>>('CRubricIdMakeDefault');
late final _CRubricIdMakeDefault = _CRubricIdMakeDefaultPtr.asFunction<_CRubricId Function()>();

late final _CItemMarkerInfo_objectIdPtr = _lookup<ffi.NativeFunction<_COptional_CDgisObjectId Function(_CItemMarkerInfo)>>('CItemMarkerInfo_objectId');
late final _CItemMarkerInfo_objectId = _CItemMarkerInfo_objectIdPtr.asFunction<_COptional_CDgisObjectId Function(_CItemMarkerInfo)>();
late final _CItemMarkerInfo_geoPointPtr = _lookup<ffi.NativeFunction<_CGeoPointWithElevation Function(_CItemMarkerInfo)>>('CItemMarkerInfo_geoPoint');
late final _CItemMarkerInfo_geoPoint = _CItemMarkerInfo_geoPointPtr.asFunction<_CGeoPointWithElevation Function(_CItemMarkerInfo)>();
late final _CItemMarkerInfo_floorInfoPtr = _lookup<ffi.NativeFunction<_COptional_CFloorInfo Function(_CItemMarkerInfo)>>('CItemMarkerInfo_floorInfo');
late final _CItemMarkerInfo_floorInfo = _CItemMarkerInfo_floorInfoPtr.asFunction<_COptional_CFloorInfo Function(_CItemMarkerInfo)>();
late final _CItemMarkerInfo_titlePtr = _lookup<ffi.NativeFunction<_COptional_CString Function(_CItemMarkerInfo)>>('CItemMarkerInfo_title');
late final _CItemMarkerInfo_title = _CItemMarkerInfo_titlePtr.asFunction<_COptional_CString Function(_CItemMarkerInfo)>();
late final _CItemMarkerInfo_rubricIdsPtr = _lookup<ffi.NativeFunction<_CArray_CRubricId Function(_CItemMarkerInfo)>>('CItemMarkerInfo_rubricIds');
late final _CItemMarkerInfo_rubricIds = _CItemMarkerInfo_rubricIdsPtr.asFunction<_CArray_CRubricId Function(_CItemMarkerInfo)>();

late final _CItemMarkerInfo_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CItemMarkerInfo_cg_objectIdentifier');
late final _CItemMarkerInfo_cg_objectIdentifier = _CItemMarkerInfo_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CItemMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CItemMarkerInfo_release');
late final _CItemMarkerInfo_release = _CItemMarkerInfo_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CItemMarkerInfo_retainPtr = _lookup<ffi.NativeFunction<_CItemMarkerInfo Function(ffi.Pointer<ffi.Void>)>>('CItemMarkerInfo_retain');
late final _CItemMarkerInfo_retain = _CItemMarkerInfo_retainPtr.asFunction<_CItemMarkerInfo Function(ffi.Pointer<ffi.Void>)>();
late final _CItemMarkerInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CItemMarkerInfo Function()>>('CItemMarkerInfoMakeDefault');
late final _CItemMarkerInfoMakeDefault = _CItemMarkerInfoMakeDefaultPtr.asFunction<_CItemMarkerInfo Function()>();


late final _COptional_CDgisObjectIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CDgisObjectId Function()>>('COptional_CDgisObjectIdMakeDefault');
late final _COptional_CDgisObjectIdMakeDefault = _COptional_CDgisObjectIdMakeDefaultPtr.asFunction<_COptional_CDgisObjectId Function()>();

late final _CElevationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CElevation Function()>>('CElevationMakeDefault');
late final _CElevationMakeDefault = _CElevationMakeDefaultPtr.asFunction<_CElevation Function()>();


late final _CGeoPointWithElevationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeoPointWithElevation Function()>>('CGeoPointWithElevationMakeDefault');
late final _CGeoPointWithElevationMakeDefault = _CGeoPointWithElevationMakeDefaultPtr.asFunction<_CGeoPointWithElevation Function()>();


late final _COptional_CFloorInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CFloorInfo Function()>>('COptional_CFloorInfoMakeDefault');
late final _COptional_CFloorInfoMakeDefault = _COptional_CFloorInfoMakeDefaultPtr.asFunction<_COptional_CFloorInfo Function()>();

late final _CArray_CRubricIdmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRubricId Function()>>('CArray_CRubricId_makeEmpty');
late final _CArray_CRubricIdmakeEmpty = _CArray_CRubricIdmakeEmptyPtr.asFunction<_CArray_CRubricId Function()>();
late final _CArray_CRubricIdaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRubricId, _CRubricId)>>('CArray_CRubricId_addElement');
late final _CArray_CRubricIdaddElement = _CArray_CRubricIdaddElementPtr.asFunction<void Function(_CArray_CRubricId, _CRubricId)>();
late final _forEach_CArray_CRubricIdPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRubricId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRubricId)>>)
>>('CArray_CRubricId_forEachWithFunctionPointer');
late final _forEach_CArray_CRubricId = _forEach_CArray_CRubricIdPtr.asFunction<
  void Function(_CArray_CRubricId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRubricId)
>>)>();
late final _CArray_CRubricId_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRubricId)>>('CArray_CRubricId_release');
late final _CArray_CRubricId_release = _CArray_CRubricId_releasePtr.asFunction<void Function(_CArray_CRubricId)>();

late final _CObjectTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CObjectType Function()>>('CObjectTypeMakeDefault');
late final _CObjectTypeMakeDefault = _CObjectTypeMakeDefaultPtr.asFunction<_CObjectType Function()>();

late final _CArray_CArray_CWeekTimeIntervalmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CArray_CWeekTimeInterval Function()>>('CArray_CArray_CWeekTimeInterval_makeEmpty');
late final _CArray_CArray_CWeekTimeIntervalmakeEmpty = _CArray_CArray_CWeekTimeIntervalmakeEmptyPtr.asFunction<_CArray_CArray_CWeekTimeInterval Function()>();
late final _CArray_CArray_CWeekTimeIntervaladdElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CArray_CWeekTimeInterval, _CArray_CWeekTimeInterval)>>('CArray_CArray_CWeekTimeInterval_addElement');
late final _CArray_CArray_CWeekTimeIntervaladdElement = _CArray_CArray_CWeekTimeIntervaladdElementPtr.asFunction<void Function(_CArray_CArray_CWeekTimeInterval, _CArray_CWeekTimeInterval)>();
late final _forEach_CArray_CArray_CWeekTimeIntervalPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CArray_CWeekTimeInterval, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CWeekTimeInterval)>>)
>>('CArray_CArray_CWeekTimeInterval_forEachWithFunctionPointer');
late final _forEach_CArray_CArray_CWeekTimeInterval = _forEach_CArray_CArray_CWeekTimeIntervalPtr.asFunction<
  void Function(_CArray_CArray_CWeekTimeInterval, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CWeekTimeInterval)
>>)>();
late final _CArray_CArray_CWeekTimeInterval_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CArray_CWeekTimeInterval)>>('CArray_CArray_CWeekTimeInterval_release');
late final _CArray_CArray_CWeekTimeInterval_release = _CArray_CArray_CWeekTimeInterval_releasePtr.asFunction<void Function(_CArray_CArray_CWeekTimeInterval)>();

late final _COpeningHoursMakeDefaultPtr = _lookup<ffi.NativeFunction<_COpeningHours Function()>>('COpeningHoursMakeDefault');
late final _COpeningHoursMakeDefault = _COpeningHoursMakeDefaultPtr.asFunction<_COpeningHours Function()>();


late final _CArray_CWeekTimeIntervalmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CWeekTimeInterval Function()>>('CArray_CWeekTimeInterval_makeEmpty');
late final _CArray_CWeekTimeIntervalmakeEmpty = _CArray_CWeekTimeIntervalmakeEmptyPtr.asFunction<_CArray_CWeekTimeInterval Function()>();
late final _CArray_CWeekTimeIntervaladdElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CWeekTimeInterval, _CWeekTimeInterval)>>('CArray_CWeekTimeInterval_addElement');
late final _CArray_CWeekTimeIntervaladdElement = _CArray_CWeekTimeIntervaladdElementPtr.asFunction<void Function(_CArray_CWeekTimeInterval, _CWeekTimeInterval)>();
late final _forEach_CArray_CWeekTimeIntervalPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CWeekTimeInterval, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CWeekTimeInterval)>>)
>>('CArray_CWeekTimeInterval_forEachWithFunctionPointer');
late final _forEach_CArray_CWeekTimeInterval = _forEach_CArray_CWeekTimeIntervalPtr.asFunction<
  void Function(_CArray_CWeekTimeInterval, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CWeekTimeInterval)
>>)>();
late final _CArray_CWeekTimeInterval_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CWeekTimeInterval)>>('CArray_CWeekTimeInterval_release');
late final _CArray_CWeekTimeInterval_release = _CArray_CWeekTimeInterval_releasePtr.asFunction<void Function(_CArray_CWeekTimeInterval)>();

late final _COrgIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_COrgId Function()>>('COrgIdMakeDefault');
late final _COrgIdMakeDefault = _COrgIdMakeDefaultPtr.asFunction<_COrgId Function()>();


late final _COrgInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COrgInfo Function()>>('COrgInfoMakeDefault');
late final _COrgInfoMakeDefault = _COrgInfoMakeDefaultPtr.asFunction<_COrgInfo Function()>();


late final _CParkingAccessMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingAccess Function()>>('CParkingAccessMakeDefault');
late final _CParkingAccessMakeDefault = _CParkingAccessMakeDefaultPtr.asFunction<_CParkingAccess Function()>();

late final _CSpecialSpaceTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSpecialSpaceType Function()>>('CSpecialSpaceTypeMakeDefault');
late final _CSpecialSpaceTypeMakeDefault = _CSpecialSpaceTypeMakeDefaultPtr.asFunction<_CSpecialSpaceType Function()>();

late final _CSpecialSpaceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSpecialSpace Function()>>('CSpecialSpaceMakeDefault');
late final _CSpecialSpaceMakeDefault = _CSpecialSpaceMakeDefaultPtr.asFunction<_CSpecialSpace Function()>();


late final _CArray_CSpecialSpacemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSpecialSpace Function()>>('CArray_CSpecialSpace_makeEmpty');
late final _CArray_CSpecialSpacemakeEmpty = _CArray_CSpecialSpacemakeEmptyPtr.asFunction<_CArray_CSpecialSpace Function()>();
late final _CArray_CSpecialSpaceaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSpecialSpace, _CSpecialSpace)>>('CArray_CSpecialSpace_addElement');
late final _CArray_CSpecialSpaceaddElement = _CArray_CSpecialSpaceaddElementPtr.asFunction<void Function(_CArray_CSpecialSpace, _CSpecialSpace)>();
late final _forEach_CArray_CSpecialSpacePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSpecialSpace, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSpecialSpace)>>)
>>('CArray_CSpecialSpace_forEachWithFunctionPointer');
late final _forEach_CArray_CSpecialSpace = _forEach_CArray_CSpecialSpacePtr.asFunction<
  void Function(_CArray_CSpecialSpace, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSpecialSpace)
>>)>();
late final _CArray_CSpecialSpace_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSpecialSpace)>>('CArray_CSpecialSpace_release');
late final _CArray_CSpecialSpace_release = _CArray_CSpecialSpace_releasePtr.asFunction<void Function(_CArray_CSpecialSpace)>();

late final _CParkingCapacityMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingCapacity Function()>>('CParkingCapacityMakeDefault');
late final _CParkingCapacityMakeDefault = _CParkingCapacityMakeDefaultPtr.asFunction<_CParkingCapacity Function()>();


late final _CParkingTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingType Function()>>('CParkingTypeMakeDefault');
late final _CParkingTypeMakeDefault = _CParkingTypeMakeDefaultPtr.asFunction<_CParkingType Function()>();

late final _CParkingPurposeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingPurpose Function()>>('CParkingPurposeMakeDefault');
late final _CParkingPurposeMakeDefault = _CParkingPurposeMakeDefaultPtr.asFunction<_CParkingPurpose Function()>();

late final _CParkingPavingTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingPavingType Function()>>('CParkingPavingTypeMakeDefault');
late final _CParkingPavingTypeMakeDefault = _CParkingPavingTypeMakeDefaultPtr.asFunction<_CParkingPavingType Function()>();

late final _COptional_CParkingTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CParkingType Function()>>('COptional_CParkingTypeMakeDefault');
late final _COptional_CParkingTypeMakeDefault = _COptional_CParkingTypeMakeDefaultPtr.asFunction<_COptional_CParkingType Function()>();

late final _COptional_CParkingPavingTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CParkingPavingType Function()>>('COptional_CParkingPavingTypeMakeDefault');
late final _COptional_CParkingPavingTypeMakeDefault = _COptional_CParkingPavingTypeMakeDefaultPtr.asFunction<_COptional_CParkingPavingType Function()>();

late final _COptional_uint16_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_uint16_t Function()>>('COptional_uint16_tMakeDefault');
late final _COptional_uint16_tMakeDefault = _COptional_uint16_tMakeDefaultPtr.asFunction<_COptional_uint16_t Function()>();

late final _COptional_CParkingCapacityMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CParkingCapacity Function()>>('COptional_CParkingCapacityMakeDefault');
late final _COptional_CParkingCapacityMakeDefault = _COptional_CParkingCapacityMakeDefaultPtr.asFunction<_COptional_CParkingCapacity Function()>();

late final _COptional_CParkingCapacity_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CParkingCapacity)>>('COptional_CParkingCapacity_release');
late final _COptional_CParkingCapacity_release = _COptional_CParkingCapacity_releasePtr.asFunction<void Function(_COptional_CParkingCapacity)>();

late final _CParkingInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingInfo Function()>>('CParkingInfoMakeDefault');
late final _CParkingInfoMakeDefault = _CParkingInfoMakeDefaultPtr.asFunction<_CParkingInfo Function()>();


late final _CReviewsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CReviews Function()>>('CReviewsMakeDefault');
late final _CReviewsMakeDefault = _CReviewsMakeDefaultPtr.asFunction<_CReviews Function()>();


late final _CSearchResultTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchResultType Function()>>('CSearchResultTypeMakeDefault');
late final _CSearchResultTypeMakeDefault = _CSearchResultTypeMakeDefaultPtr.asFunction<_CSearchResultType Function()>();

late final _CSortingTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSortingType Function()>>('CSortingTypeMakeDefault');
late final _CSortingTypeMakeDefault = _CSortingTypeMakeDefaultPtr.asFunction<_CSortingType Function()>();

late final _CTradeLicenseMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTradeLicense Function()>>('CTradeLicenseMakeDefault');
late final _CTradeLicenseMakeDefault = _CTradeLicenseMakeDefaultPtr.asFunction<_CTradeLicense Function()>();


late final _CUIMarkerInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CUIMarkerInfo Function()>>('CUIMarkerInfoMakeDefault');
late final _CUIMarkerInfoMakeDefault = _CUIMarkerInfoMakeDefaultPtr.asFunction<_CUIMarkerInfo Function()>();


late final _CWorkStatusMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWorkStatus Function()>>('CWorkStatusMakeDefault');
late final _CWorkStatusMakeDefault = _CWorkStatusMakeDefaultPtr.asFunction<_CWorkStatus Function()>();


late final _CAddressAdmDivMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddressAdmDiv Function()>>('CAddressAdmDivMakeDefault');
late final _CAddressAdmDivMakeDefault = _CAddressAdmDivMakeDefaultPtr.asFunction<_CAddressAdmDiv Function()>();


late final _CAddressStreetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddressStreet Function()>>('CAddressStreetMakeDefault');
late final _CAddressStreetMakeDefault = _CAddressStreetMakeDefaultPtr.asFunction<_CAddressStreet Function()>();


late final _CAddressNumberMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddressNumber Function()>>('CAddressNumberMakeDefault');
late final _CAddressNumberMakeDefault = _CAddressNumberMakeDefaultPtr.asFunction<_CAddressNumber Function()>();


late final _CAddressLocationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddressLocation Function()>>('CAddressLocationMakeDefault');
late final _CAddressLocationMakeDefault = _CAddressLocationMakeDefaultPtr.asFunction<_CAddressLocation Function()>();


late final _CAddressComponent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAddressComponent)>>('CAddressComponent_release');
late final _CAddressComponent_release = _CAddressComponent_releasePtr.asFunction<void Function(_CAddressComponent)>();
late final _CAddressComponentMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddressComponent Function()>>('CAddressComponentMakeDefault');
late final _CAddressComponentMakeDefault = _CAddressComponentMakeDefaultPtr.asFunction<_CAddressComponent Function()>();

late final _CArray_CAddressAdmDivmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CAddressAdmDiv Function()>>('CArray_CAddressAdmDiv_makeEmpty');
late final _CArray_CAddressAdmDivmakeEmpty = _CArray_CAddressAdmDivmakeEmptyPtr.asFunction<_CArray_CAddressAdmDiv Function()>();
late final _CArray_CAddressAdmDivaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAddressAdmDiv, _CAddressAdmDiv)>>('CArray_CAddressAdmDiv_addElement');
late final _CArray_CAddressAdmDivaddElement = _CArray_CAddressAdmDivaddElementPtr.asFunction<void Function(_CArray_CAddressAdmDiv, _CAddressAdmDiv)>();
late final _forEach_CArray_CAddressAdmDivPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CAddressAdmDiv, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAddressAdmDiv)>>)
>>('CArray_CAddressAdmDiv_forEachWithFunctionPointer');
late final _forEach_CArray_CAddressAdmDiv = _forEach_CArray_CAddressAdmDivPtr.asFunction<
  void Function(_CArray_CAddressAdmDiv, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAddressAdmDiv)
>>)>();
late final _CArray_CAddressAdmDiv_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAddressAdmDiv)>>('CArray_CAddressAdmDiv_release');
late final _CArray_CAddressAdmDiv_release = _CArray_CAddressAdmDiv_releasePtr.asFunction<void Function(_CArray_CAddressAdmDiv)>();

late final _CArray_CAddressComponentmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CAddressComponent Function()>>('CArray_CAddressComponent_makeEmpty');
late final _CArray_CAddressComponentmakeEmpty = _CArray_CAddressComponentmakeEmptyPtr.asFunction<_CArray_CAddressComponent Function()>();
late final _CArray_CAddressComponentaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAddressComponent, _CAddressComponent)>>('CArray_CAddressComponent_addElement');
late final _CArray_CAddressComponentaddElement = _CArray_CAddressComponentaddElementPtr.asFunction<void Function(_CArray_CAddressComponent, _CAddressComponent)>();
late final _forEach_CArray_CAddressComponentPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CAddressComponent, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAddressComponent)>>)
>>('CArray_CAddressComponent_forEachWithFunctionPointer');
late final _forEach_CArray_CAddressComponent = _forEach_CArray_CAddressComponentPtr.asFunction<
  void Function(_CArray_CAddressComponent, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAddressComponent)
>>)>();
late final _CArray_CAddressComponent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAddressComponent)>>('CArray_CAddressComponent_release');
late final _CArray_CAddressComponent_release = _CArray_CAddressComponent_releasePtr.asFunction<void Function(_CArray_CAddressComponent)>();

late final _CAddressMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddress Function()>>('CAddressMakeDefault');
late final _CAddressMakeDefault = _CAddressMakeDefaultPtr.asFunction<_CAddress Function()>();

late final _CDirectoryObject_typesPtr = _lookup<ffi.NativeFunction<_CArray_CObjectType Function(_CDirectoryObject)>>('CDirectoryObject_types');
late final _CDirectoryObject_types = _CDirectoryObject_typesPtr.asFunction<_CArray_CObjectType Function(_CDirectoryObject)>();
late final _CDirectoryObject_titlePtr = _lookup<ffi.NativeFunction<_CString Function(_CDirectoryObject)>>('CDirectoryObject_title');
late final _CDirectoryObject_title = _CDirectoryObject_titlePtr.asFunction<_CString Function(_CDirectoryObject)>();
late final _CDirectoryObject_titleAdditionPtr = _lookup<ffi.NativeFunction<_CString Function(_CDirectoryObject)>>('CDirectoryObject_titleAddition');
late final _CDirectoryObject_titleAddition = _CDirectoryObject_titleAdditionPtr.asFunction<_CString Function(_CDirectoryObject)>();
late final _CDirectoryObject_subtitlePtr = _lookup<ffi.NativeFunction<_CString Function(_CDirectoryObject)>>('CDirectoryObject_subtitle');
late final _CDirectoryObject_subtitle = _CDirectoryObject_subtitlePtr.asFunction<_CString Function(_CDirectoryObject)>();
late final _CDirectoryObject_descriptionPtr = _lookup<ffi.NativeFunction<_CString Function(_CDirectoryObject)>>('CDirectoryObject_description');
late final _CDirectoryObject_description = _CDirectoryObject_descriptionPtr.asFunction<_CString Function(_CDirectoryObject)>();
late final _CDirectoryObject_idPtr = _lookup<ffi.NativeFunction<_COptional_CDgisObjectId Function(_CDirectoryObject)>>('CDirectoryObject_id');
late final _CDirectoryObject_id = _CDirectoryObject_idPtr.asFunction<_COptional_CDgisObjectId Function(_CDirectoryObject)>();
late final _CDirectoryObject_markerPositionPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPointWithElevation Function(_CDirectoryObject)>>('CDirectoryObject_markerPosition');
late final _CDirectoryObject_markerPosition = _CDirectoryObject_markerPositionPtr.asFunction<_COptional_CGeoPointWithElevation Function(_CDirectoryObject)>();
late final _CDirectoryObject_addressPtr = _lookup<ffi.NativeFunction<_COptional_CAddress Function(_CDirectoryObject)>>('CDirectoryObject_address');
late final _CDirectoryObject_address = _CDirectoryObject_addressPtr.asFunction<_COptional_CAddress Function(_CDirectoryObject)>();
late final _CDirectoryObject_attributesPtr = _lookup<ffi.NativeFunction<_CArray_CAttribute Function(_CDirectoryObject)>>('CDirectoryObject_attributes');
late final _CDirectoryObject_attributes = _CDirectoryObject_attributesPtr.asFunction<_CArray_CAttribute Function(_CDirectoryObject)>();
late final _CDirectoryObject_contextAttributesPtr = _lookup<ffi.NativeFunction<_CArray_CAttribute Function(_CDirectoryObject)>>('CDirectoryObject_contextAttributes');
late final _CDirectoryObject_contextAttributes = _CDirectoryObject_contextAttributesPtr.asFunction<_CArray_CAttribute Function(_CDirectoryObject)>();
late final _CDirectoryObject_timeZoneOffsetPtr = _lookup<ffi.NativeFunction<_COptional_CTimeInterval Function(_CDirectoryObject)>>('CDirectoryObject_timeZoneOffset');
late final _CDirectoryObject_timeZoneOffset = _CDirectoryObject_timeZoneOffsetPtr.asFunction<_COptional_CTimeInterval Function(_CDirectoryObject)>();
late final _CDirectoryObject_openingHoursPtr = _lookup<ffi.NativeFunction<_COptional_COpeningHours Function(_CDirectoryObject)>>('CDirectoryObject_openingHours');
late final _CDirectoryObject_openingHours = _CDirectoryObject_openingHoursPtr.asFunction<_COptional_COpeningHours Function(_CDirectoryObject)>();
late final _CDirectoryObject_contactInfosPtr = _lookup<ffi.NativeFunction<_CArray_CContactInfo Function(_CDirectoryObject)>>('CDirectoryObject_contactInfos');
late final _CDirectoryObject_contactInfos = _CDirectoryObject_contactInfosPtr.asFunction<_CArray_CContactInfo Function(_CDirectoryObject)>();
late final _CDirectoryObject_reviewsPtr = _lookup<ffi.NativeFunction<_COptional_CReviews Function(_CDirectoryObject)>>('CDirectoryObject_reviews');
late final _CDirectoryObject_reviews = _CDirectoryObject_reviewsPtr.asFunction<_COptional_CReviews Function(_CDirectoryObject)>();
late final _CDirectoryObject_parkingInfoPtr = _lookup<ffi.NativeFunction<_COptional_CParkingInfo Function(_CDirectoryObject)>>('CDirectoryObject_parkingInfo');
late final _CDirectoryObject_parkingInfo = _CDirectoryObject_parkingInfoPtr.asFunction<_COptional_CParkingInfo Function(_CDirectoryObject)>();
late final _CDirectoryObject_workStatusPtr = _lookup<ffi.NativeFunction<_COptional_CWorkStatus Function(_CDirectoryObject)>>('CDirectoryObject_workStatus');
late final _CDirectoryObject_workStatus = _CDirectoryObject_workStatusPtr.asFunction<_COptional_CWorkStatus Function(_CDirectoryObject)>();
late final _CDirectoryObject_levelIdPtr = _lookup<ffi.NativeFunction<_COptional_CLevelId Function(_CDirectoryObject)>>('CDirectoryObject_levelId');
late final _CDirectoryObject_levelId = _CDirectoryObject_levelIdPtr.asFunction<_COptional_CLevelId Function(_CDirectoryObject)>();
late final _CDirectoryObject_buildingLevelsPtr = _lookup<ffi.NativeFunction<_COptional_CBuildingLevels Function(_CDirectoryObject)>>('CDirectoryObject_buildingLevels');
late final _CDirectoryObject_buildingLevels = _CDirectoryObject_buildingLevelsPtr.asFunction<_COptional_CBuildingLevels Function(_CDirectoryObject)>();
late final _CDirectoryObject_entrancesPtr = _lookup<ffi.NativeFunction<_CArray_CEntranceInfo Function(_CDirectoryObject)>>('CDirectoryObject_entrances');
late final _CDirectoryObject_entrances = _CDirectoryObject_entrancesPtr.asFunction<_CArray_CEntranceInfo Function(_CDirectoryObject)>();
late final _CDirectoryObject_tradeLicensePtr = _lookup<ffi.NativeFunction<_COptional_CTradeLicense Function(_CDirectoryObject)>>('CDirectoryObject_tradeLicense');
late final _CDirectoryObject_tradeLicense = _CDirectoryObject_tradeLicensePtr.asFunction<_COptional_CTradeLicense Function(_CDirectoryObject)>();
late final _CDirectoryObject_buildingInfoPtr = _lookup<ffi.NativeFunction<_CBuildingInfo Function(_CDirectoryObject)>>('CDirectoryObject_buildingInfo');
late final _CDirectoryObject_buildingInfo = _CDirectoryObject_buildingInfoPtr.asFunction<_CBuildingInfo Function(_CDirectoryObject)>();
late final _CDirectoryObject_chargingStationPtr = _lookup<ffi.NativeFunction<_COptional_CChargingStation Function(_CDirectoryObject)>>('CDirectoryObject_chargingStation');
late final _CDirectoryObject_chargingStation = _CDirectoryObject_chargingStationPtr.asFunction<_COptional_CChargingStation Function(_CDirectoryObject)>();
late final _CDirectoryObject_rubricIdsPtr = _lookup<ffi.NativeFunction<_CArray_CRubricId Function(_CDirectoryObject)>>('CDirectoryObject_rubricIds');
late final _CDirectoryObject_rubricIds = _CDirectoryObject_rubricIdsPtr.asFunction<_CArray_CRubricId Function(_CDirectoryObject)>();
late final _CDirectoryObject_orgInfoPtr = _lookup<ffi.NativeFunction<_COptional_COrgInfo Function(_CDirectoryObject)>>('CDirectoryObject_orgInfo');
late final _CDirectoryObject_orgInfo = _CDirectoryObject_orgInfoPtr.asFunction<_COptional_COrgInfo Function(_CDirectoryObject)>();

late final _CDirectoryObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectoryObject_cg_objectIdentifier');
late final _CDirectoryObject_cg_objectIdentifier = _CDirectoryObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectoryObject_formattedAddress_CFormattingTypePtr = _lookup<ffi.NativeFunction<_COptional_CFormattedAddress Function(_CDirectoryObject, _CFormattingType)>>('CDirectoryObject_formattedAddress_CFormattingType');
late final _CDirectoryObject_formattedAddress_CFormattingType = _CDirectoryObject_formattedAddress_CFormattingTypePtr.asFunction<_COptional_CFormattedAddress Function(_CDirectoryObject, _CFormattingType)>();

late final _CDirectoryObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectoryObject_release');
late final _CDirectoryObject_release = _CDirectoryObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectoryObject_retainPtr = _lookup<ffi.NativeFunction<_CDirectoryObject Function(ffi.Pointer<ffi.Void>)>>('CDirectoryObject_retain');
late final _CDirectoryObject_retain = _CDirectoryObject_retainPtr.asFunction<_CDirectoryObject Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectoryObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectoryObject Function()>>('CDirectoryObjectMakeDefault');
late final _CDirectoryObjectMakeDefault = _CDirectoryObjectMakeDefaultPtr.asFunction<_CDirectoryObject Function()>();


late final _CArray_CObjectTypemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CObjectType Function()>>('CArray_CObjectType_makeEmpty');
late final _CArray_CObjectTypemakeEmpty = _CArray_CObjectTypemakeEmptyPtr.asFunction<_CArray_CObjectType Function()>();
late final _CArray_CObjectTypeaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CObjectType, _CObjectType)>>('CArray_CObjectType_addElement');
late final _CArray_CObjectTypeaddElement = _CArray_CObjectTypeaddElementPtr.asFunction<void Function(_CArray_CObjectType, _CObjectType)>();
late final _forEach_CArray_CObjectTypePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CObjectType, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CObjectType)>>)
>>('CArray_CObjectType_forEachWithFunctionPointer');
late final _forEach_CArray_CObjectType = _forEach_CArray_CObjectTypePtr.asFunction<
  void Function(_CArray_CObjectType, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CObjectType)
>>)>();
late final _CArray_CObjectType_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CObjectType)>>('CArray_CObjectType_release');
late final _CArray_CObjectType_release = _CArray_CObjectType_releasePtr.asFunction<void Function(_CArray_CObjectType)>();

late final _COptional_CGeoPointWithElevationMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPointWithElevation Function()>>('COptional_CGeoPointWithElevationMakeDefault');
late final _COptional_CGeoPointWithElevationMakeDefault = _COptional_CGeoPointWithElevationMakeDefaultPtr.asFunction<_COptional_CGeoPointWithElevation Function()>();

late final _COptional_CAddressMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CAddress Function()>>('COptional_CAddressMakeDefault');
late final _COptional_CAddressMakeDefault = _COptional_CAddressMakeDefaultPtr.asFunction<_COptional_CAddress Function()>();

late final _COptional_CAddress_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CAddress)>>('COptional_CAddress_release');
late final _COptional_CAddress_release = _COptional_CAddress_releasePtr.asFunction<void Function(_COptional_CAddress)>();

late final _CArray_CAttributemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CAttribute Function()>>('CArray_CAttribute_makeEmpty');
late final _CArray_CAttributemakeEmpty = _CArray_CAttributemakeEmptyPtr.asFunction<_CArray_CAttribute Function()>();
late final _CArray_CAttributeaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAttribute, _CAttribute)>>('CArray_CAttribute_addElement');
late final _CArray_CAttributeaddElement = _CArray_CAttributeaddElementPtr.asFunction<void Function(_CArray_CAttribute, _CAttribute)>();
late final _forEach_CArray_CAttributePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CAttribute, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAttribute)>>)
>>('CArray_CAttribute_forEachWithFunctionPointer');
late final _forEach_CArray_CAttribute = _forEach_CArray_CAttributePtr.asFunction<
  void Function(_CArray_CAttribute, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAttribute)
>>)>();
late final _CArray_CAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAttribute)>>('CArray_CAttribute_release');
late final _CArray_CAttribute_release = _CArray_CAttribute_releasePtr.asFunction<void Function(_CArray_CAttribute)>();

late final _COptional_CFormattedAddressMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CFormattedAddress Function()>>('COptional_CFormattedAddressMakeDefault');
late final _COptional_CFormattedAddressMakeDefault = _COptional_CFormattedAddressMakeDefaultPtr.asFunction<_COptional_CFormattedAddress Function()>();

late final _COptional_CFormattedAddress_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CFormattedAddress)>>('COptional_CFormattedAddress_release');
late final _COptional_CFormattedAddress_release = _COptional_CFormattedAddress_releasePtr.asFunction<void Function(_COptional_CFormattedAddress)>();

late final _COptional_CTimeIntervalMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CTimeInterval Function()>>('COptional_CTimeIntervalMakeDefault');
late final _COptional_CTimeIntervalMakeDefault = _COptional_CTimeIntervalMakeDefaultPtr.asFunction<_COptional_CTimeInterval Function()>();

late final _COptional_COpeningHoursMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_COpeningHours Function()>>('COptional_COpeningHoursMakeDefault');
late final _COptional_COpeningHoursMakeDefault = _COptional_COpeningHoursMakeDefaultPtr.asFunction<_COptional_COpeningHours Function()>();

late final _COptional_COpeningHours_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_COpeningHours)>>('COptional_COpeningHours_release');
late final _COptional_COpeningHours_release = _COptional_COpeningHours_releasePtr.asFunction<void Function(_COptional_COpeningHours)>();

late final _CArray_CContactInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CContactInfo Function()>>('CArray_CContactInfo_makeEmpty');
late final _CArray_CContactInfomakeEmpty = _CArray_CContactInfomakeEmptyPtr.asFunction<_CArray_CContactInfo Function()>();
late final _CArray_CContactInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CContactInfo, _CContactInfo)>>('CArray_CContactInfo_addElement');
late final _CArray_CContactInfoaddElement = _CArray_CContactInfoaddElementPtr.asFunction<void Function(_CArray_CContactInfo, _CContactInfo)>();
late final _forEach_CArray_CContactInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CContactInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CContactInfo)>>)
>>('CArray_CContactInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CContactInfo = _forEach_CArray_CContactInfoPtr.asFunction<
  void Function(_CArray_CContactInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CContactInfo)
>>)>();
late final _CArray_CContactInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CContactInfo)>>('CArray_CContactInfo_release');
late final _CArray_CContactInfo_release = _CArray_CContactInfo_releasePtr.asFunction<void Function(_CArray_CContactInfo)>();

late final _COptional_CReviewsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CReviews Function()>>('COptional_CReviewsMakeDefault');
late final _COptional_CReviewsMakeDefault = _COptional_CReviewsMakeDefaultPtr.asFunction<_COptional_CReviews Function()>();

late final _COptional_CParkingInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CParkingInfo Function()>>('COptional_CParkingInfoMakeDefault');
late final _COptional_CParkingInfoMakeDefault = _COptional_CParkingInfoMakeDefaultPtr.asFunction<_COptional_CParkingInfo Function()>();

late final _COptional_CParkingInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CParkingInfo)>>('COptional_CParkingInfo_release');
late final _COptional_CParkingInfo_release = _COptional_CParkingInfo_releasePtr.asFunction<void Function(_COptional_CParkingInfo)>();

late final _COptional_CWorkStatusMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CWorkStatus Function()>>('COptional_CWorkStatusMakeDefault');
late final _COptional_CWorkStatusMakeDefault = _COptional_CWorkStatusMakeDefaultPtr.asFunction<_COptional_CWorkStatus Function()>();

late final _COptional_CWorkStatus_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CWorkStatus)>>('COptional_CWorkStatus_release');
late final _COptional_CWorkStatus_release = _COptional_CWorkStatus_releasePtr.asFunction<void Function(_COptional_CWorkStatus)>();

late final _COptional_CLevelIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLevelId Function()>>('COptional_CLevelIdMakeDefault');
late final _COptional_CLevelIdMakeDefault = _COptional_CLevelIdMakeDefaultPtr.asFunction<_COptional_CLevelId Function()>();

late final _CArray_CEntranceInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CEntranceInfo Function()>>('CArray_CEntranceInfo_makeEmpty');
late final _CArray_CEntranceInfomakeEmpty = _CArray_CEntranceInfomakeEmptyPtr.asFunction<_CArray_CEntranceInfo Function()>();
late final _CArray_CEntranceInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CEntranceInfo, _CEntranceInfo)>>('CArray_CEntranceInfo_addElement');
late final _CArray_CEntranceInfoaddElement = _CArray_CEntranceInfoaddElementPtr.asFunction<void Function(_CArray_CEntranceInfo, _CEntranceInfo)>();
late final _forEach_CArray_CEntranceInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CEntranceInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CEntranceInfo)>>)
>>('CArray_CEntranceInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CEntranceInfo = _forEach_CArray_CEntranceInfoPtr.asFunction<
  void Function(_CArray_CEntranceInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CEntranceInfo)
>>)>();
late final _CArray_CEntranceInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CEntranceInfo)>>('CArray_CEntranceInfo_release');
late final _CArray_CEntranceInfo_release = _CArray_CEntranceInfo_releasePtr.asFunction<void Function(_CArray_CEntranceInfo)>();

late final _COptional_CTradeLicenseMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CTradeLicense Function()>>('COptional_CTradeLicenseMakeDefault');
late final _COptional_CTradeLicenseMakeDefault = _COptional_CTradeLicenseMakeDefaultPtr.asFunction<_COptional_CTradeLicense Function()>();

late final _COptional_CTradeLicense_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CTradeLicense)>>('COptional_CTradeLicense_release');
late final _COptional_CTradeLicense_release = _COptional_CTradeLicense_releasePtr.asFunction<void Function(_COptional_CTradeLicense)>();

late final _COptional_CChargingStationMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CChargingStation Function()>>('COptional_CChargingStationMakeDefault');
late final _COptional_CChargingStationMakeDefault = _COptional_CChargingStationMakeDefaultPtr.asFunction<_COptional_CChargingStation Function()>();

late final _COptional_CChargingStation_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CChargingStation)>>('COptional_CChargingStation_release');
late final _COptional_CChargingStation_release = _COptional_CChargingStation_releasePtr.asFunction<void Function(_COptional_CChargingStation)>();

late final _COptional_COrgInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_COrgInfo Function()>>('COptional_COrgInfoMakeDefault');
late final _COptional_COrgInfoMakeDefault = _COptional_COrgInfoMakeDefaultPtr.asFunction<_COptional_COrgInfo Function()>();

late final _COptional_COrgInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_COrgInfo)>>('COptional_COrgInfo_release');
late final _COptional_COrgInfo_release = _COptional_COrgInfo_releasePtr.asFunction<void Function(_COptional_COrgInfo)>();
late final _CPage_itemsPtr = _lookup<ffi.NativeFunction<_CArray_CDirectoryObject Function(_CPage)>>('CPage_items');
late final _CPage_items = _CPage_itemsPtr.asFunction<_CArray_CDirectoryObject Function(_CPage)>();

late final _CPage_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPage_cg_objectIdentifier');
late final _CPage_cg_objectIdentifier = _CPage_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPage_fetchPrevPagePtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CPage Function(_CPage)>>('CPage_fetchPrevPage');
late final _CPage_fetchPrevPage = _CPage_fetchPrevPagePtr.asFunction<_CFuture_COptional_CPage Function(_CPage)>();
late final _CPage_fetchNextPagePtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CPage Function(_CPage)>>('CPage_fetchNextPage');
late final _CPage_fetchNextPage = _CPage_fetchNextPagePtr.asFunction<_CFuture_COptional_CPage Function(_CPage)>();

late final _CPage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPage_release');
late final _CPage_release = _CPage_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPage_retainPtr = _lookup<ffi.NativeFunction<_CPage Function(ffi.Pointer<ffi.Void>)>>('CPage_retain');
late final _CPage_retain = _CPage_retainPtr.asFunction<_CPage Function(ffi.Pointer<ffi.Void>)>();
late final _CPageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPage Function()>>('CPageMakeDefault');
late final _CPageMakeDefault = _CPageMakeDefaultPtr.asFunction<_CPage Function()>();


late final _CArray_CDirectoryObjectmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CDirectoryObject Function()>>('CArray_CDirectoryObject_makeEmpty');
late final _CArray_CDirectoryObjectmakeEmpty = _CArray_CDirectoryObjectmakeEmptyPtr.asFunction<_CArray_CDirectoryObject Function()>();
late final _CArray_CDirectoryObjectaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDirectoryObject, _CDirectoryObject)>>('CArray_CDirectoryObject_addElement');
late final _CArray_CDirectoryObjectaddElement = _CArray_CDirectoryObjectaddElementPtr.asFunction<void Function(_CArray_CDirectoryObject, _CDirectoryObject)>();
late final _forEach_CArray_CDirectoryObjectPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CDirectoryObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDirectoryObject)>>)
>>('CArray_CDirectoryObject_forEachWithFunctionPointer');
late final _forEach_CArray_CDirectoryObject = _forEach_CArray_CDirectoryObjectPtr.asFunction<
  void Function(_CArray_CDirectoryObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDirectoryObject)
>>)>();
late final _CArray_CDirectoryObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDirectoryObject)>>('CArray_CDirectoryObject_release');
late final _CArray_CDirectoryObject_release = _CArray_CDirectoryObject_releasePtr.asFunction<void Function(_CArray_CDirectoryObject)>();

late final _CFuture_COptional_CPageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CPage Function()>>('CFuture_COptional_CPageMakeDefault');
late final _CFuture_COptional_CPageMakeDefault = _CFuture_COptional_CPageMakeDefaultPtr.asFunction<_CFuture_COptional_CPage Function()>();
late final _CFuture_COptional_CPage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_COptional_CPage)>>('CFuture_COptional_CPage_release');
late final _CFuture_COptional_CPage_release = _CFuture_COptional_CPage_releasePtr.asFunction<void Function(_CFuture_COptional_CPage)>();
late final _CFuture_COptional_CPage_retainPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CPage Function(_CFuture_COptional_CPage)>>('CFuture_COptional_CPage_retain');
late final _CFuture_COptional_CPage_retain = _CFuture_COptional_CPage_retainPtr.asFunction<_CFuture_COptional_CPage Function(_CFuture_COptional_CPage)>();
late final _CFuture_COptional_CPageReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_COptional_CPage,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CPage, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_COptional_CPage_receive');
late final _CFuture_COptional_CPageReceive = _CFuture_COptional_CPageReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_COptional_CPage,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CPage, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _COptional_CPageMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CPage Function()>>('COptional_CPageMakeDefault');
late final _COptional_CPageMakeDefault = _COptional_CPageMakeDefaultPtr.asFunction<_COptional_CPage Function()>();

late final _COptional_CPage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CPage)>>('COptional_CPage_release');
late final _COptional_CPage_release = _COptional_CPage_releasePtr.asFunction<void Function(_COptional_CPage)>();

late final _CCancellableMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCancellable Function()>>('CCancellableMakeDefault');
late final _CCancellableMakeDefault = _CCancellableMakeDefaultPtr.asFunction<_CCancellable Function()>();
late final _CCancellable_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCancellable)>>('CCancellable_release');
late final _CCancellable_release = _CCancellable_releasePtr.asFunction<void Function(_CCancellable)>();
late final _CCancellable_retainPtr = _lookup<ffi.NativeFunction<_CCancellable Function(_CCancellable)>>('CCancellable_retain');
late final _CCancellable_retain = _CCancellable_retainPtr.asFunction<_CCancellable Function(_CCancellable)>();
late final _CCancellableCancelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCancellable)>>('CCancellable_cancel');
late final _CCancellableCancel = _CCancellableCancelPtr.asFunction<void Function(_CCancellable)>();

late final _CErrorCreateWithDescriptionPtr = _lookup<ffi.NativeFunction<_CError Function(ffi.Pointer<ffi_package.Utf8>)>>('CError_createWithDescription');
late final _CErrorCreateWithDescription = _CErrorCreateWithDescriptionPtr.asFunction<_CError Function(ffi.Pointer<ffi_package.Utf8>)>();
late final _CErrorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CError Function()>>('CErrorMakeDefault');
late final _CErrorMakeDefault = _CErrorMakeDefaultPtr.asFunction<_CError Function()>();
late final _CError_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CError)>>('CError_release');
late final _CError_release = _CError_releasePtr.asFunction<void Function(_CError)>();
late final _CErrorGetDescriptionPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi_package.Utf8> Function(_CError)>>('CError_getDescription');
late final _CErrorGetDescription = _CErrorGetDescriptionPtr.asFunction<ffi.Pointer<ffi_package.Utf8> Function(_CError)>();

late final _CWidgetTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWidgetType Function()>>('CWidgetTypeMakeDefault');
late final _CWidgetTypeMakeDefault = _CWidgetTypeMakeDefaultPtr.asFunction<_CWidgetType Function()>();
late final _CWidget_typePtr = _lookup<ffi.NativeFunction<_CWidgetType Function(_CWidget)>>('CWidget_type');
late final _CWidget_type = _CWidget_typePtr.asFunction<_CWidgetType Function(_CWidget)>();
late final _CWidget_captionPtr = _lookup<ffi.NativeFunction<_COptional_CString Function(_CWidget)>>('CWidget_caption');
late final _CWidget_caption = _CWidget_captionPtr.asFunction<_COptional_CString Function(_CWidget)>();
late final _CWidget_filtersPtr = _lookup<ffi.NativeFunction<_CArray_CDynamicFilter Function(_CWidget)>>('CWidget_filters');
late final _CWidget_filters = _CWidget_filtersPtr.asFunction<_CArray_CDynamicFilter Function(_CWidget)>();

late final _CWidget_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CWidget_cg_objectIdentifier');
late final _CWidget_cg_objectIdentifier = _CWidget_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CWidget_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CWidget)>>('CWidget_cg_getSelector');
late final _CWidget_cg_getSelector = _CWidget_cg_getSelectorPtr.asFunction<int Function(_CWidget)>();

late final _CWidget_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CWidget_release');
late final _CWidget_release = _CWidget_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CWidget_retainPtr = _lookup<ffi.NativeFunction<_CWidget Function(ffi.Pointer<ffi.Void>)>>('CWidget_retain');
late final _CWidget_retain = _CWidget_retainPtr.asFunction<_CWidget Function(ffi.Pointer<ffi.Void>)>();
late final _CWidgetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWidget Function()>>('CWidgetMakeDefault');
late final _CWidgetMakeDefault = _CWidgetMakeDefaultPtr.asFunction<_CWidget Function()>();

late final _CCheckbox_filterTypePtr = _lookup<ffi.NativeFunction<_CFilterType Function(_CCheckbox)>>('CCheckbox_filterType');
late final _CCheckbox_filterType = _CCheckbox_filterTypePtr.asFunction<_CFilterType Function(_CCheckbox)>();
late final _CCheckbox_checkedTextPtr = _lookup<ffi.NativeFunction<_COptional_CString Function(_CCheckbox)>>('CCheckbox_checkedText');
late final _CCheckbox_checkedText = _CCheckbox_checkedTextPtr.asFunction<_COptional_CString Function(_CCheckbox)>();
late final _CCheckbox_uncheckedTextPtr = _lookup<ffi.NativeFunction<_COptional_CString Function(_CCheckbox)>>('CCheckbox_uncheckedText');
late final _CCheckbox_uncheckedText = _CCheckbox_uncheckedTextPtr.asFunction<_COptional_CString Function(_CCheckbox)>();
late final _CCheckbox_valuesPtr = _lookup<ffi.NativeFunction<_CArray_CString Function(_CCheckbox)>>('CCheckbox_values');
late final _CCheckbox_values = _CCheckbox_valuesPtr.asFunction<_CArray_CString Function(_CCheckbox)>();
late final _CCheckbox_isCheckedPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CCheckbox)>>('CCheckbox_isChecked');
late final _CCheckbox_isChecked = _CCheckbox_isCheckedPtr.asFunction<bool Function(_CCheckbox)>();
late final _CCheckbox_setChecked_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCheckbox, ffi.Bool)>>('CCheckbox_setChecked_bool');
late final _CCheckbox_setChecked_bool = _CCheckbox_setChecked_boolPtr.asFunction<void Function(_CCheckbox, bool)>();

late final _CCheckbox_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCheckbox_cg_objectIdentifier');
late final _CCheckbox_cg_objectIdentifier = _CCheckbox_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CCheckbox_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCheckbox_release');
late final _CCheckbox_release = _CCheckbox_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckbox_retainPtr = _lookup<ffi.NativeFunction<_CCheckbox Function(ffi.Pointer<ffi.Void>)>>('CCheckbox_retain');
late final _CCheckbox_retain = _CCheckbox_retainPtr.asFunction<_CCheckbox Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckboxMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCheckbox Function()>>('CCheckboxMakeDefault');
late final _CCheckboxMakeDefault = _CCheckboxMakeDefaultPtr.asFunction<_CCheckbox Function()>();


late final _CArray_CStringmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CString Function()>>('CArray_CString_makeEmpty');
late final _CArray_CStringmakeEmpty = _CArray_CStringmakeEmptyPtr.asFunction<_CArray_CString Function()>();
late final _CArray_CStringaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CString, _CString)>>('CArray_CString_addElement');
late final _CArray_CStringaddElement = _CArray_CStringaddElementPtr.asFunction<void Function(_CArray_CString, _CString)>();
late final _forEach_CArray_CStringPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CString, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CString)>>)
>>('CArray_CString_forEachWithFunctionPointer');
late final _forEach_CArray_CString = _forEach_CArray_CStringPtr.asFunction<
  void Function(_CArray_CString, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CString)
>>)>();
late final _CArray_CString_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CString)>>('CArray_CString_release');
late final _CArray_CString_release = _CArray_CString_releasePtr.asFunction<void Function(_CArray_CString)>();

late final _CCheckableItemTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCheckableItemType Function()>>('CCheckableItemTypeMakeDefault');
late final _CCheckableItemTypeMakeDefault = _CCheckableItemTypeMakeDefaultPtr.asFunction<_CCheckableItemType Function()>();
late final _CCheckableItem_typePtr = _lookup<ffi.NativeFunction<_CCheckableItemType Function(_CCheckableItem)>>('CCheckableItem_type');
late final _CCheckableItem_type = _CCheckableItem_typePtr.asFunction<_CCheckableItemType Function(_CCheckableItem)>();
late final _CCheckableItem_filterTypePtr = _lookup<ffi.NativeFunction<_CFilterType Function(_CCheckableItem)>>('CCheckableItem_filterType');
late final _CCheckableItem_filterType = _CCheckableItem_filterTypePtr.asFunction<_CFilterType Function(_CCheckableItem)>();

late final _CCheckableItem_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCheckableItem_cg_objectIdentifier');
late final _CCheckableItem_cg_objectIdentifier = _CCheckableItem_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCheckableItem_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CCheckableItem)>>('CCheckableItem_cg_getSelector');
late final _CCheckableItem_cg_getSelector = _CCheckableItem_cg_getSelectorPtr.asFunction<int Function(_CCheckableItem)>();

late final _CCheckableItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCheckableItem_release');
late final _CCheckableItem_release = _CCheckableItem_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckableItem_retainPtr = _lookup<ffi.NativeFunction<_CCheckableItem Function(ffi.Pointer<ffi.Void>)>>('CCheckableItem_retain');
late final _CCheckableItem_retain = _CCheckableItem_retainPtr.asFunction<_CCheckableItem Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckableItemMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCheckableItem Function()>>('CCheckableItemMakeDefault');
late final _CCheckableItemMakeDefault = _CCheckableItemMakeDefaultPtr.asFunction<_CCheckableItem Function()>();

late final _CCheckableGroupedItem_textPtr = _lookup<ffi.NativeFunction<_CString Function(_CCheckableGroupedItem)>>('CCheckableGroupedItem_text');
late final _CCheckableGroupedItem_text = _CCheckableGroupedItem_textPtr.asFunction<_CString Function(_CCheckableGroupedItem)>();
late final _CCheckableGroupedItem_valuesPtr = _lookup<ffi.NativeFunction<_CArray_CString Function(_CCheckableGroupedItem)>>('CCheckableGroupedItem_values');
late final _CCheckableGroupedItem_values = _CCheckableGroupedItem_valuesPtr.asFunction<_CArray_CString Function(_CCheckableGroupedItem)>();
late final _CCheckableGroupedItem_isCheckedPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CCheckableGroupedItem)>>('CCheckableGroupedItem_isChecked');
late final _CCheckableGroupedItem_isChecked = _CCheckableGroupedItem_isCheckedPtr.asFunction<bool Function(_CCheckableGroupedItem)>();
late final _CCheckableGroupedItem_setChecked_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCheckableGroupedItem, ffi.Bool)>>('CCheckableGroupedItem_setChecked_bool');
late final _CCheckableGroupedItem_setChecked_bool = _CCheckableGroupedItem_setChecked_boolPtr.asFunction<void Function(_CCheckableGroupedItem, bool)>();

late final _CCheckableGroupedItem_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCheckableGroupedItem_cg_objectIdentifier');
late final _CCheckableGroupedItem_cg_objectIdentifier = _CCheckableGroupedItem_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CCheckableGroupedItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCheckableGroupedItem_release');
late final _CCheckableGroupedItem_release = _CCheckableGroupedItem_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckableGroupedItem_retainPtr = _lookup<ffi.NativeFunction<_CCheckableGroupedItem Function(ffi.Pointer<ffi.Void>)>>('CCheckableGroupedItem_retain');
late final _CCheckableGroupedItem_retain = _CCheckableGroupedItem_retainPtr.asFunction<_CCheckableGroupedItem Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckableGroupedItemMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCheckableGroupedItem Function()>>('CCheckableGroupedItemMakeDefault');
late final _CCheckableGroupedItemMakeDefault = _CCheckableGroupedItemMakeDefaultPtr.asFunction<_CCheckableGroupedItem Function()>();

late final _CCheckableItemsGroup_itemsPtr = _lookup<ffi.NativeFunction<_CArray_CCheckableItem Function(_CCheckableItemsGroup)>>('CCheckableItemsGroup_items');
late final _CCheckableItemsGroup_items = _CCheckableItemsGroup_itemsPtr.asFunction<_CArray_CCheckableItem Function(_CCheckableItemsGroup)>();

late final _CCheckableItemsGroup_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCheckableItemsGroup_cg_objectIdentifier');
late final _CCheckableItemsGroup_cg_objectIdentifier = _CCheckableItemsGroup_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CCheckableItemsGroup_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCheckableItemsGroup_release');
late final _CCheckableItemsGroup_release = _CCheckableItemsGroup_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckableItemsGroup_retainPtr = _lookup<ffi.NativeFunction<_CCheckableItemsGroup Function(ffi.Pointer<ffi.Void>)>>('CCheckableItemsGroup_retain');
late final _CCheckableItemsGroup_retain = _CCheckableItemsGroup_retainPtr.asFunction<_CCheckableItemsGroup Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckableItemsGroupMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCheckableItemsGroup Function()>>('CCheckableItemsGroupMakeDefault');
late final _CCheckableItemsGroupMakeDefault = _CCheckableItemsGroupMakeDefaultPtr.asFunction<_CCheckableItemsGroup Function()>();


late final _CArray_CCheckableItemmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CCheckableItem Function()>>('CArray_CCheckableItem_makeEmpty');
late final _CArray_CCheckableItemmakeEmpty = _CArray_CCheckableItemmakeEmptyPtr.asFunction<_CArray_CCheckableItem Function()>();
late final _CArray_CCheckableItemaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CCheckableItem, _CCheckableItem)>>('CArray_CCheckableItem_addElement');
late final _CArray_CCheckableItemaddElement = _CArray_CCheckableItemaddElementPtr.asFunction<void Function(_CArray_CCheckableItem, _CCheckableItem)>();
late final _forEach_CArray_CCheckableItemPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CCheckableItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCheckableItem)>>)
>>('CArray_CCheckableItem_forEachWithFunctionPointer');
late final _forEach_CArray_CCheckableItem = _forEach_CArray_CCheckableItemPtr.asFunction<
  void Function(_CArray_CCheckableItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCheckableItem)
>>)>();
late final _CArray_CCheckableItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CCheckableItem)>>('CArray_CCheckableItem_release');
late final _CArray_CCheckableItem_release = _CArray_CCheckableItem_releasePtr.asFunction<void Function(_CArray_CCheckableItem)>();
late final _CSimpleCheckableItem_textPtr = _lookup<ffi.NativeFunction<_CString Function(_CSimpleCheckableItem)>>('CSimpleCheckableItem_text');
late final _CSimpleCheckableItem_text = _CSimpleCheckableItem_textPtr.asFunction<_CString Function(_CSimpleCheckableItem)>();
late final _CSimpleCheckableItem_valuesPtr = _lookup<ffi.NativeFunction<_CArray_CString Function(_CSimpleCheckableItem)>>('CSimpleCheckableItem_values');
late final _CSimpleCheckableItem_values = _CSimpleCheckableItem_valuesPtr.asFunction<_CArray_CString Function(_CSimpleCheckableItem)>();
late final _CSimpleCheckableItem_isCheckedPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CSimpleCheckableItem)>>('CSimpleCheckableItem_isChecked');
late final _CSimpleCheckableItem_isChecked = _CSimpleCheckableItem_isCheckedPtr.asFunction<bool Function(_CSimpleCheckableItem)>();
late final _CSimpleCheckableItem_setChecked_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleCheckableItem, ffi.Bool)>>('CSimpleCheckableItem_setChecked_bool');
late final _CSimpleCheckableItem_setChecked_bool = _CSimpleCheckableItem_setChecked_boolPtr.asFunction<void Function(_CSimpleCheckableItem, bool)>();

late final _CSimpleCheckableItem_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSimpleCheckableItem_cg_objectIdentifier');
late final _CSimpleCheckableItem_cg_objectIdentifier = _CSimpleCheckableItem_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSimpleCheckableItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSimpleCheckableItem_release');
late final _CSimpleCheckableItem_release = _CSimpleCheckableItem_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleCheckableItem_retainPtr = _lookup<ffi.NativeFunction<_CSimpleCheckableItem Function(ffi.Pointer<ffi.Void>)>>('CSimpleCheckableItem_retain');
late final _CSimpleCheckableItem_retain = _CSimpleCheckableItem_retainPtr.asFunction<_CSimpleCheckableItem Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleCheckableItemMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimpleCheckableItem Function()>>('CSimpleCheckableItemMakeDefault');
late final _CSimpleCheckableItemMakeDefault = _CSimpleCheckableItemMakeDefaultPtr.asFunction<_CSimpleCheckableItem Function()>();

late final _CGroupCheckableItem_itemsPtr = _lookup<ffi.NativeFunction<_CArray_CCheckableGroupedItem Function(_CGroupCheckableItem)>>('CGroupCheckableItem_items');
late final _CGroupCheckableItem_items = _CGroupCheckableItem_itemsPtr.asFunction<_CArray_CCheckableGroupedItem Function(_CGroupCheckableItem)>();

late final _CGroupCheckableItem_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGroupCheckableItem_cg_objectIdentifier');
late final _CGroupCheckableItem_cg_objectIdentifier = _CGroupCheckableItem_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CGroupCheckableItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGroupCheckableItem_release');
late final _CGroupCheckableItem_release = _CGroupCheckableItem_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGroupCheckableItem_retainPtr = _lookup<ffi.NativeFunction<_CGroupCheckableItem Function(ffi.Pointer<ffi.Void>)>>('CGroupCheckableItem_retain');
late final _CGroupCheckableItem_retain = _CGroupCheckableItem_retainPtr.asFunction<_CGroupCheckableItem Function(ffi.Pointer<ffi.Void>)>();
late final _CGroupCheckableItemMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGroupCheckableItem Function()>>('CGroupCheckableItemMakeDefault');
late final _CGroupCheckableItemMakeDefault = _CGroupCheckableItemMakeDefaultPtr.asFunction<_CGroupCheckableItem Function()>();


late final _CArray_CCheckableGroupedItemmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CCheckableGroupedItem Function()>>('CArray_CCheckableGroupedItem_makeEmpty');
late final _CArray_CCheckableGroupedItemmakeEmpty = _CArray_CCheckableGroupedItemmakeEmptyPtr.asFunction<_CArray_CCheckableGroupedItem Function()>();
late final _CArray_CCheckableGroupedItemaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CCheckableGroupedItem, _CCheckableGroupedItem)>>('CArray_CCheckableGroupedItem_addElement');
late final _CArray_CCheckableGroupedItemaddElement = _CArray_CCheckableGroupedItemaddElementPtr.asFunction<void Function(_CArray_CCheckableGroupedItem, _CCheckableGroupedItem)>();
late final _forEach_CArray_CCheckableGroupedItemPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CCheckableGroupedItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCheckableGroupedItem)>>)
>>('CArray_CCheckableGroupedItem_forEachWithFunctionPointer');
late final _forEach_CArray_CCheckableGroupedItem = _forEach_CArray_CCheckableGroupedItemPtr.asFunction<
  void Function(_CArray_CCheckableGroupedItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCheckableGroupedItem)
>>)>();
late final _CArray_CCheckableGroupedItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CCheckableGroupedItem)>>('CArray_CCheckableGroupedItem_release');
late final _CArray_CCheckableGroupedItem_release = _CArray_CCheckableGroupedItem_releasePtr.asFunction<void Function(_CArray_CCheckableGroupedItem)>();

late final _CBordersMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBorders Function()>>('CBordersMakeDefault');
late final _CBordersMakeDefault = _CBordersMakeDefaultPtr.asFunction<_CBorders Function()>();


late final _COrderedValueMakeDefaultPtr = _lookup<ffi.NativeFunction<_COrderedValue Function()>>('COrderedValueMakeDefault');
late final _COrderedValueMakeDefault = _COrderedValueMakeDefaultPtr.asFunction<_COrderedValue Function()>();


late final _CArray_COrderedValuemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_COrderedValue Function()>>('CArray_COrderedValue_makeEmpty');
late final _CArray_COrderedValuemakeEmpty = _CArray_COrderedValuemakeEmptyPtr.asFunction<_CArray_COrderedValue Function()>();
late final _CArray_COrderedValueaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_COrderedValue, _COrderedValue)>>('CArray_COrderedValue_addElement');
late final _CArray_COrderedValueaddElement = _CArray_COrderedValueaddElementPtr.asFunction<void Function(_CArray_COrderedValue, _COrderedValue)>();
late final _forEach_CArray_COrderedValuePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_COrderedValue, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COrderedValue)>>)
>>('CArray_COrderedValue_forEachWithFunctionPointer');
late final _forEach_CArray_COrderedValue = _forEach_CArray_COrderedValuePtr.asFunction<
  void Function(_CArray_COrderedValue, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COrderedValue)
>>)>();
late final _CArray_COrderedValue_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_COrderedValue)>>('CArray_COrderedValue_release');
late final _CArray_COrderedValue_release = _CArray_COrderedValue_releasePtr.asFunction<void Function(_CArray_COrderedValue)>();

late final _COrderedValuesMakeDefaultPtr = _lookup<ffi.NativeFunction<_COrderedValues Function()>>('COrderedValuesMakeDefault');
late final _COrderedValuesMakeDefault = _COrderedValuesMakeDefaultPtr.asFunction<_COrderedValues Function()>();


late final _CRange_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRange)>>('CRange_release');
late final _CRange_release = _CRange_releasePtr.asFunction<void Function(_CRange)>();
late final _CRangeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRange Function()>>('CRangeMakeDefault');
late final _CRangeMakeDefault = _CRangeMakeDefaultPtr.asFunction<_CRange Function()>();
late final _CRangeWidget_rangePtr = _lookup<ffi.NativeFunction<_CRange Function(_CRangeWidget)>>('CRangeWidget_range');
late final _CRangeWidget_range = _CRangeWidget_rangePtr.asFunction<_CRange Function(_CRangeWidget)>();

late final _CRangeWidget_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRangeWidget_cg_objectIdentifier');
late final _CRangeWidget_cg_objectIdentifier = _CRangeWidget_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRangeWidget_setValues_double_doublePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRangeWidget, ffi.Double, ffi.Double)>>('CRangeWidget_setValues_double_double');
late final _CRangeWidget_setValues_double_double = _CRangeWidget_setValues_double_doublePtr.asFunction<void Function(_CRangeWidget, double, double)>();

late final _CRangeWidget_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRangeWidget_release');
late final _CRangeWidget_release = _CRangeWidget_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRangeWidget_retainPtr = _lookup<ffi.NativeFunction<_CRangeWidget Function(ffi.Pointer<ffi.Void>)>>('CRangeWidget_retain');
late final _CRangeWidget_retain = _CRangeWidget_retainPtr.asFunction<_CRangeWidget Function(ffi.Pointer<ffi.Void>)>();
late final _CRangeWidgetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRangeWidget Function()>>('CRangeWidgetMakeDefault');
late final _CRangeWidgetMakeDefault = _CRangeWidgetMakeDefaultPtr.asFunction<_CRangeWidget Function()>();

late final _CSearchResult_firstPagePtr = _lookup<ffi.NativeFunction<_COptional_CPage Function(_CSearchResult)>>('CSearchResult_firstPage');
late final _CSearchResult_firstPage = _CSearchResult_firstPagePtr.asFunction<_COptional_CPage Function(_CSearchResult)>();
late final _CSearchResult_representativeAreaPtr = _lookup<ffi.NativeFunction<_COptional_CGeometry Function(_CSearchResult)>>('CSearchResult_representativeArea');
late final _CSearchResult_representativeArea = _CSearchResult_representativeAreaPtr.asFunction<_COptional_CGeometry Function(_CSearchResult)>();
late final _CSearchResult_itemMarkerInfosPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CArray_CItemMarkerInfo Function(_CSearchResult)>>('CSearchResult_itemMarkerInfos');
late final _CSearchResult_itemMarkerInfos = _CSearchResult_itemMarkerInfosPtr.asFunction<_CFuture_COptional_CArray_CItemMarkerInfo Function(_CSearchResult)>();
late final _CSearchResult_searchResultTypePtr = _lookup<ffi.NativeFunction<_CSearchResultType Function(_CSearchResult)>>('CSearchResult_searchResultType');
late final _CSearchResult_searchResultType = _CSearchResult_searchResultTypePtr.asFunction<_CSearchResultType Function(_CSearchResult)>();
late final _CSearchResult_dynamicFiltersPtr = _lookup<ffi.NativeFunction<_CArray_CDynamicFilter Function(_CSearchResult)>>('CSearchResult_dynamicFilters');
late final _CSearchResult_dynamicFilters = _CSearchResult_dynamicFiltersPtr.asFunction<_CArray_CDynamicFilter Function(_CSearchResult)>();
late final _CSearchResult_actionWidgetsPtr = _lookup<ffi.NativeFunction<_CArray_CWidget Function(_CSearchResult)>>('CSearchResult_actionWidgets');
late final _CSearchResult_actionWidgets = _CSearchResult_actionWidgetsPtr.asFunction<_CArray_CWidget Function(_CSearchResult)>();
late final _CSearchResult_mainWidgetsPtr = _lookup<ffi.NativeFunction<_CArray_CWidget Function(_CSearchResult)>>('CSearchResult_mainWidgets');
late final _CSearchResult_mainWidgets = _CSearchResult_mainWidgetsPtr.asFunction<_CArray_CWidget Function(_CSearchResult)>();
late final _CSearchResult_autoUseFirstResultPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CSearchResult)>>('CSearchResult_autoUseFirstResult');
late final _CSearchResult_autoUseFirstResult = _CSearchResult_autoUseFirstResultPtr.asFunction<bool Function(_CSearchResult)>();

late final _CSearchResult_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchResult_cg_objectIdentifier');
late final _CSearchResult_cg_objectIdentifier = _CSearchResult_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSearchResult_markerTitles_CArray_CDgisObjectIdPtr = _lookup<ffi.NativeFunction<_CArray_CFuture_CArray_CUIMarkerInfo Function(_CSearchResult, _CArray_CDgisObjectId)>>('CSearchResult_markerTitles_CArray_CDgisObjectId');
late final _CSearchResult_markerTitles_CArray_CDgisObjectId = _CSearchResult_markerTitles_CArray_CDgisObjectIdPtr.asFunction<_CArray_CFuture_CArray_CUIMarkerInfo Function(_CSearchResult, _CArray_CDgisObjectId)>();

late final _CSearchResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchResult_release');
late final _CSearchResult_release = _CSearchResult_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchResult_retainPtr = _lookup<ffi.NativeFunction<_CSearchResult Function(ffi.Pointer<ffi.Void>)>>('CSearchResult_retain');
late final _CSearchResult_retain = _CSearchResult_retainPtr.asFunction<_CSearchResult Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchResult Function()>>('CSearchResultMakeDefault');
late final _CSearchResultMakeDefault = _CSearchResultMakeDefaultPtr.asFunction<_CSearchResult Function()>();


late final _CGeometryKindMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeometryKind Function()>>('CGeometryKindMakeDefault');
late final _CGeometryKindMakeDefault = _CGeometryKindMakeDefaultPtr.asFunction<_CGeometryKind Function()>();
late final _CGeometry_kindPtr = _lookup<ffi.NativeFunction<_CGeometryKind Function(_CGeometry)>>('CGeometry_kind');
late final _CGeometry_kind = _CGeometry_kindPtr.asFunction<_CGeometryKind Function(_CGeometry)>();
late final _CGeometry_boundsPtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CGeometry)>>('CGeometry_bounds');
late final _CGeometry_bounds = _CGeometry_boundsPtr.asFunction<_CGeoRect Function(_CGeometry)>();
late final _CGeometry_minPointPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CGeometry)>>('CGeometry_minPoint');
late final _CGeometry_minPoint = _CGeometry_minPointPtr.asFunction<_CGeoPoint Function(_CGeometry)>();
late final _CGeometry_maxPointPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CGeometry)>>('CGeometry_maxPoint');
late final _CGeometry_maxPoint = _CGeometry_maxPointPtr.asFunction<_CGeoPoint Function(_CGeometry)>();

late final _CGeometry_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGeometry_cg_objectIdentifier');
late final _CGeometry_cg_objectIdentifier = _CGeometry_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CGeometry_intersects_CGeometryPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeometry, _CGeometry)>>('CGeometry_intersects_CGeometry');
late final _CGeometry_intersects_CGeometry = _CGeometry_intersects_CGeometryPtr.asFunction<bool Function(_CGeometry, _CGeometry)>();
late final _CGeometry_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CGeometry)>>('CGeometry_cg_getSelector');
late final _CGeometry_cg_getSelector = _CGeometry_cg_getSelectorPtr.asFunction<int Function(_CGeometry)>();

late final _CGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGeometry_release');
late final _CGeometry_release = _CGeometry_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometry_retainPtr = _lookup<ffi.NativeFunction<_CGeometry Function(ffi.Pointer<ffi.Void>)>>('CGeometry_retain');
late final _CGeometry_retain = _CGeometry_retainPtr.asFunction<_CGeometry Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeometry Function()>>('CGeometryMakeDefault');
late final _CGeometryMakeDefault = _CGeometryMakeDefaultPtr.asFunction<_CGeometry Function()>();


late final _COptional_CGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGeometry Function()>>('COptional_CGeometryMakeDefault');
late final _COptional_CGeometryMakeDefault = _COptional_CGeometryMakeDefaultPtr.asFunction<_COptional_CGeometry Function()>();

late final _COptional_CGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CGeometry)>>('COptional_CGeometry_release');
late final _COptional_CGeometry_release = _COptional_CGeometry_releasePtr.asFunction<void Function(_COptional_CGeometry)>();

late final _CFuture_COptional_CArray_CItemMarkerInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CArray_CItemMarkerInfo Function()>>('CFuture_COptional_CArray_CItemMarkerInfoMakeDefault');
late final _CFuture_COptional_CArray_CItemMarkerInfoMakeDefault = _CFuture_COptional_CArray_CItemMarkerInfoMakeDefaultPtr.asFunction<_CFuture_COptional_CArray_CItemMarkerInfo Function()>();
late final _CFuture_COptional_CArray_CItemMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_COptional_CArray_CItemMarkerInfo)>>('CFuture_COptional_CArray_CItemMarkerInfo_release');
late final _CFuture_COptional_CArray_CItemMarkerInfo_release = _CFuture_COptional_CArray_CItemMarkerInfo_releasePtr.asFunction<void Function(_CFuture_COptional_CArray_CItemMarkerInfo)>();
late final _CFuture_COptional_CArray_CItemMarkerInfo_retainPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CArray_CItemMarkerInfo Function(_CFuture_COptional_CArray_CItemMarkerInfo)>>('CFuture_COptional_CArray_CItemMarkerInfo_retain');
late final _CFuture_COptional_CArray_CItemMarkerInfo_retain = _CFuture_COptional_CArray_CItemMarkerInfo_retainPtr.asFunction<_CFuture_COptional_CArray_CItemMarkerInfo Function(_CFuture_COptional_CArray_CItemMarkerInfo)>();
late final _CFuture_COptional_CArray_CItemMarkerInfoReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_COptional_CArray_CItemMarkerInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CArray_CItemMarkerInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_COptional_CArray_CItemMarkerInfo_receive');
late final _CFuture_COptional_CArray_CItemMarkerInfoReceive = _CFuture_COptional_CArray_CItemMarkerInfoReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_COptional_CArray_CItemMarkerInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CArray_CItemMarkerInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CArray_CItemMarkerInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CItemMarkerInfo Function()>>('CArray_CItemMarkerInfo_makeEmpty');
late final _CArray_CItemMarkerInfomakeEmpty = _CArray_CItemMarkerInfomakeEmptyPtr.asFunction<_CArray_CItemMarkerInfo Function()>();
late final _CArray_CItemMarkerInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CItemMarkerInfo, _CItemMarkerInfo)>>('CArray_CItemMarkerInfo_addElement');
late final _CArray_CItemMarkerInfoaddElement = _CArray_CItemMarkerInfoaddElementPtr.asFunction<void Function(_CArray_CItemMarkerInfo, _CItemMarkerInfo)>();
late final _forEach_CArray_CItemMarkerInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CItemMarkerInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CItemMarkerInfo)>>)
>>('CArray_CItemMarkerInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CItemMarkerInfo = _forEach_CArray_CItemMarkerInfoPtr.asFunction<
  void Function(_CArray_CItemMarkerInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CItemMarkerInfo)
>>)>();
late final _CArray_CItemMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CItemMarkerInfo)>>('CArray_CItemMarkerInfo_release');
late final _CArray_CItemMarkerInfo_release = _CArray_CItemMarkerInfo_releasePtr.asFunction<void Function(_CArray_CItemMarkerInfo)>();

late final _COptional_CArray_CItemMarkerInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CArray_CItemMarkerInfo Function()>>('COptional_CArray_CItemMarkerInfoMakeDefault');
late final _COptional_CArray_CItemMarkerInfoMakeDefault = _COptional_CArray_CItemMarkerInfoMakeDefaultPtr.asFunction<_COptional_CArray_CItemMarkerInfo Function()>();

late final _COptional_CArray_CItemMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CArray_CItemMarkerInfo)>>('COptional_CArray_CItemMarkerInfo_release');
late final _COptional_CArray_CItemMarkerInfo_release = _COptional_CArray_CItemMarkerInfo_releasePtr.asFunction<void Function(_COptional_CArray_CItemMarkerInfo)>();

late final _CArray_CFuture_CArray_CUIMarkerInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CFuture_CArray_CUIMarkerInfo Function()>>('CArray_CFuture_CArray_CUIMarkerInfo_makeEmpty');
late final _CArray_CFuture_CArray_CUIMarkerInfomakeEmpty = _CArray_CFuture_CArray_CUIMarkerInfomakeEmptyPtr.asFunction<_CArray_CFuture_CArray_CUIMarkerInfo Function()>();
late final _CArray_CFuture_CArray_CUIMarkerInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CFuture_CArray_CUIMarkerInfo, _CFuture_CArray_CUIMarkerInfo)>>('CArray_CFuture_CArray_CUIMarkerInfo_addElement');
late final _CArray_CFuture_CArray_CUIMarkerInfoaddElement = _CArray_CFuture_CArray_CUIMarkerInfoaddElementPtr.asFunction<void Function(_CArray_CFuture_CArray_CUIMarkerInfo, _CFuture_CArray_CUIMarkerInfo)>();
late final _forEach_CArray_CFuture_CArray_CUIMarkerInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CFuture_CArray_CUIMarkerInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CUIMarkerInfo)>>)
>>('CArray_CFuture_CArray_CUIMarkerInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CFuture_CArray_CUIMarkerInfo = _forEach_CArray_CFuture_CArray_CUIMarkerInfoPtr.asFunction<
  void Function(_CArray_CFuture_CArray_CUIMarkerInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CUIMarkerInfo)
>>)>();
late final _CArray_CFuture_CArray_CUIMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CFuture_CArray_CUIMarkerInfo)>>('CArray_CFuture_CArray_CUIMarkerInfo_release');
late final _CArray_CFuture_CArray_CUIMarkerInfo_release = _CArray_CFuture_CArray_CUIMarkerInfo_releasePtr.asFunction<void Function(_CArray_CFuture_CArray_CUIMarkerInfo)>();

late final _CFuture_CArray_CUIMarkerInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CUIMarkerInfo Function()>>('CFuture_CArray_CUIMarkerInfoMakeDefault');
late final _CFuture_CArray_CUIMarkerInfoMakeDefault = _CFuture_CArray_CUIMarkerInfoMakeDefaultPtr.asFunction<_CFuture_CArray_CUIMarkerInfo Function()>();
late final _CFuture_CArray_CUIMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CUIMarkerInfo)>>('CFuture_CArray_CUIMarkerInfo_release');
late final _CFuture_CArray_CUIMarkerInfo_release = _CFuture_CArray_CUIMarkerInfo_releasePtr.asFunction<void Function(_CFuture_CArray_CUIMarkerInfo)>();
late final _CFuture_CArray_CUIMarkerInfo_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CUIMarkerInfo Function(_CFuture_CArray_CUIMarkerInfo)>>('CFuture_CArray_CUIMarkerInfo_retain');
late final _CFuture_CArray_CUIMarkerInfo_retain = _CFuture_CArray_CUIMarkerInfo_retainPtr.asFunction<_CFuture_CArray_CUIMarkerInfo Function(_CFuture_CArray_CUIMarkerInfo)>();
late final _CFuture_CArray_CUIMarkerInfoReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CArray_CUIMarkerInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CUIMarkerInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CArray_CUIMarkerInfo_receive');
late final _CFuture_CArray_CUIMarkerInfoReceive = _CFuture_CArray_CUIMarkerInfoReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CArray_CUIMarkerInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CUIMarkerInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CArray_CUIMarkerInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CUIMarkerInfo Function()>>('CArray_CUIMarkerInfo_makeEmpty');
late final _CArray_CUIMarkerInfomakeEmpty = _CArray_CUIMarkerInfomakeEmptyPtr.asFunction<_CArray_CUIMarkerInfo Function()>();
late final _CArray_CUIMarkerInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CUIMarkerInfo, _CUIMarkerInfo)>>('CArray_CUIMarkerInfo_addElement');
late final _CArray_CUIMarkerInfoaddElement = _CArray_CUIMarkerInfoaddElementPtr.asFunction<void Function(_CArray_CUIMarkerInfo, _CUIMarkerInfo)>();
late final _forEach_CArray_CUIMarkerInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CUIMarkerInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CUIMarkerInfo)>>)
>>('CArray_CUIMarkerInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CUIMarkerInfo = _forEach_CArray_CUIMarkerInfoPtr.asFunction<
  void Function(_CArray_CUIMarkerInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CUIMarkerInfo)
>>)>();
late final _CArray_CUIMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CUIMarkerInfo)>>('CArray_CUIMarkerInfo_release');
late final _CArray_CUIMarkerInfo_release = _CArray_CUIMarkerInfo_releasePtr.asFunction<void Function(_CArray_CUIMarkerInfo)>();

late final _CArray_CDgisObjectIdmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CDgisObjectId Function()>>('CArray_CDgisObjectId_makeEmpty');
late final _CArray_CDgisObjectIdmakeEmpty = _CArray_CDgisObjectIdmakeEmptyPtr.asFunction<_CArray_CDgisObjectId Function()>();
late final _CArray_CDgisObjectIdaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDgisObjectId, _CDgisObjectId)>>('CArray_CDgisObjectId_addElement');
late final _CArray_CDgisObjectIdaddElement = _CArray_CDgisObjectIdaddElementPtr.asFunction<void Function(_CArray_CDgisObjectId, _CDgisObjectId)>();
late final _forEach_CArray_CDgisObjectIdPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CDgisObjectId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDgisObjectId)>>)
>>('CArray_CDgisObjectId_forEachWithFunctionPointer');
late final _forEach_CArray_CDgisObjectId = _forEach_CArray_CDgisObjectIdPtr.asFunction<
  void Function(_CArray_CDgisObjectId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDgisObjectId)
>>)>();
late final _CArray_CDgisObjectId_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDgisObjectId)>>('CArray_CDgisObjectId_release');
late final _CArray_CDgisObjectId_release = _CArray_CDgisObjectId_releasePtr.asFunction<void Function(_CArray_CDgisObjectId)>();

late final _CArray_CWidgetmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CWidget Function()>>('CArray_CWidget_makeEmpty');
late final _CArray_CWidgetmakeEmpty = _CArray_CWidgetmakeEmptyPtr.asFunction<_CArray_CWidget Function()>();
late final _CArray_CWidgetaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CWidget, _CWidget)>>('CArray_CWidget_addElement');
late final _CArray_CWidgetaddElement = _CArray_CWidgetaddElementPtr.asFunction<void Function(_CArray_CWidget, _CWidget)>();
late final _forEach_CArray_CWidgetPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CWidget, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CWidget)>>)
>>('CArray_CWidget_forEachWithFunctionPointer');
late final _forEach_CArray_CWidget = _forEach_CArray_CWidgetPtr.asFunction<
  void Function(_CArray_CWidget, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CWidget)
>>)>();
late final _CArray_CWidget_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CWidget)>>('CArray_CWidget_release');
late final _CArray_CWidget_release = _CArray_CWidget_releasePtr.asFunction<void Function(_CArray_CWidget)>();

late final _CSearchQuery_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchQuery_cg_objectIdentifier');
late final _CSearchQuery_cg_objectIdentifier = _CSearchQuery_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSearchQuery_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchQuery_release');
late final _CSearchQuery_release = _CSearchQuery_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchQuery_retainPtr = _lookup<ffi.NativeFunction<_CSearchQuery Function(ffi.Pointer<ffi.Void>)>>('CSearchQuery_retain');
late final _CSearchQuery_retain = _CSearchQuery_retainPtr.asFunction<_CSearchQuery Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchQueryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchQuery Function()>>('CSearchQueryMakeDefault');
late final _CSearchQueryMakeDefault = _CSearchQueryMakeDefaultPtr.asFunction<_CSearchQuery Function()>();

late final _CSuggestObjectHandler_itemPtr = _lookup<ffi.NativeFunction<_CDirectoryObject Function(_CSuggestObjectHandler)>>('CSuggestObjectHandler_item');
late final _CSuggestObjectHandler_item = _CSuggestObjectHandler_itemPtr.asFunction<_CDirectoryObject Function(_CSuggestObjectHandler)>();

late final _CSuggestObjectHandler_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSuggestObjectHandler_cg_objectIdentifier');
late final _CSuggestObjectHandler_cg_objectIdentifier = _CSuggestObjectHandler_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSuggestObjectHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSuggestObjectHandler_release');
late final _CSuggestObjectHandler_release = _CSuggestObjectHandler_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestObjectHandler_retainPtr = _lookup<ffi.NativeFunction<_CSuggestObjectHandler Function(ffi.Pointer<ffi.Void>)>>('CSuggestObjectHandler_retain');
late final _CSuggestObjectHandler_retain = _CSuggestObjectHandler_retainPtr.asFunction<_CSuggestObjectHandler Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestObjectHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestObjectHandler Function()>>('CSuggestObjectHandlerMakeDefault');
late final _CSuggestObjectHandlerMakeDefault = _CSuggestObjectHandlerMakeDefaultPtr.asFunction<_CSuggestObjectHandler Function()>();

late final _CPerformSearchHandler_searchQueryPtr = _lookup<ffi.NativeFunction<_CSearchQuery Function(_CPerformSearchHandler)>>('CPerformSearchHandler_searchQuery');
late final _CPerformSearchHandler_searchQuery = _CPerformSearchHandler_searchQueryPtr.asFunction<_CSearchQuery Function(_CPerformSearchHandler)>();

late final _CPerformSearchHandler_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPerformSearchHandler_cg_objectIdentifier');
late final _CPerformSearchHandler_cg_objectIdentifier = _CPerformSearchHandler_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CPerformSearchHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPerformSearchHandler_release');
late final _CPerformSearchHandler_release = _CPerformSearchHandler_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPerformSearchHandler_retainPtr = _lookup<ffi.NativeFunction<_CPerformSearchHandler Function(ffi.Pointer<ffi.Void>)>>('CPerformSearchHandler_retain');
late final _CPerformSearchHandler_retain = _CPerformSearchHandler_retainPtr.asFunction<_CPerformSearchHandler Function(ffi.Pointer<ffi.Void>)>();
late final _CPerformSearchHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPerformSearchHandler Function()>>('CPerformSearchHandlerMakeDefault');
late final _CPerformSearchHandlerMakeDefault = _CPerformSearchHandlerMakeDefaultPtr.asFunction<_CPerformSearchHandler Function()>();

late final _CIncompleteTextHandler_queryTextPtr = _lookup<ffi.NativeFunction<_CString Function(_CIncompleteTextHandler)>>('CIncompleteTextHandler_queryText');
late final _CIncompleteTextHandler_queryText = _CIncompleteTextHandler_queryTextPtr.asFunction<_CString Function(_CIncompleteTextHandler)>();

late final _CIncompleteTextHandler_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CIncompleteTextHandler_cg_objectIdentifier');
late final _CIncompleteTextHandler_cg_objectIdentifier = _CIncompleteTextHandler_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CIncompleteTextHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CIncompleteTextHandler_release');
late final _CIncompleteTextHandler_release = _CIncompleteTextHandler_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CIncompleteTextHandler_retainPtr = _lookup<ffi.NativeFunction<_CIncompleteTextHandler Function(ffi.Pointer<ffi.Void>)>>('CIncompleteTextHandler_retain');
late final _CIncompleteTextHandler_retain = _CIncompleteTextHandler_retainPtr.asFunction<_CIncompleteTextHandler Function(ffi.Pointer<ffi.Void>)>();
late final _CIncompleteTextHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIncompleteTextHandler Function()>>('CIncompleteTextHandlerMakeDefault');
late final _CIncompleteTextHandlerMakeDefault = _CIncompleteTextHandlerMakeDefaultPtr.asFunction<_CIncompleteTextHandler Function()>();


late final _COptional_CSuggestObjectHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CSuggestObjectHandler Function()>>('COptional_CSuggestObjectHandlerMakeDefault');
late final _COptional_CSuggestObjectHandlerMakeDefault = _COptional_CSuggestObjectHandlerMakeDefaultPtr.asFunction<_COptional_CSuggestObjectHandler Function()>();

late final _COptional_CSuggestObjectHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CSuggestObjectHandler)>>('COptional_CSuggestObjectHandler_release');
late final _COptional_CSuggestObjectHandler_release = _COptional_CSuggestObjectHandler_releasePtr.asFunction<void Function(_COptional_CSuggestObjectHandler)>();

late final _COptional_CPerformSearchHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CPerformSearchHandler Function()>>('COptional_CPerformSearchHandlerMakeDefault');
late final _COptional_CPerformSearchHandlerMakeDefault = _COptional_CPerformSearchHandlerMakeDefaultPtr.asFunction<_COptional_CPerformSearchHandler Function()>();

late final _COptional_CPerformSearchHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CPerformSearchHandler)>>('COptional_CPerformSearchHandler_release');
late final _COptional_CPerformSearchHandler_release = _COptional_CPerformSearchHandler_releasePtr.asFunction<void Function(_COptional_CPerformSearchHandler)>();

late final _COptional_CIncompleteTextHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CIncompleteTextHandler Function()>>('COptional_CIncompleteTextHandlerMakeDefault');
late final _COptional_CIncompleteTextHandlerMakeDefault = _COptional_CIncompleteTextHandlerMakeDefaultPtr.asFunction<_COptional_CIncompleteTextHandler Function()>();

late final _COptional_CIncompleteTextHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CIncompleteTextHandler)>>('COptional_CIncompleteTextHandler_release');
late final _COptional_CIncompleteTextHandler_release = _COptional_CIncompleteTextHandler_releasePtr.asFunction<void Function(_COptional_CIncompleteTextHandler)>();

late final _CSuggestHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSuggestHandler)>>('CSuggestHandler_release');
late final _CSuggestHandler_release = _CSuggestHandler_releasePtr.asFunction<void Function(_CSuggestHandler)>();
late final _CSuggestHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestHandler Function()>>('CSuggestHandlerMakeDefault');
late final _CSuggestHandlerMakeDefault = _CSuggestHandlerMakeDefaultPtr.asFunction<_CSuggestHandler Function()>();

late final _CMarkedUpTextSpanMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMarkedUpTextSpan Function()>>('CMarkedUpTextSpanMakeDefault');
late final _CMarkedUpTextSpanMakeDefault = _CMarkedUpTextSpanMakeDefaultPtr.asFunction<_CMarkedUpTextSpan Function()>();


late final _CArray_CMarkedUpTextSpanmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CMarkedUpTextSpan Function()>>('CArray_CMarkedUpTextSpan_makeEmpty');
late final _CArray_CMarkedUpTextSpanmakeEmpty = _CArray_CMarkedUpTextSpanmakeEmptyPtr.asFunction<_CArray_CMarkedUpTextSpan Function()>();
late final _CArray_CMarkedUpTextSpanaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CMarkedUpTextSpan, _CMarkedUpTextSpan)>>('CArray_CMarkedUpTextSpan_addElement');
late final _CArray_CMarkedUpTextSpanaddElement = _CArray_CMarkedUpTextSpanaddElementPtr.asFunction<void Function(_CArray_CMarkedUpTextSpan, _CMarkedUpTextSpan)>();
late final _forEach_CArray_CMarkedUpTextSpanPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CMarkedUpTextSpan, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMarkedUpTextSpan)>>)
>>('CArray_CMarkedUpTextSpan_forEachWithFunctionPointer');
late final _forEach_CArray_CMarkedUpTextSpan = _forEach_CArray_CMarkedUpTextSpanPtr.asFunction<
  void Function(_CArray_CMarkedUpTextSpan, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMarkedUpTextSpan)
>>)>();
late final _CArray_CMarkedUpTextSpan_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CMarkedUpTextSpan)>>('CArray_CMarkedUpTextSpan_release');
late final _CArray_CMarkedUpTextSpan_release = _CArray_CMarkedUpTextSpan_releasePtr.asFunction<void Function(_CArray_CMarkedUpTextSpan)>();

late final _CMarkedUpTextMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMarkedUpText Function()>>('CMarkedUpTextMakeDefault');
late final _CMarkedUpTextMakeDefault = _CMarkedUpTextMakeDefaultPtr.asFunction<_CMarkedUpText Function()>();


late final _CSuggestedTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestedType Function()>>('CSuggestedTypeMakeDefault');
late final _CSuggestedTypeMakeDefault = _CSuggestedTypeMakeDefaultPtr.asFunction<_CSuggestedType Function()>();

late final _CSuggestorTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestorType Function()>>('CSuggestorTypeMakeDefault');
late final _CSuggestorTypeMakeDefault = _CSuggestorTypeMakeDefaultPtr.asFunction<_CSuggestorType Function()>();
late final _CSuggest_handlerPtr = _lookup<ffi.NativeFunction<_CSuggestHandler Function(_CSuggest)>>('CSuggest_handler');
late final _CSuggest_handler = _CSuggest_handlerPtr.asFunction<_CSuggestHandler Function(_CSuggest)>();
late final _CSuggest_suggestedTypePtr = _lookup<ffi.NativeFunction<_CSuggestedType Function(_CSuggest)>>('CSuggest_suggestedType');
late final _CSuggest_suggestedType = _CSuggest_suggestedTypePtr.asFunction<_CSuggestedType Function(_CSuggest)>();
late final _CSuggest_titlePtr = _lookup<ffi.NativeFunction<_CMarkedUpText Function(_CSuggest)>>('CSuggest_title');
late final _CSuggest_title = _CSuggest_titlePtr.asFunction<_CMarkedUpText Function(_CSuggest)>();
late final _CSuggest_subtitlePtr = _lookup<ffi.NativeFunction<_CMarkedUpText Function(_CSuggest)>>('CSuggest_subtitle');
late final _CSuggest_subtitle = _CSuggest_subtitlePtr.asFunction<_CMarkedUpText Function(_CSuggest)>();

late final _CSuggest_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSuggest_cg_objectIdentifier');
late final _CSuggest_cg_objectIdentifier = _CSuggest_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSuggest_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSuggest_release');
late final _CSuggest_release = _CSuggest_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggest_retainPtr = _lookup<ffi.NativeFunction<_CSuggest Function(ffi.Pointer<ffi.Void>)>>('CSuggest_retain');
late final _CSuggest_retain = _CSuggest_retainPtr.asFunction<_CSuggest Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggest Function()>>('CSuggestMakeDefault');
late final _CSuggestMakeDefault = _CSuggestMakeDefaultPtr.asFunction<_CSuggest Function()>();

late final _CSuggestResult_suggestsPtr = _lookup<ffi.NativeFunction<_CArray_CSuggest Function(_CSuggestResult)>>('CSuggestResult_suggests');
late final _CSuggestResult_suggests = _CSuggestResult_suggestsPtr.asFunction<_CArray_CSuggest Function(_CSuggestResult)>();

late final _CSuggestResult_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSuggestResult_cg_objectIdentifier');
late final _CSuggestResult_cg_objectIdentifier = _CSuggestResult_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSuggestResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSuggestResult_release');
late final _CSuggestResult_release = _CSuggestResult_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestResult_retainPtr = _lookup<ffi.NativeFunction<_CSuggestResult Function(ffi.Pointer<ffi.Void>)>>('CSuggestResult_retain');
late final _CSuggestResult_retain = _CSuggestResult_retainPtr.asFunction<_CSuggestResult Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestResult Function()>>('CSuggestResultMakeDefault');
late final _CSuggestResultMakeDefault = _CSuggestResultMakeDefaultPtr.asFunction<_CSuggestResult Function()>();


late final _CArray_CSuggestmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSuggest Function()>>('CArray_CSuggest_makeEmpty');
late final _CArray_CSuggestmakeEmpty = _CArray_CSuggestmakeEmptyPtr.asFunction<_CArray_CSuggest Function()>();
late final _CArray_CSuggestaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSuggest, _CSuggest)>>('CArray_CSuggest_addElement');
late final _CArray_CSuggestaddElement = _CArray_CSuggestaddElementPtr.asFunction<void Function(_CArray_CSuggest, _CSuggest)>();
late final _forEach_CArray_CSuggestPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSuggest, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSuggest)>>)
>>('CArray_CSuggest_forEachWithFunctionPointer');
late final _forEach_CArray_CSuggest = _forEach_CArray_CSuggestPtr.asFunction<
  void Function(_CArray_CSuggest, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSuggest)
>>)>();
late final _CArray_CSuggest_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSuggest)>>('CArray_CSuggest_release');
late final _CArray_CSuggest_release = _CArray_CSuggest_releasePtr.asFunction<void Function(_CArray_CSuggest)>();

late final _CSuggestQuery_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSuggestQuery_cg_objectIdentifier');
late final _CSuggestQuery_cg_objectIdentifier = _CSuggestQuery_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSuggestQuery_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSuggestQuery_release');
late final _CSuggestQuery_release = _CSuggestQuery_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestQuery_retainPtr = _lookup<ffi.NativeFunction<_CSuggestQuery Function(ffi.Pointer<ffi.Void>)>>('CSuggestQuery_retain');
late final _CSuggestQuery_retain = _CSuggestQuery_retainPtr.asFunction<_CSuggestQuery Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestQueryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestQuery Function()>>('CSuggestQueryMakeDefault');
late final _CSuggestQueryMakeDefault = _CSuggestQueryMakeDefaultPtr.asFunction<_CSuggestQuery Function()>();


late final _CSearchManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchManager_cg_objectIdentifier');
late final _CSearchManager_cg_objectIdentifier = _CSearchManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSearchManager_S_createOnlineManager_CContextPtr = _lookup<ffi.NativeFunction<_CResult_CSearchManager Function(_CContext)>>('CSearchManager_S_createOnlineManager_CContext');
late final _CSearchManager_S_createOnlineManager_CContext = _CSearchManager_S_createOnlineManager_CContextPtr.asFunction<_CResult_CSearchManager Function(_CContext)>();
late final _CSearchManager_S_createOfflineManager_CContextPtr = _lookup<ffi.NativeFunction<_CResult_CSearchManager Function(_CContext)>>('CSearchManager_S_createOfflineManager_CContext');
late final _CSearchManager_S_createOfflineManager_CContext = _CSearchManager_S_createOfflineManager_CContextPtr.asFunction<_CResult_CSearchManager Function(_CContext)>();
late final _CSearchManager_S_createSmartManager_CContextPtr = _lookup<ffi.NativeFunction<_CResult_CSearchManager Function(_CContext)>>('CSearchManager_S_createSmartManager_CContext');
late final _CSearchManager_S_createSmartManager_CContext = _CSearchManager_S_createSmartManager_CContextPtr.asFunction<_CResult_CSearchManager Function(_CContext)>();
late final _CSearchManager_suggest_CSuggestQueryPtr = _lookup<ffi.NativeFunction<_CFuture_CSuggestResult Function(_CSearchManager, _CSuggestQuery)>>('CSearchManager_suggest_CSuggestQuery');
late final _CSearchManager_suggest_CSuggestQuery = _CSearchManager_suggest_CSuggestQueryPtr.asFunction<_CFuture_CSuggestResult Function(_CSearchManager, _CSuggestQuery)>();
late final _CSearchManager_search_CSearchQueryPtr = _lookup<ffi.NativeFunction<_CFuture_CSearchResult Function(_CSearchManager, _CSearchQuery)>>('CSearchManager_search_CSearchQuery');
late final _CSearchManager_search_CSearchQuery = _CSearchManager_search_CSearchQueryPtr.asFunction<_CFuture_CSearchResult Function(_CSearchManager, _CSearchQuery)>();
late final _CSearchManager_searchById_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CDirectoryObject Function(_CSearchManager, _CString)>>('CSearchManager_searchById_CString');
late final _CSearchManager_searchById_CString = _CSearchManager_searchById_CStringPtr.asFunction<_CFuture_COptional_CDirectoryObject Function(_CSearchManager, _CString)>();
late final _CSearchManager_searchByDirectoryObjectId_CDgisObjectIdPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CDirectoryObject Function(_CSearchManager, _CDgisObjectId)>>('CSearchManager_searchByDirectoryObjectId_CDgisObjectId');
late final _CSearchManager_searchByDirectoryObjectId_CDgisObjectId = _CSearchManager_searchByDirectoryObjectId_CDgisObjectIdPtr.asFunction<_CFuture_COptional_CDirectoryObject Function(_CSearchManager, _CDgisObjectId)>();

late final _CSearchManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchManager_release');
late final _CSearchManager_release = _CSearchManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchManager_retainPtr = _lookup<ffi.NativeFunction<_CSearchManager Function(ffi.Pointer<ffi.Void>)>>('CSearchManager_retain');
late final _CSearchManager_retain = _CSearchManager_retainPtr.asFunction<_CSearchManager Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchManager Function()>>('CSearchManagerMakeDefault');
late final _CSearchManagerMakeDefault = _CSearchManagerMakeDefaultPtr.asFunction<_CSearchManager Function()>();


late final _CResult_CSearchManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CSearchManager)>>('CResult_CSearchManager_release');
late final _CResult_CSearchManager_release = _CResult_CSearchManager_releasePtr.asFunction<void Function(_CResult_CSearchManager)>();

late final _CFuture_CSuggestResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CSuggestResult Function()>>('CFuture_CSuggestResultMakeDefault');
late final _CFuture_CSuggestResultMakeDefault = _CFuture_CSuggestResultMakeDefaultPtr.asFunction<_CFuture_CSuggestResult Function()>();
late final _CFuture_CSuggestResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CSuggestResult)>>('CFuture_CSuggestResult_release');
late final _CFuture_CSuggestResult_release = _CFuture_CSuggestResult_releasePtr.asFunction<void Function(_CFuture_CSuggestResult)>();
late final _CFuture_CSuggestResult_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CSuggestResult Function(_CFuture_CSuggestResult)>>('CFuture_CSuggestResult_retain');
late final _CFuture_CSuggestResult_retain = _CFuture_CSuggestResult_retainPtr.asFunction<_CFuture_CSuggestResult Function(_CFuture_CSuggestResult)>();
late final _CFuture_CSuggestResultReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CSuggestResult,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSuggestResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CSuggestResult_receive');
late final _CFuture_CSuggestResultReceive = _CFuture_CSuggestResultReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CSuggestResult,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSuggestResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CFuture_CSearchResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CSearchResult Function()>>('CFuture_CSearchResultMakeDefault');
late final _CFuture_CSearchResultMakeDefault = _CFuture_CSearchResultMakeDefaultPtr.asFunction<_CFuture_CSearchResult Function()>();
late final _CFuture_CSearchResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CSearchResult)>>('CFuture_CSearchResult_release');
late final _CFuture_CSearchResult_release = _CFuture_CSearchResult_releasePtr.asFunction<void Function(_CFuture_CSearchResult)>();
late final _CFuture_CSearchResult_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CSearchResult Function(_CFuture_CSearchResult)>>('CFuture_CSearchResult_retain');
late final _CFuture_CSearchResult_retain = _CFuture_CSearchResult_retainPtr.asFunction<_CFuture_CSearchResult Function(_CFuture_CSearchResult)>();
late final _CFuture_CSearchResultReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CSearchResult,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSearchResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CSearchResult_receive');
late final _CFuture_CSearchResultReceive = _CFuture_CSearchResultReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CSearchResult,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSearchResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CFuture_COptional_CDirectoryObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CDirectoryObject Function()>>('CFuture_COptional_CDirectoryObjectMakeDefault');
late final _CFuture_COptional_CDirectoryObjectMakeDefault = _CFuture_COptional_CDirectoryObjectMakeDefaultPtr.asFunction<_CFuture_COptional_CDirectoryObject Function()>();
late final _CFuture_COptional_CDirectoryObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_COptional_CDirectoryObject)>>('CFuture_COptional_CDirectoryObject_release');
late final _CFuture_COptional_CDirectoryObject_release = _CFuture_COptional_CDirectoryObject_releasePtr.asFunction<void Function(_CFuture_COptional_CDirectoryObject)>();
late final _CFuture_COptional_CDirectoryObject_retainPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CDirectoryObject Function(_CFuture_COptional_CDirectoryObject)>>('CFuture_COptional_CDirectoryObject_retain');
late final _CFuture_COptional_CDirectoryObject_retain = _CFuture_COptional_CDirectoryObject_retainPtr.asFunction<_CFuture_COptional_CDirectoryObject Function(_CFuture_COptional_CDirectoryObject)>();
late final _CFuture_COptional_CDirectoryObjectReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_COptional_CDirectoryObject,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CDirectoryObject, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_COptional_CDirectoryObject_receive');
late final _CFuture_COptional_CDirectoryObjectReceive = _CFuture_COptional_CDirectoryObjectReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_COptional_CDirectoryObject,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CDirectoryObject, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _COptional_CDirectoryObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CDirectoryObject Function()>>('COptional_CDirectoryObjectMakeDefault');
late final _COptional_CDirectoryObjectMakeDefault = _COptional_CDirectoryObjectMakeDefaultPtr.asFunction<_COptional_CDirectoryObject Function()>();

late final _COptional_CDirectoryObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CDirectoryObject)>>('COptional_CDirectoryObject_release');
late final _COptional_CDirectoryObject_release = _COptional_CDirectoryObject_releasePtr.asFunction<void Function(_COptional_CDirectoryObject)>();

late final _CSearchQueryBuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchQueryBuilder_cg_objectIdentifier');
late final _CSearchQueryBuilder_cg_objectIdentifier = _CSearchQueryBuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSearchQueryBuilder_S_fromQueryText_CStringPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CString)>>('CSearchQueryBuilder_S_fromQueryText_CString');
late final _CSearchQueryBuilder_S_fromQueryText_CString = _CSearchQueryBuilder_S_fromQueryText_CStringPtr.asFunction<_CSearchQueryBuilder Function(_CString)>();
late final _CSearchQueryBuilder_S_fromRubricIds_CArray_CRubricIdPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CArray_CRubricId)>>('CSearchQueryBuilder_S_fromRubricIds_CArray_CRubricId');
late final _CSearchQueryBuilder_S_fromRubricIds_CArray_CRubricId = _CSearchQueryBuilder_S_fromRubricIds_CArray_CRubricIdPtr.asFunction<_CSearchQueryBuilder Function(_CArray_CRubricId)>();
late final _CSearchQueryBuilder_S_fromQueryTextAndRubricIds_CString_CArray_CRubricIdPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CString, _CArray_CRubricId)>>('CSearchQueryBuilder_S_fromQueryTextAndRubricIds_CString_CArray_CRubricId');
late final _CSearchQueryBuilder_S_fromQueryTextAndRubricIds_CString_CArray_CRubricId = _CSearchQueryBuilder_S_fromQueryTextAndRubricIds_CString_CArray_CRubricIdPtr.asFunction<_CSearchQueryBuilder Function(_CString, _CArray_CRubricId)>();
late final _CSearchQueryBuilder_S_fromQuery_CSearchQueryPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQuery)>>('CSearchQueryBuilder_S_fromQuery_CSearchQuery');
late final _CSearchQueryBuilder_S_fromQuery_CSearchQuery = _CSearchQueryBuilder_S_fromQuery_CSearchQueryPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQuery)>();
late final _CSearchQueryBuilder_S_fromOrgId_COrgIdPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_COrgId)>>('CSearchQueryBuilder_S_fromOrgId_COrgId');
late final _CSearchQueryBuilder_S_fromOrgId_COrgId = _CSearchQueryBuilder_S_fromOrgId_COrgIdPtr.asFunction<_CSearchQueryBuilder Function(_COrgId)>();
late final _CSearchQueryBuilder_S_fromBuildingId_CBuildingIdPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CBuildingId)>>('CSearchQueryBuilder_S_fromBuildingId_CBuildingId');
late final _CSearchQueryBuilder_S_fromBuildingId_CBuildingId = _CSearchQueryBuilder_S_fromBuildingId_CBuildingIdPtr.asFunction<_CSearchQueryBuilder Function(_CBuildingId)>();
late final _CSearchQueryBuilder_S_fromGeoPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CGeoPoint)>>('CSearchQueryBuilder_S_fromGeoPoint_CGeoPoint');
late final _CSearchQueryBuilder_S_fromGeoPoint_CGeoPoint = _CSearchQueryBuilder_S_fromGeoPoint_CGeoPointPtr.asFunction<_CSearchQueryBuilder Function(_CGeoPoint)>();
late final _CSearchQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _COptional_CArray_CGeoPoint)>>('CSearchQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPoint');
late final _CSearchQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPoint = _CSearchQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPointPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _COptional_CArray_CGeoPoint)>();
late final _CSearchQueryBuilder_setAreaOfInterest_COptional_CGeoRectPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _COptional_CGeoRect)>>('CSearchQueryBuilder_setAreaOfInterest_COptional_CGeoRect');
late final _CSearchQueryBuilder_setAreaOfInterest_COptional_CGeoRect = _CSearchQueryBuilder_setAreaOfInterest_COptional_CGeoRectPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _COptional_CGeoRect)>();
late final _CSearchQueryBuilder_setAllowedResultTypes_CArray_CObjectTypePtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CArray_CObjectType)>>('CSearchQueryBuilder_setAllowedResultTypes_CArray_CObjectType');
late final _CSearchQueryBuilder_setAllowedResultTypes_CArray_CObjectType = _CSearchQueryBuilder_setAllowedResultTypes_CArray_CObjectTypePtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CArray_CObjectType)>();
late final _CSearchQueryBuilder_setPageSize_int32_tPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, ffi.Int32)>>('CSearchQueryBuilder_setPageSize_int32_t');
late final _CSearchQueryBuilder_setPageSize_int32_t = _CSearchQueryBuilder_setPageSize_int32_tPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, int)>();
late final _CSearchQueryBuilder_setDirectoryFilter_CDirectoryFilterPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CDirectoryFilter)>>('CSearchQueryBuilder_setDirectoryFilter_CDirectoryFilter');
late final _CSearchQueryBuilder_setDirectoryFilter_CDirectoryFilter = _CSearchQueryBuilder_setDirectoryFilter_CDirectoryFilterPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CDirectoryFilter)>();
late final _CSearchQueryBuilder_setSortingType_CSortingTypePtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CSortingType)>>('CSearchQueryBuilder_setSortingType_CSortingType');
late final _CSearchQueryBuilder_setSortingType_CSortingType = _CSearchQueryBuilder_setSortingType_CSortingTypePtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CSortingType)>();
late final _CSearchQueryBuilder_setGeoPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CGeoPoint)>>('CSearchQueryBuilder_setGeoPoint_CGeoPoint');
late final _CSearchQueryBuilder_setGeoPoint_CGeoPoint = _CSearchQueryBuilder_setGeoPoint_CGeoPointPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CGeoPoint)>();
late final _CSearchQueryBuilder_setRadius_CMeterPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CMeter)>>('CSearchQueryBuilder_setRadius_CMeter');
late final _CSearchQueryBuilder_setRadius_CMeter = _CSearchQueryBuilder_setRadius_CMeterPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CMeter)>();
late final _CSearchQueryBuilder_buildPtr = _lookup<ffi.NativeFunction<_CSearchQuery Function(_CSearchQueryBuilder)>>('CSearchQueryBuilder_build');
late final _CSearchQueryBuilder_build = _CSearchQueryBuilder_buildPtr.asFunction<_CSearchQuery Function(_CSearchQueryBuilder)>();

late final _CSearchQueryBuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchQueryBuilder_release');
late final _CSearchQueryBuilder_release = _CSearchQueryBuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchQueryBuilder_retainPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(ffi.Pointer<ffi.Void>)>>('CSearchQueryBuilder_retain');
late final _CSearchQueryBuilder_retain = _CSearchQueryBuilder_retainPtr.asFunction<_CSearchQueryBuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchQueryBuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function()>>('CSearchQueryBuilderMakeDefault');
late final _CSearchQueryBuilderMakeDefault = _CSearchQueryBuilderMakeDefaultPtr.asFunction<_CSearchQueryBuilder Function()>();


late final _COptional_CArray_CGeoPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CArray_CGeoPoint Function()>>('COptional_CArray_CGeoPointMakeDefault');
late final _COptional_CArray_CGeoPointMakeDefault = _COptional_CArray_CGeoPointMakeDefaultPtr.asFunction<_COptional_CArray_CGeoPoint Function()>();

late final _COptional_CArray_CGeoPoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CArray_CGeoPoint)>>('COptional_CArray_CGeoPoint_release');
late final _COptional_CArray_CGeoPoint_release = _COptional_CArray_CGeoPoint_releasePtr.asFunction<void Function(_COptional_CArray_CGeoPoint)>();

late final _COptional_CGeoRectMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGeoRect Function()>>('COptional_CGeoRectMakeDefault');
late final _COptional_CGeoRectMakeDefault = _COptional_CGeoRectMakeDefaultPtr.asFunction<_COptional_CGeoRect Function()>();

late final _CSuggestQueryBuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSuggestQueryBuilder_cg_objectIdentifier');
late final _CSuggestQueryBuilder_cg_objectIdentifier = _CSuggestQueryBuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSuggestQueryBuilder_S_fromQueryText_CStringPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CString)>>('CSuggestQueryBuilder_S_fromQueryText_CString');
late final _CSuggestQueryBuilder_S_fromQueryText_CString = _CSuggestQueryBuilder_S_fromQueryText_CStringPtr.asFunction<_CSuggestQueryBuilder Function(_CString)>();
late final _CSuggestQueryBuilder_S_fromQuery_CSuggestQueryPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQuery)>>('CSuggestQueryBuilder_S_fromQuery_CSuggestQuery');
late final _CSuggestQueryBuilder_S_fromQuery_CSuggestQuery = _CSuggestQueryBuilder_S_fromQuery_CSuggestQueryPtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQuery)>();
late final _CSuggestQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _COptional_CArray_CGeoPoint)>>('CSuggestQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPoint');
late final _CSuggestQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPoint = _CSuggestQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPointPtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _COptional_CArray_CGeoPoint)>();
late final _CSuggestQueryBuilder_setAreaOfInterest_COptional_CGeoRectPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _COptional_CGeoRect)>>('CSuggestQueryBuilder_setAreaOfInterest_COptional_CGeoRect');
late final _CSuggestQueryBuilder_setAreaOfInterest_COptional_CGeoRect = _CSuggestQueryBuilder_setAreaOfInterest_COptional_CGeoRectPtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _COptional_CGeoRect)>();
late final _CSuggestQueryBuilder_setAllowedResultTypes_CArray_CSuggestedTypePtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _CArray_CSuggestedType)>>('CSuggestQueryBuilder_setAllowedResultTypes_CArray_CSuggestedType');
late final _CSuggestQueryBuilder_setAllowedResultTypes_CArray_CSuggestedType = _CSuggestQueryBuilder_setAllowedResultTypes_CArray_CSuggestedTypePtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _CArray_CSuggestedType)>();
late final _CSuggestQueryBuilder_setSuggestorType_CSuggestorTypePtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _CSuggestorType)>>('CSuggestQueryBuilder_setSuggestorType_CSuggestorType');
late final _CSuggestQueryBuilder_setSuggestorType_CSuggestorType = _CSuggestQueryBuilder_setSuggestorType_CSuggestorTypePtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _CSuggestorType)>();
late final _CSuggestQueryBuilder_setLimit_int32_tPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, ffi.Int32)>>('CSuggestQueryBuilder_setLimit_int32_t');
late final _CSuggestQueryBuilder_setLimit_int32_t = _CSuggestQueryBuilder_setLimit_int32_tPtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, int)>();
late final _CSuggestQueryBuilder_buildPtr = _lookup<ffi.NativeFunction<_CSuggestQuery Function(_CSuggestQueryBuilder)>>('CSuggestQueryBuilder_build');
late final _CSuggestQueryBuilder_build = _CSuggestQueryBuilder_buildPtr.asFunction<_CSuggestQuery Function(_CSuggestQueryBuilder)>();

late final _CSuggestQueryBuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSuggestQueryBuilder_release');
late final _CSuggestQueryBuilder_release = _CSuggestQueryBuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestQueryBuilder_retainPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(ffi.Pointer<ffi.Void>)>>('CSuggestQueryBuilder_retain');
late final _CSuggestQueryBuilder_retain = _CSuggestQueryBuilder_retainPtr.asFunction<_CSuggestQueryBuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestQueryBuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function()>>('CSuggestQueryBuilderMakeDefault');
late final _CSuggestQueryBuilderMakeDefault = _CSuggestQueryBuilderMakeDefaultPtr.asFunction<_CSuggestQueryBuilder Function()>();


late final _CArray_CSuggestedTypemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSuggestedType Function()>>('CArray_CSuggestedType_makeEmpty');
late final _CArray_CSuggestedTypemakeEmpty = _CArray_CSuggestedTypemakeEmptyPtr.asFunction<_CArray_CSuggestedType Function()>();
late final _CArray_CSuggestedTypeaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSuggestedType, _CSuggestedType)>>('CArray_CSuggestedType_addElement');
late final _CArray_CSuggestedTypeaddElement = _CArray_CSuggestedTypeaddElementPtr.asFunction<void Function(_CArray_CSuggestedType, _CSuggestedType)>();
late final _forEach_CArray_CSuggestedTypePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSuggestedType, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSuggestedType)>>)
>>('CArray_CSuggestedType_forEachWithFunctionPointer');
late final _forEach_CArray_CSuggestedType = _forEach_CArray_CSuggestedTypePtr.asFunction<
  void Function(_CArray_CSuggestedType, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSuggestedType)
>>)>();
late final _CArray_CSuggestedType_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSuggestedType)>>('CArray_CSuggestedType_release');
late final _CArray_CSuggestedType_release = _CArray_CSuggestedType_releasePtr.asFunction<void Function(_CArray_CSuggestedType)>();

late final _CChangeTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChangeType Function()>>('CChangeTypeMakeDefault');
late final _CChangeTypeMakeDefault = _CChangeTypeMakeDefaultPtr.asFunction<_CChangeType Function()>();
late final _CSearchQueryWithInfo_searchQueryPtr = _lookup<ffi.NativeFunction<_CSearchQuery Function(_CSearchQueryWithInfo)>>('CSearchQueryWithInfo_searchQuery');
late final _CSearchQueryWithInfo_searchQuery = _CSearchQueryWithInfo_searchQueryPtr.asFunction<_CSearchQuery Function(_CSearchQueryWithInfo)>();
late final _CSearchQueryWithInfo_titlePtr = _lookup<ffi.NativeFunction<_CString Function(_CSearchQueryWithInfo)>>('CSearchQueryWithInfo_title');
late final _CSearchQueryWithInfo_title = _CSearchQueryWithInfo_titlePtr.asFunction<_CString Function(_CSearchQueryWithInfo)>();
late final _CSearchQueryWithInfo_subtitlePtr = _lookup<ffi.NativeFunction<_CString Function(_CSearchQueryWithInfo)>>('CSearchQueryWithInfo_subtitle');
late final _CSearchQueryWithInfo_subtitle = _CSearchQueryWithInfo_subtitlePtr.asFunction<_CString Function(_CSearchQueryWithInfo)>();

late final _CSearchQueryWithInfo_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchQueryWithInfo_cg_objectIdentifier');
late final _CSearchQueryWithInfo_cg_objectIdentifier = _CSearchQueryWithInfo_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSearchQueryWithInfo_C_createWith_CSearchQuery_CString_CStringPtr = _lookup<ffi.NativeFunction<_CSearchQueryWithInfo Function(_CSearchQuery, _CString, _CString)>>('CSearchQueryWithInfo_C_createWith_CSearchQuery_CString_CString');
late final _CSearchQueryWithInfo_C_createWith_CSearchQuery_CString_CString = _CSearchQueryWithInfo_C_createWith_CSearchQuery_CString_CStringPtr.asFunction<_CSearchQueryWithInfo Function(_CSearchQuery, _CString, _CString)>();

late final _CSearchQueryWithInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchQueryWithInfo_release');
late final _CSearchQueryWithInfo_release = _CSearchQueryWithInfo_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchQueryWithInfo_retainPtr = _lookup<ffi.NativeFunction<_CSearchQueryWithInfo Function(ffi.Pointer<ffi.Void>)>>('CSearchQueryWithInfo_retain');
late final _CSearchQueryWithInfo_retain = _CSearchQueryWithInfo_retainPtr.asFunction<_CSearchQueryWithInfo Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchQueryWithInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchQueryWithInfo Function()>>('CSearchQueryWithInfoMakeDefault');
late final _CSearchQueryWithInfoMakeDefault = _CSearchQueryWithInfoMakeDefaultPtr.asFunction<_CSearchQueryWithInfo Function()>();


late final _CSearchHistoryItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSearchHistoryItem)>>('CSearchHistoryItem_release');
late final _CSearchHistoryItem_release = _CSearchHistoryItem_releasePtr.asFunction<void Function(_CSearchHistoryItem)>();
late final _CSearchHistoryItemMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchHistoryItem Function()>>('CSearchHistoryItemMakeDefault');
late final _CSearchHistoryItemMakeDefault = _CSearchHistoryItemMakeDefaultPtr.asFunction<_CSearchHistoryItem Function()>();
late final _CSearchHistoryResult_itemsPtr = _lookup<ffi.NativeFunction<_CArray_CSearchHistoryItem Function(_CSearchHistoryResult)>>('CSearchHistoryResult_items');
late final _CSearchHistoryResult_items = _CSearchHistoryResult_itemsPtr.asFunction<_CArray_CSearchHistoryItem Function(_CSearchHistoryResult)>();

late final _CSearchHistoryResult_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchHistoryResult_cg_objectIdentifier');
late final _CSearchHistoryResult_cg_objectIdentifier = _CSearchHistoryResult_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSearchHistoryResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchHistoryResult_release');
late final _CSearchHistoryResult_release = _CSearchHistoryResult_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchHistoryResult_retainPtr = _lookup<ffi.NativeFunction<_CSearchHistoryResult Function(ffi.Pointer<ffi.Void>)>>('CSearchHistoryResult_retain');
late final _CSearchHistoryResult_retain = _CSearchHistoryResult_retainPtr.asFunction<_CSearchHistoryResult Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchHistoryResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchHistoryResult Function()>>('CSearchHistoryResultMakeDefault');
late final _CSearchHistoryResultMakeDefault = _CSearchHistoryResultMakeDefaultPtr.asFunction<_CSearchHistoryResult Function()>();


late final _CArray_CSearchHistoryItemmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSearchHistoryItem Function()>>('CArray_CSearchHistoryItem_makeEmpty');
late final _CArray_CSearchHistoryItemmakeEmpty = _CArray_CSearchHistoryItemmakeEmptyPtr.asFunction<_CArray_CSearchHistoryItem Function()>();
late final _CArray_CSearchHistoryItemaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSearchHistoryItem, _CSearchHistoryItem)>>('CArray_CSearchHistoryItem_addElement');
late final _CArray_CSearchHistoryItemaddElement = _CArray_CSearchHistoryItemaddElementPtr.asFunction<void Function(_CArray_CSearchHistoryItem, _CSearchHistoryItem)>();
late final _forEach_CArray_CSearchHistoryItemPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSearchHistoryItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSearchHistoryItem)>>)
>>('CArray_CSearchHistoryItem_forEachWithFunctionPointer');
late final _forEach_CArray_CSearchHistoryItem = _forEach_CArray_CSearchHistoryItemPtr.asFunction<
  void Function(_CArray_CSearchHistoryItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSearchHistoryItem)
>>)>();
late final _CArray_CSearchHistoryItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSearchHistoryItem)>>('CArray_CSearchHistoryItem_release');
late final _CArray_CSearchHistoryItem_release = _CArray_CSearchHistoryItem_releasePtr.asFunction<void Function(_CArray_CSearchHistoryItem)>();

late final _CSearchHistoryFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchHistoryFilter Function()>>('CSearchHistoryFilterMakeDefault');
late final _CSearchHistoryFilterMakeDefault = _CSearchHistoryFilterMakeDefaultPtr.asFunction<_CSearchHistoryFilter Function()>();

late final _COptionSet_CSearchHistoryFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CSearchHistoryFilter Function()>>('COptionSet_CSearchHistoryFilterMakeDefault');
late final _COptionSet_CSearchHistoryFilterMakeDefault = _COptionSet_CSearchHistoryFilterMakeDefaultPtr.asFunction<_COptionSet_CSearchHistoryFilter Function()>();

late final _CSearchHistoryPageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchHistoryPage Function()>>('CSearchHistoryPageMakeDefault');
late final _CSearchHistoryPageMakeDefault = _CSearchHistoryPageMakeDefaultPtr.asFunction<_CSearchHistoryPage Function()>();

late final _CSearchHistory_capacityPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CSearchHistory)>>('CSearchHistory_capacity');
late final _CSearchHistory_capacity = _CSearchHistory_capacityPtr.asFunction<int Function(_CSearchHistory)>();
late final _CSearchHistory_onHistoryChangedPtr = _lookup<ffi.NativeFunction<_CChannel_CChangeType Function(_CSearchHistory)>>('CSearchHistory_onHistoryChanged');
late final _CSearchHistory_onHistoryChanged = _CSearchHistory_onHistoryChangedPtr.asFunction<_CChannel_CChangeType Function(_CSearchHistory)>();

late final _CSearchHistory_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchHistory_cg_objectIdentifier');
late final _CSearchHistory_cg_objectIdentifier = _CSearchHistory_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSearchHistory_items_CSearchHistoryPagePtr = _lookup<ffi.NativeFunction<_CFuture_CSearchHistoryResult Function(_CSearchHistory, _CSearchHistoryPage)>>('CSearchHistory_items_CSearchHistoryPage');
late final _CSearchHistory_items_CSearchHistoryPage = _CSearchHistory_items_CSearchHistoryPagePtr.asFunction<_CFuture_CSearchHistoryResult Function(_CSearchHistory, _CSearchHistoryPage)>();
late final _CSearchHistory_addItem_CSearchHistoryItemPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSearchHistory, _CSearchHistoryItem)>>('CSearchHistory_addItem_CSearchHistoryItem');
late final _CSearchHistory_addItem_CSearchHistoryItem = _CSearchHistory_addItem_CSearchHistoryItemPtr.asFunction<void Function(_CSearchHistory, _CSearchHistoryItem)>();
late final _CSearchHistory_addItems_CArray_CSearchHistoryItemPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSearchHistory, _CArray_CSearchHistoryItem)>>('CSearchHistory_addItems_CArray_CSearchHistoryItem');
late final _CSearchHistory_addItems_CArray_CSearchHistoryItem = _CSearchHistory_addItems_CArray_CSearchHistoryItemPtr.asFunction<void Function(_CSearchHistory, _CArray_CSearchHistoryItem)>();
late final _CSearchHistory_removeItem_CSearchHistoryItemPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSearchHistory, _CSearchHistoryItem)>>('CSearchHistory_removeItem_CSearchHistoryItem');
late final _CSearchHistory_removeItem_CSearchHistoryItem = _CSearchHistory_removeItem_CSearchHistoryItemPtr.asFunction<void Function(_CSearchHistory, _CSearchHistoryItem)>();
late final _CSearchHistory_removeItems_CArray_CSearchHistoryItemPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSearchHistory, _CArray_CSearchHistoryItem)>>('CSearchHistory_removeItems_CArray_CSearchHistoryItem');
late final _CSearchHistory_removeItems_CArray_CSearchHistoryItem = _CSearchHistory_removeItems_CArray_CSearchHistoryItemPtr.asFunction<void Function(_CSearchHistory, _CArray_CSearchHistoryItem)>();
late final _CSearchHistory_clearPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSearchHistory)>>('CSearchHistory_clear');
late final _CSearchHistory_clear = _CSearchHistory_clearPtr.asFunction<void Function(_CSearchHistory)>();
late final _CSearchHistory_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CSearchHistory Function(_CContext)>>('CSearchHistory_C_createWith_CContext');
late final _CSearchHistory_C_createWith_CContext = _CSearchHistory_C_createWith_CContextPtr.asFunction<_CSearchHistory Function(_CContext)>();

late final _CSearchHistory_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchHistory_release');
late final _CSearchHistory_release = _CSearchHistory_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchHistory_retainPtr = _lookup<ffi.NativeFunction<_CSearchHistory Function(ffi.Pointer<ffi.Void>)>>('CSearchHistory_retain');
late final _CSearchHistory_retain = _CSearchHistory_retainPtr.asFunction<_CSearchHistory Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchHistoryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchHistory Function()>>('CSearchHistoryMakeDefault');
late final _CSearchHistoryMakeDefault = _CSearchHistoryMakeDefaultPtr.asFunction<_CSearchHistory Function()>();


late final _CFuture_CSearchHistoryResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CSearchHistoryResult Function()>>('CFuture_CSearchHistoryResultMakeDefault');
late final _CFuture_CSearchHistoryResultMakeDefault = _CFuture_CSearchHistoryResultMakeDefaultPtr.asFunction<_CFuture_CSearchHistoryResult Function()>();
late final _CFuture_CSearchHistoryResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CSearchHistoryResult)>>('CFuture_CSearchHistoryResult_release');
late final _CFuture_CSearchHistoryResult_release = _CFuture_CSearchHistoryResult_releasePtr.asFunction<void Function(_CFuture_CSearchHistoryResult)>();
late final _CFuture_CSearchHistoryResult_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CSearchHistoryResult Function(_CFuture_CSearchHistoryResult)>>('CFuture_CSearchHistoryResult_retain');
late final _CFuture_CSearchHistoryResult_retain = _CFuture_CSearchHistoryResult_retainPtr.asFunction<_CFuture_CSearchHistoryResult Function(_CFuture_CSearchHistoryResult)>();
late final _CFuture_CSearchHistoryResultReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CSearchHistoryResult,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSearchHistoryResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CSearchHistoryResult_receive');
late final _CFuture_CSearchHistoryResultReceive = _CFuture_CSearchHistoryResultReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CSearchHistoryResult,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSearchHistoryResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CChannel_CChangeTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChannel_CChangeType Function()>>('CChannel_CChangeTypeMakeDefault');
late final _CChannel_CChangeTypeMakeDefault = _CChannel_CChangeTypeMakeDefaultPtr.asFunction<_CChannel_CChangeType Function()>();
late final _CChannel_CChangeType_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CChannel_CChangeType)>>('CChannel_CChangeType_release');
late final _CChannel_CChangeType_release = _CChannel_CChangeType_releasePtr.asFunction<void Function(_CChannel_CChangeType)>();
late final _CChannel_CChangeType_retainPtr = _lookup<ffi.NativeFunction<_CChannel_CChangeType Function(_CChannel_CChangeType)>>('CChannel_CChangeType_retain');
late final _CChannel_CChangeType_retain = _CChannel_CChangeType_retainPtr.asFunction<_CChannel_CChangeType Function(_CChannel_CChangeType)>();
late final _CChannel_CChangeTypeConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CChannel_CChangeType,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CChangeType, ffi.Int64)>>
  )
>>('CChannel_CChangeType_connect');
late final _CChannel_CChangeTypeConnect = _CChannel_CChangeTypeConnectPtr.asFunction<
  _CCancellable Function(
    _CChannel_CChangeType,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CChangeType, ffi.Int64)>>
  )
>();
late final _CPackedSearchQuery_queryTextPtr = _lookup<ffi.NativeFunction<_CString Function(_CPackedSearchQuery)>>('CPackedSearchQuery_queryText');
late final _CPackedSearchQuery_queryText = _CPackedSearchQuery_queryTextPtr.asFunction<_CString Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_spatialRestrictionPtr = _lookup<ffi.NativeFunction<_COptional_CArray_CGeoPoint Function(_CPackedSearchQuery)>>('CPackedSearchQuery_spatialRestriction');
late final _CPackedSearchQuery_spatialRestriction = _CPackedSearchQuery_spatialRestrictionPtr.asFunction<_COptional_CArray_CGeoPoint Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_areaOfInterestPtr = _lookup<ffi.NativeFunction<_COptional_CGeoRect Function(_CPackedSearchQuery)>>('CPackedSearchQuery_areaOfInterest');
late final _CPackedSearchQuery_areaOfInterest = _CPackedSearchQuery_areaOfInterestPtr.asFunction<_COptional_CGeoRect Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_allowedResultTypesPtr = _lookup<ffi.NativeFunction<_CArray_CObjectType Function(_CPackedSearchQuery)>>('CPackedSearchQuery_allowedResultTypes');
late final _CPackedSearchQuery_allowedResultTypes = _CPackedSearchQuery_allowedResultTypesPtr.asFunction<_CArray_CObjectType Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_pageSizePtr = _lookup<ffi.NativeFunction<ffi.Int32 Function(_CPackedSearchQuery)>>('CPackedSearchQuery_pageSize');
late final _CPackedSearchQuery_pageSize = _CPackedSearchQuery_pageSizePtr.asFunction<int Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_directoryFilterPtr = _lookup<ffi.NativeFunction<_CDirectoryFilter Function(_CPackedSearchQuery)>>('CPackedSearchQuery_directoryFilter');
late final _CPackedSearchQuery_directoryFilter = _CPackedSearchQuery_directoryFilterPtr.asFunction<_CDirectoryFilter Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_sortingTypePtr = _lookup<ffi.NativeFunction<_CSortingType Function(_CPackedSearchQuery)>>('CPackedSearchQuery_sortingType');
late final _CPackedSearchQuery_sortingType = _CPackedSearchQuery_sortingTypePtr.asFunction<_CSortingType Function(_CPackedSearchQuery)>();

late final _CPackedSearchQuery_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPackedSearchQuery_cg_objectIdentifier');
late final _CPackedSearchQuery_cg_objectIdentifier = _CPackedSearchQuery_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPackedSearchQuery_S_fromBytes_CDataPtr = _lookup<ffi.NativeFunction<_CResult_CPackedSearchQuery Function(_CData)>>('CPackedSearchQuery_S_fromBytes_CData');
late final _CPackedSearchQuery_S_fromBytes_CData = _CPackedSearchQuery_S_fromBytes_CDataPtr.asFunction<_CResult_CPackedSearchQuery Function(_CData)>();
late final _CPackedSearchQuery_S_fromSearchQuery_CSearchQueryPtr = _lookup<ffi.NativeFunction<_CPackedSearchQuery Function(_CSearchQuery)>>('CPackedSearchQuery_S_fromSearchQuery_CSearchQuery');
late final _CPackedSearchQuery_S_fromSearchQuery_CSearchQuery = _CPackedSearchQuery_S_fromSearchQuery_CSearchQueryPtr.asFunction<_CPackedSearchQuery Function(_CSearchQuery)>();
late final _CPackedSearchQuery_toBytesPtr = _lookup<ffi.NativeFunction<_CData Function(_CPackedSearchQuery)>>('CPackedSearchQuery_toBytes');
late final _CPackedSearchQuery_toBytes = _CPackedSearchQuery_toBytesPtr.asFunction<_CData Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_toSearchQueryPtr = _lookup<ffi.NativeFunction<_CSearchQuery Function(_CPackedSearchQuery)>>('CPackedSearchQuery_toSearchQuery');
late final _CPackedSearchQuery_toSearchQuery = _CPackedSearchQuery_toSearchQueryPtr.asFunction<_CSearchQuery Function(_CPackedSearchQuery)>();

late final _CPackedSearchQuery_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPackedSearchQuery_release');
late final _CPackedSearchQuery_release = _CPackedSearchQuery_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPackedSearchQuery_retainPtr = _lookup<ffi.NativeFunction<_CPackedSearchQuery Function(ffi.Pointer<ffi.Void>)>>('CPackedSearchQuery_retain');
late final _CPackedSearchQuery_retain = _CPackedSearchQuery_retainPtr.asFunction<_CPackedSearchQuery Function(ffi.Pointer<ffi.Void>)>();
late final _CPackedSearchQueryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPackedSearchQuery Function()>>('CPackedSearchQueryMakeDefault');
late final _CPackedSearchQueryMakeDefault = _CPackedSearchQueryMakeDefaultPtr.asFunction<_CPackedSearchQuery Function()>();


late final _CResult_CPackedSearchQuery_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CPackedSearchQuery)>>('CResult_CPackedSearchQuery_release');
late final _CResult_CPackedSearchQuery_release = _CResult_CPackedSearchQuery_releasePtr.asFunction<void Function(_CResult_CPackedSearchQuery)>();

late final _CDataCreateWithDataPtr = _lookup<ffi.NativeFunction<_CData Function(ffi.Size size, ffi.Pointer<ffi.Uint8>)>>('CData_createWithData');
late final _CDataCreateWithData = _CDataCreateWithDataPtr.asFunction<_CData Function(int, ffi.Pointer<ffi.Uint8>)>();
late final _GetSizeWith_CDataPtr = _lookup<ffi.NativeFunction<ffi.Size Function(_CData)>>('CData_getSize');
late final _GetSizeWith_CData = _GetSizeWith_CDataPtr.asFunction<int Function(_CData)>();
late final _GetDataWith_CDataPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Uint8> Function(_CData)>>('CData_getData');
late final _GetDataWith_CData = _GetDataWith_CDataPtr.asFunction<ffi.Pointer<ffi.Uint8> Function(_CData)>();
late final _CData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CData)>>('CData_release');
late final _CData_release = _CData_releasePtr.asFunction<void Function(_CData)>();

late final _CPointGeometryData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPointGeometryData)>>('CPointGeometryData_release');
late final _CPointGeometryData_release = _CPointGeometryData_releasePtr.asFunction<void Function(_CPointGeometryData)>();
late final _CPointGeometryDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPointGeometryData Function()>>('CPointGeometryDataMakeDefault');
late final _CPointGeometryDataMakeDefault = _CPointGeometryDataMakeDefaultPtr.asFunction<_CPointGeometryData Function()>();
late final _CPointGeometry_pointPtr = _lookup<ffi.NativeFunction<_CPointGeometryData Function(_CPointGeometry)>>('CPointGeometry_point');
late final _CPointGeometry_point = _CPointGeometry_pointPtr.asFunction<_CPointGeometryData Function(_CPointGeometry)>();

late final _CPointGeometry_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPointGeometry_cg_objectIdentifier');
late final _CPointGeometry_cg_objectIdentifier = _CPointGeometry_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPointGeometry_C_createWith_CGeoPointPtr = _lookup<ffi.NativeFunction<_CPointGeometry Function(_CGeoPoint)>>('CPointGeometry_C_createWith_CGeoPoint');
late final _CPointGeometry_C_createWith_CGeoPoint = _CPointGeometry_C_createWith_CGeoPointPtr.asFunction<_CPointGeometry Function(_CGeoPoint)>();
late final _CPointGeometry_C_createWith_CGeoPointWithElevationPtr = _lookup<ffi.NativeFunction<_CPointGeometry Function(_CGeoPointWithElevation)>>('CPointGeometry_C_createWith_CGeoPointWithElevation');
late final _CPointGeometry_C_createWith_CGeoPointWithElevation = _CPointGeometry_C_createWith_CGeoPointWithElevationPtr.asFunction<_CPointGeometry Function(_CGeoPointWithElevation)>();

late final _CPointGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPointGeometry_release');
late final _CPointGeometry_release = _CPointGeometry_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPointGeometry_retainPtr = _lookup<ffi.NativeFunction<_CPointGeometry Function(ffi.Pointer<ffi.Void>)>>('CPointGeometry_retain');
late final _CPointGeometry_retain = _CPointGeometry_retainPtr.asFunction<_CPointGeometry Function(ffi.Pointer<ffi.Void>)>();
late final _CPointGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPointGeometry Function()>>('CPointGeometryMakeDefault');
late final _CPointGeometryMakeDefault = _CPointGeometryMakeDefaultPtr.asFunction<_CPointGeometry Function()>();

late final _CPolygonGeometry_contoursPtr = _lookup<ffi.NativeFunction<_CArray_CArray_CGeoPoint Function(_CPolygonGeometry)>>('CPolygonGeometry_contours');
late final _CPolygonGeometry_contours = _CPolygonGeometry_contoursPtr.asFunction<_CArray_CArray_CGeoPoint Function(_CPolygonGeometry)>();

late final _CPolygonGeometry_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPolygonGeometry_cg_objectIdentifier');
late final _CPolygonGeometry_cg_objectIdentifier = _CPolygonGeometry_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPolygonGeometry_C_createWith_CArray_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<_CPolygonGeometry Function(_CArray_CArray_CGeoPoint)>>('CPolygonGeometry_C_createWith_CArray_CArray_CGeoPoint');
late final _CPolygonGeometry_C_createWith_CArray_CArray_CGeoPoint = _CPolygonGeometry_C_createWith_CArray_CArray_CGeoPointPtr.asFunction<_CPolygonGeometry Function(_CArray_CArray_CGeoPoint)>();

late final _CPolygonGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPolygonGeometry_release');
late final _CPolygonGeometry_release = _CPolygonGeometry_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPolygonGeometry_retainPtr = _lookup<ffi.NativeFunction<_CPolygonGeometry Function(ffi.Pointer<ffi.Void>)>>('CPolygonGeometry_retain');
late final _CPolygonGeometry_retain = _CPolygonGeometry_retainPtr.asFunction<_CPolygonGeometry Function(ffi.Pointer<ffi.Void>)>();
late final _CPolygonGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPolygonGeometry Function()>>('CPolygonGeometryMakeDefault');
late final _CPolygonGeometryMakeDefault = _CPolygonGeometryMakeDefaultPtr.asFunction<_CPolygonGeometry Function()>();

late final _CPolylineGeometry_pointsPtr = _lookup<ffi.NativeFunction<_CArray_CGeoPoint Function(_CPolylineGeometry)>>('CPolylineGeometry_points');
late final _CPolylineGeometry_points = _CPolylineGeometry_pointsPtr.asFunction<_CArray_CGeoPoint Function(_CPolylineGeometry)>();

late final _CPolylineGeometry_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPolylineGeometry_cg_objectIdentifier');
late final _CPolylineGeometry_cg_objectIdentifier = _CPolylineGeometry_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPolylineGeometry_C_createWith_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<_CPolylineGeometry Function(_CArray_CGeoPoint)>>('CPolylineGeometry_C_createWith_CArray_CGeoPoint');
late final _CPolylineGeometry_C_createWith_CArray_CGeoPoint = _CPolylineGeometry_C_createWith_CArray_CGeoPointPtr.asFunction<_CPolylineGeometry Function(_CArray_CGeoPoint)>();

late final _CPolylineGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPolylineGeometry_release');
late final _CPolylineGeometry_release = _CPolylineGeometry_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPolylineGeometry_retainPtr = _lookup<ffi.NativeFunction<_CPolylineGeometry Function(ffi.Pointer<ffi.Void>)>>('CPolylineGeometry_retain');
late final _CPolylineGeometry_retain = _CPolylineGeometry_retainPtr.asFunction<_CPolylineGeometry Function(ffi.Pointer<ffi.Void>)>();
late final _CPolylineGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPolylineGeometry Function()>>('CPolylineGeometryMakeDefault');
late final _CPolylineGeometryMakeDefault = _CPolylineGeometryMakeDefaultPtr.asFunction<_CPolylineGeometry Function()>();

late final _CComplexGeometry_elementsPtr = _lookup<ffi.NativeFunction<_CArray_CGeometry Function(_CComplexGeometry)>>('CComplexGeometry_elements');
late final _CComplexGeometry_elements = _CComplexGeometry_elementsPtr.asFunction<_CArray_CGeometry Function(_CComplexGeometry)>();

late final _CComplexGeometry_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CComplexGeometry_cg_objectIdentifier');
late final _CComplexGeometry_cg_objectIdentifier = _CComplexGeometry_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CComplexGeometry_C_createWith_CArray_CGeometryPtr = _lookup<ffi.NativeFunction<_CComplexGeometry Function(_CArray_CGeometry)>>('CComplexGeometry_C_createWith_CArray_CGeometry');
late final _CComplexGeometry_C_createWith_CArray_CGeometry = _CComplexGeometry_C_createWith_CArray_CGeometryPtr.asFunction<_CComplexGeometry Function(_CArray_CGeometry)>();

late final _CComplexGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CComplexGeometry_release');
late final _CComplexGeometry_release = _CComplexGeometry_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CComplexGeometry_retainPtr = _lookup<ffi.NativeFunction<_CComplexGeometry Function(ffi.Pointer<ffi.Void>)>>('CComplexGeometry_retain');
late final _CComplexGeometry_retain = _CComplexGeometry_retainPtr.asFunction<_CComplexGeometry Function(ffi.Pointer<ffi.Void>)>();
late final _CComplexGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CComplexGeometry Function()>>('CComplexGeometryMakeDefault');
late final _CComplexGeometryMakeDefault = _CComplexGeometryMakeDefaultPtr.asFunction<_CComplexGeometry Function()>();


late final _CArray_CGeometrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CGeometry Function()>>('CArray_CGeometry_makeEmpty');
late final _CArray_CGeometrymakeEmpty = _CArray_CGeometrymakeEmptyPtr.asFunction<_CArray_CGeometry Function()>();
late final _CArray_CGeometryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeometry, _CGeometry)>>('CArray_CGeometry_addElement');
late final _CArray_CGeometryaddElement = _CArray_CGeometryaddElementPtr.asFunction<void Function(_CArray_CGeometry, _CGeometry)>();
late final _forEach_CArray_CGeometryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CGeometry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeometry)>>)
>>('CArray_CGeometry_forEachWithFunctionPointer');
late final _forEach_CArray_CGeometry = _forEach_CArray_CGeometryPtr.asFunction<
  void Function(_CArray_CGeometry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeometry)
>>)>();
late final _CArray_CGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeometry)>>('CArray_CGeometry_release');
late final _CArray_CGeometry_release = _CArray_CGeometry_releasePtr.asFunction<void Function(_CArray_CGeometry)>();
late final _CFunction_G_downloadData_With_CContext_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CData Function(_CContext, _CString)>>('CFunction_G_downloadData_With_CContext_CString');
late final _CFunction_G_downloadData_With_CContext_CString = _CFunction_G_downloadData_With_CContext_CStringPtr.asFunction<_CFuture_CData Function(_CContext, _CString)>();

late final _CFuture_CDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CData Function()>>('CFuture_CDataMakeDefault');
late final _CFuture_CDataMakeDefault = _CFuture_CDataMakeDefaultPtr.asFunction<_CFuture_CData Function()>();
late final _CFuture_CData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CData)>>('CFuture_CData_release');
late final _CFuture_CData_release = _CFuture_CData_releasePtr.asFunction<void Function(_CFuture_CData)>();
late final _CFuture_CData_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CData Function(_CFuture_CData)>>('CFuture_CData_retain');
late final _CFuture_CData_retain = _CFuture_CData_retainPtr.asFunction<_CFuture_CData Function(_CFuture_CData)>();
late final _CFuture_CDataReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CData,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CData, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CData_receive');
late final _CFuture_CDataReceive = _CFuture_CDataReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CData,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CData, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CAnchorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAnchor Function()>>('CAnchorMakeDefault');
late final _CAnchorMakeDefault = _CAnchorMakeDefaultPtr.asFunction<_CAnchor Function()>();


late final _CArray_CAttributeValuemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CAttributeValue Function()>>('CArray_CAttributeValue_makeEmpty');
late final _CArray_CAttributeValuemakeEmpty = _CArray_CAttributeValuemakeEmptyPtr.asFunction<_CArray_CAttributeValue Function()>();
late final _CArray_CAttributeValueaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAttributeValue, _CAttributeValue)>>('CArray_CAttributeValue_addElement');
late final _CArray_CAttributeValueaddElement = _CArray_CAttributeValueaddElementPtr.asFunction<void Function(_CArray_CAttributeValue, _CAttributeValue)>();
late final _forEach_CArray_CAttributeValuePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CAttributeValue, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAttributeValue)>>)
>>('CArray_CAttributeValue_forEachWithFunctionPointer');
late final _forEach_CArray_CAttributeValue = _forEach_CArray_CAttributeValuePtr.asFunction<
  void Function(_CArray_CAttributeValue, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAttributeValue)
>>)>();
late final _CArray_CAttributeValue_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAttributeValue)>>('CArray_CAttributeValue_release');
late final _CArray_CAttributeValue_release = _CArray_CAttributeValue_releasePtr.asFunction<void Function(_CArray_CAttributeValue)>();

late final _CDictionary_CString_CAttributeValuemakeEmptyPtr = _lookup<ffi.NativeFunction<_CDictionary_CString_CAttributeValue Function()>>('CDictionary_CString_CAttributeValue_makeEmpty');
late final _CDictionary_CString_CAttributeValuemakeEmpty = _CDictionary_CString_CAttributeValuemakeEmptyPtr.asFunction<_CDictionary_CString_CAttributeValue Function()>();
late final _CDictionary_CString_CAttributeValueaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDictionary_CString_CAttributeValue, _CString, _CAttributeValue)>>('CDictionary_CString_CAttributeValue_addElement');
late final _CDictionary_CString_CAttributeValueaddElement = _CDictionary_CString_CAttributeValueaddElementPtr.asFunction<void Function(_CDictionary_CString_CAttributeValue, _CString, _CAttributeValue)>();
late final _forEach_CDictionary_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CDictionary_CString_CAttributeValue, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CString, _CAttributeValue)>>)
>>('CDictionary_CString_CAttributeValue_forEachKeyValueWithFunctionPointer');
late final _forEach_CDictionary_CString_CAttributeValue = _forEach_CDictionary_CString_CAttributeValuePtr.asFunction<
  void Function(_CDictionary_CString_CAttributeValue, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CString, _CAttributeValue)
>>)>();
late final _CDictionary_CString_CAttributeValue_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDictionary_CString_CAttributeValue)>>('CDictionary_CString_CAttributeValue_release');
late final _CDictionary_CString_CAttributeValue_release = _CDictionary_CString_CAttributeValue_releasePtr.asFunction<void Function(_CDictionary_CString_CAttributeValue)>();

late final _CAttributeValue_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAttributeValue)>>('CAttributeValue_release');
late final _CAttributeValue_release = _CAttributeValue_releasePtr.asFunction<void Function(_CAttributeValue)>();
late final _CAttributeValueMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAttributeValue Function()>>('CAttributeValueMakeDefault');
late final _CAttributeValueMakeDefault = _CAttributeValueMakeDefaultPtr.asFunction<_CAttributeValue Function()>();

late final _CBearingSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBearingSource Function()>>('CBearingSourceMakeDefault');
late final _CBearingSourceMakeDefault = _CBearingSourceMakeDefaultPtr.asFunction<_CBearingSource Function()>();

late final _CCameraAnimatedMoveReasonMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraAnimatedMoveReason Function()>>('CCameraAnimatedMoveReasonMakeDefault');
late final _CCameraAnimatedMoveReasonMakeDefault = _CCameraAnimatedMoveReasonMakeDefaultPtr.asFunction<_CCameraAnimatedMoveReason Function()>();

late final _CCameraAnimatedMoveResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraAnimatedMoveResult Function()>>('CCameraAnimatedMoveResultMakeDefault');
late final _CCameraAnimatedMoveResultMakeDefault = _CCameraAnimatedMoveResultMakeDefaultPtr.asFunction<_CCameraAnimatedMoveResult Function()>();

late final _CCameraAnimationTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraAnimationType Function()>>('CCameraAnimationTypeMakeDefault');
late final _CCameraAnimationTypeMakeDefault = _CCameraAnimationTypeMakeDefaultPtr.asFunction<_CCameraAnimationType Function()>();

late final _CCameraBehaviourChangeReasonMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraBehaviourChangeReason Function()>>('CCameraBehaviourChangeReasonMakeDefault');
late final _CCameraBehaviourChangeReasonMakeDefault = _CCameraBehaviourChangeReasonMakeDefaultPtr.asFunction<_CCameraBehaviourChangeReason Function()>();

late final _CCameraPositionPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraPositionPoint Function()>>('CCameraPositionPointMakeDefault');
late final _CCameraPositionPointMakeDefault = _CCameraPositionPointMakeDefaultPtr.asFunction<_CCameraPositionPoint Function()>();


late final _CCameraStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraState Function()>>('CCameraStateMakeDefault');
late final _CCameraStateMakeDefault = _CCameraStateMakeDefaultPtr.asFunction<_CCameraState Function()>();

late final _CCameraViewPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraViewPoint Function()>>('CCameraViewPointMakeDefault');
late final _CCameraViewPointMakeDefault = _CCameraViewPointMakeDefaultPtr.asFunction<_CCameraViewPoint Function()>();


late final _CColorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CColor Function()>>('CColorMakeDefault');
late final _CColorMakeDefault = _CColorMakeDefaultPtr.asFunction<_CColor Function()>();


late final _CDeviceDensityMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDeviceDensity Function()>>('CDeviceDensityMakeDefault');
late final _CDeviceDensityMakeDefault = _CDeviceDensityMakeDefaultPtr.asFunction<_CDeviceDensity Function()>();


late final _CDevicePpiMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDevicePpi Function()>>('CDevicePpiMakeDefault');
late final _CDevicePpiMakeDefault = _CDevicePpiMakeDefaultPtr.asFunction<_CDevicePpi Function()>();


late final _CGraphicsPresetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGraphicsPreset Function()>>('CGraphicsPresetMakeDefault');
late final _CGraphicsPresetMakeDefault = _CGraphicsPresetMakeDefaultPtr.asFunction<_CGraphicsPreset Function()>();

late final _CZIndexMakeDefaultPtr = _lookup<ffi.NativeFunction<_CZIndex Function()>>('CZIndexMakeDefault');
late final _CZIndexMakeDefault = _CZIndexMakeDefaultPtr.asFunction<_CZIndex Function()>();


late final _CZoomMakeDefaultPtr = _lookup<ffi.NativeFunction<_CZoom Function()>>('CZoomMakeDefault');
late final _CZoomMakeDefault = _CZoomMakeDefaultPtr.asFunction<_CZoom Function()>();


late final _CTiltMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTilt Function()>>('CTiltMakeDefault');
late final _CTiltMakeDefault = _CTiltMakeDefaultPtr.asFunction<_CTilt Function()>();


late final _CCameraPositionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraPosition Function()>>('CCameraPositionMakeDefault');
late final _CCameraPositionMakeDefault = _CCameraPositionMakeDefaultPtr.asFunction<_CCameraPosition Function()>();


late final _CCameraMoveControllerCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCameraMoveControllerCpp_cg_objectIdentifier');
late final _CCameraMoveControllerCpp_cg_objectIdentifier = _CCameraMoveControllerCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCameraMoveControllerCpp_position_CTimeIntervalPtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CCameraMoveControllerCpp, _CTimeInterval)>>('CCameraMoveControllerCpp_position_CTimeInterval');
late final _CCameraMoveControllerCpp_position_CTimeInterval = _CCameraMoveControllerCpp_position_CTimeIntervalPtr.asFunction<_CCameraPosition Function(_CCameraMoveControllerCpp, _CTimeInterval)>();
late final _CCameraMoveControllerCpp_animationTimePtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CCameraMoveControllerCpp)>>('CCameraMoveControllerCpp_animationTime');
late final _CCameraMoveControllerCpp_animationTime = _CCameraMoveControllerCpp_animationTimePtr.asFunction<_CTimeInterval Function(_CCameraMoveControllerCpp)>();

late final _CCameraMoveControllerCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCameraMoveControllerCpp_release');
late final _CCameraMoveControllerCpp_release = _CCameraMoveControllerCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCameraMoveControllerCpp_retainPtr = _lookup<ffi.NativeFunction<_CCameraMoveControllerCpp Function(ffi.Pointer<ffi.Void>)>>('CCameraMoveControllerCpp_retain');
late final _CCameraMoveControllerCpp_retain = _CCameraMoveControllerCpp_retainPtr.asFunction<_CCameraMoveControllerCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CCameraMoveControllerCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraMoveControllerCpp Function()>>('CCameraMoveControllerCppMakeDefault');
late final _CCameraMoveControllerCppMakeDefault = _CCameraMoveControllerCppMakeDefaultPtr.asFunction<_CCameraMoveControllerCpp Function()>();


late final _CCameraMoveControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraMoveController Function()>>('CCameraMoveControllerMakeDefault');
late final _CCameraMoveControllerMakeDefault = _CCameraMoveControllerMakeDefaultPtr.asFunction<_CCameraMoveController Function()>();
late final _CCameraMoveController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCameraMoveController)>>('CCameraMoveController_release');
late final _CCameraMoveController_release = _CCameraMoveController_releasePtr.asFunction<void Function(_CCameraMoveController)>();

late final _CNewValuesNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CNewValuesNotifier_cg_objectIdentifier');
late final _CNewValuesNotifier_cg_objectIdentifier = _CNewValuesNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CNewValuesNotifier_sendNotificationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CNewValuesNotifier)>>('CNewValuesNotifier_sendNotification');
late final _CNewValuesNotifier_sendNotification = _CNewValuesNotifier_sendNotificationPtr.asFunction<void Function(_CNewValuesNotifier)>();

late final _CNewValuesNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CNewValuesNotifier_release');
late final _CNewValuesNotifier_release = _CNewValuesNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CNewValuesNotifier_retainPtr = _lookup<ffi.NativeFunction<_CNewValuesNotifier Function(ffi.Pointer<ffi.Void>)>>('CNewValuesNotifier_retain');
late final _CNewValuesNotifier_retain = _CNewValuesNotifier_retainPtr.asFunction<_CNewValuesNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CNewValuesNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CNewValuesNotifier Function()>>('CNewValuesNotifierMakeDefault');
late final _CNewValuesNotifierMakeDefault = _CNewValuesNotifierMakeDefaultPtr.asFunction<_CNewValuesNotifier Function()>();


late final _CFollowValueMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFollowValue Function()>>('CFollowValueMakeDefault');
late final _CFollowValueMakeDefault = _CFollowValueMakeDefaultPtr.asFunction<_CFollowValue Function()>();

late final _CStyleZoomMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyleZoom Function()>>('CStyleZoomMakeDefault');
late final _CStyleZoomMakeDefault = _CStyleZoomMakeDefaultPtr.asFunction<_CStyleZoom Function()>();


late final _CCustomFollowControllerCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCustomFollowControllerCpp_cg_objectIdentifier');
late final _CCustomFollowControllerCpp_cg_objectIdentifier = _CCustomFollowControllerCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCustomFollowControllerCpp_availableValuesPtr = _lookup<ffi.NativeFunction<_COptionSet_CFollowValue Function(_CCustomFollowControllerCpp)>>('CCustomFollowControllerCpp_availableValues');
late final _CCustomFollowControllerCpp_availableValues = _CCustomFollowControllerCpp_availableValuesPtr.asFunction<_COptionSet_CFollowValue Function(_CCustomFollowControllerCpp)>();
late final _CCustomFollowControllerCpp_requestValues_COptionSet_CFollowValuePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCustomFollowControllerCpp, _COptionSet_CFollowValue)>>('CCustomFollowControllerCpp_requestValues_COptionSet_CFollowValue');
late final _CCustomFollowControllerCpp_requestValues_COptionSet_CFollowValue = _CCustomFollowControllerCpp_requestValues_COptionSet_CFollowValuePtr.asFunction<void Function(_CCustomFollowControllerCpp, _COptionSet_CFollowValue)>();
late final _CCustomFollowControllerCpp_setNewValuesNotifier_COptional_CNewValuesNotifierPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCustomFollowControllerCpp, _COptional_CNewValuesNotifier)>>('CCustomFollowControllerCpp_setNewValuesNotifier_COptional_CNewValuesNotifier');
late final _CCustomFollowControllerCpp_setNewValuesNotifier_COptional_CNewValuesNotifier = _CCustomFollowControllerCpp_setNewValuesNotifier_COptional_CNewValuesNotifierPtr.asFunction<void Function(_CCustomFollowControllerCpp, _COptional_CNewValuesNotifier)>();
late final _CCustomFollowControllerCpp_coordinatesPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPoint Function(_CCustomFollowControllerCpp)>>('CCustomFollowControllerCpp_coordinates');
late final _CCustomFollowControllerCpp_coordinates = _CCustomFollowControllerCpp_coordinatesPtr.asFunction<_COptional_CGeoPoint Function(_CCustomFollowControllerCpp)>();
late final _CCustomFollowControllerCpp_bearingPtr = _lookup<ffi.NativeFunction<_COptional_CBearing Function(_CCustomFollowControllerCpp)>>('CCustomFollowControllerCpp_bearing');
late final _CCustomFollowControllerCpp_bearing = _CCustomFollowControllerCpp_bearingPtr.asFunction<_COptional_CBearing Function(_CCustomFollowControllerCpp)>();
late final _CCustomFollowControllerCpp_tiltPtr = _lookup<ffi.NativeFunction<_COptional_CTilt Function(_CCustomFollowControllerCpp)>>('CCustomFollowControllerCpp_tilt');
late final _CCustomFollowControllerCpp_tilt = _CCustomFollowControllerCpp_tiltPtr.asFunction<_COptional_CTilt Function(_CCustomFollowControllerCpp)>();
late final _CCustomFollowControllerCpp_styleZoomPtr = _lookup<ffi.NativeFunction<_COptional_CStyleZoom Function(_CCustomFollowControllerCpp)>>('CCustomFollowControllerCpp_styleZoom');
late final _CCustomFollowControllerCpp_styleZoom = _CCustomFollowControllerCpp_styleZoomPtr.asFunction<_COptional_CStyleZoom Function(_CCustomFollowControllerCpp)>();

late final _CCustomFollowControllerCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCustomFollowControllerCpp_release');
late final _CCustomFollowControllerCpp_release = _CCustomFollowControllerCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCustomFollowControllerCpp_retainPtr = _lookup<ffi.NativeFunction<_CCustomFollowControllerCpp Function(ffi.Pointer<ffi.Void>)>>('CCustomFollowControllerCpp_retain');
late final _CCustomFollowControllerCpp_retain = _CCustomFollowControllerCpp_retainPtr.asFunction<_CCustomFollowControllerCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CCustomFollowControllerCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCustomFollowControllerCpp Function()>>('CCustomFollowControllerCppMakeDefault');
late final _CCustomFollowControllerCppMakeDefault = _CCustomFollowControllerCppMakeDefaultPtr.asFunction<_CCustomFollowControllerCpp Function()>();


late final _COptionSet_CFollowValueMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CFollowValue Function()>>('COptionSet_CFollowValueMakeDefault');
late final _COptionSet_CFollowValueMakeDefault = _COptionSet_CFollowValueMakeDefaultPtr.asFunction<_COptionSet_CFollowValue Function()>();

late final _COptional_CNewValuesNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CNewValuesNotifier Function()>>('COptional_CNewValuesNotifierMakeDefault');
late final _COptional_CNewValuesNotifierMakeDefault = _COptional_CNewValuesNotifierMakeDefaultPtr.asFunction<_COptional_CNewValuesNotifier Function()>();

late final _COptional_CNewValuesNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CNewValuesNotifier)>>('COptional_CNewValuesNotifier_release');
late final _COptional_CNewValuesNotifier_release = _COptional_CNewValuesNotifier_releasePtr.asFunction<void Function(_COptional_CNewValuesNotifier)>();

late final _COptional_CGeoPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPoint Function()>>('COptional_CGeoPointMakeDefault');
late final _COptional_CGeoPointMakeDefault = _COptional_CGeoPointMakeDefaultPtr.asFunction<_COptional_CGeoPoint Function()>();

late final _COptional_CTiltMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CTilt Function()>>('COptional_CTiltMakeDefault');
late final _COptional_CTiltMakeDefault = _COptional_CTiltMakeDefaultPtr.asFunction<_COptional_CTilt Function()>();

late final _COptional_CStyleZoomMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CStyleZoom Function()>>('COptional_CStyleZoomMakeDefault');
late final _COptional_CStyleZoomMakeDefault = _COptional_CStyleZoomMakeDefaultPtr.asFunction<_COptional_CStyleZoom Function()>();

late final _CCustomFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCustomFollowController Function()>>('CCustomFollowControllerMakeDefault');
late final _CCustomFollowControllerMakeDefault = _CCustomFollowControllerMakeDefaultPtr.asFunction<_CCustomFollowController Function()>();
late final _CCustomFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCustomFollowController)>>('CCustomFollowController_release');
late final _CCustomFollowController_release = _CCustomFollowController_releasePtr.asFunction<void Function(_CCustomFollowController)>();

late final _CEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CEvent_cg_objectIdentifier');
late final _CEvent_cg_objectIdentifier = _CEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CEvent_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CEvent)>>('CEvent_cg_getSelector');
late final _CEvent_cg_getSelector = _CEvent_cg_getSelectorPtr.asFunction<int Function(_CEvent)>();

late final _CEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CEvent_release');
late final _CEvent_release = _CEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CEvent_retainPtr = _lookup<ffi.NativeFunction<_CEvent Function(ffi.Pointer<ffi.Void>)>>('CEvent_retain');
late final _CEvent_retain = _CEvent_retainPtr.asFunction<_CEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CEvent Function()>>('CEventMakeDefault');
late final _CEventMakeDefault = _CEventMakeDefaultPtr.asFunction<_CEvent Function()>();

late final _CInputEvent_timestampPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CInputEvent)>>('CInputEvent_timestamp');
late final _CInputEvent_timestamp = _CInputEvent_timestampPtr.asFunction<_CTimeInterval Function(_CInputEvent)>();

late final _CInputEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CInputEvent_cg_objectIdentifier');
late final _CInputEvent_cg_objectIdentifier = _CInputEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CInputEvent_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CInputEvent)>>('CInputEvent_cg_getSelector');
late final _CInputEvent_cg_getSelector = _CInputEvent_cg_getSelectorPtr.asFunction<int Function(_CInputEvent)>();

late final _CInputEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CInputEvent_release');
late final _CInputEvent_release = _CInputEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CInputEvent_retainPtr = _lookup<ffi.NativeFunction<_CInputEvent Function(ffi.Pointer<ffi.Void>)>>('CInputEvent_retain');
late final _CInputEvent_retain = _CInputEvent_retainPtr.asFunction<_CInputEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CInputEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CInputEvent Function()>>('CInputEventMakeDefault');
late final _CInputEventMakeDefault = _CInputEventMakeDefaultPtr.asFunction<_CInputEvent Function()>();


late final _CCancelEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCancelEvent_cg_objectIdentifier');
late final _CCancelEvent_cg_objectIdentifier = _CCancelEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCancelEvent_C_createPtr = _lookup<ffi.NativeFunction<_CCancelEvent Function()>>('CCancelEvent_C_create');
late final _CCancelEvent_C_create = _CCancelEvent_C_createPtr.asFunction<_CCancelEvent Function()>();

late final _CCancelEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCancelEvent_release');
late final _CCancelEvent_release = _CCancelEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCancelEvent_retainPtr = _lookup<ffi.NativeFunction<_CCancelEvent Function(ffi.Pointer<ffi.Void>)>>('CCancelEvent_retain');
late final _CCancelEvent_retain = _CCancelEvent_retainPtr.asFunction<_CCancelEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CCancelEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCancelEvent Function()>>('CCancelEventMakeDefault');
late final _CCancelEventMakeDefault = _CCancelEventMakeDefaultPtr.asFunction<_CCancelEvent Function()>();


late final _CDgisSourceWorkingModeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDgisSourceWorkingMode Function()>>('CDgisSourceWorkingModeMakeDefault');
late final _CDgisSourceWorkingModeMakeDefault = _CDgisSourceWorkingModeMakeDefaultPtr.asFunction<_CDgisSourceWorkingMode Function()>();

late final _CDirectMapControlBeginEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectMapControlBeginEvent_cg_objectIdentifier');
late final _CDirectMapControlBeginEvent_cg_objectIdentifier = _CDirectMapControlBeginEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectMapControlBeginEvent_C_createPtr = _lookup<ffi.NativeFunction<_CDirectMapControlBeginEvent Function()>>('CDirectMapControlBeginEvent_C_create');
late final _CDirectMapControlBeginEvent_C_create = _CDirectMapControlBeginEvent_C_createPtr.asFunction<_CDirectMapControlBeginEvent Function()>();

late final _CDirectMapControlBeginEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectMapControlBeginEvent_release');
late final _CDirectMapControlBeginEvent_release = _CDirectMapControlBeginEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapControlBeginEvent_retainPtr = _lookup<ffi.NativeFunction<_CDirectMapControlBeginEvent Function(ffi.Pointer<ffi.Void>)>>('CDirectMapControlBeginEvent_retain');
late final _CDirectMapControlBeginEvent_retain = _CDirectMapControlBeginEvent_retainPtr.asFunction<_CDirectMapControlBeginEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapControlBeginEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectMapControlBeginEvent Function()>>('CDirectMapControlBeginEventMakeDefault');
late final _CDirectMapControlBeginEventMakeDefault = _CDirectMapControlBeginEventMakeDefaultPtr.asFunction<_CDirectMapControlBeginEvent Function()>();


late final _CDirectMapControlEndEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectMapControlEndEvent_cg_objectIdentifier');
late final _CDirectMapControlEndEvent_cg_objectIdentifier = _CDirectMapControlEndEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectMapControlEndEvent_C_createWith_CTimeIntervalPtr = _lookup<ffi.NativeFunction<_CDirectMapControlEndEvent Function(_CTimeInterval)>>('CDirectMapControlEndEvent_C_createWith_CTimeInterval');
late final _CDirectMapControlEndEvent_C_createWith_CTimeInterval = _CDirectMapControlEndEvent_C_createWith_CTimeIntervalPtr.asFunction<_CDirectMapControlEndEvent Function(_CTimeInterval)>();

late final _CDirectMapControlEndEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectMapControlEndEvent_release');
late final _CDirectMapControlEndEvent_release = _CDirectMapControlEndEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapControlEndEvent_retainPtr = _lookup<ffi.NativeFunction<_CDirectMapControlEndEvent Function(ffi.Pointer<ffi.Void>)>>('CDirectMapControlEndEvent_retain');
late final _CDirectMapControlEndEvent_retain = _CDirectMapControlEndEvent_retainPtr.asFunction<_CDirectMapControlEndEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapControlEndEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectMapControlEndEvent Function()>>('CDirectMapControlEndEventMakeDefault');
late final _CDirectMapControlEndEventMakeDefault = _CDirectMapControlEndEventMakeDefaultPtr.asFunction<_CDirectMapControlEndEvent Function()>();


late final _CScreenPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScreenPoint Function()>>('CScreenPointMakeDefault');
late final _CScreenPointMakeDefault = _CScreenPointMakeDefaultPtr.asFunction<_CScreenPoint Function()>();

late final _CDirectMapRotationEvent_bearingDeltaPtr = _lookup<ffi.NativeFunction<_CBearing Function(_CDirectMapRotationEvent)>>('CDirectMapRotationEvent_bearingDelta');
late final _CDirectMapRotationEvent_bearingDelta = _CDirectMapRotationEvent_bearingDeltaPtr.asFunction<_CBearing Function(_CDirectMapRotationEvent)>();
late final _CDirectMapRotationEvent_rotationCenterPtr = _lookup<ffi.NativeFunction<_COptional_CScreenPoint Function(_CDirectMapRotationEvent)>>('CDirectMapRotationEvent_rotationCenter');
late final _CDirectMapRotationEvent_rotationCenter = _CDirectMapRotationEvent_rotationCenterPtr.asFunction<_COptional_CScreenPoint Function(_CDirectMapRotationEvent)>();

late final _CDirectMapRotationEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectMapRotationEvent_cg_objectIdentifier');
late final _CDirectMapRotationEvent_cg_objectIdentifier = _CDirectMapRotationEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectMapRotationEvent_C_createWith_CBearing_CTimeInterval_COptional_CScreenPointPtr = _lookup<ffi.NativeFunction<_CDirectMapRotationEvent Function(_CBearing, _CTimeInterval, _COptional_CScreenPoint)>>('CDirectMapRotationEvent_C_createWith_CBearing_CTimeInterval_COptional_CScreenPoint');
late final _CDirectMapRotationEvent_C_createWith_CBearing_CTimeInterval_COptional_CScreenPoint = _CDirectMapRotationEvent_C_createWith_CBearing_CTimeInterval_COptional_CScreenPointPtr.asFunction<_CDirectMapRotationEvent Function(_CBearing, _CTimeInterval, _COptional_CScreenPoint)>();

late final _CDirectMapRotationEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectMapRotationEvent_release');
late final _CDirectMapRotationEvent_release = _CDirectMapRotationEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapRotationEvent_retainPtr = _lookup<ffi.NativeFunction<_CDirectMapRotationEvent Function(ffi.Pointer<ffi.Void>)>>('CDirectMapRotationEvent_retain');
late final _CDirectMapRotationEvent_retain = _CDirectMapRotationEvent_retainPtr.asFunction<_CDirectMapRotationEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapRotationEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectMapRotationEvent Function()>>('CDirectMapRotationEventMakeDefault');
late final _CDirectMapRotationEventMakeDefault = _CDirectMapRotationEventMakeDefaultPtr.asFunction<_CDirectMapRotationEvent Function()>();


late final _COptional_CScreenPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CScreenPoint Function()>>('COptional_CScreenPointMakeDefault');
late final _COptional_CScreenPointMakeDefault = _COptional_CScreenPointMakeDefaultPtr.asFunction<_COptional_CScreenPoint Function()>();
late final _CDirectMapScalingEvent_zoomDeltaPtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CDirectMapScalingEvent)>>('CDirectMapScalingEvent_zoomDelta');
late final _CDirectMapScalingEvent_zoomDelta = _CDirectMapScalingEvent_zoomDeltaPtr.asFunction<double Function(_CDirectMapScalingEvent)>();
late final _CDirectMapScalingEvent_scalingCenterPtr = _lookup<ffi.NativeFunction<_COptional_CScreenPoint Function(_CDirectMapScalingEvent)>>('CDirectMapScalingEvent_scalingCenter');
late final _CDirectMapScalingEvent_scalingCenter = _CDirectMapScalingEvent_scalingCenterPtr.asFunction<_COptional_CScreenPoint Function(_CDirectMapScalingEvent)>();

late final _CDirectMapScalingEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectMapScalingEvent_cg_objectIdentifier');
late final _CDirectMapScalingEvent_cg_objectIdentifier = _CDirectMapScalingEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectMapScalingEvent_C_createWith_float_CTimeInterval_COptional_CScreenPointPtr = _lookup<ffi.NativeFunction<_CDirectMapScalingEvent Function(ffi.Float, _CTimeInterval, _COptional_CScreenPoint)>>('CDirectMapScalingEvent_C_createWith_float_CTimeInterval_COptional_CScreenPoint');
late final _CDirectMapScalingEvent_C_createWith_float_CTimeInterval_COptional_CScreenPoint = _CDirectMapScalingEvent_C_createWith_float_CTimeInterval_COptional_CScreenPointPtr.asFunction<_CDirectMapScalingEvent Function(double, _CTimeInterval, _COptional_CScreenPoint)>();

late final _CDirectMapScalingEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectMapScalingEvent_release');
late final _CDirectMapScalingEvent_release = _CDirectMapScalingEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapScalingEvent_retainPtr = _lookup<ffi.NativeFunction<_CDirectMapScalingEvent Function(ffi.Pointer<ffi.Void>)>>('CDirectMapScalingEvent_retain');
late final _CDirectMapScalingEvent_retain = _CDirectMapScalingEvent_retainPtr.asFunction<_CDirectMapScalingEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapScalingEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectMapScalingEvent Function()>>('CDirectMapScalingEventMakeDefault');
late final _CDirectMapScalingEventMakeDefault = _CDirectMapScalingEventMakeDefaultPtr.asFunction<_CDirectMapScalingEvent Function()>();


late final _CScreenShiftMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScreenShift Function()>>('CScreenShiftMakeDefault');
late final _CScreenShiftMakeDefault = _CScreenShiftMakeDefaultPtr.asFunction<_CScreenShift Function()>();

late final _CDirectMapShiftEvent_screenShiftPtr = _lookup<ffi.NativeFunction<_CScreenShift Function(_CDirectMapShiftEvent)>>('CDirectMapShiftEvent_screenShift');
late final _CDirectMapShiftEvent_screenShift = _CDirectMapShiftEvent_screenShiftPtr.asFunction<_CScreenShift Function(_CDirectMapShiftEvent)>();
late final _CDirectMapShiftEvent_shiftedPointPtr = _lookup<ffi.NativeFunction<_CScreenPoint Function(_CDirectMapShiftEvent)>>('CDirectMapShiftEvent_shiftedPoint');
late final _CDirectMapShiftEvent_shiftedPoint = _CDirectMapShiftEvent_shiftedPointPtr.asFunction<_CScreenPoint Function(_CDirectMapShiftEvent)>();

late final _CDirectMapShiftEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectMapShiftEvent_cg_objectIdentifier');
late final _CDirectMapShiftEvent_cg_objectIdentifier = _CDirectMapShiftEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectMapShiftEvent_C_createWith_CScreenShift_CScreenPoint_CTimeIntervalPtr = _lookup<ffi.NativeFunction<_CDirectMapShiftEvent Function(_CScreenShift, _CScreenPoint, _CTimeInterval)>>('CDirectMapShiftEvent_C_createWith_CScreenShift_CScreenPoint_CTimeInterval');
late final _CDirectMapShiftEvent_C_createWith_CScreenShift_CScreenPoint_CTimeInterval = _CDirectMapShiftEvent_C_createWith_CScreenShift_CScreenPoint_CTimeIntervalPtr.asFunction<_CDirectMapShiftEvent Function(_CScreenShift, _CScreenPoint, _CTimeInterval)>();

late final _CDirectMapShiftEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectMapShiftEvent_release');
late final _CDirectMapShiftEvent_release = _CDirectMapShiftEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapShiftEvent_retainPtr = _lookup<ffi.NativeFunction<_CDirectMapShiftEvent Function(ffi.Pointer<ffi.Void>)>>('CDirectMapShiftEvent_retain');
late final _CDirectMapShiftEvent_retain = _CDirectMapShiftEvent_retainPtr.asFunction<_CDirectMapShiftEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapShiftEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectMapShiftEvent Function()>>('CDirectMapShiftEventMakeDefault');
late final _CDirectMapShiftEventMakeDefault = _CDirectMapShiftEventMakeDefaultPtr.asFunction<_CDirectMapShiftEvent Function()>();

late final _CDirectMapTiltEvent_deltaPtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CDirectMapTiltEvent)>>('CDirectMapTiltEvent_delta');
late final _CDirectMapTiltEvent_delta = _CDirectMapTiltEvent_deltaPtr.asFunction<double Function(_CDirectMapTiltEvent)>();

late final _CDirectMapTiltEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectMapTiltEvent_cg_objectIdentifier');
late final _CDirectMapTiltEvent_cg_objectIdentifier = _CDirectMapTiltEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectMapTiltEvent_C_createWith_float_CTimeIntervalPtr = _lookup<ffi.NativeFunction<_CDirectMapTiltEvent Function(ffi.Float, _CTimeInterval)>>('CDirectMapTiltEvent_C_createWith_float_CTimeInterval');
late final _CDirectMapTiltEvent_C_createWith_float_CTimeInterval = _CDirectMapTiltEvent_C_createWith_float_CTimeIntervalPtr.asFunction<_CDirectMapTiltEvent Function(double, _CTimeInterval)>();

late final _CDirectMapTiltEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectMapTiltEvent_release');
late final _CDirectMapTiltEvent_release = _CDirectMapTiltEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapTiltEvent_retainPtr = _lookup<ffi.NativeFunction<_CDirectMapTiltEvent Function(ffi.Pointer<ffi.Void>)>>('CDirectMapTiltEvent_retain');
late final _CDirectMapTiltEvent_retain = _CDirectMapTiltEvent_retainPtr.asFunction<_CDirectMapTiltEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapTiltEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectMapTiltEvent Function()>>('CDirectMapTiltEventMakeDefault');
late final _CDirectMapTiltEventMakeDefault = _CDirectMapTiltEventMakeDefaultPtr.asFunction<_CDirectMapTiltEvent Function()>();


late final _CMapRotationDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapRotationDirection Function()>>('CMapRotationDirectionMakeDefault');
late final _CMapRotationDirectionMakeDefault = _CMapRotationDirectionMakeDefaultPtr.asFunction<_CMapRotationDirection Function()>();
late final _CMapRotationBeginEvent_directionPtr = _lookup<ffi.NativeFunction<_CMapRotationDirection Function(_CMapRotationBeginEvent)>>('CMapRotationBeginEvent_direction');
late final _CMapRotationBeginEvent_direction = _CMapRotationBeginEvent_directionPtr.asFunction<_CMapRotationDirection Function(_CMapRotationBeginEvent)>();

late final _CMapRotationBeginEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapRotationBeginEvent_cg_objectIdentifier');
late final _CMapRotationBeginEvent_cg_objectIdentifier = _CMapRotationBeginEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapRotationBeginEvent_C_createWith_CMapRotationDirectionPtr = _lookup<ffi.NativeFunction<_CMapRotationBeginEvent Function(_CMapRotationDirection)>>('CMapRotationBeginEvent_C_createWith_CMapRotationDirection');
late final _CMapRotationBeginEvent_C_createWith_CMapRotationDirection = _CMapRotationBeginEvent_C_createWith_CMapRotationDirectionPtr.asFunction<_CMapRotationBeginEvent Function(_CMapRotationDirection)>();

late final _CMapRotationBeginEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapRotationBeginEvent_release');
late final _CMapRotationBeginEvent_release = _CMapRotationBeginEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapRotationBeginEvent_retainPtr = _lookup<ffi.NativeFunction<_CMapRotationBeginEvent Function(ffi.Pointer<ffi.Void>)>>('CMapRotationBeginEvent_retain');
late final _CMapRotationBeginEvent_retain = _CMapRotationBeginEvent_retainPtr.asFunction<_CMapRotationBeginEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CMapRotationBeginEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapRotationBeginEvent Function()>>('CMapRotationBeginEventMakeDefault');
late final _CMapRotationBeginEventMakeDefault = _CMapRotationBeginEventMakeDefaultPtr.asFunction<_CMapRotationBeginEvent Function()>();


late final _CMapRotationEndEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapRotationEndEvent_cg_objectIdentifier');
late final _CMapRotationEndEvent_cg_objectIdentifier = _CMapRotationEndEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapRotationEndEvent_C_createPtr = _lookup<ffi.NativeFunction<_CMapRotationEndEvent Function()>>('CMapRotationEndEvent_C_create');
late final _CMapRotationEndEvent_C_create = _CMapRotationEndEvent_C_createPtr.asFunction<_CMapRotationEndEvent Function()>();

late final _CMapRotationEndEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapRotationEndEvent_release');
late final _CMapRotationEndEvent_release = _CMapRotationEndEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapRotationEndEvent_retainPtr = _lookup<ffi.NativeFunction<_CMapRotationEndEvent Function(ffi.Pointer<ffi.Void>)>>('CMapRotationEndEvent_retain');
late final _CMapRotationEndEvent_retain = _CMapRotationEndEvent_retainPtr.asFunction<_CMapRotationEndEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CMapRotationEndEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapRotationEndEvent Function()>>('CMapRotationEndEventMakeDefault');
late final _CMapRotationEndEventMakeDefault = _CMapRotationEndEventMakeDefaultPtr.asFunction<_CMapRotationEndEvent Function()>();


late final _CMapScalingDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapScalingDirection Function()>>('CMapScalingDirectionMakeDefault');
late final _CMapScalingDirectionMakeDefault = _CMapScalingDirectionMakeDefaultPtr.asFunction<_CMapScalingDirection Function()>();
late final _CMapScalingBeginEvent_directionPtr = _lookup<ffi.NativeFunction<_CMapScalingDirection Function(_CMapScalingBeginEvent)>>('CMapScalingBeginEvent_direction');
late final _CMapScalingBeginEvent_direction = _CMapScalingBeginEvent_directionPtr.asFunction<_CMapScalingDirection Function(_CMapScalingBeginEvent)>();

late final _CMapScalingBeginEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapScalingBeginEvent_cg_objectIdentifier');
late final _CMapScalingBeginEvent_cg_objectIdentifier = _CMapScalingBeginEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapScalingBeginEvent_C_createWith_CMapScalingDirectionPtr = _lookup<ffi.NativeFunction<_CMapScalingBeginEvent Function(_CMapScalingDirection)>>('CMapScalingBeginEvent_C_createWith_CMapScalingDirection');
late final _CMapScalingBeginEvent_C_createWith_CMapScalingDirection = _CMapScalingBeginEvent_C_createWith_CMapScalingDirectionPtr.asFunction<_CMapScalingBeginEvent Function(_CMapScalingDirection)>();

late final _CMapScalingBeginEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapScalingBeginEvent_release');
late final _CMapScalingBeginEvent_release = _CMapScalingBeginEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapScalingBeginEvent_retainPtr = _lookup<ffi.NativeFunction<_CMapScalingBeginEvent Function(ffi.Pointer<ffi.Void>)>>('CMapScalingBeginEvent_retain');
late final _CMapScalingBeginEvent_retain = _CMapScalingBeginEvent_retainPtr.asFunction<_CMapScalingBeginEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CMapScalingBeginEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapScalingBeginEvent Function()>>('CMapScalingBeginEventMakeDefault');
late final _CMapScalingBeginEventMakeDefault = _CMapScalingBeginEventMakeDefaultPtr.asFunction<_CMapScalingBeginEvent Function()>();


late final _CMapScalingEndEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapScalingEndEvent_cg_objectIdentifier');
late final _CMapScalingEndEvent_cg_objectIdentifier = _CMapScalingEndEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapScalingEndEvent_C_createPtr = _lookup<ffi.NativeFunction<_CMapScalingEndEvent Function()>>('CMapScalingEndEvent_C_create');
late final _CMapScalingEndEvent_C_create = _CMapScalingEndEvent_C_createPtr.asFunction<_CMapScalingEndEvent Function()>();

late final _CMapScalingEndEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapScalingEndEvent_release');
late final _CMapScalingEndEvent_release = _CMapScalingEndEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapScalingEndEvent_retainPtr = _lookup<ffi.NativeFunction<_CMapScalingEndEvent Function(ffi.Pointer<ffi.Void>)>>('CMapScalingEndEvent_retain');
late final _CMapScalingEndEvent_retain = _CMapScalingEndEvent_retainPtr.asFunction<_CMapScalingEndEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CMapScalingEndEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapScalingEndEvent Function()>>('CMapScalingEndEventMakeDefault');
late final _CMapScalingEndEventMakeDefault = _CMapScalingEndEventMakeDefaultPtr.asFunction<_CMapScalingEndEvent Function()>();


late final _CMapShiftDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapShiftDirection Function()>>('CMapShiftDirectionMakeDefault');
late final _CMapShiftDirectionMakeDefault = _CMapShiftDirectionMakeDefaultPtr.asFunction<_CMapShiftDirection Function()>();
late final _CMapShiftBeginEvent_directionPtr = _lookup<ffi.NativeFunction<_CMapShiftDirection Function(_CMapShiftBeginEvent)>>('CMapShiftBeginEvent_direction');
late final _CMapShiftBeginEvent_direction = _CMapShiftBeginEvent_directionPtr.asFunction<_CMapShiftDirection Function(_CMapShiftBeginEvent)>();

late final _CMapShiftBeginEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapShiftBeginEvent_cg_objectIdentifier');
late final _CMapShiftBeginEvent_cg_objectIdentifier = _CMapShiftBeginEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapShiftBeginEvent_C_createWith_CMapShiftDirectionPtr = _lookup<ffi.NativeFunction<_CMapShiftBeginEvent Function(_CMapShiftDirection)>>('CMapShiftBeginEvent_C_createWith_CMapShiftDirection');
late final _CMapShiftBeginEvent_C_createWith_CMapShiftDirection = _CMapShiftBeginEvent_C_createWith_CMapShiftDirectionPtr.asFunction<_CMapShiftBeginEvent Function(_CMapShiftDirection)>();

late final _CMapShiftBeginEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapShiftBeginEvent_release');
late final _CMapShiftBeginEvent_release = _CMapShiftBeginEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapShiftBeginEvent_retainPtr = _lookup<ffi.NativeFunction<_CMapShiftBeginEvent Function(ffi.Pointer<ffi.Void>)>>('CMapShiftBeginEvent_retain');
late final _CMapShiftBeginEvent_retain = _CMapShiftBeginEvent_retainPtr.asFunction<_CMapShiftBeginEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CMapShiftBeginEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapShiftBeginEvent Function()>>('CMapShiftBeginEventMakeDefault');
late final _CMapShiftBeginEventMakeDefault = _CMapShiftBeginEventMakeDefaultPtr.asFunction<_CMapShiftBeginEvent Function()>();


late final _CMapShiftEndEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapShiftEndEvent_cg_objectIdentifier');
late final _CMapShiftEndEvent_cg_objectIdentifier = _CMapShiftEndEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapShiftEndEvent_C_createPtr = _lookup<ffi.NativeFunction<_CMapShiftEndEvent Function()>>('CMapShiftEndEvent_C_create');
late final _CMapShiftEndEvent_C_create = _CMapShiftEndEvent_C_createPtr.asFunction<_CMapShiftEndEvent Function()>();

late final _CMapShiftEndEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapShiftEndEvent_release');
late final _CMapShiftEndEvent_release = _CMapShiftEndEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapShiftEndEvent_retainPtr = _lookup<ffi.NativeFunction<_CMapShiftEndEvent Function(ffi.Pointer<ffi.Void>)>>('CMapShiftEndEvent_retain');
late final _CMapShiftEndEvent_retain = _CMapShiftEndEvent_retainPtr.asFunction<_CMapShiftEndEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CMapShiftEndEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapShiftEndEvent Function()>>('CMapShiftEndEventMakeDefault');
late final _CMapShiftEndEventMakeDefault = _CMapShiftEndEventMakeDefaultPtr.asFunction<_CMapShiftEndEvent Function()>();


late final _CRotateMapToNorthEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRotateMapToNorthEvent_cg_objectIdentifier');
late final _CRotateMapToNorthEvent_cg_objectIdentifier = _CRotateMapToNorthEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRotateMapToNorthEvent_C_createPtr = _lookup<ffi.NativeFunction<_CRotateMapToNorthEvent Function()>>('CRotateMapToNorthEvent_C_create');
late final _CRotateMapToNorthEvent_C_create = _CRotateMapToNorthEvent_C_createPtr.asFunction<_CRotateMapToNorthEvent Function()>();

late final _CRotateMapToNorthEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRotateMapToNorthEvent_release');
late final _CRotateMapToNorthEvent_release = _CRotateMapToNorthEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRotateMapToNorthEvent_retainPtr = _lookup<ffi.NativeFunction<_CRotateMapToNorthEvent Function(ffi.Pointer<ffi.Void>)>>('CRotateMapToNorthEvent_retain');
late final _CRotateMapToNorthEvent_retain = _CRotateMapToNorthEvent_retainPtr.asFunction<_CRotateMapToNorthEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CRotateMapToNorthEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRotateMapToNorthEvent Function()>>('CRotateMapToNorthEventMakeDefault');
late final _CRotateMapToNorthEventMakeDefault = _CRotateMapToNorthEventMakeDefaultPtr.asFunction<_CRotateMapToNorthEvent Function()>();

late final _CScaleMapEvent_zoomDeltaPtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CScaleMapEvent)>>('CScaleMapEvent_zoomDelta');
late final _CScaleMapEvent_zoomDelta = _CScaleMapEvent_zoomDeltaPtr.asFunction<double Function(_CScaleMapEvent)>();
late final _CScaleMapEvent_scalingCenterPtr = _lookup<ffi.NativeFunction<_COptional_CScreenPoint Function(_CScaleMapEvent)>>('CScaleMapEvent_scalingCenter');
late final _CScaleMapEvent_scalingCenter = _CScaleMapEvent_scalingCenterPtr.asFunction<_COptional_CScreenPoint Function(_CScaleMapEvent)>();

late final _CScaleMapEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CScaleMapEvent_cg_objectIdentifier');
late final _CScaleMapEvent_cg_objectIdentifier = _CScaleMapEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CScaleMapEvent_C_createWith_float_COptional_CScreenPointPtr = _lookup<ffi.NativeFunction<_CScaleMapEvent Function(ffi.Float, _COptional_CScreenPoint)>>('CScaleMapEvent_C_createWith_float_COptional_CScreenPoint');
late final _CScaleMapEvent_C_createWith_float_COptional_CScreenPoint = _CScaleMapEvent_C_createWith_float_COptional_CScreenPointPtr.asFunction<_CScaleMapEvent Function(double, _COptional_CScreenPoint)>();

late final _CScaleMapEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CScaleMapEvent_release');
late final _CScaleMapEvent_release = _CScaleMapEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CScaleMapEvent_retainPtr = _lookup<ffi.NativeFunction<_CScaleMapEvent Function(ffi.Pointer<ffi.Void>)>>('CScaleMapEvent_retain');
late final _CScaleMapEvent_retain = _CScaleMapEvent_retainPtr.asFunction<_CScaleMapEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CScaleMapEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScaleMapEvent Function()>>('CScaleMapEventMakeDefault');
late final _CScaleMapEventMakeDefault = _CScaleMapEventMakeDefaultPtr.asFunction<_CScaleMapEvent Function()>();


late final _CAnyMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAny Function()>>('CAnyMakeDefault');
late final _CAnyMakeDefault = _CAnyMakeDefaultPtr.asFunction<_CAny Function()>();
late final _CAny_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAny)>>('CAny_release');
late final _CAny_release = _CAny_releasePtr.asFunction<void Function(_CAny)>();

late final _CClusterOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CClusterOptions Function()>>('CClusterOptionsMakeDefault');
late final _CClusterOptionsMakeDefault = _CClusterOptionsMakeDefaultPtr.asFunction<_CClusterOptions Function()>();


late final _CFollowBearingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFollowBearing Function()>>('CFollowBearingMakeDefault');
late final _CFollowBearingMakeDefault = _CFollowBearingMakeDefaultPtr.asFunction<_CFollowBearing Function()>();

late final _CFollowStyleZoomMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFollowStyleZoom Function()>>('CFollowStyleZoomMakeDefault');
late final _CFollowStyleZoomMakeDefault = _CFollowStyleZoomMakeDefaultPtr.asFunction<_CFollowStyleZoom Function()>();

late final _CFollowPositionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFollowPosition Function()>>('CFollowPositionMakeDefault');
late final _CFollowPositionMakeDefault = _CFollowPositionMakeDefaultPtr.asFunction<_CFollowPosition Function()>();


late final _CFollowTiltMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFollowTilt Function()>>('CFollowTiltMakeDefault');
late final _CFollowTiltMakeDefault = _CFollowTiltMakeDefaultPtr.asFunction<_CFollowTilt Function()>();
late final _CAttributes_attributeNamesPtr = _lookup<ffi.NativeFunction<_CArray_CString Function(_CAttributes)>>('CAttributes_attributeNames');
late final _CAttributes_attributeNames = _CAttributes_attributeNamesPtr.asFunction<_CArray_CString Function(_CAttributes)>();
late final _CAttributes_changedPtr = _lookup<ffi.NativeFunction<_CChannel_CArray_CString Function(_CAttributes)>>('CAttributes_changed');
late final _CAttributes_changed = _CAttributes_changedPtr.asFunction<_CChannel_CArray_CString Function(_CAttributes)>();

late final _CAttributes_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CAttributes_cg_objectIdentifier');
late final _CAttributes_cg_objectIdentifier = _CAttributes_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CAttributes_setAttributeValue_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAttributes, _CString, _CAttributeValue)>>('CAttributes_setAttributeValue_CString_CAttributeValue');
late final _CAttributes_setAttributeValue_CString_CAttributeValue = _CAttributes_setAttributeValue_CString_CAttributeValuePtr.asFunction<void Function(_CAttributes, _CString, _CAttributeValue)>();
late final _CAttributes_setAttributeValues_CDictionary_CString_CAttributeValue_CArray_CStringPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAttributes, _CDictionary_CString_CAttributeValue, _CArray_CString)>>('CAttributes_setAttributeValues_CDictionary_CString_CAttributeValue_CArray_CString');
late final _CAttributes_setAttributeValues_CDictionary_CString_CAttributeValue_CArray_CString = _CAttributes_setAttributeValues_CDictionary_CString_CAttributeValue_CArray_CStringPtr.asFunction<void Function(_CAttributes, _CDictionary_CString_CAttributeValue, _CArray_CString)>();
late final _CAttributes_removeAttribute_CStringPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAttributes, _CString)>>('CAttributes_removeAttribute_CString');
late final _CAttributes_removeAttribute_CString = _CAttributes_removeAttribute_CStringPtr.asFunction<void Function(_CAttributes, _CString)>();
late final _CAttributes_getAttributeValue_CStringPtr = _lookup<ffi.NativeFunction<_CAttributeValue Function(_CAttributes, _CString)>>('CAttributes_getAttributeValue_CString');
late final _CAttributes_getAttributeValue_CString = _CAttributes_getAttributeValue_CStringPtr.asFunction<_CAttributeValue Function(_CAttributes, _CString)>();

late final _CAttributes_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CAttributes_release');
late final _CAttributes_release = _CAttributes_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CAttributes_retainPtr = _lookup<ffi.NativeFunction<_CAttributes Function(ffi.Pointer<ffi.Void>)>>('CAttributes_retain');
late final _CAttributes_retain = _CAttributes_retainPtr.asFunction<_CAttributes Function(ffi.Pointer<ffi.Void>)>();
late final _CAttributesMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAttributes Function()>>('CAttributesMakeDefault');
late final _CAttributesMakeDefault = _CAttributesMakeDefaultPtr.asFunction<_CAttributes Function()>();


late final _CChannel_CArray_CStringMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChannel_CArray_CString Function()>>('CChannel_CArray_CStringMakeDefault');
late final _CChannel_CArray_CStringMakeDefault = _CChannel_CArray_CStringMakeDefaultPtr.asFunction<_CChannel_CArray_CString Function()>();
late final _CChannel_CArray_CString_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CChannel_CArray_CString)>>('CChannel_CArray_CString_release');
late final _CChannel_CArray_CString_release = _CChannel_CArray_CString_releasePtr.asFunction<void Function(_CChannel_CArray_CString)>();
late final _CChannel_CArray_CString_retainPtr = _lookup<ffi.NativeFunction<_CChannel_CArray_CString Function(_CChannel_CArray_CString)>>('CChannel_CArray_CString_retain');
late final _CChannel_CArray_CString_retain = _CChannel_CArray_CString_retainPtr.asFunction<_CChannel_CArray_CString Function(_CChannel_CArray_CString)>();
late final _CChannel_CArray_CStringConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CChannel_CArray_CString,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CString, ffi.Int64)>>
  )
>>('CChannel_CArray_CString_connect');
late final _CChannel_CArray_CStringConnect = _CChannel_CArray_CStringConnectPtr.asFunction<
  _CCancellable Function(
    _CChannel_CArray_CString,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CString, ffi.Int64)>>
  )
>();
late final _CAnimationSettings_animationIndexPtr = _lookup<ffi.NativeFunction<_COptional_int32_t Function(_CAnimationSettings)>>('CAnimationSettings_animationIndex');
late final _CAnimationSettings_animationIndex = _CAnimationSettings_animationIndexPtr.asFunction<_COptional_int32_t Function(_CAnimationSettings)>();
late final _CAnimationSettings_setAnimationIndex_COptional_int32_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAnimationSettings, _COptional_int32_t)>>('CAnimationSettings_setAnimationIndex_COptional_int32_t');
late final _CAnimationSettings_setAnimationIndex_COptional_int32_t = _CAnimationSettings_setAnimationIndex_COptional_int32_tPtr.asFunction<void Function(_CAnimationSettings, _COptional_int32_t)>();
late final _CAnimationSettings_animationNamePtr = _lookup<ffi.NativeFunction<_COptional_CString Function(_CAnimationSettings)>>('CAnimationSettings_animationName');
late final _CAnimationSettings_animationName = _CAnimationSettings_animationNamePtr.asFunction<_COptional_CString Function(_CAnimationSettings)>();
late final _CAnimationSettings_setAnimationName_COptional_CStringPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAnimationSettings, _COptional_CString)>>('CAnimationSettings_setAnimationName_COptional_CString');
late final _CAnimationSettings_setAnimationName_COptional_CString = _CAnimationSettings_setAnimationName_COptional_CStringPtr.asFunction<void Function(_CAnimationSettings, _COptional_CString)>();
late final _CAnimationSettings_sceneIndexPtr = _lookup<ffi.NativeFunction<_COptional_int32_t Function(_CAnimationSettings)>>('CAnimationSettings_sceneIndex');
late final _CAnimationSettings_sceneIndex = _CAnimationSettings_sceneIndexPtr.asFunction<_COptional_int32_t Function(_CAnimationSettings)>();
late final _CAnimationSettings_setSceneIndex_COptional_int32_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAnimationSettings, _COptional_int32_t)>>('CAnimationSettings_setSceneIndex_COptional_int32_t');
late final _CAnimationSettings_setSceneIndex_COptional_int32_t = _CAnimationSettings_setSceneIndex_COptional_int32_tPtr.asFunction<void Function(_CAnimationSettings, _COptional_int32_t)>();
late final _CAnimationSettings_sceneNamePtr = _lookup<ffi.NativeFunction<_COptional_CString Function(_CAnimationSettings)>>('CAnimationSettings_sceneName');
late final _CAnimationSettings_sceneName = _CAnimationSettings_sceneNamePtr.asFunction<_COptional_CString Function(_CAnimationSettings)>();
late final _CAnimationSettings_setSceneName_COptional_CStringPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAnimationSettings, _COptional_CString)>>('CAnimationSettings_setSceneName_COptional_CString');
late final _CAnimationSettings_setSceneName_COptional_CString = _CAnimationSettings_setSceneName_COptional_CStringPtr.asFunction<void Function(_CAnimationSettings, _COptional_CString)>();
late final _CAnimationSettings_animationRepeatCountPtr = _lookup<ffi.NativeFunction<_COptional_int32_t Function(_CAnimationSettings)>>('CAnimationSettings_animationRepeatCount');
late final _CAnimationSettings_animationRepeatCount = _CAnimationSettings_animationRepeatCountPtr.asFunction<_COptional_int32_t Function(_CAnimationSettings)>();
late final _CAnimationSettings_setAnimationRepeatCount_COptional_int32_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAnimationSettings, _COptional_int32_t)>>('CAnimationSettings_setAnimationRepeatCount_COptional_int32_t');
late final _CAnimationSettings_setAnimationRepeatCount_COptional_int32_t = _CAnimationSettings_setAnimationRepeatCount_COptional_int32_tPtr.asFunction<void Function(_CAnimationSettings, _COptional_int32_t)>();
late final _CAnimationSettings_animationSpeedPtr = _lookup<ffi.NativeFunction<_COptional_float Function(_CAnimationSettings)>>('CAnimationSettings_animationSpeed');
late final _CAnimationSettings_animationSpeed = _CAnimationSettings_animationSpeedPtr.asFunction<_COptional_float Function(_CAnimationSettings)>();
late final _CAnimationSettings_setAnimationSpeed_COptional_floatPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAnimationSettings, _COptional_float)>>('CAnimationSettings_setAnimationSpeed_COptional_float');
late final _CAnimationSettings_setAnimationSpeed_COptional_float = _CAnimationSettings_setAnimationSpeed_COptional_floatPtr.asFunction<void Function(_CAnimationSettings, _COptional_float)>();

late final _CAnimationSettings_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CAnimationSettings_cg_objectIdentifier');
late final _CAnimationSettings_cg_objectIdentifier = _CAnimationSettings_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CAnimationSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CAnimationSettings_release');
late final _CAnimationSettings_release = _CAnimationSettings_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CAnimationSettings_retainPtr = _lookup<ffi.NativeFunction<_CAnimationSettings Function(ffi.Pointer<ffi.Void>)>>('CAnimationSettings_retain');
late final _CAnimationSettings_retain = _CAnimationSettings_retainPtr.asFunction<_CAnimationSettings Function(ffi.Pointer<ffi.Void>)>();
late final _CAnimationSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAnimationSettings Function()>>('CAnimationSettingsMakeDefault');
late final _CAnimationSettingsMakeDefault = _CAnimationSettingsMakeDefaultPtr.asFunction<_CAnimationSettings Function()>();


late final _COptional_int32_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_int32_t Function()>>('COptional_int32_tMakeDefault');
late final _COptional_int32_tMakeDefault = _COptional_int32_tMakeDefaultPtr.asFunction<_COptional_int32_t Function()>();

late final _COptional_floatMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_float Function()>>('COptional_floatMakeDefault');
late final _COptional_floatMakeDefault = _COptional_floatMakeDefaultPtr.asFunction<_COptional_float Function()>();
late final _CMapObject_userDataPtr = _lookup<ffi.NativeFunction<_CAny Function(_CMapObject)>>('CMapObject_userData');
late final _CMapObject_userData = _CMapObject_userDataPtr.asFunction<_CAny Function(_CMapObject)>();
late final _CMapObject_setUserData_CAnyPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObject, _CAny)>>('CMapObject_setUserData_CAny');
late final _CMapObject_setUserData_CAny = _CMapObject_setUserData_CAnyPtr.asFunction<void Function(_CMapObject, _CAny)>();

late final _CMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapObject_cg_objectIdentifier');
late final _CMapObject_cg_objectIdentifier = _CMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapObject_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CMapObject)>>('CMapObject_cg_getSelector');
late final _CMapObject_cg_getSelector = _CMapObject_cg_getSelectorPtr.asFunction<int Function(_CMapObject)>();

late final _CMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapObject_release');
late final _CMapObject_release = _CMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapObject_retainPtr = _lookup<ffi.NativeFunction<_CMapObject Function(ffi.Pointer<ffi.Void>)>>('CMapObject_retain');
late final _CMapObject_retain = _CMapObject_retainPtr.asFunction<_CMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapObject Function()>>('CMapObjectMakeDefault');
late final _CMapObjectMakeDefault = _CMapObjectMakeDefaultPtr.asFunction<_CMapObject Function()>();

late final _CGeometryMapObject_geometryChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeometry Function(_CGeometryMapObject)>>('CGeometryMapObject_geometryChannel');
late final _CGeometryMapObject_geometryChannel = _CGeometryMapObject_geometryChannelPtr.asFunction<_CStatefulChannel_CGeometry Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_geometryPtr = _lookup<ffi.NativeFunction<_CGeometry Function(_CGeometryMapObject)>>('CGeometryMapObject_geometry');
late final _CGeometryMapObject_geometry = _CGeometryMapObject_geometryPtr.asFunction<_CGeometry Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_setGeometry_CGeometryPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObject, _CGeometry)>>('CGeometryMapObject_setGeometry_CGeometry');
late final _CGeometryMapObject_setGeometry_CGeometry = _CGeometryMapObject_setGeometry_CGeometryPtr.asFunction<void Function(_CGeometryMapObject, _CGeometry)>();
late final _CGeometryMapObject_objectAttributesPtr = _lookup<ffi.NativeFunction<_CAttributes Function(_CGeometryMapObject)>>('CGeometryMapObject_objectAttributes');
late final _CGeometryMapObject_objectAttributes = _CGeometryMapObject_objectAttributesPtr.asFunction<_CAttributes Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_isVisibleChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CGeometryMapObject)>>('CGeometryMapObject_isVisibleChannel');
late final _CGeometryMapObject_isVisibleChannel = _CGeometryMapObject_isVisibleChannelPtr.asFunction<_CStatefulChannel_bool Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_isVisiblePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeometryMapObject)>>('CGeometryMapObject_isVisible');
late final _CGeometryMapObject_isVisible = _CGeometryMapObject_isVisiblePtr.asFunction<bool Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_setVisible_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObject, ffi.Bool)>>('CGeometryMapObject_setVisible_bool');
late final _CGeometryMapObject_setVisible_bool = _CGeometryMapObject_setVisible_boolPtr.asFunction<void Function(_CGeometryMapObject, bool)>();
late final _CGeometryMapObject_isDraggableChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CGeometryMapObject)>>('CGeometryMapObject_isDraggableChannel');
late final _CGeometryMapObject_isDraggableChannel = _CGeometryMapObject_isDraggableChannelPtr.asFunction<_CStatefulChannel_bool Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_isDraggablePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeometryMapObject)>>('CGeometryMapObject_isDraggable');
late final _CGeometryMapObject_isDraggable = _CGeometryMapObject_isDraggablePtr.asFunction<bool Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_setDraggable_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObject, ffi.Bool)>>('CGeometryMapObject_setDraggable_bool');
late final _CGeometryMapObject_setDraggable_bool = _CGeometryMapObject_setDraggable_boolPtr.asFunction<void Function(_CGeometryMapObject, bool)>();
late final _CGeometryMapObject_animationSettingsPtr = _lookup<ffi.NativeFunction<_CAnimationSettings Function(_CGeometryMapObject)>>('CGeometryMapObject_animationSettings');
late final _CGeometryMapObject_animationSettings = _CGeometryMapObject_animationSettingsPtr.asFunction<_CAnimationSettings Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_boundsPtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CGeometryMapObject)>>('CGeometryMapObject_bounds');
late final _CGeometryMapObject_bounds = _CGeometryMapObject_boundsPtr.asFunction<_CGeoRect Function(_CGeometryMapObject)>();

late final _CGeometryMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObject_cg_objectIdentifier');
late final _CGeometryMapObject_cg_objectIdentifier = _CGeometryMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CGeometryMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObject_release');
late final _CGeometryMapObject_release = _CGeometryMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObject_retainPtr = _lookup<ffi.NativeFunction<_CGeometryMapObject Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObject_retain');
late final _CGeometryMapObject_retain = _CGeometryMapObject_retainPtr.asFunction<_CGeometryMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeometryMapObject Function()>>('CGeometryMapObjectMakeDefault');
late final _CGeometryMapObjectMakeDefault = _CGeometryMapObjectMakeDefaultPtr.asFunction<_CGeometryMapObject Function()>();


late final _CStatefulChannel_CGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeometry Function()>>('CStatefulChannel_CGeometryMakeDefault');
late final _CStatefulChannel_CGeometryMakeDefault = _CStatefulChannel_CGeometryMakeDefaultPtr.asFunction<_CStatefulChannel_CGeometry Function()>();
late final _CStatefulChannel_CGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CGeometry)>>('CStatefulChannel_CGeometry_release');
late final _CStatefulChannel_CGeometry_release = _CStatefulChannel_CGeometry_releasePtr.asFunction<void Function(_CStatefulChannel_CGeometry)>();
late final _CStatefulChannel_CGeometry_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeometry Function(_CStatefulChannel_CGeometry)>>('CStatefulChannel_CGeometry_retain');
late final _CStatefulChannel_CGeometry_retain = _CStatefulChannel_CGeometry_retainPtr.asFunction<_CStatefulChannel_CGeometry Function(_CStatefulChannel_CGeometry)>();
late final _CStatefulChannel_CGeometryGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CGeometry Function(_CStatefulChannel_CGeometry)>>('CStatefulChannel_CGeometry_getCurrentValue');
late final _CStatefulChannel_CGeometryGetCurrentValue = _CStatefulChannel_CGeometryGetCurrentValuePtr.asFunction<_CGeometry Function(_CStatefulChannel_CGeometry)>();
late final _CStatefulChannel_CGeometryConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CGeometry,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeometry, ffi.Int64)>>
  )
>>('CStatefulChannel_CGeometry_connect');
late final _CStatefulChannel_CGeometryConnect = _CStatefulChannel_CGeometryConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CGeometry,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeometry, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_boolMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function()>>('CStatefulChannel_boolMakeDefault');
late final _CStatefulChannel_boolMakeDefault = _CStatefulChannel_boolMakeDefaultPtr.asFunction<_CStatefulChannel_bool Function()>();
late final _CStatefulChannel_bool_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_bool)>>('CStatefulChannel_bool_release');
late final _CStatefulChannel_bool_release = _CStatefulChannel_bool_releasePtr.asFunction<void Function(_CStatefulChannel_bool)>();
late final _CStatefulChannel_bool_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CStatefulChannel_bool)>>('CStatefulChannel_bool_retain');
late final _CStatefulChannel_bool_retain = _CStatefulChannel_bool_retainPtr.asFunction<_CStatefulChannel_bool Function(_CStatefulChannel_bool)>();
late final _CStatefulChannel_boolGetCurrentValuePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CStatefulChannel_bool)>>('CStatefulChannel_bool_getCurrentValue');
late final _CStatefulChannel_boolGetCurrentValue = _CStatefulChannel_boolGetCurrentValuePtr.asFunction<bool Function(_CStatefulChannel_bool)>();
late final _CStatefulChannel_boolConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_bool,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Int64)>>
  )
>>('CStatefulChannel_bool_connect');
late final _CStatefulChannel_boolConnect = _CStatefulChannel_boolConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_bool,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Int64)>>
  )
>();
late final _CClusterObject_positionPtr = _lookup<ffi.NativeFunction<_CGeoPointWithElevation Function(_CClusterObject)>>('CClusterObject_position');
late final _CClusterObject_position = _CClusterObject_positionPtr.asFunction<_CGeoPointWithElevation Function(_CClusterObject)>();
late final _CClusterObject_objectCountPtr = _lookup<ffi.NativeFunction<ffi.Uint32 Function(_CClusterObject)>>('CClusterObject_objectCount');
late final _CClusterObject_objectCount = _CClusterObject_objectCountPtr.asFunction<int Function(_CClusterObject)>();
late final _CClusterObject_objectsPtr = _lookup<ffi.NativeFunction<_CArray_CGeometryMapObject Function(_CClusterObject)>>('CClusterObject_objects');
late final _CClusterObject_objects = _CClusterObject_objectsPtr.asFunction<_CArray_CGeometryMapObject Function(_CClusterObject)>();
late final _CClusterObject_geometryObjectPtr = _lookup<ffi.NativeFunction<_COptional_CGeometryMapObject Function(_CClusterObject)>>('CClusterObject_geometryObject');
late final _CClusterObject_geometryObject = _CClusterObject_geometryObjectPtr.asFunction<_COptional_CGeometryMapObject Function(_CClusterObject)>();

late final _CClusterObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CClusterObject_cg_objectIdentifier');
late final _CClusterObject_cg_objectIdentifier = _CClusterObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CClusterObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CClusterObject_release');
late final _CClusterObject_release = _CClusterObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CClusterObject_retainPtr = _lookup<ffi.NativeFunction<_CClusterObject Function(ffi.Pointer<ffi.Void>)>>('CClusterObject_retain');
late final _CClusterObject_retain = _CClusterObject_retainPtr.asFunction<_CClusterObject Function(ffi.Pointer<ffi.Void>)>();
late final _CClusterObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CClusterObject Function()>>('CClusterObjectMakeDefault');
late final _CClusterObjectMakeDefault = _CClusterObjectMakeDefaultPtr.asFunction<_CClusterObject Function()>();


late final _CArray_CGeometryMapObjectmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CGeometryMapObject Function()>>('CArray_CGeometryMapObject_makeEmpty');
late final _CArray_CGeometryMapObjectmakeEmpty = _CArray_CGeometryMapObjectmakeEmptyPtr.asFunction<_CArray_CGeometryMapObject Function()>();
late final _CArray_CGeometryMapObjectaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeometryMapObject, _CGeometryMapObject)>>('CArray_CGeometryMapObject_addElement');
late final _CArray_CGeometryMapObjectaddElement = _CArray_CGeometryMapObjectaddElementPtr.asFunction<void Function(_CArray_CGeometryMapObject, _CGeometryMapObject)>();
late final _forEach_CArray_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CGeometryMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObject)>>)
>>('CArray_CGeometryMapObject_forEachWithFunctionPointer');
late final _forEach_CArray_CGeometryMapObject = _forEach_CArray_CGeometryMapObjectPtr.asFunction<
  void Function(_CArray_CGeometryMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObject)
>>)>();
late final _CArray_CGeometryMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeometryMapObject)>>('CArray_CGeometryMapObject_release');
late final _CArray_CGeometryMapObject_release = _CArray_CGeometryMapObject_releasePtr.asFunction<void Function(_CArray_CGeometryMapObject)>();

late final _COptional_CGeometryMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGeometryMapObject Function()>>('COptional_CGeometryMapObjectMakeDefault');
late final _COptional_CGeometryMapObjectMakeDefault = _COptional_CGeometryMapObjectMakeDefaultPtr.asFunction<_COptional_CGeometryMapObject Function()>();

late final _COptional_CGeometryMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CGeometryMapObject)>>('COptional_CGeometryMapObject_release');
late final _COptional_CGeometryMapObject_release = _COptional_CGeometryMapObject_releasePtr.asFunction<void Function(_COptional_CGeometryMapObject)>();
late final _CDgisMapObject_idPtr = _lookup<ffi.NativeFunction<_CDgisObjectId Function(_CDgisMapObject)>>('CDgisMapObject_id');
late final _CDgisMapObject_id = _CDgisMapObject_idPtr.asFunction<_CDgisObjectId Function(_CDgisMapObject)>();

late final _CDgisMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDgisMapObject_cg_objectIdentifier');
late final _CDgisMapObject_cg_objectIdentifier = _CDgisMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CDgisMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDgisMapObject_release');
late final _CDgisMapObject_release = _CDgisMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDgisMapObject_retainPtr = _lookup<ffi.NativeFunction<_CDgisMapObject Function(ffi.Pointer<ffi.Void>)>>('CDgisMapObject_retain');
late final _CDgisMapObject_retain = _CDgisMapObject_retainPtr.asFunction<_CDgisMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CDgisMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDgisMapObject Function()>>('CDgisMapObjectMakeDefault');
late final _CDgisMapObjectMakeDefault = _CDgisMapObjectMakeDefaultPtr.asFunction<_CDgisMapObject Function()>();


late final _CSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSource_cg_objectIdentifier');
late final _CSource_cg_objectIdentifier = _CSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSource_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CSource)>>('CSource_cg_getSelector');
late final _CSource_cg_getSelector = _CSource_cg_getSelectorPtr.asFunction<int Function(_CSource)>();

late final _CSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSource_release');
late final _CSource_release = _CSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSource_retainPtr = _lookup<ffi.NativeFunction<_CSource Function(ffi.Pointer<ffi.Void>)>>('CSource_retain');
late final _CSource_retain = _CSource_retainPtr.asFunction<_CSource Function(ffi.Pointer<ffi.Void>)>();
late final _CSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSource Function()>>('CSourceMakeDefault');
late final _CSourceMakeDefault = _CSourceMakeDefaultPtr.asFunction<_CSource Function()>();

late final _CDgisSource_highlightedObjectsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CDgisObjectId Function(_CDgisSource)>>('CDgisSource_highlightedObjectsChannel');
late final _CDgisSource_highlightedObjectsChannel = _CDgisSource_highlightedObjectsChannelPtr.asFunction<_CStatefulChannel_CArray_CDgisObjectId Function(_CDgisSource)>();
late final _CDgisSource_highlightedObjectsPtr = _lookup<ffi.NativeFunction<_CArray_CDgisObjectId Function(_CDgisSource)>>('CDgisSource_highlightedObjects');
late final _CDgisSource_highlightedObjects = _CDgisSource_highlightedObjectsPtr.asFunction<_CArray_CDgisObjectId Function(_CDgisSource)>();

late final _CDgisSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDgisSource_cg_objectIdentifier');
late final _CDgisSource_cg_objectIdentifier = _CDgisSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDgisSource_S_createDgisSource_CContext_CDgisSourceWorkingModePtr = _lookup<ffi.NativeFunction<_CSource Function(_CContext, _CDgisSourceWorkingMode)>>('CDgisSource_S_createDgisSource_CContext_CDgisSourceWorkingMode');
late final _CDgisSource_S_createDgisSource_CContext_CDgisSourceWorkingMode = _CDgisSource_S_createDgisSource_CContext_CDgisSourceWorkingModePtr.asFunction<_CSource Function(_CContext, _CDgisSourceWorkingMode)>();
late final _CDgisSource_setHighlighted_CArray_CDgisObjectId_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDgisSource, _CArray_CDgisObjectId, ffi.Bool)>>('CDgisSource_setHighlighted_CArray_CDgisObjectId_bool');
late final _CDgisSource_setHighlighted_CArray_CDgisObjectId_bool = _CDgisSource_setHighlighted_CArray_CDgisObjectId_boolPtr.asFunction<void Function(_CDgisSource, _CArray_CDgisObjectId, bool)>();

late final _CDgisSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDgisSource_release');
late final _CDgisSource_release = _CDgisSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDgisSource_retainPtr = _lookup<ffi.NativeFunction<_CDgisSource Function(ffi.Pointer<ffi.Void>)>>('CDgisSource_retain');
late final _CDgisSource_retain = _CDgisSource_retainPtr.asFunction<_CDgisSource Function(ffi.Pointer<ffi.Void>)>();
late final _CDgisSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDgisSource Function()>>('CDgisSourceMakeDefault');
late final _CDgisSourceMakeDefault = _CDgisSourceMakeDefaultPtr.asFunction<_CDgisSource Function()>();


late final _CStatefulChannel_CArray_CDgisObjectIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CDgisObjectId Function()>>('CStatefulChannel_CArray_CDgisObjectIdMakeDefault');
late final _CStatefulChannel_CArray_CDgisObjectIdMakeDefault = _CStatefulChannel_CArray_CDgisObjectIdMakeDefaultPtr.asFunction<_CStatefulChannel_CArray_CDgisObjectId Function()>();
late final _CStatefulChannel_CArray_CDgisObjectId_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CArray_CDgisObjectId)>>('CStatefulChannel_CArray_CDgisObjectId_release');
late final _CStatefulChannel_CArray_CDgisObjectId_release = _CStatefulChannel_CArray_CDgisObjectId_releasePtr.asFunction<void Function(_CStatefulChannel_CArray_CDgisObjectId)>();
late final _CStatefulChannel_CArray_CDgisObjectId_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CDgisObjectId Function(_CStatefulChannel_CArray_CDgisObjectId)>>('CStatefulChannel_CArray_CDgisObjectId_retain');
late final _CStatefulChannel_CArray_CDgisObjectId_retain = _CStatefulChannel_CArray_CDgisObjectId_retainPtr.asFunction<_CStatefulChannel_CArray_CDgisObjectId Function(_CStatefulChannel_CArray_CDgisObjectId)>();
late final _CStatefulChannel_CArray_CDgisObjectIdGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CArray_CDgisObjectId Function(_CStatefulChannel_CArray_CDgisObjectId)>>('CStatefulChannel_CArray_CDgisObjectId_getCurrentValue');
late final _CStatefulChannel_CArray_CDgisObjectIdGetCurrentValue = _CStatefulChannel_CArray_CDgisObjectIdGetCurrentValuePtr.asFunction<_CArray_CDgisObjectId Function(_CStatefulChannel_CArray_CDgisObjectId)>();
late final _CStatefulChannel_CArray_CDgisObjectIdConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CDgisObjectId,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CDgisObjectId, ffi.Int64)>>
  )
>>('CStatefulChannel_CArray_CDgisObjectId_connect');
late final _CStatefulChannel_CArray_CDgisObjectIdConnect = _CStatefulChannel_CArray_CDgisObjectIdConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CDgisObjectId,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CDgisObjectId, ffi.Int64)>>
  )
>();

late final _CFollowController_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CFollowController_cg_objectIdentifier');
late final _CFollowController_cg_objectIdentifier = _CFollowController_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CFollowController_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CFollowController)>>('CFollowController_cg_getSelector');
late final _CFollowController_cg_getSelector = _CFollowController_cg_getSelectorPtr.asFunction<int Function(_CFollowController)>();

late final _CFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CFollowController_release');
late final _CFollowController_release = _CFollowController_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CFollowController_retainPtr = _lookup<ffi.NativeFunction<_CFollowController Function(ffi.Pointer<ffi.Void>)>>('CFollowController_retain');
late final _CFollowController_retain = _CFollowController_retainPtr.asFunction<_CFollowController Function(ffi.Pointer<ffi.Void>)>();
late final _CFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFollowController Function()>>('CFollowControllerMakeDefault');
late final _CFollowControllerMakeDefault = _CFollowControllerMakeDefaultPtr.asFunction<_CFollowController Function()>();

late final _CGeometryMapObjectSource_objectsPtr = _lookup<ffi.NativeFunction<_CArray_CGeometryMapObject Function(_CGeometryMapObjectSource)>>('CGeometryMapObjectSource_objects');
late final _CGeometryMapObjectSource_objects = _CGeometryMapObjectSource_objectsPtr.asFunction<_CArray_CGeometryMapObject Function(_CGeometryMapObjectSource)>();
late final _CGeometryMapObjectSource_sourceAttributesPtr = _lookup<ffi.NativeFunction<_CAttributes Function(_CGeometryMapObjectSource)>>('CGeometryMapObjectSource_sourceAttributes');
late final _CGeometryMapObjectSource_sourceAttributes = _CGeometryMapObjectSource_sourceAttributesPtr.asFunction<_CAttributes Function(_CGeometryMapObjectSource)>();

late final _CGeometryMapObjectSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectSource_cg_objectIdentifier');
late final _CGeometryMapObjectSource_cg_objectIdentifier = _CGeometryMapObjectSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CGeometryMapObjectSource_clusteringObjects_CCameraPositionPtr = _lookup<ffi.NativeFunction<_CArray_CMapObject Function(_CGeometryMapObjectSource, _CCameraPosition)>>('CGeometryMapObjectSource_clusteringObjects_CCameraPosition');
late final _CGeometryMapObjectSource_clusteringObjects_CCameraPosition = _CGeometryMapObjectSource_clusteringObjects_CCameraPositionPtr.asFunction<_CArray_CMapObject Function(_CGeometryMapObjectSource, _CCameraPosition)>();
late final _CGeometryMapObjectSource_addObject_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObjectSource, _CGeometryMapObject)>>('CGeometryMapObjectSource_addObject_CGeometryMapObject');
late final _CGeometryMapObjectSource_addObject_CGeometryMapObject = _CGeometryMapObjectSource_addObject_CGeometryMapObjectPtr.asFunction<void Function(_CGeometryMapObjectSource, _CGeometryMapObject)>();
late final _CGeometryMapObjectSource_addObjects_CArray_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObjectSource, _CArray_CGeometryMapObject)>>('CGeometryMapObjectSource_addObjects_CArray_CGeometryMapObject');
late final _CGeometryMapObjectSource_addObjects_CArray_CGeometryMapObject = _CGeometryMapObjectSource_addObjects_CArray_CGeometryMapObjectPtr.asFunction<void Function(_CGeometryMapObjectSource, _CArray_CGeometryMapObject)>();
late final _CGeometryMapObjectSource_removeObject_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObjectSource, _CGeometryMapObject)>>('CGeometryMapObjectSource_removeObject_CGeometryMapObject');
late final _CGeometryMapObjectSource_removeObject_CGeometryMapObject = _CGeometryMapObjectSource_removeObject_CGeometryMapObjectPtr.asFunction<void Function(_CGeometryMapObjectSource, _CGeometryMapObject)>();
late final _CGeometryMapObjectSource_removeObjects_CArray_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObjectSource, _CArray_CGeometryMapObject)>>('CGeometryMapObjectSource_removeObjects_CArray_CGeometryMapObject');
late final _CGeometryMapObjectSource_removeObjects_CArray_CGeometryMapObject = _CGeometryMapObjectSource_removeObjects_CArray_CGeometryMapObjectPtr.asFunction<void Function(_CGeometryMapObjectSource, _CArray_CGeometryMapObject)>();
late final _CGeometryMapObjectSource_removeAndAddObjects_CArray_CGeometryMapObject_CArray_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObjectSource, _CArray_CGeometryMapObject, _CArray_CGeometryMapObject)>>('CGeometryMapObjectSource_removeAndAddObjects_CArray_CGeometryMapObject_CArray_CGeometryMapObject');
late final _CGeometryMapObjectSource_removeAndAddObjects_CArray_CGeometryMapObject_CArray_CGeometryMapObject = _CGeometryMapObjectSource_removeAndAddObjects_CArray_CGeometryMapObject_CArray_CGeometryMapObjectPtr.asFunction<void Function(_CGeometryMapObjectSource, _CArray_CGeometryMapObject, _CArray_CGeometryMapObject)>();
late final _CGeometryMapObjectSource_clearPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObjectSource)>>('CGeometryMapObjectSource_clear');
late final _CGeometryMapObjectSource_clear = _CGeometryMapObjectSource_clearPtr.asFunction<void Function(_CGeometryMapObjectSource)>();

late final _CGeometryMapObjectSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectSource_release');
late final _CGeometryMapObjectSource_release = _CGeometryMapObjectSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectSource_retainPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSource Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectSource_retain');
late final _CGeometryMapObjectSource_retain = _CGeometryMapObjectSource_retainPtr.asFunction<_CGeometryMapObjectSource Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSource Function()>>('CGeometryMapObjectSourceMakeDefault');
late final _CGeometryMapObjectSourceMakeDefault = _CGeometryMapObjectSourceMakeDefaultPtr.asFunction<_CGeometryMapObjectSource Function()>();


late final _CArray_CMapObjectmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CMapObject Function()>>('CArray_CMapObject_makeEmpty');
late final _CArray_CMapObjectmakeEmpty = _CArray_CMapObjectmakeEmptyPtr.asFunction<_CArray_CMapObject Function()>();
late final _CArray_CMapObjectaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CMapObject, _CMapObject)>>('CArray_CMapObject_addElement');
late final _CArray_CMapObjectaddElement = _CArray_CMapObjectaddElementPtr.asFunction<void Function(_CArray_CMapObject, _CMapObject)>();
late final _forEach_CArray_CMapObjectPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMapObject)>>)
>>('CArray_CMapObject_forEachWithFunctionPointer');
late final _forEach_CArray_CMapObject = _forEach_CArray_CMapObjectPtr.asFunction<
  void Function(_CArray_CMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMapObject)
>>)>();
late final _CArray_CMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CMapObject)>>('CArray_CMapObject_release');
late final _CArray_CMapObject_release = _CArray_CMapObject_releasePtr.asFunction<void Function(_CArray_CMapObject)>();

late final _CImage_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CImage_cg_objectIdentifier');
late final _CImage_cg_objectIdentifier = _CImage_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CImage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CImage_release');
late final _CImage_release = _CImage_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CImage_retainPtr = _lookup<ffi.NativeFunction<_CImage Function(ffi.Pointer<ffi.Void>)>>('CImage_retain');
late final _CImage_retain = _CImage_retainPtr.asFunction<_CImage Function(ffi.Pointer<ffi.Void>)>();
late final _CImageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CImage Function()>>('CImageMakeDefault');
late final _CImageMakeDefault = _CImageMakeDefaultPtr.asFunction<_CImage Function()>();


late final _CImageFormatMakeDefaultPtr = _lookup<ffi.NativeFunction<_CImageFormat Function()>>('CImageFormatMakeDefault');
late final _CImageFormatMakeDefault = _CImageFormatMakeDefaultPtr.asFunction<_CImageFormat Function()>();

late final _CImageDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CImageData Function()>>('CImageDataMakeDefault');
late final _CImageDataMakeDefault = _CImageDataMakeDefaultPtr.asFunction<_CImageData Function()>();


late final _CImageLoaderCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CImageLoaderCpp_cg_objectIdentifier');
late final _CImageLoaderCpp_cg_objectIdentifier = _CImageLoaderCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CImageLoaderCpp_loadPtr = _lookup<ffi.NativeFunction<_CImageData Function(_CImageLoaderCpp)>>('CImageLoaderCpp_load');
late final _CImageLoaderCpp_load = _CImageLoaderCpp_loadPtr.asFunction<_CImageData Function(_CImageLoaderCpp)>();

late final _CImageLoaderCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CImageLoaderCpp_release');
late final _CImageLoaderCpp_release = _CImageLoaderCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CImageLoaderCpp_retainPtr = _lookup<ffi.NativeFunction<_CImageLoaderCpp Function(ffi.Pointer<ffi.Void>)>>('CImageLoaderCpp_retain');
late final _CImageLoaderCpp_retain = _CImageLoaderCpp_retainPtr.asFunction<_CImageLoaderCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CImageLoaderCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CImageLoaderCpp Function()>>('CImageLoaderCppMakeDefault');
late final _CImageLoaderCppMakeDefault = _CImageLoaderCppMakeDefaultPtr.asFunction<_CImageLoaderCpp Function()>();


late final _CImageLoaderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CImageLoader Function()>>('CImageLoaderMakeDefault');
late final _CImageLoaderMakeDefault = _CImageLoaderMakeDefaultPtr.asFunction<_CImageLoader Function()>();
late final _CImageLoader_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CImageLoader)>>('CImageLoader_release');
late final _CImageLoader_release = _CImageLoader_releasePtr.asFunction<void Function(_CImageLoader)>();

late final _CBearingFollowController_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CBearingFollowController_cg_objectIdentifier');
late final _CBearingFollowController_cg_objectIdentifier = _CBearingFollowController_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CBearingFollowController_C_createWith_CBearingSource_CTimeInterval_CBearingPtr = _lookup<ffi.NativeFunction<_CBearingFollowController Function(_CBearingSource, _CTimeInterval, _CBearing)>>('CBearingFollowController_C_createWith_CBearingSource_CTimeInterval_CBearing');
late final _CBearingFollowController_C_createWith_CBearingSource_CTimeInterval_CBearing = _CBearingFollowController_C_createWith_CBearingSource_CTimeInterval_CBearingPtr.asFunction<_CBearingFollowController Function(_CBearingSource, _CTimeInterval, _CBearing)>();

late final _CBearingFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CBearingFollowController_release');
late final _CBearingFollowController_release = _CBearingFollowController_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CBearingFollowController_retainPtr = _lookup<ffi.NativeFunction<_CBearingFollowController Function(ffi.Pointer<ffi.Void>)>>('CBearingFollowController_retain');
late final _CBearingFollowController_retain = _CBearingFollowController_retainPtr.asFunction<_CBearingFollowController Function(ffi.Pointer<ffi.Void>)>();
late final _CBearingFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBearingFollowController Function()>>('CBearingFollowControllerMakeDefault');
late final _CBearingFollowControllerMakeDefault = _CBearingFollowControllerMakeDefaultPtr.asFunction<_CBearingFollowController Function()>();


late final _CCoordinatesFollowController_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCoordinatesFollowController_cg_objectIdentifier');
late final _CCoordinatesFollowController_cg_objectIdentifier = _CCoordinatesFollowController_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCoordinatesFollowController_C_createWith_CTimeInterval_CMeterPtr = _lookup<ffi.NativeFunction<_CCoordinatesFollowController Function(_CTimeInterval, _CMeter)>>('CCoordinatesFollowController_C_createWith_CTimeInterval_CMeter');
late final _CCoordinatesFollowController_C_createWith_CTimeInterval_CMeter = _CCoordinatesFollowController_C_createWith_CTimeInterval_CMeterPtr.asFunction<_CCoordinatesFollowController Function(_CTimeInterval, _CMeter)>();

late final _CCoordinatesFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCoordinatesFollowController_release');
late final _CCoordinatesFollowController_release = _CCoordinatesFollowController_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCoordinatesFollowController_retainPtr = _lookup<ffi.NativeFunction<_CCoordinatesFollowController Function(ffi.Pointer<ffi.Void>)>>('CCoordinatesFollowController_retain');
late final _CCoordinatesFollowController_retain = _CCoordinatesFollowController_retainPtr.asFunction<_CCoordinatesFollowController Function(ffi.Pointer<ffi.Void>)>();
late final _CCoordinatesFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCoordinatesFollowController Function()>>('CCoordinatesFollowControllerMakeDefault');
late final _CCoordinatesFollowControllerMakeDefault = _CCoordinatesFollowControllerMakeDefaultPtr.asFunction<_CCoordinatesFollowController Function()>();


late final _COptional_CBearingSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CBearingSource Function()>>('COptional_CBearingSourceMakeDefault');
late final _COptional_CBearingSourceMakeDefault = _COptional_CBearingSourceMakeDefaultPtr.asFunction<_COptional_CBearingSource Function()>();

late final _CMyLocationControllerSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMyLocationControllerSettings Function()>>('CMyLocationControllerSettingsMakeDefault');
late final _CMyLocationControllerSettingsMakeDefault = _CMyLocationControllerSettingsMakeDefaultPtr.asFunction<_CMyLocationControllerSettings Function()>();


late final _CMyLocationMapObjectMarkerTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObjectMarkerType Function()>>('CMyLocationMapObjectMarkerTypeMakeDefault');
late final _CMyLocationMapObjectMarkerTypeMakeDefault = _CMyLocationMapObjectMarkerTypeMakeDefaultPtr.asFunction<_CMyLocationMapObjectMarkerType Function()>();

late final _CModelData_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CModelData_cg_objectIdentifier');
late final _CModelData_cg_objectIdentifier = _CModelData_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CModelData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CModelData_release');
late final _CModelData_release = _CModelData_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CModelData_retainPtr = _lookup<ffi.NativeFunction<_CModelData Function(ffi.Pointer<ffi.Void>)>>('CModelData_retain');
late final _CModelData_retain = _CModelData_retainPtr.asFunction<_CModelData Function(ffi.Pointer<ffi.Void>)>();
late final _CModelDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelData Function()>>('CModelDataMakeDefault');
late final _CModelDataMakeDefault = _CModelDataMakeDefaultPtr.asFunction<_CModelData Function()>();

late final _CMyLocationMapObject_animationSettingsPtr = _lookup<ffi.NativeFunction<_CAnimationSettings Function(_CMyLocationMapObject)>>('CMyLocationMapObject_animationSettings');
late final _CMyLocationMapObject_animationSettings = _CMyLocationMapObject_animationSettingsPtr.asFunction<_CAnimationSettings Function(_CMyLocationMapObject)>();
late final _CMyLocationMapObject_objectAttributesPtr = _lookup<ffi.NativeFunction<_CAttributes Function(_CMyLocationMapObject)>>('CMyLocationMapObject_objectAttributes');
late final _CMyLocationMapObject_objectAttributes = _CMyLocationMapObject_objectAttributesPtr.asFunction<_CAttributes Function(_CMyLocationMapObject)>();

late final _CMyLocationMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObject_cg_objectIdentifier');
late final _CMyLocationMapObject_cg_objectIdentifier = _CMyLocationMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMyLocationMapObject_setModelData_COptional_CModelDataPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMyLocationMapObject, _COptional_CModelData)>>('CMyLocationMapObject_setModelData_COptional_CModelData');
late final _CMyLocationMapObject_setModelData_COptional_CModelData = _CMyLocationMapObject_setModelData_COptional_CModelDataPtr.asFunction<void Function(_CMyLocationMapObject, _COptional_CModelData)>();

late final _CMyLocationMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObject_release');
late final _CMyLocationMapObject_release = _CMyLocationMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationMapObject_retainPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObject Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObject_retain');
late final _CMyLocationMapObject_retain = _CMyLocationMapObject_retainPtr.asFunction<_CMyLocationMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObject Function()>>('CMyLocationMapObjectMakeDefault');
late final _CMyLocationMapObjectMakeDefault = _CMyLocationMapObjectMakeDefaultPtr.asFunction<_CMyLocationMapObject Function()>();


late final _COptional_CModelDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CModelData Function()>>('COptional_CModelDataMakeDefault');
late final _COptional_CModelDataMakeDefault = _COptional_CModelDataMakeDefaultPtr.asFunction<_COptional_CModelData Function()>();

late final _COptional_CModelData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CModelData)>>('COptional_CModelData_release');
late final _COptional_CModelData_release = _COptional_CModelData_releasePtr.asFunction<void Function(_COptional_CModelData)>();
late final _CMyLocationMapObjectSource_itemPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObject Function(_CMyLocationMapObjectSource)>>('CMyLocationMapObjectSource_item');
late final _CMyLocationMapObjectSource_item = _CMyLocationMapObjectSource_itemPtr.asFunction<_CMyLocationMapObject Function(_CMyLocationMapObjectSource)>();

late final _CMyLocationMapObjectSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObjectSource_cg_objectIdentifier');
late final _CMyLocationMapObjectSource_cg_objectIdentifier = _CMyLocationMapObjectSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMyLocationMapObjectSource_C_createWith_CContext_CMyLocationControllerSettings_CMyLocationMapObjectMarkerTypePtr = _lookup<ffi.NativeFunction<_CMyLocationMapObjectSource Function(_CContext, _CMyLocationControllerSettings, _CMyLocationMapObjectMarkerType)>>('CMyLocationMapObjectSource_C_createWith_CContext_CMyLocationControllerSettings_CMyLocationMapObjectMarkerType');
late final _CMyLocationMapObjectSource_C_createWith_CContext_CMyLocationControllerSettings_CMyLocationMapObjectMarkerType = _CMyLocationMapObjectSource_C_createWith_CContext_CMyLocationControllerSettings_CMyLocationMapObjectMarkerTypePtr.asFunction<_CMyLocationMapObjectSource Function(_CContext, _CMyLocationControllerSettings, _CMyLocationMapObjectMarkerType)>();

late final _CMyLocationMapObjectSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObjectSource_release');
late final _CMyLocationMapObjectSource_release = _CMyLocationMapObjectSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationMapObjectSource_retainPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObjectSource Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObjectSource_retain');
late final _CMyLocationMapObjectSource_retain = _CMyLocationMapObjectSource_retainPtr.asFunction<_CMyLocationMapObjectSource Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationMapObjectSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObjectSource Function()>>('CMyLocationMapObjectSourceMakeDefault');
late final _CMyLocationMapObjectSourceMakeDefault = _CMyLocationMapObjectSourceMakeDefaultPtr.asFunction<_CMyLocationMapObjectSource Function()>();

late final _CRoadEventMapObject_idPtr = _lookup<ffi.NativeFunction<_CDgisObjectId Function(_CRoadEventMapObject)>>('CRoadEventMapObject_id');
late final _CRoadEventMapObject_id = _CRoadEventMapObject_idPtr.asFunction<_CDgisObjectId Function(_CRoadEventMapObject)>();
late final _CRoadEventMapObject_eventPtr = _lookup<ffi.NativeFunction<_CRoadEvent Function(_CRoadEventMapObject)>>('CRoadEventMapObject_event');
late final _CRoadEventMapObject_event = _CRoadEventMapObject_eventPtr.asFunction<_CRoadEvent Function(_CRoadEventMapObject)>();
late final _CRoadEventMapObject_animationSettingsPtr = _lookup<ffi.NativeFunction<_CAnimationSettings Function(_CRoadEventMapObject)>>('CRoadEventMapObject_animationSettings');
late final _CRoadEventMapObject_animationSettings = _CRoadEventMapObject_animationSettingsPtr.asFunction<_CAnimationSettings Function(_CRoadEventMapObject)>();

late final _CRoadEventMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEventMapObject_cg_objectIdentifier');
late final _CRoadEventMapObject_cg_objectIdentifier = _CRoadEventMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CRoadEventMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEventMapObject_release');
late final _CRoadEventMapObject_release = _CRoadEventMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventMapObject_retainPtr = _lookup<ffi.NativeFunction<_CRoadEventMapObject Function(ffi.Pointer<ffi.Void>)>>('CRoadEventMapObject_retain');
late final _CRoadEventMapObject_retain = _CRoadEventMapObject_retainPtr.asFunction<_CRoadEventMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventMapObject Function()>>('CRoadEventMapObjectMakeDefault');
late final _CRoadEventMapObjectMakeDefault = _CRoadEventMapObjectMakeDefaultPtr.asFunction<_CRoadEventMapObject Function()>();


late final _CRoadEventTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventType Function()>>('CRoadEventTypeMakeDefault');
late final _CRoadEventTypeMakeDefault = _CRoadEventTypeMakeDefaultPtr.asFunction<_CRoadEventType Function()>();
late final _CRoadEvent_typePtr = _lookup<ffi.NativeFunction<_CRoadEventType Function(_CRoadEvent)>>('CRoadEvent_type');
late final _CRoadEvent_type = _CRoadEvent_typePtr.asFunction<_CRoadEventType Function(_CRoadEvent)>();
late final _CRoadEvent_idPtr = _lookup<ffi.NativeFunction<_CString Function(_CRoadEvent)>>('CRoadEvent_id');
late final _CRoadEvent_id = _CRoadEvent_idPtr.asFunction<_CString Function(_CRoadEvent)>();
late final _CRoadEvent_namePtr = _lookup<ffi.NativeFunction<_CString Function(_CRoadEvent)>>('CRoadEvent_name');
late final _CRoadEvent_name = _CRoadEvent_namePtr.asFunction<_CString Function(_CRoadEvent)>();
late final _CRoadEvent_authorPtr = _lookup<ffi.NativeFunction<_CAuthorInfo Function(_CRoadEvent)>>('CRoadEvent_author');
late final _CRoadEvent_author = _CRoadEvent_authorPtr.asFunction<_CAuthorInfo Function(_CRoadEvent)>();
late final _CRoadEvent_timestampPtr = _lookup<ffi.NativeFunction<_COptional_CDate Function(_CRoadEvent)>>('CRoadEvent_timestamp');
late final _CRoadEvent_timestamp = _CRoadEvent_timestampPtr.asFunction<_COptional_CDate Function(_CRoadEvent)>();
late final _CRoadEvent_locationPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CRoadEvent)>>('CRoadEvent_location');
late final _CRoadEvent_location = _CRoadEvent_locationPtr.asFunction<_CGeoPoint Function(_CRoadEvent)>();
late final _CRoadEvent_descriptionPtr = _lookup<ffi.NativeFunction<_CString Function(_CRoadEvent)>>('CRoadEvent_description');
late final _CRoadEvent_description = _CRoadEvent_descriptionPtr.asFunction<_CString Function(_CRoadEvent)>();
late final _CRoadEvent_cameraInfoPtr = _lookup<ffi.NativeFunction<_COptional_CRoadCameraInfo Function(_CRoadEvent)>>('CRoadEvent_cameraInfo');
late final _CRoadEvent_cameraInfo = _CRoadEvent_cameraInfoPtr.asFunction<_COptional_CRoadCameraInfo Function(_CRoadEvent)>();
late final _CRoadEvent_schedulePtr = _lookup<ffi.NativeFunction<_COptional_CSchedule Function(_CRoadEvent)>>('CRoadEvent_schedule');
late final _CRoadEvent_schedule = _CRoadEvent_schedulePtr.asFunction<_COptional_CSchedule Function(_CRoadEvent)>();
late final _CRoadEvent_lanesPtr = _lookup<ffi.NativeFunction<_COptionSet_CLane Function(_CRoadEvent)>>('CRoadEvent_lanes');
late final _CRoadEvent_lanes = _CRoadEvent_lanesPtr.asFunction<_COptionSet_CLane Function(_CRoadEvent)>();
late final _CRoadEvent_availableActionsPtr = _lookup<ffi.NativeFunction<_CArray_CRoadEventAction Function(_CRoadEvent)>>('CRoadEvent_availableActions');
late final _CRoadEvent_availableActions = _CRoadEvent_availableActionsPtr.asFunction<_CArray_CRoadEventAction Function(_CRoadEvent)>();
late final _CRoadEvent_removerPtr = _lookup<ffi.NativeFunction<_COptional_CRemover Function(_CRoadEvent)>>('CRoadEvent_remover');
late final _CRoadEvent_remover = _CRoadEvent_removerPtr.asFunction<_COptional_CRemover Function(_CRoadEvent)>();

late final _CRoadEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEvent_cg_objectIdentifier');
late final _CRoadEvent_cg_objectIdentifier = _CRoadEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadEvent_photosPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CRoadEventPhoto Function(_CRoadEvent)>>('CRoadEvent_photos');
late final _CRoadEvent_photos = _CRoadEvent_photosPtr.asFunction<_CFuture_CArray_CRoadEventPhoto Function(_CRoadEvent)>();

late final _CRoadEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEvent_release');
late final _CRoadEvent_release = _CRoadEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEvent_retainPtr = _lookup<ffi.NativeFunction<_CRoadEvent Function(ffi.Pointer<ffi.Void>)>>('CRoadEvent_retain');
late final _CRoadEvent_retain = _CRoadEvent_retainPtr.asFunction<_CRoadEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEvent Function()>>('CRoadEventMakeDefault');
late final _CRoadEventMakeDefault = _CRoadEventMakeDefaultPtr.asFunction<_CRoadEvent Function()>();


late final _CAuthorTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAuthorType Function()>>('CAuthorTypeMakeDefault');
late final _CAuthorTypeMakeDefault = _CAuthorTypeMakeDefaultPtr.asFunction<_CAuthorType Function()>();

late final _CAuthorInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAuthorInfo Function()>>('CAuthorInfoMakeDefault');
late final _CAuthorInfoMakeDefault = _CAuthorInfoMakeDefaultPtr.asFunction<_CAuthorInfo Function()>();


late final _CDateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDate Function()>>('CDateMakeDefault');
late final _CDateMakeDefault = _CDateMakeDefaultPtr.asFunction<_CDate Function()>();

late final _COptional_CDateMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CDate Function()>>('COptional_CDateMakeDefault');
late final _COptional_CDateMakeDefault = _COptional_CDateMakeDefaultPtr.asFunction<_COptional_CDate Function()>();

late final _CCameraPurposeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraPurpose Function()>>('CCameraPurposeMakeDefault');
late final _CCameraPurposeMakeDefault = _CCameraPurposeMakeDefaultPtr.asFunction<_CCameraPurpose Function()>();

late final _COptionSet_CCameraPurposeMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CCameraPurpose Function()>>('COptionSet_CCameraPurposeMakeDefault');
late final _COptionSet_CCameraPurposeMakeDefault = _COptionSet_CCameraPurposeMakeDefaultPtr.asFunction<_COptionSet_CCameraPurpose Function()>();

late final _CRoadCameraInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadCameraInfo Function()>>('CRoadCameraInfoMakeDefault');
late final _CRoadCameraInfoMakeDefault = _CRoadCameraInfoMakeDefaultPtr.asFunction<_CRoadCameraInfo Function()>();


late final _COptional_CRoadCameraInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRoadCameraInfo Function()>>('COptional_CRoadCameraInfoMakeDefault');
late final _COptional_CRoadCameraInfoMakeDefault = _COptional_CRoadCameraInfoMakeDefaultPtr.asFunction<_COptional_CRoadCameraInfo Function()>();

late final _CScheduleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSchedule Function()>>('CScheduleMakeDefault');
late final _CScheduleMakeDefault = _CScheduleMakeDefaultPtr.asFunction<_CSchedule Function()>();


late final _COptional_CScheduleMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CSchedule Function()>>('COptional_CScheduleMakeDefault');
late final _COptional_CScheduleMakeDefault = _COptional_CScheduleMakeDefaultPtr.asFunction<_COptional_CSchedule Function()>();

late final _COptional_CSchedule_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CSchedule)>>('COptional_CSchedule_release');
late final _COptional_CSchedule_release = _COptional_CSchedule_releasePtr.asFunction<void Function(_COptional_CSchedule)>();

late final _CLaneMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLane Function()>>('CLaneMakeDefault');
late final _CLaneMakeDefault = _CLaneMakeDefaultPtr.asFunction<_CLane Function()>();

late final _COptionSet_CLaneMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CLane Function()>>('COptionSet_CLaneMakeDefault');
late final _COptionSet_CLaneMakeDefault = _COptionSet_CLaneMakeDefaultPtr.asFunction<_COptionSet_CLane Function()>();

late final _CFuture_CArray_CRoadEventPhotoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CRoadEventPhoto Function()>>('CFuture_CArray_CRoadEventPhotoMakeDefault');
late final _CFuture_CArray_CRoadEventPhotoMakeDefault = _CFuture_CArray_CRoadEventPhotoMakeDefaultPtr.asFunction<_CFuture_CArray_CRoadEventPhoto Function()>();
late final _CFuture_CArray_CRoadEventPhoto_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CRoadEventPhoto)>>('CFuture_CArray_CRoadEventPhoto_release');
late final _CFuture_CArray_CRoadEventPhoto_release = _CFuture_CArray_CRoadEventPhoto_releasePtr.asFunction<void Function(_CFuture_CArray_CRoadEventPhoto)>();
late final _CFuture_CArray_CRoadEventPhoto_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CRoadEventPhoto Function(_CFuture_CArray_CRoadEventPhoto)>>('CFuture_CArray_CRoadEventPhoto_retain');
late final _CFuture_CArray_CRoadEventPhoto_retain = _CFuture_CArray_CRoadEventPhoto_retainPtr.asFunction<_CFuture_CArray_CRoadEventPhoto Function(_CFuture_CArray_CRoadEventPhoto)>();
late final _CFuture_CArray_CRoadEventPhotoReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CArray_CRoadEventPhoto,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventPhoto, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CArray_CRoadEventPhoto_receive');
late final _CFuture_CArray_CRoadEventPhotoReceive = _CFuture_CArray_CRoadEventPhotoReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CArray_CRoadEventPhoto,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventPhoto, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CArray_CRoadEventPhotomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRoadEventPhoto Function()>>('CArray_CRoadEventPhoto_makeEmpty');
late final _CArray_CRoadEventPhotomakeEmpty = _CArray_CRoadEventPhotomakeEmptyPtr.asFunction<_CArray_CRoadEventPhoto Function()>();
late final _CArray_CRoadEventPhotoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventPhoto, _CRoadEventPhoto)>>('CArray_CRoadEventPhoto_addElement');
late final _CArray_CRoadEventPhotoaddElement = _CArray_CRoadEventPhotoaddElementPtr.asFunction<void Function(_CArray_CRoadEventPhoto, _CRoadEventPhoto)>();
late final _forEach_CArray_CRoadEventPhotoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRoadEventPhoto, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventPhoto)>>)
>>('CArray_CRoadEventPhoto_forEachWithFunctionPointer');
late final _forEach_CArray_CRoadEventPhoto = _forEach_CArray_CRoadEventPhotoPtr.asFunction<
  void Function(_CArray_CRoadEventPhoto, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventPhoto)
>>)>();
late final _CArray_CRoadEventPhoto_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventPhoto)>>('CArray_CRoadEventPhoto_release');
late final _CArray_CRoadEventPhoto_release = _CArray_CRoadEventPhoto_releasePtr.asFunction<void Function(_CArray_CRoadEventPhoto)>();
late final _CRoadEventPhoto_photoUrlPtr = _lookup<ffi.NativeFunction<_CString Function(_CRoadEventPhoto)>>('CRoadEventPhoto_photoUrl');
late final _CRoadEventPhoto_photoUrl = _CRoadEventPhoto_photoUrlPtr.asFunction<_CString Function(_CRoadEventPhoto)>();
late final _CRoadEventPhoto_authorPtr = _lookup<ffi.NativeFunction<_CAuthorInfo Function(_CRoadEventPhoto)>>('CRoadEventPhoto_author');
late final _CRoadEventPhoto_author = _CRoadEventPhoto_authorPtr.asFunction<_CAuthorInfo Function(_CRoadEventPhoto)>();
late final _CRoadEventPhoto_timestampPtr = _lookup<ffi.NativeFunction<_CDate Function(_CRoadEventPhoto)>>('CRoadEventPhoto_timestamp');
late final _CRoadEventPhoto_timestamp = _CRoadEventPhoto_timestampPtr.asFunction<_CDate Function(_CRoadEventPhoto)>();
late final _CRoadEventPhoto_removerPtr = _lookup<ffi.NativeFunction<_COptional_CRemover Function(_CRoadEventPhoto)>>('CRoadEventPhoto_remover');
late final _CRoadEventPhoto_remover = _CRoadEventPhoto_removerPtr.asFunction<_COptional_CRemover Function(_CRoadEventPhoto)>();

late final _CRoadEventPhoto_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEventPhoto_cg_objectIdentifier');
late final _CRoadEventPhoto_cg_objectIdentifier = _CRoadEventPhoto_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadEventPhoto_previewUrl_CScreenSizePtr = _lookup<ffi.NativeFunction<_CString Function(_CRoadEventPhoto, _CScreenSize)>>('CRoadEventPhoto_previewUrl_CScreenSize');
late final _CRoadEventPhoto_previewUrl_CScreenSize = _CRoadEventPhoto_previewUrl_CScreenSizePtr.asFunction<_CString Function(_CRoadEventPhoto, _CScreenSize)>();
late final _CRoadEventPhoto_reportPtr = _lookup<ffi.NativeFunction<_CFuture_CActionResult Function(_CRoadEventPhoto)>>('CRoadEventPhoto_report');
late final _CRoadEventPhoto_report = _CRoadEventPhoto_reportPtr.asFunction<_CFuture_CActionResult Function(_CRoadEventPhoto)>();

late final _CRoadEventPhoto_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEventPhoto_release');
late final _CRoadEventPhoto_release = _CRoadEventPhoto_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventPhoto_retainPtr = _lookup<ffi.NativeFunction<_CRoadEventPhoto Function(ffi.Pointer<ffi.Void>)>>('CRoadEventPhoto_retain');
late final _CRoadEventPhoto_retain = _CRoadEventPhoto_retainPtr.asFunction<_CRoadEventPhoto Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventPhotoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventPhoto Function()>>('CRoadEventPhotoMakeDefault');
late final _CRoadEventPhotoMakeDefault = _CRoadEventPhotoMakeDefaultPtr.asFunction<_CRoadEventPhoto Function()>();


late final _CActionResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CActionResult Function()>>('CActionResultMakeDefault');
late final _CActionResultMakeDefault = _CActionResultMakeDefaultPtr.asFunction<_CActionResult Function()>();

late final _CFuture_CActionResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CActionResult Function()>>('CFuture_CActionResultMakeDefault');
late final _CFuture_CActionResultMakeDefault = _CFuture_CActionResultMakeDefaultPtr.asFunction<_CFuture_CActionResult Function()>();
late final _CFuture_CActionResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CActionResult)>>('CFuture_CActionResult_release');
late final _CFuture_CActionResult_release = _CFuture_CActionResult_releasePtr.asFunction<void Function(_CFuture_CActionResult)>();
late final _CFuture_CActionResult_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CActionResult Function(_CFuture_CActionResult)>>('CFuture_CActionResult_retain');
late final _CFuture_CActionResult_retain = _CFuture_CActionResult_retainPtr.asFunction<_CFuture_CActionResult Function(_CFuture_CActionResult)>();
late final _CFuture_CActionResultReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CActionResult,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CActionResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CActionResult_receive');
late final _CFuture_CActionResultReceive = _CFuture_CActionResultReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CActionResult,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CActionResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CRemover_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRemover_cg_objectIdentifier');
late final _CRemover_cg_objectIdentifier = _CRemover_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRemover_removePtr = _lookup<ffi.NativeFunction<_CFuture_CActionResult Function(_CRemover)>>('CRemover_remove');
late final _CRemover_remove = _CRemover_removePtr.asFunction<_CFuture_CActionResult Function(_CRemover)>();

late final _CRemover_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRemover_release');
late final _CRemover_release = _CRemover_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRemover_retainPtr = _lookup<ffi.NativeFunction<_CRemover Function(ffi.Pointer<ffi.Void>)>>('CRemover_retain');
late final _CRemover_retain = _CRemover_retainPtr.asFunction<_CRemover Function(ffi.Pointer<ffi.Void>)>();
late final _CRemoverMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRemover Function()>>('CRemoverMakeDefault');
late final _CRemoverMakeDefault = _CRemoverMakeDefaultPtr.asFunction<_CRemover Function()>();


late final _COptional_CRemoverMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRemover Function()>>('COptional_CRemoverMakeDefault');
late final _COptional_CRemoverMakeDefault = _COptional_CRemoverMakeDefaultPtr.asFunction<_COptional_CRemover Function()>();

late final _COptional_CRemover_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CRemover)>>('COptional_CRemover_release');
late final _COptional_CRemover_release = _COptional_CRemover_releasePtr.asFunction<void Function(_COptional_CRemover)>();

late final _CArray_CRoadEventActionmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRoadEventAction Function()>>('CArray_CRoadEventAction_makeEmpty');
late final _CArray_CRoadEventActionmakeEmpty = _CArray_CRoadEventActionmakeEmptyPtr.asFunction<_CArray_CRoadEventAction Function()>();
late final _CArray_CRoadEventActionaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventAction, _CRoadEventAction)>>('CArray_CRoadEventAction_addElement');
late final _CArray_CRoadEventActionaddElement = _CArray_CRoadEventActionaddElementPtr.asFunction<void Function(_CArray_CRoadEventAction, _CRoadEventAction)>();
late final _forEach_CArray_CRoadEventActionPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRoadEventAction, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventAction)>>)
>>('CArray_CRoadEventAction_forEachWithFunctionPointer');
late final _forEach_CArray_CRoadEventAction = _forEach_CArray_CRoadEventActionPtr.asFunction<
  void Function(_CArray_CRoadEventAction, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventAction)
>>)>();
late final _CArray_CRoadEventAction_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventAction)>>('CArray_CRoadEventAction_release');
late final _CArray_CRoadEventAction_release = _CArray_CRoadEventAction_releasePtr.asFunction<void Function(_CArray_CRoadEventAction)>();

late final _CRoadEventActionTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventActionType Function()>>('CRoadEventActionTypeMakeDefault');
late final _CRoadEventActionTypeMakeDefault = _CRoadEventActionTypeMakeDefaultPtr.asFunction<_CRoadEventActionType Function()>();
late final _CRoadEventAction_typePtr = _lookup<ffi.NativeFunction<_CRoadEventActionType Function(_CRoadEventAction)>>('CRoadEventAction_type');
late final _CRoadEventAction_type = _CRoadEventAction_typePtr.asFunction<_CRoadEventActionType Function(_CRoadEventAction)>();
late final _CRoadEventAction_namePtr = _lookup<ffi.NativeFunction<_CString Function(_CRoadEventAction)>>('CRoadEventAction_name');
late final _CRoadEventAction_name = _CRoadEventAction_namePtr.asFunction<_CString Function(_CRoadEventAction)>();
late final _CRoadEventAction_infoChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRoadEventActionInfo Function(_CRoadEventAction)>>('CRoadEventAction_infoChannel');
late final _CRoadEventAction_infoChannel = _CRoadEventAction_infoChannelPtr.asFunction<_CStatefulChannel_CRoadEventActionInfo Function(_CRoadEventAction)>();
late final _CRoadEventAction_infoPtr = _lookup<ffi.NativeFunction<_CRoadEventActionInfo Function(_CRoadEventAction)>>('CRoadEventAction_info');
late final _CRoadEventAction_info = _CRoadEventAction_infoPtr.asFunction<_CRoadEventActionInfo Function(_CRoadEventAction)>();

late final _CRoadEventAction_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEventAction_cg_objectIdentifier');
late final _CRoadEventAction_cg_objectIdentifier = _CRoadEventAction_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadEventAction_setPtr = _lookup<ffi.NativeFunction<_CFuture_CActionResult Function(_CRoadEventAction)>>('CRoadEventAction_set');
late final _CRoadEventAction_set = _CRoadEventAction_setPtr.asFunction<_CFuture_CActionResult Function(_CRoadEventAction)>();
late final _CRoadEventAction_resetPtr = _lookup<ffi.NativeFunction<_CFuture_CActionResult Function(_CRoadEventAction)>>('CRoadEventAction_reset');
late final _CRoadEventAction_reset = _CRoadEventAction_resetPtr.asFunction<_CFuture_CActionResult Function(_CRoadEventAction)>();

late final _CRoadEventAction_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEventAction_release');
late final _CRoadEventAction_release = _CRoadEventAction_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventAction_retainPtr = _lookup<ffi.NativeFunction<_CRoadEventAction Function(ffi.Pointer<ffi.Void>)>>('CRoadEventAction_retain');
late final _CRoadEventAction_retain = _CRoadEventAction_retainPtr.asFunction<_CRoadEventAction Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventActionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventAction Function()>>('CRoadEventActionMakeDefault');
late final _CRoadEventActionMakeDefault = _CRoadEventActionMakeDefaultPtr.asFunction<_CRoadEventAction Function()>();


late final _CStatefulChannel_CRoadEventActionInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRoadEventActionInfo Function()>>('CStatefulChannel_CRoadEventActionInfoMakeDefault');
late final _CStatefulChannel_CRoadEventActionInfoMakeDefault = _CStatefulChannel_CRoadEventActionInfoMakeDefaultPtr.asFunction<_CStatefulChannel_CRoadEventActionInfo Function()>();
late final _CStatefulChannel_CRoadEventActionInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CRoadEventActionInfo)>>('CStatefulChannel_CRoadEventActionInfo_release');
late final _CStatefulChannel_CRoadEventActionInfo_release = _CStatefulChannel_CRoadEventActionInfo_releasePtr.asFunction<void Function(_CStatefulChannel_CRoadEventActionInfo)>();
late final _CStatefulChannel_CRoadEventActionInfo_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRoadEventActionInfo Function(_CStatefulChannel_CRoadEventActionInfo)>>('CStatefulChannel_CRoadEventActionInfo_retain');
late final _CStatefulChannel_CRoadEventActionInfo_retain = _CStatefulChannel_CRoadEventActionInfo_retainPtr.asFunction<_CStatefulChannel_CRoadEventActionInfo Function(_CStatefulChannel_CRoadEventActionInfo)>();
late final _CStatefulChannel_CRoadEventActionInfoGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CRoadEventActionInfo Function(_CStatefulChannel_CRoadEventActionInfo)>>('CStatefulChannel_CRoadEventActionInfo_getCurrentValue');
late final _CStatefulChannel_CRoadEventActionInfoGetCurrentValue = _CStatefulChannel_CRoadEventActionInfoGetCurrentValuePtr.asFunction<_CRoadEventActionInfo Function(_CStatefulChannel_CRoadEventActionInfo)>();
late final _CStatefulChannel_CRoadEventActionInfoConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CRoadEventActionInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventActionInfo, ffi.Int64)>>
  )
>>('CStatefulChannel_CRoadEventActionInfo_connect');
late final _CStatefulChannel_CRoadEventActionInfoConnect = _CStatefulChannel_CRoadEventActionInfoConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CRoadEventActionInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventActionInfo, ffi.Int64)>>
  )
>();

late final _CRoadEventActionStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventActionState Function()>>('CRoadEventActionStateMakeDefault');
late final _CRoadEventActionStateMakeDefault = _CRoadEventActionStateMakeDefaultPtr.asFunction<_CRoadEventActionState Function()>();

late final _COptional_uint32_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_uint32_t Function()>>('COptional_uint32_tMakeDefault');
late final _COptional_uint32_tMakeDefault = _COptional_uint32_tMakeDefaultPtr.asFunction<_COptional_uint32_t Function()>();

late final _CRoadEventActionInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventActionInfo Function()>>('CRoadEventActionInfoMakeDefault');
late final _CRoadEventActionInfoMakeDefault = _CRoadEventActionInfoMakeDefaultPtr.asFunction<_CRoadEventActionInfo Function()>();

late final _CStyle_styleAttributesPtr = _lookup<ffi.NativeFunction<_CAttributes Function(_CStyle)>>('CStyle_styleAttributes');
late final _CStyle_styleAttributes = _CStyle_styleAttributesPtr.asFunction<_CAttributes Function(_CStyle)>();

late final _CStyle_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CStyle_cg_objectIdentifier');
late final _CStyle_cg_objectIdentifier = _CStyle_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CStyle_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CStyle_release');
late final _CStyle_release = _CStyle_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CStyle_retainPtr = _lookup<ffi.NativeFunction<_CStyle Function(ffi.Pointer<ffi.Void>)>>('CStyle_retain');
late final _CStyle_retain = _CStyle_retainPtr.asFunction<_CStyle Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyle Function()>>('CStyleMakeDefault');
late final _CStyleMakeDefault = _CStyleMakeDefaultPtr.asFunction<_CStyle Function()>();


late final _CStyleZoomFollowController_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CStyleZoomFollowController_cg_objectIdentifier');
late final _CStyleZoomFollowController_cg_objectIdentifier = _CStyleZoomFollowController_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CStyleZoomFollowController_setStyleZoom_CStyleZoomPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStyleZoomFollowController, _CStyleZoom)>>('CStyleZoomFollowController_setStyleZoom_CStyleZoom');
late final _CStyleZoomFollowController_setStyleZoom_CStyleZoom = _CStyleZoomFollowController_setStyleZoom_CStyleZoomPtr.asFunction<void Function(_CStyleZoomFollowController, _CStyleZoom)>();
late final _CStyleZoomFollowController_setStyleZoomRange_CStyleZoom_CStyleZoomPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStyleZoomFollowController, _CStyleZoom, _CStyleZoom)>>('CStyleZoomFollowController_setStyleZoomRange_CStyleZoom_CStyleZoom');
late final _CStyleZoomFollowController_setStyleZoomRange_CStyleZoom_CStyleZoom = _CStyleZoomFollowController_setStyleZoomRange_CStyleZoom_CStyleZoomPtr.asFunction<void Function(_CStyleZoomFollowController, _CStyleZoom, _CStyleZoom)>();
late final _CStyleZoomFollowController_C_createWith_CTimeIntervalPtr = _lookup<ffi.NativeFunction<_CStyleZoomFollowController Function(_CTimeInterval)>>('CStyleZoomFollowController_C_createWith_CTimeInterval');
late final _CStyleZoomFollowController_C_createWith_CTimeInterval = _CStyleZoomFollowController_C_createWith_CTimeIntervalPtr.asFunction<_CStyleZoomFollowController Function(_CTimeInterval)>();

late final _CStyleZoomFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CStyleZoomFollowController_release');
late final _CStyleZoomFollowController_release = _CStyleZoomFollowController_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleZoomFollowController_retainPtr = _lookup<ffi.NativeFunction<_CStyleZoomFollowController Function(ffi.Pointer<ffi.Void>)>>('CStyleZoomFollowController_retain');
late final _CStyleZoomFollowController_retain = _CStyleZoomFollowController_retainPtr.asFunction<_CStyleZoomFollowController Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleZoomFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyleZoomFollowController Function()>>('CStyleZoomFollowControllerMakeDefault');
late final _CStyleZoomFollowControllerMakeDefault = _CStyleZoomFollowControllerMakeDefaultPtr.asFunction<_CStyleZoomFollowController Function()>();


late final _CStyleZoomToTiltRelationCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CStyleZoomToTiltRelationCpp_cg_objectIdentifier');
late final _CStyleZoomToTiltRelationCpp_cg_objectIdentifier = _CStyleZoomToTiltRelationCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CStyleZoomToTiltRelationCpp_styleZoomToTilt_CStyleZoomPtr = _lookup<ffi.NativeFunction<_CTilt Function(_CStyleZoomToTiltRelationCpp, _CStyleZoom)>>('CStyleZoomToTiltRelationCpp_styleZoomToTilt_CStyleZoom');
late final _CStyleZoomToTiltRelationCpp_styleZoomToTilt_CStyleZoom = _CStyleZoomToTiltRelationCpp_styleZoomToTilt_CStyleZoomPtr.asFunction<_CTilt Function(_CStyleZoomToTiltRelationCpp, _CStyleZoom)>();

late final _CStyleZoomToTiltRelationCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CStyleZoomToTiltRelationCpp_release');
late final _CStyleZoomToTiltRelationCpp_release = _CStyleZoomToTiltRelationCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleZoomToTiltRelationCpp_retainPtr = _lookup<ffi.NativeFunction<_CStyleZoomToTiltRelationCpp Function(ffi.Pointer<ffi.Void>)>>('CStyleZoomToTiltRelationCpp_retain');
late final _CStyleZoomToTiltRelationCpp_retain = _CStyleZoomToTiltRelationCpp_retainPtr.asFunction<_CStyleZoomToTiltRelationCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleZoomToTiltRelationCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyleZoomToTiltRelationCpp Function()>>('CStyleZoomToTiltRelationCppMakeDefault');
late final _CStyleZoomToTiltRelationCppMakeDefault = _CStyleZoomToTiltRelationCppMakeDefaultPtr.asFunction<_CStyleZoomToTiltRelationCpp Function()>();


late final _CStyleZoomToTiltRelationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyleZoomToTiltRelation Function()>>('CStyleZoomToTiltRelationMakeDefault');
late final _CStyleZoomToTiltRelationMakeDefault = _CStyleZoomToTiltRelationMakeDefaultPtr.asFunction<_CStyleZoomToTiltRelation Function()>();
late final _CStyleZoomToTiltRelation_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStyleZoomToTiltRelation)>>('CStyleZoomToTiltRelation_release');
late final _CStyleZoomToTiltRelation_release = _CStyleZoomToTiltRelation_releasePtr.asFunction<void Function(_CStyleZoomToTiltRelation)>();

late final _CTiltFollowController_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTiltFollowController_cg_objectIdentifier');
late final _CTiltFollowController_cg_objectIdentifier = _CTiltFollowController_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTiltFollowController_C_createWith_CStyleZoomToTiltRelationPtr = _lookup<ffi.NativeFunction<_CTiltFollowController Function(_CStyleZoomToTiltRelation)>>('CTiltFollowController_C_createWith_CStyleZoomToTiltRelation');
late final _CTiltFollowController_C_createWith_CStyleZoomToTiltRelation = _CTiltFollowController_C_createWith_CStyleZoomToTiltRelationPtr.asFunction<_CTiltFollowController Function(_CStyleZoomToTiltRelation)>();

late final _CTiltFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTiltFollowController_release');
late final _CTiltFollowController_release = _CTiltFollowController_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTiltFollowController_retainPtr = _lookup<ffi.NativeFunction<_CTiltFollowController Function(ffi.Pointer<ffi.Void>)>>('CTiltFollowController_retain');
late final _CTiltFollowController_retain = _CTiltFollowController_retainPtr.asFunction<_CTiltFollowController Function(ffi.Pointer<ffi.Void>)>();
late final _CTiltFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTiltFollowController Function()>>('CTiltFollowControllerMakeDefault');
late final _CTiltFollowControllerMakeDefault = _CTiltFollowControllerMakeDefaultPtr.asFunction<_CTiltFollowController Function()>();


late final _CTrafficSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTrafficSource_cg_objectIdentifier');
late final _CTrafficSource_cg_objectIdentifier = _CTrafficSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTrafficSource_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CTrafficSource Function(_CContext)>>('CTrafficSource_C_createWith_CContext');
late final _CTrafficSource_C_createWith_CContext = _CTrafficSource_C_createWith_CContextPtr.asFunction<_CTrafficSource Function(_CContext)>();

late final _CTrafficSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTrafficSource_release');
late final _CTrafficSource_release = _CTrafficSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficSource_retainPtr = _lookup<ffi.NativeFunction<_CTrafficSource Function(ffi.Pointer<ffi.Void>)>>('CTrafficSource_retain');
late final _CTrafficSource_retain = _CTrafficSource_retainPtr.asFunction<_CTrafficSource Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficSource Function()>>('CTrafficSourceMakeDefault');
late final _CTrafficSourceMakeDefault = _CTrafficSourceMakeDefaultPtr.asFunction<_CTrafficSource Function()>();


late final _CRoadEventDisplayCategoryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventDisplayCategory Function()>>('CRoadEventDisplayCategoryMakeDefault');
late final _CRoadEventDisplayCategoryMakeDefault = _CRoadEventDisplayCategoryMakeDefaultPtr.asFunction<_CRoadEventDisplayCategory Function()>();
late final _CRoadEventSource_getVisibleEventsPtr = _lookup<ffi.NativeFunction<_COptionSet_CRoadEventDisplayCategory Function(_CRoadEventSource)>>('CRoadEventSource_getVisibleEvents');
late final _CRoadEventSource_getVisibleEvents = _CRoadEventSource_getVisibleEventsPtr.asFunction<_COptionSet_CRoadEventDisplayCategory Function(_CRoadEventSource)>();
late final _CRoadEventSource_setVisibleEvents_COptionSet_CRoadEventDisplayCategoryPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRoadEventSource, _COptionSet_CRoadEventDisplayCategory)>>('CRoadEventSource_setVisibleEvents_COptionSet_CRoadEventDisplayCategory');
late final _CRoadEventSource_setVisibleEvents_COptionSet_CRoadEventDisplayCategory = _CRoadEventSource_setVisibleEvents_COptionSet_CRoadEventDisplayCategoryPtr.asFunction<void Function(_CRoadEventSource, _COptionSet_CRoadEventDisplayCategory)>();
late final _CRoadEventSource_highlightedObjectsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CDgisObjectId Function(_CRoadEventSource)>>('CRoadEventSource_highlightedObjectsChannel');
late final _CRoadEventSource_highlightedObjectsChannel = _CRoadEventSource_highlightedObjectsChannelPtr.asFunction<_CStatefulChannel_CArray_CDgisObjectId Function(_CRoadEventSource)>();
late final _CRoadEventSource_highlightedObjectsPtr = _lookup<ffi.NativeFunction<_CArray_CDgisObjectId Function(_CRoadEventSource)>>('CRoadEventSource_highlightedObjects');
late final _CRoadEventSource_highlightedObjects = _CRoadEventSource_highlightedObjectsPtr.asFunction<_CArray_CDgisObjectId Function(_CRoadEventSource)>();

late final _CRoadEventSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEventSource_cg_objectIdentifier');
late final _CRoadEventSource_cg_objectIdentifier = _CRoadEventSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadEventSource_setHighlighted_CArray_CDgisObjectId_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRoadEventSource, _CArray_CDgisObjectId, ffi.Bool)>>('CRoadEventSource_setHighlighted_CArray_CDgisObjectId_bool');
late final _CRoadEventSource_setHighlighted_CArray_CDgisObjectId_bool = _CRoadEventSource_setHighlighted_CArray_CDgisObjectId_boolPtr.asFunction<void Function(_CRoadEventSource, _CArray_CDgisObjectId, bool)>();
late final _CRoadEventSource_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CRoadEventSource Function(_CContext)>>('CRoadEventSource_C_createWith_CContext');
late final _CRoadEventSource_C_createWith_CContext = _CRoadEventSource_C_createWith_CContextPtr.asFunction<_CRoadEventSource Function(_CContext)>();

late final _CRoadEventSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEventSource_release');
late final _CRoadEventSource_release = _CRoadEventSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventSource_retainPtr = _lookup<ffi.NativeFunction<_CRoadEventSource Function(ffi.Pointer<ffi.Void>)>>('CRoadEventSource_retain');
late final _CRoadEventSource_retain = _CRoadEventSource_retainPtr.asFunction<_CRoadEventSource Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventSource Function()>>('CRoadEventSourceMakeDefault');
late final _CRoadEventSourceMakeDefault = _CRoadEventSourceMakeDefaultPtr.asFunction<_CRoadEventSource Function()>();


late final _COptionSet_CRoadEventDisplayCategoryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CRoadEventDisplayCategory Function()>>('COptionSet_CRoadEventDisplayCategoryMakeDefault');
late final _COptionSet_CRoadEventDisplayCategoryMakeDefault = _COptionSet_CRoadEventDisplayCategoryMakeDefaultPtr.asFunction<_COptionSet_CRoadEventDisplayCategory Function()>();

late final _CAlignmentMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAlignment Function()>>('CAlignmentMakeDefault');
late final _CAlignmentMakeDefault = _CAlignmentMakeDefaultPtr.asFunction<_CAlignment Function()>();

late final _CAnimationModeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAnimationMode Function()>>('CAnimationModeMakeDefault');
late final _CAnimationModeMakeDefault = _CAnimationModeMakeDefaultPtr.asFunction<_CAnimationMode Function()>();

late final _CLogicalPixelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLogicalPixel Function()>>('CLogicalPixelMakeDefault');
late final _CLogicalPixelMakeDefault = _CLogicalPixelMakeDefaultPtr.asFunction<_CLogicalPixel Function()>();


late final _CMapDataLoadingStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapDataLoadingState Function()>>('CMapDataLoadingStateMakeDefault');
late final _CMapDataLoadingStateMakeDefault = _CMapDataLoadingStateMakeDefaultPtr.asFunction<_CMapDataLoadingState Function()>();

late final _CMapDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapDirection Function()>>('CMapDirectionMakeDefault');
late final _CMapDirectionMakeDefault = _CMapDirectionMakeDefaultPtr.asFunction<_CMapDirection Function()>();


late final _CMapIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapId Function()>>('CMapIdMakeDefault');
late final _CMapIdMakeDefault = _CMapIdMakeDefaultPtr.asFunction<_CMapId Function()>();


late final _CMapVisibilityStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapVisibilityState Function()>>('CMapVisibilityStateMakeDefault');
late final _CMapVisibilityStateMakeDefault = _CMapVisibilityStateMakeDefaultPtr.asFunction<_CMapVisibilityState Function()>();

late final _COpacityMakeDefaultPtr = _lookup<ffi.NativeFunction<_COpacity Function()>>('COpacityMakeDefault');
late final _COpacityMakeDefault = _COpacityMakeDefaultPtr.asFunction<_COpacity Function()>();


late final _CPaddingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPadding Function()>>('CPaddingMakeDefault');
late final _CPaddingMakeDefault = _CPaddingMakeDefaultPtr.asFunction<_CPadding Function()>();


late final _CProductTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CProductType Function()>>('CProductTypeMakeDefault');
late final _CProductTypeMakeDefault = _CProductTypeMakeDefaultPtr.asFunction<_CProductType Function()>();

late final _CModelScaleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelScale Function()>>('CModelScaleMakeDefault');
late final _CModelScaleMakeDefault = _CModelScaleMakeDefaultPtr.asFunction<_CModelScale Function()>();


late final _CRenderedObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRenderedObject Function()>>('CRenderedObjectMakeDefault');
late final _CRenderedObjectMakeDefault = _CRenderedObjectMakeDefaultPtr.asFunction<_CRenderedObject Function()>();


late final _CScreenDistanceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScreenDistance Function()>>('CScreenDistanceMakeDefault');
late final _CScreenDistanceMakeDefault = _CScreenDistanceMakeDefaultPtr.asFunction<_CScreenDistance Function()>();


late final _CStyleLayerIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyleLayerId Function()>>('CStyleLayerIdMakeDefault');
late final _CStyleLayerIdMakeDefault = _CStyleLayerIdMakeDefaultPtr.asFunction<_CStyleLayerId Function()>();


late final _CTextHorizontalAlignmentMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTextHorizontalAlignment Function()>>('CTextHorizontalAlignmentMakeDefault');
late final _CTextHorizontalAlignmentMakeDefault = _CTextHorizontalAlignmentMakeDefaultPtr.asFunction<_CTextHorizontalAlignment Function()>();

late final _CTextPlacementMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTextPlacement Function()>>('CTextPlacementMakeDefault');
late final _CTextPlacementMakeDefault = _CTextPlacementMakeDefaultPtr.asFunction<_CTextPlacement Function()>();

late final _CTextStyleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTextStyle Function()>>('CTextStyleMakeDefault');
late final _CTextStyleMakeDefault = _CTextStyleMakeDefaultPtr.asFunction<_CTextStyle Function()>();


late final _COptional_CFollowPositionMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CFollowPosition Function()>>('COptional_CFollowPositionMakeDefault');
late final _COptional_CFollowPositionMakeDefault = _COptional_CFollowPositionMakeDefaultPtr.asFunction<_COptional_CFollowPosition Function()>();

late final _CCameraBehaviourMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraBehaviour Function()>>('CCameraBehaviourMakeDefault');
late final _CCameraBehaviourMakeDefault = _CCameraBehaviourMakeDefaultPtr.asFunction<_CCameraBehaviour Function()>();


late final _CCameraBehaviourChangeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraBehaviourChange Function()>>('CCameraBehaviourChangeMakeDefault');
late final _CCameraBehaviourChangeMakeDefault = _CCameraBehaviourChangeMakeDefaultPtr.asFunction<_CCameraBehaviourChange Function()>();


late final _COptional_CZoomMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CZoom Function()>>('COptional_CZoomMakeDefault');
late final _COptional_CZoomMakeDefault = _COptional_CZoomMakeDefaultPtr.asFunction<_COptional_CZoom Function()>();

late final _CCameraPositionChangeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraPositionChange Function()>>('CCameraPositionChangeMakeDefault');
late final _CCameraPositionChangeMakeDefault = _CCameraPositionChangeMakeDefaultPtr.asFunction<_CCameraPositionChange Function()>();


late final _CCameraZoomRestrictionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraZoomRestrictions Function()>>('CCameraZoomRestrictionsMakeDefault');
late final _CCameraZoomRestrictionsMakeDefault = _CCameraZoomRestrictionsMakeDefaultPtr.asFunction<_CCameraZoomRestrictions Function()>();


late final _CGeometryMapObjectBuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectBuilder_cg_objectIdentifier');
late final _CGeometryMapObjectBuilder_cg_objectIdentifier = _CGeometryMapObjectBuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CGeometryMapObjectBuilder_setObjectAttribute_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CString, _CAttributeValue)>>('CGeometryMapObjectBuilder_setObjectAttribute_CString_CAttributeValue');
late final _CGeometryMapObjectBuilder_setObjectAttribute_CString_CAttributeValue = _CGeometryMapObjectBuilder_setObjectAttribute_CString_CAttributeValuePtr.asFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CString, _CAttributeValue)>();
late final _CGeometryMapObjectBuilder_setObjectAttributes_CDictionary_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CDictionary_CString_CAttributeValue)>>('CGeometryMapObjectBuilder_setObjectAttributes_CDictionary_CString_CAttributeValue');
late final _CGeometryMapObjectBuilder_setObjectAttributes_CDictionary_CString_CAttributeValue = _CGeometryMapObjectBuilder_setObjectAttributes_CDictionary_CString_CAttributeValuePtr.asFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CDictionary_CString_CAttributeValue)>();
late final _CGeometryMapObjectBuilder_setGeometry_CGeometryPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CGeometry)>>('CGeometryMapObjectBuilder_setGeometry_CGeometry');
late final _CGeometryMapObjectBuilder_setGeometry_CGeometry = _CGeometryMapObjectBuilder_setGeometry_CGeometryPtr.asFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CGeometry)>();
late final _CGeometryMapObjectBuilder_setVisible_boolPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, ffi.Bool)>>('CGeometryMapObjectBuilder_setVisible_bool');
late final _CGeometryMapObjectBuilder_setVisible_bool = _CGeometryMapObjectBuilder_setVisible_boolPtr.asFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, bool)>();
late final _CGeometryMapObjectBuilder_setDraggable_boolPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, ffi.Bool)>>('CGeometryMapObjectBuilder_setDraggable_bool');
late final _CGeometryMapObjectBuilder_setDraggable_bool = _CGeometryMapObjectBuilder_setDraggable_boolPtr.asFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, bool)>();
late final _CGeometryMapObjectBuilder_setUserData_CAnyPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CAny)>>('CGeometryMapObjectBuilder_setUserData_CAny');
late final _CGeometryMapObjectBuilder_setUserData_CAny = _CGeometryMapObjectBuilder_setUserData_CAnyPtr.asFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CAny)>();
late final _CGeometryMapObjectBuilder_createObjectPtr = _lookup<ffi.NativeFunction<_CGeometryMapObject Function(_CGeometryMapObjectBuilder)>>('CGeometryMapObjectBuilder_createObject');
late final _CGeometryMapObjectBuilder_createObject = _CGeometryMapObjectBuilder_createObjectPtr.asFunction<_CGeometryMapObject Function(_CGeometryMapObjectBuilder)>();
late final _CGeometryMapObjectBuilder_C_createPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function()>>('CGeometryMapObjectBuilder_C_create');
late final _CGeometryMapObjectBuilder_C_create = _CGeometryMapObjectBuilder_C_createPtr.asFunction<_CGeometryMapObjectBuilder Function()>();

late final _CGeometryMapObjectBuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectBuilder_release');
late final _CGeometryMapObjectBuilder_release = _CGeometryMapObjectBuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectBuilder_retainPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectBuilder_retain');
late final _CGeometryMapObjectBuilder_retain = _CGeometryMapObjectBuilder_retainPtr.asFunction<_CGeometryMapObjectBuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectBuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function()>>('CGeometryMapObjectBuilderMakeDefault');
late final _CGeometryMapObjectBuilderMakeDefault = _CGeometryMapObjectBuilderMakeDefaultPtr.asFunction<_CGeometryMapObjectBuilder Function()>();


late final _CGeometryMapObjectSourceBuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectSourceBuilder_cg_objectIdentifier');
late final _CGeometryMapObjectSourceBuilder_cg_objectIdentifier = _CGeometryMapObjectSourceBuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CGeometryMapObjectSourceBuilder_setSourceAttribute_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CString, _CAttributeValue)>>('CGeometryMapObjectSourceBuilder_setSourceAttribute_CString_CAttributeValue');
late final _CGeometryMapObjectSourceBuilder_setSourceAttribute_CString_CAttributeValue = _CGeometryMapObjectSourceBuilder_setSourceAttribute_CString_CAttributeValuePtr.asFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CString, _CAttributeValue)>();
late final _CGeometryMapObjectSourceBuilder_setSourceAttributes_CDictionary_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CDictionary_CString_CAttributeValue)>>('CGeometryMapObjectSourceBuilder_setSourceAttributes_CDictionary_CString_CAttributeValue');
late final _CGeometryMapObjectSourceBuilder_setSourceAttributes_CDictionary_CString_CAttributeValue = _CGeometryMapObjectSourceBuilder_setSourceAttributes_CDictionary_CString_CAttributeValuePtr.asFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CDictionary_CString_CAttributeValue)>();
late final _CGeometryMapObjectSourceBuilder_addObject_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CGeometryMapObject)>>('CGeometryMapObjectSourceBuilder_addObject_CGeometryMapObject');
late final _CGeometryMapObjectSourceBuilder_addObject_CGeometryMapObject = _CGeometryMapObjectSourceBuilder_addObject_CGeometryMapObjectPtr.asFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CGeometryMapObject)>();
late final _CGeometryMapObjectSourceBuilder_addObjects_CArray_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CArray_CGeometryMapObject)>>('CGeometryMapObjectSourceBuilder_addObjects_CArray_CGeometryMapObject');
late final _CGeometryMapObjectSourceBuilder_addObjects_CArray_CGeometryMapObject = _CGeometryMapObjectSourceBuilder_addObjects_CArray_CGeometryMapObjectPtr.asFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CArray_CGeometryMapObject)>();
late final _CGeometryMapObjectSourceBuilder_createSourcePtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSource Function(_CGeometryMapObjectSourceBuilder)>>('CGeometryMapObjectSourceBuilder_createSource');
late final _CGeometryMapObjectSourceBuilder_createSource = _CGeometryMapObjectSourceBuilder_createSourcePtr.asFunction<_CGeometryMapObjectSource Function(_CGeometryMapObjectSourceBuilder)>();
late final _CGeometryMapObjectSourceBuilder_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function(_CContext)>>('CGeometryMapObjectSourceBuilder_C_createWith_CContext');
late final _CGeometryMapObjectSourceBuilder_C_createWith_CContext = _CGeometryMapObjectSourceBuilder_C_createWith_CContextPtr.asFunction<_CGeometryMapObjectSourceBuilder Function(_CContext)>();

late final _CGeometryMapObjectSourceBuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectSourceBuilder_release');
late final _CGeometryMapObjectSourceBuilder_release = _CGeometryMapObjectSourceBuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectSourceBuilder_retainPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectSourceBuilder_retain');
late final _CGeometryMapObjectSourceBuilder_retain = _CGeometryMapObjectSourceBuilder_retainPtr.asFunction<_CGeometryMapObjectSourceBuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectSourceBuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function()>>('CGeometryMapObjectSourceBuilderMakeDefault');
late final _CGeometryMapObjectSourceBuilderMakeDefault = _CGeometryMapObjectSourceBuilderMakeDefaultPtr.asFunction<_CGeometryMapObjectSourceBuilder Function()>();

late final _CIndoorBuilding_idPtr = _lookup<ffi.NativeFunction<_CDgisObjectId Function(_CIndoorBuilding)>>('CIndoorBuilding_id');
late final _CIndoorBuilding_id = _CIndoorBuilding_idPtr.asFunction<_CDgisObjectId Function(_CIndoorBuilding)>();
late final _CIndoorBuilding_defaultLevelIndexPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CIndoorBuilding)>>('CIndoorBuilding_defaultLevelIndex');
late final _CIndoorBuilding_defaultLevelIndex = _CIndoorBuilding_defaultLevelIndexPtr.asFunction<int Function(_CIndoorBuilding)>();
late final _CIndoorBuilding_levelsPtr = _lookup<ffi.NativeFunction<_CArray_CLevelInfo Function(_CIndoorBuilding)>>('CIndoorBuilding_levels');
late final _CIndoorBuilding_levels = _CIndoorBuilding_levelsPtr.asFunction<_CArray_CLevelInfo Function(_CIndoorBuilding)>();
late final _CIndoorBuilding_activeLevelIndexChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_uint64_t Function(_CIndoorBuilding)>>('CIndoorBuilding_activeLevelIndexChannel');
late final _CIndoorBuilding_activeLevelIndexChannel = _CIndoorBuilding_activeLevelIndexChannelPtr.asFunction<_CStatefulChannel_uint64_t Function(_CIndoorBuilding)>();
late final _CIndoorBuilding_activeLevelIndexPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CIndoorBuilding)>>('CIndoorBuilding_activeLevelIndex');
late final _CIndoorBuilding_activeLevelIndex = _CIndoorBuilding_activeLevelIndexPtr.asFunction<int Function(_CIndoorBuilding)>();
late final _CIndoorBuilding_setActiveLevelIndex_uint64_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CIndoorBuilding, ffi.Uint64)>>('CIndoorBuilding_setActiveLevelIndex_uint64_t');
late final _CIndoorBuilding_setActiveLevelIndex_uint64_t = _CIndoorBuilding_setActiveLevelIndex_uint64_tPtr.asFunction<void Function(_CIndoorBuilding, int)>();

late final _CIndoorBuilding_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CIndoorBuilding_cg_objectIdentifier');
late final _CIndoorBuilding_cg_objectIdentifier = _CIndoorBuilding_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CIndoorBuilding_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CIndoorBuilding_release');
late final _CIndoorBuilding_release = _CIndoorBuilding_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorBuilding_retainPtr = _lookup<ffi.NativeFunction<_CIndoorBuilding Function(ffi.Pointer<ffi.Void>)>>('CIndoorBuilding_retain');
late final _CIndoorBuilding_retain = _CIndoorBuilding_retainPtr.asFunction<_CIndoorBuilding Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorBuildingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIndoorBuilding Function()>>('CIndoorBuildingMakeDefault');
late final _CIndoorBuildingMakeDefault = _CIndoorBuildingMakeDefaultPtr.asFunction<_CIndoorBuilding Function()>();


late final _CStatefulChannel_uint64_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_uint64_t Function()>>('CStatefulChannel_uint64_tMakeDefault');
late final _CStatefulChannel_uint64_tMakeDefault = _CStatefulChannel_uint64_tMakeDefaultPtr.asFunction<_CStatefulChannel_uint64_t Function()>();
late final _CStatefulChannel_uint64_t_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_uint64_t)>>('CStatefulChannel_uint64_t_release');
late final _CStatefulChannel_uint64_t_release = _CStatefulChannel_uint64_t_releasePtr.asFunction<void Function(_CStatefulChannel_uint64_t)>();
late final _CStatefulChannel_uint64_t_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_uint64_t Function(_CStatefulChannel_uint64_t)>>('CStatefulChannel_uint64_t_retain');
late final _CStatefulChannel_uint64_t_retain = _CStatefulChannel_uint64_t_retainPtr.asFunction<_CStatefulChannel_uint64_t Function(_CStatefulChannel_uint64_t)>();
late final _CStatefulChannel_uint64_tGetCurrentValuePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CStatefulChannel_uint64_t)>>('CStatefulChannel_uint64_t_getCurrentValue');
late final _CStatefulChannel_uint64_tGetCurrentValue = _CStatefulChannel_uint64_tGetCurrentValuePtr.asFunction<int Function(_CStatefulChannel_uint64_t)>();
late final _CStatefulChannel_uint64_tConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_uint64_t,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint64, ffi.Int64)>>
  )
>>('CStatefulChannel_uint64_t_connect');
late final _CStatefulChannel_uint64_tConnect = _CStatefulChannel_uint64_tConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_uint64_t,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint64, ffi.Int64)>>
  )
>();

late final _CIndoorManagerStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIndoorManagerState Function()>>('CIndoorManagerStateMakeDefault');
late final _CIndoorManagerStateMakeDefault = _CIndoorManagerStateMakeDefaultPtr.asFunction<_CIndoorManagerState Function()>();
late final _CIndoorManager_focusedBuildingChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CIndoorBuilding Function(_CIndoorManager)>>('CIndoorManager_focusedBuildingChannel');
late final _CIndoorManager_focusedBuildingChannel = _CIndoorManager_focusedBuildingChannelPtr.asFunction<_CStatefulChannel_COptional_CIndoorBuilding Function(_CIndoorManager)>();
late final _CIndoorManager_focusedBuildingPtr = _lookup<ffi.NativeFunction<_COptional_CIndoorBuilding Function(_CIndoorManager)>>('CIndoorManager_focusedBuilding');
late final _CIndoorManager_focusedBuilding = _CIndoorManager_focusedBuildingPtr.asFunction<_COptional_CIndoorBuilding Function(_CIndoorManager)>();

late final _CIndoorManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CIndoorManager_cg_objectIdentifier');
late final _CIndoorManager_cg_objectIdentifier = _CIndoorManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CIndoorManager_setIndoorState_CIndoorManagerStatePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CIndoorManager, _CIndoorManagerState)>>('CIndoorManager_setIndoorState_CIndoorManagerState');
late final _CIndoorManager_setIndoorState_CIndoorManagerState = _CIndoorManager_setIndoorState_CIndoorManagerStatePtr.asFunction<void Function(_CIndoorManager, _CIndoorManagerState)>();

late final _CIndoorManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CIndoorManager_release');
late final _CIndoorManager_release = _CIndoorManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorManager_retainPtr = _lookup<ffi.NativeFunction<_CIndoorManager Function(ffi.Pointer<ffi.Void>)>>('CIndoorManager_retain');
late final _CIndoorManager_retain = _CIndoorManager_retainPtr.asFunction<_CIndoorManager Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIndoorManager Function()>>('CIndoorManagerMakeDefault');
late final _CIndoorManagerMakeDefault = _CIndoorManagerMakeDefaultPtr.asFunction<_CIndoorManager Function()>();


late final _CStatefulChannel_COptional_CIndoorBuildingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CIndoorBuilding Function()>>('CStatefulChannel_COptional_CIndoorBuildingMakeDefault');
late final _CStatefulChannel_COptional_CIndoorBuildingMakeDefault = _CStatefulChannel_COptional_CIndoorBuildingMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CIndoorBuilding Function()>();
late final _CStatefulChannel_COptional_CIndoorBuilding_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CIndoorBuilding)>>('CStatefulChannel_COptional_CIndoorBuilding_release');
late final _CStatefulChannel_COptional_CIndoorBuilding_release = _CStatefulChannel_COptional_CIndoorBuilding_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CIndoorBuilding)>();
late final _CStatefulChannel_COptional_CIndoorBuilding_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CIndoorBuilding Function(_CStatefulChannel_COptional_CIndoorBuilding)>>('CStatefulChannel_COptional_CIndoorBuilding_retain');
late final _CStatefulChannel_COptional_CIndoorBuilding_retain = _CStatefulChannel_COptional_CIndoorBuilding_retainPtr.asFunction<_CStatefulChannel_COptional_CIndoorBuilding Function(_CStatefulChannel_COptional_CIndoorBuilding)>();
late final _CStatefulChannel_COptional_CIndoorBuildingGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CIndoorBuilding Function(_CStatefulChannel_COptional_CIndoorBuilding)>>('CStatefulChannel_COptional_CIndoorBuilding_getCurrentValue');
late final _CStatefulChannel_COptional_CIndoorBuildingGetCurrentValue = _CStatefulChannel_COptional_CIndoorBuildingGetCurrentValuePtr.asFunction<_COptional_CIndoorBuilding Function(_CStatefulChannel_COptional_CIndoorBuilding)>();
late final _CStatefulChannel_COptional_CIndoorBuildingConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CIndoorBuilding,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CIndoorBuilding, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CIndoorBuilding_connect');
late final _CStatefulChannel_COptional_CIndoorBuildingConnect = _CStatefulChannel_COptional_CIndoorBuildingConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CIndoorBuilding,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CIndoorBuilding, ffi.Int64)>>
  )
>();

late final _COptional_CIndoorBuildingMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CIndoorBuilding Function()>>('COptional_CIndoorBuildingMakeDefault');
late final _COptional_CIndoorBuildingMakeDefault = _COptional_CIndoorBuildingMakeDefaultPtr.asFunction<_COptional_CIndoorBuilding Function()>();

late final _COptional_CIndoorBuilding_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CIndoorBuilding)>>('COptional_CIndoorBuilding_release');
late final _COptional_CIndoorBuilding_release = _COptional_CIndoorBuilding_releasePtr.asFunction<void Function(_COptional_CIndoorBuilding)>();
late final _CIndoorControlModel_activeLevelIndexChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_uint64_t Function(_CIndoorControlModel)>>('CIndoorControlModel_activeLevelIndexChannel');
late final _CIndoorControlModel_activeLevelIndexChannel = _CIndoorControlModel_activeLevelIndexChannelPtr.asFunction<_CStatefulChannel_COptional_uint64_t Function(_CIndoorControlModel)>();
late final _CIndoorControlModel_activeLevelIndexPtr = _lookup<ffi.NativeFunction<_COptional_uint64_t Function(_CIndoorControlModel)>>('CIndoorControlModel_activeLevelIndex');
late final _CIndoorControlModel_activeLevelIndex = _CIndoorControlModel_activeLevelIndexPtr.asFunction<_COptional_uint64_t Function(_CIndoorControlModel)>();
late final _CIndoorControlModel_setActiveLevelIndex_COptional_uint64_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CIndoorControlModel, _COptional_uint64_t)>>('CIndoorControlModel_setActiveLevelIndex_COptional_uint64_t');
late final _CIndoorControlModel_setActiveLevelIndex_COptional_uint64_t = _CIndoorControlModel_setActiveLevelIndex_COptional_uint64_tPtr.asFunction<void Function(_CIndoorControlModel, _COptional_uint64_t)>();
late final _CIndoorControlModel_markedLevelsPtr = _lookup<ffi.NativeFunction<_CSet_CLevelId Function(_CIndoorControlModel)>>('CIndoorControlModel_markedLevels');
late final _CIndoorControlModel_markedLevels = _CIndoorControlModel_markedLevelsPtr.asFunction<_CSet_CLevelId Function(_CIndoorControlModel)>();
late final _CIndoorControlModel_setMarkedLevels_CSet_CLevelIdPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CIndoorControlModel, _CSet_CLevelId)>>('CIndoorControlModel_setMarkedLevels_CSet_CLevelId');
late final _CIndoorControlModel_setMarkedLevels_CSet_CLevelId = _CIndoorControlModel_setMarkedLevels_CSet_CLevelIdPtr.asFunction<void Function(_CIndoorControlModel, _CSet_CLevelId)>();
late final _CIndoorControlModel_levelNamesChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CString Function(_CIndoorControlModel)>>('CIndoorControlModel_levelNamesChannel');
late final _CIndoorControlModel_levelNamesChannel = _CIndoorControlModel_levelNamesChannelPtr.asFunction<_CStatefulChannel_CArray_CString Function(_CIndoorControlModel)>();
late final _CIndoorControlModel_levelNamesPtr = _lookup<ffi.NativeFunction<_CArray_CString Function(_CIndoorControlModel)>>('CIndoorControlModel_levelNames');
late final _CIndoorControlModel_levelNames = _CIndoorControlModel_levelNamesPtr.asFunction<_CArray_CString Function(_CIndoorControlModel)>();

late final _CIndoorControlModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CIndoorControlModel_cg_objectIdentifier');
late final _CIndoorControlModel_cg_objectIdentifier = _CIndoorControlModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CIndoorControlModel_isLevelMarked_uint64_tPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CIndoorControlModel, ffi.Uint64)>>('CIndoorControlModel_isLevelMarked_uint64_t');
late final _CIndoorControlModel_isLevelMarked_uint64_t = _CIndoorControlModel_isLevelMarked_uint64_tPtr.asFunction<bool Function(_CIndoorControlModel, int)>();
late final _CIndoorControlModel_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CIndoorControlModel Function(_CMap)>>('CIndoorControlModel_C_createWith_CMap');
late final _CIndoorControlModel_C_createWith_CMap = _CIndoorControlModel_C_createWith_CMapPtr.asFunction<_CIndoorControlModel Function(_CMap)>();

late final _CIndoorControlModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CIndoorControlModel_release');
late final _CIndoorControlModel_release = _CIndoorControlModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorControlModel_retainPtr = _lookup<ffi.NativeFunction<_CIndoorControlModel Function(ffi.Pointer<ffi.Void>)>>('CIndoorControlModel_retain');
late final _CIndoorControlModel_retain = _CIndoorControlModel_retainPtr.asFunction<_CIndoorControlModel Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorControlModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIndoorControlModel Function()>>('CIndoorControlModelMakeDefault');
late final _CIndoorControlModelMakeDefault = _CIndoorControlModelMakeDefaultPtr.asFunction<_CIndoorControlModel Function()>();


late final _CStatefulChannel_COptional_uint64_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_uint64_t Function()>>('CStatefulChannel_COptional_uint64_tMakeDefault');
late final _CStatefulChannel_COptional_uint64_tMakeDefault = _CStatefulChannel_COptional_uint64_tMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_uint64_t Function()>();
late final _CStatefulChannel_COptional_uint64_t_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_uint64_t)>>('CStatefulChannel_COptional_uint64_t_release');
late final _CStatefulChannel_COptional_uint64_t_release = _CStatefulChannel_COptional_uint64_t_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_uint64_t)>();
late final _CStatefulChannel_COptional_uint64_t_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_uint64_t Function(_CStatefulChannel_COptional_uint64_t)>>('CStatefulChannel_COptional_uint64_t_retain');
late final _CStatefulChannel_COptional_uint64_t_retain = _CStatefulChannel_COptional_uint64_t_retainPtr.asFunction<_CStatefulChannel_COptional_uint64_t Function(_CStatefulChannel_COptional_uint64_t)>();
late final _CStatefulChannel_COptional_uint64_tGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_uint64_t Function(_CStatefulChannel_COptional_uint64_t)>>('CStatefulChannel_COptional_uint64_t_getCurrentValue');
late final _CStatefulChannel_COptional_uint64_tGetCurrentValue = _CStatefulChannel_COptional_uint64_tGetCurrentValuePtr.asFunction<_COptional_uint64_t Function(_CStatefulChannel_COptional_uint64_t)>();
late final _CStatefulChannel_COptional_uint64_tConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_uint64_t,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_uint64_t, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_uint64_t_connect');
late final _CStatefulChannel_COptional_uint64_tConnect = _CStatefulChannel_COptional_uint64_tConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_uint64_t,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_uint64_t, ffi.Int64)>>
  )
>();

late final _CSet_CLevelIdmakeEmptyPtr = _lookup<ffi.NativeFunction<_CSet_CLevelId Function()>>('CSet_CLevelId_makeEmpty');
late final _CSet_CLevelIdmakeEmpty = _CSet_CLevelIdmakeEmptyPtr.asFunction<_CSet_CLevelId Function()>();
late final _CSet_CLevelIdaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSet_CLevelId, _CLevelId)>>('CSet_CLevelId_addElement');
late final _CSet_CLevelIdaddElement = _CSet_CLevelIdaddElementPtr.asFunction<void Function(_CSet_CLevelId, _CLevelId)>();
late final _forEach_CSet_CLevelIdPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CSet_CLevelId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLevelId)>>)
>>('CSet_CLevelId_forEachWithFunctionPointer');
late final _forEach_CSet_CLevelId = _forEach_CSet_CLevelIdPtr.asFunction<
  void Function(_CSet_CLevelId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLevelId)
>>)>();
late final _CSet_CLevelId_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSet_CLevelId)>>('CSet_CLevelId_release');
late final _CSet_CLevelId_release = _CSet_CLevelId_releasePtr.asFunction<void Function(_CSet_CLevelId)>();

late final _CStatefulChannel_CArray_CStringMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CString Function()>>('CStatefulChannel_CArray_CStringMakeDefault');
late final _CStatefulChannel_CArray_CStringMakeDefault = _CStatefulChannel_CArray_CStringMakeDefaultPtr.asFunction<_CStatefulChannel_CArray_CString Function()>();
late final _CStatefulChannel_CArray_CString_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CArray_CString)>>('CStatefulChannel_CArray_CString_release');
late final _CStatefulChannel_CArray_CString_release = _CStatefulChannel_CArray_CString_releasePtr.asFunction<void Function(_CStatefulChannel_CArray_CString)>();
late final _CStatefulChannel_CArray_CString_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CString Function(_CStatefulChannel_CArray_CString)>>('CStatefulChannel_CArray_CString_retain');
late final _CStatefulChannel_CArray_CString_retain = _CStatefulChannel_CArray_CString_retainPtr.asFunction<_CStatefulChannel_CArray_CString Function(_CStatefulChannel_CArray_CString)>();
late final _CStatefulChannel_CArray_CStringGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CArray_CString Function(_CStatefulChannel_CArray_CString)>>('CStatefulChannel_CArray_CString_getCurrentValue');
late final _CStatefulChannel_CArray_CStringGetCurrentValue = _CStatefulChannel_CArray_CStringGetCurrentValuePtr.asFunction<_CArray_CString Function(_CStatefulChannel_CArray_CString)>();
late final _CStatefulChannel_CArray_CStringConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CString,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CString, ffi.Int64)>>
  )
>>('CStatefulChannel_CArray_CString_connect');
late final _CStatefulChannel_CArray_CStringConnect = _CStatefulChannel_CArray_CStringConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CString,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CString, ffi.Int64)>>
  )
>();
late final _CMap_idPtr = _lookup<ffi.NativeFunction<_CMapId Function(_CMap)>>('CMap_id');
late final _CMap_id = _CMap_idPtr.asFunction<_CMapId Function(_CMap)>();
late final _CMap_cameraPtr = _lookup<ffi.NativeFunction<_CCamera Function(_CMap)>>('CMap_camera');
late final _CMap_camera = _CMap_cameraPtr.asFunction<_CCamera Function(_CMap)>();
late final _CMap_indoorManagerPtr = _lookup<ffi.NativeFunction<_CIndoorManager Function(_CMap)>>('CMap_indoorManager');
late final _CMap_indoorManager = _CMap_indoorManagerPtr.asFunction<_CIndoorManager Function(_CMap)>();
late final _CMap_dataLoadingStateChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CMapDataLoadingState Function(_CMap)>>('CMap_dataLoadingStateChannel');
late final _CMap_dataLoadingStateChannel = _CMap_dataLoadingStateChannelPtr.asFunction<_CStatefulChannel_CMapDataLoadingState Function(_CMap)>();
late final _CMap_dataLoadingStatePtr = _lookup<ffi.NativeFunction<_CMapDataLoadingState Function(_CMap)>>('CMap_dataLoadingState');
late final _CMap_dataLoadingState = _CMap_dataLoadingStatePtr.asFunction<_CMapDataLoadingState Function(_CMap)>();
late final _CMap_styleChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CStyle Function(_CMap)>>('CMap_styleChannel');
late final _CMap_styleChannel = _CMap_styleChannelPtr.asFunction<_CStatefulChannel_CStyle Function(_CMap)>();
late final _CMap_stylePtr = _lookup<ffi.NativeFunction<_CStyle Function(_CMap)>>('CMap_style');
late final _CMap_style = _CMap_stylePtr.asFunction<_CStyle Function(_CMap)>();
late final _CMap_setStyle_CStylePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, _CStyle)>>('CMap_setStyle_CStyle');
late final _CMap_setStyle_CStyle = _CMap_setStyle_CStylePtr.asFunction<void Function(_CMap, _CStyle)>();
late final _CMap_fontIconSizeMultiplierChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_float Function(_CMap)>>('CMap_fontIconSizeMultiplierChannel');
late final _CMap_fontIconSizeMultiplierChannel = _CMap_fontIconSizeMultiplierChannelPtr.asFunction<_CStatefulChannel_float Function(_CMap)>();
late final _CMap_fontIconSizeMultiplierPtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CMap)>>('CMap_fontIconSizeMultiplier');
late final _CMap_fontIconSizeMultiplier = _CMap_fontIconSizeMultiplierPtr.asFunction<double Function(_CMap)>();
late final _CMap_setFontIconSizeMultiplier_floatPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CMap, ffi.Float)>>('CMap_setFontIconSizeMultiplier_float');
late final _CMap_setFontIconSizeMultiplier_float = _CMap_setFontIconSizeMultiplier_floatPtr.asFunction<_CResult_CEmpty Function(_CMap, double)>();
late final _CMap_getSourcesPtr = _lookup<ffi.NativeFunction<_CArray_CSource Function(_CMap)>>('CMap_getSources');
late final _CMap_getSources = _CMap_getSourcesPtr.asFunction<_CArray_CSource Function(_CMap)>();
late final _CMap_mapVisibilityStateChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CMapVisibilityState Function(_CMap)>>('CMap_mapVisibilityStateChannel');
late final _CMap_mapVisibilityStateChannel = _CMap_mapVisibilityStateChannelPtr.asFunction<_CStatefulChannel_CMapVisibilityState Function(_CMap)>();
late final _CMap_mapVisibilityStatePtr = _lookup<ffi.NativeFunction<_CMapVisibilityState Function(_CMap)>>('CMap_mapVisibilityState');
late final _CMap_mapVisibilityState = _CMap_mapVisibilityStatePtr.asFunction<_CMapVisibilityState Function(_CMap)>();
late final _CMap_setMapVisibilityState_CMapVisibilityStatePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, _CMapVisibilityState)>>('CMap_setMapVisibilityState_CMapVisibilityState');
late final _CMap_setMapVisibilityState_CMapVisibilityState = _CMap_setMapVisibilityState_CMapVisibilityStatePtr.asFunction<void Function(_CMap, _CMapVisibilityState)>();
late final _CMap_needRedrawPtr = _lookup<ffi.NativeFunction<_CChannel_bool Function(_CMap)>>('CMap_needRedraw');
late final _CMap_needRedraw = _CMap_needRedrawPtr.asFunction<_CChannel_bool Function(_CMap)>();
late final _CMap_attributesPtr = _lookup<ffi.NativeFunction<_CAttributes Function(_CMap)>>('CMap_attributes');
late final _CMap_attributes = _CMap_attributesPtr.asFunction<_CAttributes Function(_CMap)>();
late final _CMap_interactiveChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CMap)>>('CMap_interactiveChannel');
late final _CMap_interactiveChannel = _CMap_interactiveChannelPtr.asFunction<_CStatefulChannel_bool Function(_CMap)>();
late final _CMap_interactivePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMap)>>('CMap_interactive');
late final _CMap_interactive = _CMap_interactivePtr.asFunction<bool Function(_CMap)>();
late final _CMap_setInteractive_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, ffi.Bool)>>('CMap_setInteractive_bool');
late final _CMap_setInteractive_bool = _CMap_setInteractive_boolPtr.asFunction<void Function(_CMap, bool)>();
late final _CMap_hideCopyrightChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CMap)>>('CMap_hideCopyrightChannel');
late final _CMap_hideCopyrightChannel = _CMap_hideCopyrightChannelPtr.asFunction<_CStatefulChannel_bool Function(_CMap)>();
late final _CMap_hideCopyrightPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMap)>>('CMap_hideCopyright');
late final _CMap_hideCopyright = _CMap_hideCopyrightPtr.asFunction<bool Function(_CMap)>();
late final _CMap_productTypeChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CProductType Function(_CMap)>>('CMap_productTypeChannel');
late final _CMap_productTypeChannel = _CMap_productTypeChannelPtr.asFunction<_CStatefulChannel_CProductType Function(_CMap)>();
late final _CMap_productTypePtr = _lookup<ffi.NativeFunction<_CProductType Function(_CMap)>>('CMap_productType');
late final _CMap_productType = _CMap_productTypePtr.asFunction<_CProductType Function(_CMap)>();
late final _CMap_graphicsPresetHintChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGraphicsPreset Function(_CMap)>>('CMap_graphicsPresetHintChannel');
late final _CMap_graphicsPresetHintChannel = _CMap_graphicsPresetHintChannelPtr.asFunction<_CStatefulChannel_COptional_CGraphicsPreset Function(_CMap)>();
late final _CMap_graphicsPresetHintPtr = _lookup<ffi.NativeFunction<_COptional_CGraphicsPreset Function(_CMap)>>('CMap_graphicsPresetHint');
late final _CMap_graphicsPresetHint = _CMap_graphicsPresetHintPtr.asFunction<_COptional_CGraphicsPreset Function(_CMap)>();
late final _CMap_graphicsPresetChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGraphicsPreset Function(_CMap)>>('CMap_graphicsPresetChannel');
late final _CMap_graphicsPresetChannel = _CMap_graphicsPresetChannelPtr.asFunction<_CStatefulChannel_COptional_CGraphicsPreset Function(_CMap)>();
late final _CMap_graphicsPresetPtr = _lookup<ffi.NativeFunction<_COptional_CGraphicsPreset Function(_CMap)>>('CMap_graphicsPreset');
late final _CMap_graphicsPreset = _CMap_graphicsPresetPtr.asFunction<_COptional_CGraphicsPreset Function(_CMap)>();
late final _CMap_setGraphicsPreset_COptional_CGraphicsPresetPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, _COptional_CGraphicsPreset)>>('CMap_setGraphicsPreset_COptional_CGraphicsPreset');
late final _CMap_setGraphicsPreset_COptional_CGraphicsPreset = _CMap_setGraphicsPreset_COptional_CGraphicsPresetPtr.asFunction<void Function(_CMap, _COptional_CGraphicsPreset)>();

late final _CMap_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMap_cg_objectIdentifier');
late final _CMap_cg_objectIdentifier = _CMap_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMap_resetFontIconSizeMultiplierPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap)>>('CMap_resetFontIconSizeMultiplier');
late final _CMap_resetFontIconSizeMultiplier = _CMap_resetFontIconSizeMultiplierPtr.asFunction<void Function(_CMap)>();
late final _CMap_addSource_CSourcePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, _CSource)>>('CMap_addSource_CSource');
late final _CMap_addSource_CSource = _CMap_addSource_CSourcePtr.asFunction<void Function(_CMap, _CSource)>();
late final _CMap_removeSource_CSourcePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, _CSource)>>('CMap_removeSource_CSource');
late final _CMap_removeSource_CSource = _CMap_removeSource_CSourcePtr.asFunction<void Function(_CMap, _CSource)>();
late final _CMap_getRenderedObjects_CScreenPoint_CScreenDistancePtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CRenderedObjectInfo Function(_CMap, _CScreenPoint, _CScreenDistance)>>('CMap_getRenderedObjects_CScreenPoint_CScreenDistance');
late final _CMap_getRenderedObjects_CScreenPoint_CScreenDistance = _CMap_getRenderedObjects_CScreenPoint_CScreenDistancePtr.asFunction<_CFuture_CArray_CRenderedObjectInfo Function(_CMap, _CScreenPoint, _CScreenDistance)>();
late final _CMap_sublayerAttributes_CStringPtr = _lookup<ffi.NativeFunction<_CAttributes Function(_CMap, _CString)>>('CMap_sublayerAttributes_CString');
late final _CMap_sublayerAttributes_CString = _CMap_sublayerAttributes_CStringPtr.asFunction<_CAttributes Function(_CMap, _CString)>();
late final _CMap_setSystemFontIconSizeMultiplier_floatPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CMap, ffi.Float)>>('CMap_setSystemFontIconSizeMultiplier_float');
late final _CMap_setSystemFontIconSizeMultiplier_float = _CMap_setSystemFontIconSizeMultiplier_floatPtr.asFunction<_CResult_CEmpty Function(_CMap, double)>();
late final _CMap_processEvent_CEventPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, _CEvent)>>('CMap_processEvent_CEvent');
late final _CMap_processEvent_CEvent = _CMap_processEvent_CEventPtr.asFunction<void Function(_CMap, _CEvent)>();
late final _CMap_takeSnapshot_CAlignmentPtr = _lookup<ffi.NativeFunction<_CResult_CImageData Function(_CMap, _CAlignment)>>('CMap_takeSnapshot_CAlignment');
late final _CMap_takeSnapshot_CAlignment = _CMap_takeSnapshot_CAlignmentPtr.asFunction<_CResult_CImageData Function(_CMap, _CAlignment)>();
late final _CMap_getMapObject_CScreenPoint_CScreenDistancePtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CRenderedObjectInfo Function(_CMap, _CScreenPoint, _CScreenDistance)>>('CMap_getMapObject_CScreenPoint_CScreenDistance');
late final _CMap_getMapObject_CScreenPoint_CScreenDistance = _CMap_getMapObject_CScreenPoint_CScreenDistancePtr.asFunction<_CFuture_COptional_CRenderedObjectInfo Function(_CMap, _CScreenPoint, _CScreenDistance)>();

late final _CMap_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMap_release');
late final _CMap_release = _CMap_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMap_retainPtr = _lookup<ffi.NativeFunction<_CMap Function(ffi.Pointer<ffi.Void>)>>('CMap_retain');
late final _CMap_retain = _CMap_retainPtr.asFunction<_CMap Function(ffi.Pointer<ffi.Void>)>();
late final _CMapMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMap Function()>>('CMapMakeDefault');
late final _CMapMakeDefault = _CMapMakeDefaultPtr.asFunction<_CMap Function()>();

late final _CCamera_stateChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraState Function(_CCamera)>>('CCamera_stateChannel');
late final _CCamera_stateChannel = _CCamera_stateChannelPtr.asFunction<_CStatefulChannel_CCameraState Function(_CCamera)>();
late final _CCamera_statePtr = _lookup<ffi.NativeFunction<_CCameraState Function(_CCamera)>>('CCamera_state');
late final _CCamera_state = _CCamera_statePtr.asFunction<_CCameraState Function(_CCamera)>();
late final _CCamera_behaviourChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraBehaviourChange Function(_CCamera)>>('CCamera_behaviourChannel');
late final _CCamera_behaviourChannel = _CCamera_behaviourChannelPtr.asFunction<_CStatefulChannel_CCameraBehaviourChange Function(_CCamera)>();
late final _CCamera_behaviourPtr = _lookup<ffi.NativeFunction<_CCameraBehaviourChange Function(_CCamera)>>('CCamera_behaviour');
late final _CCamera_behaviour = _CCamera_behaviourPtr.asFunction<_CCameraBehaviourChange Function(_CCamera)>();

late final _CCamera_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCamera_cg_objectIdentifier');
late final _CCamera_cg_objectIdentifier = _CCamera_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCamera_moveToCameraPosition_CCameraPosition_CTimeInterval_CCameraAnimationTypePtr = _lookup<ffi.NativeFunction<_CFuture_CCameraAnimatedMoveResult Function(_CCamera, _CCameraPosition, _CTimeInterval, _CCameraAnimationType)>>('CCamera_moveToCameraPosition_CCameraPosition_CTimeInterval_CCameraAnimationType');
late final _CCamera_moveToCameraPosition_CCameraPosition_CTimeInterval_CCameraAnimationType = _CCamera_moveToCameraPosition_CCameraPosition_CTimeInterval_CCameraAnimationTypePtr.asFunction<_CFuture_CCameraAnimatedMoveResult Function(_CCamera, _CCameraPosition, _CTimeInterval, _CCameraAnimationType)>();
late final _CCamera_move_CGeoPoint_CZoom_COptional_CTilt_CBearing_CTimeInterval_CCameraAnimationTypePtr = _lookup<ffi.NativeFunction<_CFuture_CCameraAnimatedMoveResult Function(_CCamera, _CGeoPoint, _CZoom, _COptional_CTilt, _CBearing, _CTimeInterval, _CCameraAnimationType)>>('CCamera_move_CGeoPoint_CZoom_COptional_CTilt_CBearing_CTimeInterval_CCameraAnimationType');
late final _CCamera_move_CGeoPoint_CZoom_COptional_CTilt_CBearing_CTimeInterval_CCameraAnimationType = _CCamera_move_CGeoPoint_CZoom_COptional_CTilt_CBearing_CTimeInterval_CCameraAnimationTypePtr.asFunction<_CFuture_CCameraAnimatedMoveResult Function(_CCamera, _CGeoPoint, _CZoom, _COptional_CTilt, _CBearing, _CTimeInterval, _CCameraAnimationType)>();
late final _CCamera_processMovementAndStopPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCamera)>>('CCamera_processMovementAndStop');
late final _CCamera_processMovementAndStop = _CCamera_processMovementAndStopPtr.asFunction<void Function(_CCamera)>();
late final _CCamera_setBehaviour_CCameraBehaviourPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCamera, _CCameraBehaviour)>>('CCamera_setBehaviour_CCameraBehaviour');
late final _CCamera_setBehaviour_CCameraBehaviour = _CCamera_setBehaviour_CCameraBehaviourPtr.asFunction<void Function(_CCamera, _CCameraBehaviour)>();
late final _CCamera_addFollowController_CFollowControllerPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCamera, _CFollowController)>>('CCamera_addFollowController_CFollowController');
late final _CCamera_addFollowController_CFollowController = _CCamera_addFollowController_CFollowControllerPtr.asFunction<void Function(_CCamera, _CFollowController)>();
late final _CCamera_removeFollowController_CFollowControllerPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCamera, _CFollowController)>>('CCamera_removeFollowController_CFollowController');
late final _CCamera_removeFollowController_CFollowController = _CCamera_removeFollowController_CFollowControllerPtr.asFunction<void Function(_CCamera, _CFollowController)>();
late final _CCamera_removeCustomFollowControllerPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCamera)>>('CCamera_removeCustomFollowController');
late final _CCamera_removeCustomFollowController = _CCamera_removeCustomFollowControllerPtr.asFunction<void Function(_CCamera)>();
late final _CCamera_moveWithController_CCameraMoveControllerPtr = _lookup<ffi.NativeFunction<_CFuture_CCameraAnimatedMoveResult Function(_CCamera, _CCameraMoveController)>>('CCamera_moveWithController_CCameraMoveController');
late final _CCamera_moveWithController_CCameraMoveController = _CCamera_moveWithController_CCameraMoveControllerPtr.asFunction<_CFuture_CCameraAnimatedMoveResult Function(_CCamera, _CCameraMoveController)>();
late final _CCamera_setCustomFollowController_CCustomFollowControllerPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCamera, _CCustomFollowController)>>('CCamera_setCustomFollowController_CCustomFollowController');
late final _CCamera_setCustomFollowController_CCustomFollowController = _CCamera_setCustomFollowController_CCustomFollowControllerPtr.asFunction<void Function(_CCamera, _CCustomFollowController)>();

late final _CCamera_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCamera_release');
late final _CCamera_release = _CCamera_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCamera_retainPtr = _lookup<ffi.NativeFunction<_CCamera Function(ffi.Pointer<ffi.Void>)>>('CCamera_retain');
late final _CCamera_retain = _CCamera_retainPtr.asFunction<_CCamera Function(ffi.Pointer<ffi.Void>)>();
late final _CCameraMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCamera Function()>>('CCameraMakeDefault');
late final _CCameraMakeDefault = _CCameraMakeDefaultPtr.asFunction<_CCamera Function()>();


late final _CFuture_CCameraAnimatedMoveResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CCameraAnimatedMoveResult Function()>>('CFuture_CCameraAnimatedMoveResultMakeDefault');
late final _CFuture_CCameraAnimatedMoveResultMakeDefault = _CFuture_CCameraAnimatedMoveResultMakeDefaultPtr.asFunction<_CFuture_CCameraAnimatedMoveResult Function()>();
late final _CFuture_CCameraAnimatedMoveResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CCameraAnimatedMoveResult)>>('CFuture_CCameraAnimatedMoveResult_release');
late final _CFuture_CCameraAnimatedMoveResult_release = _CFuture_CCameraAnimatedMoveResult_releasePtr.asFunction<void Function(_CFuture_CCameraAnimatedMoveResult)>();
late final _CFuture_CCameraAnimatedMoveResult_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CCameraAnimatedMoveResult Function(_CFuture_CCameraAnimatedMoveResult)>>('CFuture_CCameraAnimatedMoveResult_retain');
late final _CFuture_CCameraAnimatedMoveResult_retain = _CFuture_CCameraAnimatedMoveResult_retainPtr.asFunction<_CFuture_CCameraAnimatedMoveResult Function(_CFuture_CCameraAnimatedMoveResult)>();
late final _CFuture_CCameraAnimatedMoveResultReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CCameraAnimatedMoveResult,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraAnimatedMoveResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CCameraAnimatedMoveResult_receive');
late final _CFuture_CCameraAnimatedMoveResultReceive = _CFuture_CCameraAnimatedMoveResultReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CCameraAnimatedMoveResult,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraAnimatedMoveResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CCameraStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraState Function()>>('CStatefulChannel_CCameraStateMakeDefault');
late final _CStatefulChannel_CCameraStateMakeDefault = _CStatefulChannel_CCameraStateMakeDefaultPtr.asFunction<_CStatefulChannel_CCameraState Function()>();
late final _CStatefulChannel_CCameraState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CCameraState)>>('CStatefulChannel_CCameraState_release');
late final _CStatefulChannel_CCameraState_release = _CStatefulChannel_CCameraState_releasePtr.asFunction<void Function(_CStatefulChannel_CCameraState)>();
late final _CStatefulChannel_CCameraState_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraState Function(_CStatefulChannel_CCameraState)>>('CStatefulChannel_CCameraState_retain');
late final _CStatefulChannel_CCameraState_retain = _CStatefulChannel_CCameraState_retainPtr.asFunction<_CStatefulChannel_CCameraState Function(_CStatefulChannel_CCameraState)>();
late final _CStatefulChannel_CCameraStateGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CCameraState Function(_CStatefulChannel_CCameraState)>>('CStatefulChannel_CCameraState_getCurrentValue');
late final _CStatefulChannel_CCameraStateGetCurrentValue = _CStatefulChannel_CCameraStateGetCurrentValuePtr.asFunction<_CCameraState Function(_CStatefulChannel_CCameraState)>();
late final _CStatefulChannel_CCameraStateConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraState,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraState, ffi.Int64)>>
  )
>>('CStatefulChannel_CCameraState_connect');
late final _CStatefulChannel_CCameraStateConnect = _CStatefulChannel_CCameraStateConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraState,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraState, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CCameraBehaviourChangeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraBehaviourChange Function()>>('CStatefulChannel_CCameraBehaviourChangeMakeDefault');
late final _CStatefulChannel_CCameraBehaviourChangeMakeDefault = _CStatefulChannel_CCameraBehaviourChangeMakeDefaultPtr.asFunction<_CStatefulChannel_CCameraBehaviourChange Function()>();
late final _CStatefulChannel_CCameraBehaviourChange_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CCameraBehaviourChange)>>('CStatefulChannel_CCameraBehaviourChange_release');
late final _CStatefulChannel_CCameraBehaviourChange_release = _CStatefulChannel_CCameraBehaviourChange_releasePtr.asFunction<void Function(_CStatefulChannel_CCameraBehaviourChange)>();
late final _CStatefulChannel_CCameraBehaviourChange_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraBehaviourChange Function(_CStatefulChannel_CCameraBehaviourChange)>>('CStatefulChannel_CCameraBehaviourChange_retain');
late final _CStatefulChannel_CCameraBehaviourChange_retain = _CStatefulChannel_CCameraBehaviourChange_retainPtr.asFunction<_CStatefulChannel_CCameraBehaviourChange Function(_CStatefulChannel_CCameraBehaviourChange)>();
late final _CStatefulChannel_CCameraBehaviourChangeGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CCameraBehaviourChange Function(_CStatefulChannel_CCameraBehaviourChange)>>('CStatefulChannel_CCameraBehaviourChange_getCurrentValue');
late final _CStatefulChannel_CCameraBehaviourChangeGetCurrentValue = _CStatefulChannel_CCameraBehaviourChangeGetCurrentValuePtr.asFunction<_CCameraBehaviourChange Function(_CStatefulChannel_CCameraBehaviourChange)>();
late final _CStatefulChannel_CCameraBehaviourChangeConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraBehaviourChange,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraBehaviourChange, ffi.Int64)>>
  )
>>('CStatefulChannel_CCameraBehaviourChange_connect');
late final _CStatefulChannel_CCameraBehaviourChangeConnect = _CStatefulChannel_CCameraBehaviourChangeConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraBehaviourChange,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraBehaviourChange, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CMapDataLoadingStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CMapDataLoadingState Function()>>('CStatefulChannel_CMapDataLoadingStateMakeDefault');
late final _CStatefulChannel_CMapDataLoadingStateMakeDefault = _CStatefulChannel_CMapDataLoadingStateMakeDefaultPtr.asFunction<_CStatefulChannel_CMapDataLoadingState Function()>();
late final _CStatefulChannel_CMapDataLoadingState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CMapDataLoadingState)>>('CStatefulChannel_CMapDataLoadingState_release');
late final _CStatefulChannel_CMapDataLoadingState_release = _CStatefulChannel_CMapDataLoadingState_releasePtr.asFunction<void Function(_CStatefulChannel_CMapDataLoadingState)>();
late final _CStatefulChannel_CMapDataLoadingState_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CMapDataLoadingState Function(_CStatefulChannel_CMapDataLoadingState)>>('CStatefulChannel_CMapDataLoadingState_retain');
late final _CStatefulChannel_CMapDataLoadingState_retain = _CStatefulChannel_CMapDataLoadingState_retainPtr.asFunction<_CStatefulChannel_CMapDataLoadingState Function(_CStatefulChannel_CMapDataLoadingState)>();
late final _CStatefulChannel_CMapDataLoadingStateGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CMapDataLoadingState Function(_CStatefulChannel_CMapDataLoadingState)>>('CStatefulChannel_CMapDataLoadingState_getCurrentValue');
late final _CStatefulChannel_CMapDataLoadingStateGetCurrentValue = _CStatefulChannel_CMapDataLoadingStateGetCurrentValuePtr.asFunction<_CMapDataLoadingState Function(_CStatefulChannel_CMapDataLoadingState)>();
late final _CStatefulChannel_CMapDataLoadingStateConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CMapDataLoadingState,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMapDataLoadingState, ffi.Int64)>>
  )
>>('CStatefulChannel_CMapDataLoadingState_connect');
late final _CStatefulChannel_CMapDataLoadingStateConnect = _CStatefulChannel_CMapDataLoadingStateConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CMapDataLoadingState,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMapDataLoadingState, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CStyleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CStyle Function()>>('CStatefulChannel_CStyleMakeDefault');
late final _CStatefulChannel_CStyleMakeDefault = _CStatefulChannel_CStyleMakeDefaultPtr.asFunction<_CStatefulChannel_CStyle Function()>();
late final _CStatefulChannel_CStyle_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CStyle)>>('CStatefulChannel_CStyle_release');
late final _CStatefulChannel_CStyle_release = _CStatefulChannel_CStyle_releasePtr.asFunction<void Function(_CStatefulChannel_CStyle)>();
late final _CStatefulChannel_CStyle_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CStyle Function(_CStatefulChannel_CStyle)>>('CStatefulChannel_CStyle_retain');
late final _CStatefulChannel_CStyle_retain = _CStatefulChannel_CStyle_retainPtr.asFunction<_CStatefulChannel_CStyle Function(_CStatefulChannel_CStyle)>();
late final _CStatefulChannel_CStyleGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CStyle Function(_CStatefulChannel_CStyle)>>('CStatefulChannel_CStyle_getCurrentValue');
late final _CStatefulChannel_CStyleGetCurrentValue = _CStatefulChannel_CStyleGetCurrentValuePtr.asFunction<_CStyle Function(_CStatefulChannel_CStyle)>();
late final _CStatefulChannel_CStyleConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CStyle,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStyle, ffi.Int64)>>
  )
>>('CStatefulChannel_CStyle_connect');
late final _CStatefulChannel_CStyleConnect = _CStatefulChannel_CStyleConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CStyle,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStyle, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_floatMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_float Function()>>('CStatefulChannel_floatMakeDefault');
late final _CStatefulChannel_floatMakeDefault = _CStatefulChannel_floatMakeDefaultPtr.asFunction<_CStatefulChannel_float Function()>();
late final _CStatefulChannel_float_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_float)>>('CStatefulChannel_float_release');
late final _CStatefulChannel_float_release = _CStatefulChannel_float_releasePtr.asFunction<void Function(_CStatefulChannel_float)>();
late final _CStatefulChannel_float_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_float Function(_CStatefulChannel_float)>>('CStatefulChannel_float_retain');
late final _CStatefulChannel_float_retain = _CStatefulChannel_float_retainPtr.asFunction<_CStatefulChannel_float Function(_CStatefulChannel_float)>();
late final _CStatefulChannel_floatGetCurrentValuePtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CStatefulChannel_float)>>('CStatefulChannel_float_getCurrentValue');
late final _CStatefulChannel_floatGetCurrentValue = _CStatefulChannel_floatGetCurrentValuePtr.asFunction<double Function(_CStatefulChannel_float)>();
late final _CStatefulChannel_floatConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_float,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Float, ffi.Int64)>>
  )
>>('CStatefulChannel_float_connect');
late final _CStatefulChannel_floatConnect = _CStatefulChannel_floatConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_float,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Float, ffi.Int64)>>
  )
>();

late final _CResult_CEmpty_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CEmpty)>>('CResult_CEmpty_release');
late final _CResult_CEmpty_release = _CResult_CEmpty_releasePtr.asFunction<void Function(_CResult_CEmpty)>();

late final _CArray_CSourcemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSource Function()>>('CArray_CSource_makeEmpty');
late final _CArray_CSourcemakeEmpty = _CArray_CSourcemakeEmptyPtr.asFunction<_CArray_CSource Function()>();
late final _CArray_CSourceaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSource, _CSource)>>('CArray_CSource_addElement');
late final _CArray_CSourceaddElement = _CArray_CSourceaddElementPtr.asFunction<void Function(_CArray_CSource, _CSource)>();
late final _forEach_CArray_CSourcePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSource, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSource)>>)
>>('CArray_CSource_forEachWithFunctionPointer');
late final _forEach_CArray_CSource = _forEach_CArray_CSourcePtr.asFunction<
  void Function(_CArray_CSource, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSource)
>>)>();
late final _CArray_CSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSource)>>('CArray_CSource_release');
late final _CArray_CSource_release = _CArray_CSource_releasePtr.asFunction<void Function(_CArray_CSource)>();

late final _CFuture_CArray_CRenderedObjectInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CRenderedObjectInfo Function()>>('CFuture_CArray_CRenderedObjectInfoMakeDefault');
late final _CFuture_CArray_CRenderedObjectInfoMakeDefault = _CFuture_CArray_CRenderedObjectInfoMakeDefaultPtr.asFunction<_CFuture_CArray_CRenderedObjectInfo Function()>();
late final _CFuture_CArray_CRenderedObjectInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CRenderedObjectInfo)>>('CFuture_CArray_CRenderedObjectInfo_release');
late final _CFuture_CArray_CRenderedObjectInfo_release = _CFuture_CArray_CRenderedObjectInfo_releasePtr.asFunction<void Function(_CFuture_CArray_CRenderedObjectInfo)>();
late final _CFuture_CArray_CRenderedObjectInfo_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CRenderedObjectInfo Function(_CFuture_CArray_CRenderedObjectInfo)>>('CFuture_CArray_CRenderedObjectInfo_retain');
late final _CFuture_CArray_CRenderedObjectInfo_retain = _CFuture_CArray_CRenderedObjectInfo_retainPtr.asFunction<_CFuture_CArray_CRenderedObjectInfo Function(_CFuture_CArray_CRenderedObjectInfo)>();
late final _CFuture_CArray_CRenderedObjectInfoReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CArray_CRenderedObjectInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CRenderedObjectInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CArray_CRenderedObjectInfo_receive');
late final _CFuture_CArray_CRenderedObjectInfoReceive = _CFuture_CArray_CRenderedObjectInfoReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CArray_CRenderedObjectInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CRenderedObjectInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CArray_CRenderedObjectInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRenderedObjectInfo Function()>>('CArray_CRenderedObjectInfo_makeEmpty');
late final _CArray_CRenderedObjectInfomakeEmpty = _CArray_CRenderedObjectInfomakeEmptyPtr.asFunction<_CArray_CRenderedObjectInfo Function()>();
late final _CArray_CRenderedObjectInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRenderedObjectInfo, _CRenderedObjectInfo)>>('CArray_CRenderedObjectInfo_addElement');
late final _CArray_CRenderedObjectInfoaddElement = _CArray_CRenderedObjectInfoaddElementPtr.asFunction<void Function(_CArray_CRenderedObjectInfo, _CRenderedObjectInfo)>();
late final _forEach_CArray_CRenderedObjectInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRenderedObjectInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRenderedObjectInfo)>>)
>>('CArray_CRenderedObjectInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CRenderedObjectInfo = _forEach_CArray_CRenderedObjectInfoPtr.asFunction<
  void Function(_CArray_CRenderedObjectInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRenderedObjectInfo)
>>)>();
late final _CArray_CRenderedObjectInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRenderedObjectInfo)>>('CArray_CRenderedObjectInfo_release');
late final _CArray_CRenderedObjectInfo_release = _CArray_CRenderedObjectInfo_releasePtr.asFunction<void Function(_CArray_CRenderedObjectInfo)>();

late final _CRenderedObjectInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRenderedObjectInfo Function()>>('CRenderedObjectInfoMakeDefault');
late final _CRenderedObjectInfoMakeDefault = _CRenderedObjectInfoMakeDefaultPtr.asFunction<_CRenderedObjectInfo Function()>();


late final _CStatefulChannel_CMapVisibilityStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CMapVisibilityState Function()>>('CStatefulChannel_CMapVisibilityStateMakeDefault');
late final _CStatefulChannel_CMapVisibilityStateMakeDefault = _CStatefulChannel_CMapVisibilityStateMakeDefaultPtr.asFunction<_CStatefulChannel_CMapVisibilityState Function()>();
late final _CStatefulChannel_CMapVisibilityState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CMapVisibilityState)>>('CStatefulChannel_CMapVisibilityState_release');
late final _CStatefulChannel_CMapVisibilityState_release = _CStatefulChannel_CMapVisibilityState_releasePtr.asFunction<void Function(_CStatefulChannel_CMapVisibilityState)>();
late final _CStatefulChannel_CMapVisibilityState_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CMapVisibilityState Function(_CStatefulChannel_CMapVisibilityState)>>('CStatefulChannel_CMapVisibilityState_retain');
late final _CStatefulChannel_CMapVisibilityState_retain = _CStatefulChannel_CMapVisibilityState_retainPtr.asFunction<_CStatefulChannel_CMapVisibilityState Function(_CStatefulChannel_CMapVisibilityState)>();
late final _CStatefulChannel_CMapVisibilityStateGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CMapVisibilityState Function(_CStatefulChannel_CMapVisibilityState)>>('CStatefulChannel_CMapVisibilityState_getCurrentValue');
late final _CStatefulChannel_CMapVisibilityStateGetCurrentValue = _CStatefulChannel_CMapVisibilityStateGetCurrentValuePtr.asFunction<_CMapVisibilityState Function(_CStatefulChannel_CMapVisibilityState)>();
late final _CStatefulChannel_CMapVisibilityStateConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CMapVisibilityState,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMapVisibilityState, ffi.Int64)>>
  )
>>('CStatefulChannel_CMapVisibilityState_connect');
late final _CStatefulChannel_CMapVisibilityStateConnect = _CStatefulChannel_CMapVisibilityStateConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CMapVisibilityState,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMapVisibilityState, ffi.Int64)>>
  )
>();

late final _CChannel_boolMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChannel_bool Function()>>('CChannel_boolMakeDefault');
late final _CChannel_boolMakeDefault = _CChannel_boolMakeDefaultPtr.asFunction<_CChannel_bool Function()>();
late final _CChannel_bool_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CChannel_bool)>>('CChannel_bool_release');
late final _CChannel_bool_release = _CChannel_bool_releasePtr.asFunction<void Function(_CChannel_bool)>();
late final _CChannel_bool_retainPtr = _lookup<ffi.NativeFunction<_CChannel_bool Function(_CChannel_bool)>>('CChannel_bool_retain');
late final _CChannel_bool_retain = _CChannel_bool_retainPtr.asFunction<_CChannel_bool Function(_CChannel_bool)>();
late final _CChannel_boolConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CChannel_bool,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Int64)>>
  )
>>('CChannel_bool_connect');
late final _CChannel_boolConnect = _CChannel_boolConnectPtr.asFunction<
  _CCancellable Function(
    _CChannel_bool,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CProductTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CProductType Function()>>('CStatefulChannel_CProductTypeMakeDefault');
late final _CStatefulChannel_CProductTypeMakeDefault = _CStatefulChannel_CProductTypeMakeDefaultPtr.asFunction<_CStatefulChannel_CProductType Function()>();
late final _CStatefulChannel_CProductType_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CProductType)>>('CStatefulChannel_CProductType_release');
late final _CStatefulChannel_CProductType_release = _CStatefulChannel_CProductType_releasePtr.asFunction<void Function(_CStatefulChannel_CProductType)>();
late final _CStatefulChannel_CProductType_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CProductType Function(_CStatefulChannel_CProductType)>>('CStatefulChannel_CProductType_retain');
late final _CStatefulChannel_CProductType_retain = _CStatefulChannel_CProductType_retainPtr.asFunction<_CStatefulChannel_CProductType Function(_CStatefulChannel_CProductType)>();
late final _CStatefulChannel_CProductTypeGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CProductType Function(_CStatefulChannel_CProductType)>>('CStatefulChannel_CProductType_getCurrentValue');
late final _CStatefulChannel_CProductTypeGetCurrentValue = _CStatefulChannel_CProductTypeGetCurrentValuePtr.asFunction<_CProductType Function(_CStatefulChannel_CProductType)>();
late final _CStatefulChannel_CProductTypeConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CProductType,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CProductType, ffi.Int64)>>
  )
>>('CStatefulChannel_CProductType_connect');
late final _CStatefulChannel_CProductTypeConnect = _CStatefulChannel_CProductTypeConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CProductType,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CProductType, ffi.Int64)>>
  )
>();

late final _CResult_CImageData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CImageData)>>('CResult_CImageData_release');
late final _CResult_CImageData_release = _CResult_CImageData_releasePtr.asFunction<void Function(_CResult_CImageData)>();

late final _CStatefulChannel_COptional_CGraphicsPresetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGraphicsPreset Function()>>('CStatefulChannel_COptional_CGraphicsPresetMakeDefault');
late final _CStatefulChannel_COptional_CGraphicsPresetMakeDefault = _CStatefulChannel_COptional_CGraphicsPresetMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CGraphicsPreset Function()>();
late final _CStatefulChannel_COptional_CGraphicsPreset_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CGraphicsPreset)>>('CStatefulChannel_COptional_CGraphicsPreset_release');
late final _CStatefulChannel_COptional_CGraphicsPreset_release = _CStatefulChannel_COptional_CGraphicsPreset_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CGraphicsPreset)>();
late final _CStatefulChannel_COptional_CGraphicsPreset_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGraphicsPreset Function(_CStatefulChannel_COptional_CGraphicsPreset)>>('CStatefulChannel_COptional_CGraphicsPreset_retain');
late final _CStatefulChannel_COptional_CGraphicsPreset_retain = _CStatefulChannel_COptional_CGraphicsPreset_retainPtr.asFunction<_CStatefulChannel_COptional_CGraphicsPreset Function(_CStatefulChannel_COptional_CGraphicsPreset)>();
late final _CStatefulChannel_COptional_CGraphicsPresetGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CGraphicsPreset Function(_CStatefulChannel_COptional_CGraphicsPreset)>>('CStatefulChannel_COptional_CGraphicsPreset_getCurrentValue');
late final _CStatefulChannel_COptional_CGraphicsPresetGetCurrentValue = _CStatefulChannel_COptional_CGraphicsPresetGetCurrentValuePtr.asFunction<_COptional_CGraphicsPreset Function(_CStatefulChannel_COptional_CGraphicsPreset)>();
late final _CStatefulChannel_COptional_CGraphicsPresetConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CGraphicsPreset,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CGraphicsPreset, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CGraphicsPreset_connect');
late final _CStatefulChannel_COptional_CGraphicsPresetConnect = _CStatefulChannel_COptional_CGraphicsPresetConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CGraphicsPreset,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CGraphicsPreset, ffi.Int64)>>
  )
>();

late final _COptional_CGraphicsPresetMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGraphicsPreset Function()>>('COptional_CGraphicsPresetMakeDefault');
late final _COptional_CGraphicsPresetMakeDefault = _COptional_CGraphicsPresetMakeDefaultPtr.asFunction<_COptional_CGraphicsPreset Function()>();

late final _CFuture_COptional_CRenderedObjectInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CRenderedObjectInfo Function()>>('CFuture_COptional_CRenderedObjectInfoMakeDefault');
late final _CFuture_COptional_CRenderedObjectInfoMakeDefault = _CFuture_COptional_CRenderedObjectInfoMakeDefaultPtr.asFunction<_CFuture_COptional_CRenderedObjectInfo Function()>();
late final _CFuture_COptional_CRenderedObjectInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_COptional_CRenderedObjectInfo)>>('CFuture_COptional_CRenderedObjectInfo_release');
late final _CFuture_COptional_CRenderedObjectInfo_release = _CFuture_COptional_CRenderedObjectInfo_releasePtr.asFunction<void Function(_CFuture_COptional_CRenderedObjectInfo)>();
late final _CFuture_COptional_CRenderedObjectInfo_retainPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CRenderedObjectInfo Function(_CFuture_COptional_CRenderedObjectInfo)>>('CFuture_COptional_CRenderedObjectInfo_retain');
late final _CFuture_COptional_CRenderedObjectInfo_retain = _CFuture_COptional_CRenderedObjectInfo_retainPtr.asFunction<_CFuture_COptional_CRenderedObjectInfo Function(_CFuture_COptional_CRenderedObjectInfo)>();
late final _CFuture_COptional_CRenderedObjectInfoReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_COptional_CRenderedObjectInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CRenderedObjectInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_COptional_CRenderedObjectInfo_receive');
late final _CFuture_COptional_CRenderedObjectInfoReceive = _CFuture_COptional_CRenderedObjectInfoReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_COptional_CRenderedObjectInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CRenderedObjectInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _COptional_CRenderedObjectInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRenderedObjectInfo Function()>>('COptional_CRenderedObjectInfoMakeDefault');
late final _COptional_CRenderedObjectInfoMakeDefault = _COptional_CRenderedObjectInfoMakeDefaultPtr.asFunction<_COptional_CRenderedObjectInfo Function()>();

late final _COptional_CRenderedObjectInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CRenderedObjectInfo)>>('COptional_CRenderedObjectInfo_release');
late final _COptional_CRenderedObjectInfo_release = _COptional_CRenderedObjectInfo_releasePtr.asFunction<void Function(_COptional_CRenderedObjectInfo)>();

late final _CProjection_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CProjection_cg_objectIdentifier');
late final _CProjection_cg_objectIdentifier = _CProjection_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CProjection_screenToMap_CScreenPointPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPoint Function(_CProjection, _CScreenPoint)>>('CProjection_screenToMap_CScreenPoint');
late final _CProjection_screenToMap_CScreenPoint = _CProjection_screenToMap_CScreenPointPtr.asFunction<_COptional_CGeoPoint Function(_CProjection, _CScreenPoint)>();
late final _CProjection_map_to_screen_with_geo_point_CGeoPointPtr = _lookup<ffi.NativeFunction<_COptional_CScreenPoint Function(_CProjection, _CGeoPoint)>>('CProjection_map_to_screen_with_geo_point_CGeoPoint');
late final _CProjection_map_to_screen_with_geo_point_CGeoPoint = _CProjection_map_to_screen_with_geo_point_CGeoPointPtr.asFunction<_COptional_CScreenPoint Function(_CProjection, _CGeoPoint)>();
late final _CProjection_map_to_screen_with_geo_point_with_elevation_CGeoPointWithElevationPtr = _lookup<ffi.NativeFunction<_COptional_CScreenPoint Function(_CProjection, _CGeoPointWithElevation)>>('CProjection_map_to_screen_with_geo_point_with_elevation_CGeoPointWithElevation');
late final _CProjection_map_to_screen_with_geo_point_with_elevation_CGeoPointWithElevation = _CProjection_map_to_screen_with_geo_point_with_elevation_CGeoPointWithElevationPtr.asFunction<_COptional_CScreenPoint Function(_CProjection, _CGeoPointWithElevation)>();
late final _CProjection_screenToMapClipped_CScreenPointPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CProjection, _CScreenPoint)>>('CProjection_screenToMapClipped_CScreenPoint');
late final _CProjection_screenToMapClipped_CScreenPoint = _CProjection_screenToMapClipped_CScreenPointPtr.asFunction<_CGeoPoint Function(_CProjection, _CScreenPoint)>();
late final _CProjection_distance_on_screen_CScreenPoint_CScreenPointPtr = _lookup<ffi.NativeFunction<_COptional_CMeter Function(_CProjection, _CScreenPoint, _CScreenPoint)>>('CProjection_distance_on_screen_CScreenPoint_CScreenPoint');
late final _CProjection_distance_on_screen_CScreenPoint_CScreenPoint = _CProjection_distance_on_screen_CScreenPoint_CScreenPointPtr.asFunction<_COptional_CMeter Function(_CProjection, _CScreenPoint, _CScreenPoint)>();
late final _CProjection_distanceOnScreen_CGeoPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<_COptional_CLogicalPixel Function(_CProjection, _CGeoPoint, _CGeoPoint)>>('CProjection_distanceOnScreen_CGeoPoint_CGeoPoint');
late final _CProjection_distanceOnScreen_CGeoPoint_CGeoPoint = _CProjection_distanceOnScreen_CGeoPoint_CGeoPointPtr.asFunction<_COptional_CLogicalPixel Function(_CProjection, _CGeoPoint, _CGeoPoint)>();

late final _CProjection_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CProjection_release');
late final _CProjection_release = _CProjection_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CProjection_retainPtr = _lookup<ffi.NativeFunction<_CProjection Function(ffi.Pointer<ffi.Void>)>>('CProjection_retain');
late final _CProjection_retain = _CProjection_retainPtr.asFunction<_CProjection Function(ffi.Pointer<ffi.Void>)>();
late final _CProjectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CProjection Function()>>('CProjectionMakeDefault');
late final _CProjectionMakeDefault = _CProjectionMakeDefaultPtr.asFunction<_CProjection Function()>();


late final _COptional_CMeterMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CMeter Function()>>('COptional_CMeterMakeDefault');
late final _COptional_CMeterMakeDefault = _COptional_CMeterMakeDefaultPtr.asFunction<_COptional_CMeter Function()>();

late final _COptional_CLogicalPixelMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLogicalPixel Function()>>('COptional_CLogicalPixelMakeDefault');
late final _COptional_CLogicalPixelMakeDefault = _COptional_CLogicalPixelMakeDefaultPtr.asFunction<_COptional_CLogicalPixel Function()>();
late final _CBaseCamera_projectionPtr = _lookup<ffi.NativeFunction<_CProjection Function(_CBaseCamera)>>('CBaseCamera_projection');
late final _CBaseCamera_projection = _CBaseCamera_projectionPtr.asFunction<_CProjection Function(_CBaseCamera)>();
late final _CBaseCamera_positionChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraPosition Function(_CBaseCamera)>>('CBaseCamera_positionChannel');
late final _CBaseCamera_positionChannel = _CBaseCamera_positionChannelPtr.asFunction<_CStatefulChannel_CCameraPosition Function(_CBaseCamera)>();
late final _CBaseCamera_positionPtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CBaseCamera)>>('CBaseCamera_position');
late final _CBaseCamera_position = _CBaseCamera_positionPtr.asFunction<_CCameraPosition Function(_CBaseCamera)>();
late final _CBaseCamera_setPosition_CCameraPositionPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraPosition)>>('CBaseCamera_setPosition_CCameraPosition');
late final _CBaseCamera_setPosition_CCameraPosition = _CBaseCamera_setPosition_CCameraPositionPtr.asFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraPosition)>();
late final _CBaseCamera_zoomRestrictionsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraZoomRestrictions Function(_CBaseCamera)>>('CBaseCamera_zoomRestrictionsChannel');
late final _CBaseCamera_zoomRestrictionsChannel = _CBaseCamera_zoomRestrictionsChannelPtr.asFunction<_CStatefulChannel_CCameraZoomRestrictions Function(_CBaseCamera)>();
late final _CBaseCamera_zoomRestrictionsPtr = _lookup<ffi.NativeFunction<_CCameraZoomRestrictions Function(_CBaseCamera)>>('CBaseCamera_zoomRestrictions');
late final _CBaseCamera_zoomRestrictions = _CBaseCamera_zoomRestrictionsPtr.asFunction<_CCameraZoomRestrictions Function(_CBaseCamera)>();
late final _CBaseCamera_setZoomRestrictions_CCameraZoomRestrictionsPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraZoomRestrictions)>>('CBaseCamera_setZoomRestrictions_CCameraZoomRestrictions');
late final _CBaseCamera_setZoomRestrictions_CCameraZoomRestrictions = _CBaseCamera_setZoomRestrictions_CCameraZoomRestrictionsPtr.asFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraZoomRestrictions)>();
late final _CBaseCamera_devicePpiChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDevicePpi Function(_CBaseCamera)>>('CBaseCamera_devicePpiChannel');
late final _CBaseCamera_devicePpiChannel = _CBaseCamera_devicePpiChannelPtr.asFunction<_CStatefulChannel_CDevicePpi Function(_CBaseCamera)>();
late final _CBaseCamera_devicePpiPtr = _lookup<ffi.NativeFunction<_CDevicePpi Function(_CBaseCamera)>>('CBaseCamera_devicePpi');
late final _CBaseCamera_devicePpi = _CBaseCamera_devicePpiPtr.asFunction<_CDevicePpi Function(_CBaseCamera)>();
late final _CBaseCamera_deviceDensityChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDeviceDensity Function(_CBaseCamera)>>('CBaseCamera_deviceDensityChannel');
late final _CBaseCamera_deviceDensityChannel = _CBaseCamera_deviceDensityChannelPtr.asFunction<_CStatefulChannel_CDeviceDensity Function(_CBaseCamera)>();
late final _CBaseCamera_deviceDensityPtr = _lookup<ffi.NativeFunction<_CDeviceDensity Function(_CBaseCamera)>>('CBaseCamera_deviceDensity');
late final _CBaseCamera_deviceDensity = _CBaseCamera_deviceDensityPtr.asFunction<_CDeviceDensity Function(_CBaseCamera)>();
late final _CBaseCamera_sizeChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CScreenSize Function(_CBaseCamera)>>('CBaseCamera_sizeChannel');
late final _CBaseCamera_sizeChannel = _CBaseCamera_sizeChannelPtr.asFunction<_CStatefulChannel_CScreenSize Function(_CBaseCamera)>();
late final _CBaseCamera_sizePtr = _lookup<ffi.NativeFunction<_CScreenSize Function(_CBaseCamera)>>('CBaseCamera_size');
late final _CBaseCamera_size = _CBaseCamera_sizePtr.asFunction<_CScreenSize Function(_CBaseCamera)>();
late final _CBaseCamera_setSize_CScreenSizePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CBaseCamera, _CScreenSize)>>('CBaseCamera_setSize_CScreenSize');
late final _CBaseCamera_setSize_CScreenSize = _CBaseCamera_setSize_CScreenSizePtr.asFunction<void Function(_CBaseCamera, _CScreenSize)>();
late final _CBaseCamera_paddingChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CPadding Function(_CBaseCamera)>>('CBaseCamera_paddingChannel');
late final _CBaseCamera_paddingChannel = _CBaseCamera_paddingChannelPtr.asFunction<_CStatefulChannel_CPadding Function(_CBaseCamera)>();
late final _CBaseCamera_paddingPtr = _lookup<ffi.NativeFunction<_CPadding Function(_CBaseCamera)>>('CBaseCamera_padding');
late final _CBaseCamera_padding = _CBaseCamera_paddingPtr.asFunction<_CPadding Function(_CBaseCamera)>();
late final _CBaseCamera_setPadding_CPaddingPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CBaseCamera, _CPadding)>>('CBaseCamera_setPadding_CPadding');
late final _CBaseCamera_setPadding_CPadding = _CBaseCamera_setPadding_CPaddingPtr.asFunction<void Function(_CBaseCamera, _CPadding)>();
late final _CBaseCamera_positionPointChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraPositionPoint Function(_CBaseCamera)>>('CBaseCamera_positionPointChannel');
late final _CBaseCamera_positionPointChannel = _CBaseCamera_positionPointChannelPtr.asFunction<_CStatefulChannel_CCameraPositionPoint Function(_CBaseCamera)>();
late final _CBaseCamera_positionPointPtr = _lookup<ffi.NativeFunction<_CCameraPositionPoint Function(_CBaseCamera)>>('CBaseCamera_positionPoint');
late final _CBaseCamera_positionPoint = _CBaseCamera_positionPointPtr.asFunction<_CCameraPositionPoint Function(_CBaseCamera)>();
late final _CBaseCamera_setPositionPoint_CCameraPositionPointPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraPositionPoint)>>('CBaseCamera_setPositionPoint_CCameraPositionPoint');
late final _CBaseCamera_setPositionPoint_CCameraPositionPoint = _CBaseCamera_setPositionPoint_CCameraPositionPointPtr.asFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraPositionPoint)>();
late final _CBaseCamera_viewPointPtr = _lookup<ffi.NativeFunction<_COptional_CCameraViewPoint Function(_CBaseCamera)>>('CBaseCamera_viewPoint');
late final _CBaseCamera_viewPoint = _CBaseCamera_viewPointPtr.asFunction<_COptional_CCameraViewPoint Function(_CBaseCamera)>();
late final _CBaseCamera_setViewPoint_COptional_CCameraViewPointPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CBaseCamera, _COptional_CCameraViewPoint)>>('CBaseCamera_setViewPoint_COptional_CCameraViewPoint');
late final _CBaseCamera_setViewPoint_COptional_CCameraViewPoint = _CBaseCamera_setViewPoint_COptional_CCameraViewPointPtr.asFunction<_CResult_CEmpty Function(_CBaseCamera, _COptional_CCameraViewPoint)>();
late final _CBaseCamera_visibleAreaPtr = _lookup<ffi.NativeFunction<_CGeometry Function(_CBaseCamera)>>('CBaseCamera_visibleArea');
late final _CBaseCamera_visibleArea = _CBaseCamera_visibleAreaPtr.asFunction<_CGeometry Function(_CBaseCamera)>();
late final _CBaseCamera_visibleRectChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeoRect Function(_CBaseCamera)>>('CBaseCamera_visibleRectChannel');
late final _CBaseCamera_visibleRectChannel = _CBaseCamera_visibleRectChannelPtr.asFunction<_CStatefulChannel_CGeoRect Function(_CBaseCamera)>();
late final _CBaseCamera_visibleRectPtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CBaseCamera)>>('CBaseCamera_visibleRect');
late final _CBaseCamera_visibleRect = _CBaseCamera_visibleRectPtr.asFunction<_CGeoRect Function(_CBaseCamera)>();
late final _CBaseCamera_maxTiltRestrictionChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CStyleZoomToTiltRelation Function(_CBaseCamera)>>('CBaseCamera_maxTiltRestrictionChannel');
late final _CBaseCamera_maxTiltRestrictionChannel = _CBaseCamera_maxTiltRestrictionChannelPtr.asFunction<_CStatefulChannel_COptional_CStyleZoomToTiltRelation Function(_CBaseCamera)>();
late final _CBaseCamera_maxTiltRestrictionPtr = _lookup<ffi.NativeFunction<_COptional_CStyleZoomToTiltRelation Function(_CBaseCamera)>>('CBaseCamera_maxTiltRestriction');
late final _CBaseCamera_maxTiltRestriction = _CBaseCamera_maxTiltRestrictionPtr.asFunction<_COptional_CStyleZoomToTiltRelation Function(_CBaseCamera)>();
late final _CBaseCamera_setMaxTiltRestriction_COptional_CStyleZoomToTiltRelationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CBaseCamera, _COptional_CStyleZoomToTiltRelation)>>('CBaseCamera_setMaxTiltRestriction_COptional_CStyleZoomToTiltRelation');
late final _CBaseCamera_setMaxTiltRestriction_COptional_CStyleZoomToTiltRelation = _CBaseCamera_setMaxTiltRestriction_COptional_CStyleZoomToTiltRelationPtr.asFunction<void Function(_CBaseCamera, _COptional_CStyleZoomToTiltRelation)>();
late final _CBaseCamera_viewportRestrictionChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGeoRect Function(_CBaseCamera)>>('CBaseCamera_viewportRestrictionChannel');
late final _CBaseCamera_viewportRestrictionChannel = _CBaseCamera_viewportRestrictionChannelPtr.asFunction<_CStatefulChannel_COptional_CGeoRect Function(_CBaseCamera)>();
late final _CBaseCamera_viewportRestrictionPtr = _lookup<ffi.NativeFunction<_COptional_CGeoRect Function(_CBaseCamera)>>('CBaseCamera_viewportRestriction');
late final _CBaseCamera_viewportRestriction = _CBaseCamera_viewportRestrictionPtr.asFunction<_COptional_CGeoRect Function(_CBaseCamera)>();
late final _CBaseCamera_setViewportRestriction_COptional_CGeoRectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CBaseCamera, _COptional_CGeoRect)>>('CBaseCamera_setViewportRestriction_COptional_CGeoRect');
late final _CBaseCamera_setViewportRestriction_COptional_CGeoRect = _CBaseCamera_setViewportRestriction_COptional_CGeoRectPtr.asFunction<void Function(_CBaseCamera, _COptional_CGeoRect)>();

late final _CBaseCamera_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CBaseCamera_cg_objectIdentifier');
late final _CBaseCamera_cg_objectIdentifier = _CBaseCamera_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CBaseCamera_clonePtr = _lookup<ffi.NativeFunction<_CBaseCamera Function(_CBaseCamera)>>('CBaseCamera_clone');
late final _CBaseCamera_clone = _CBaseCamera_clonePtr.asFunction<_CBaseCamera Function(_CBaseCamera)>();
late final _CBaseCamera_changePosition_CCameraPositionChangePtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraPositionChange)>>('CBaseCamera_changePosition_CCameraPositionChange');
late final _CBaseCamera_changePosition_CCameraPositionChange = _CBaseCamera_changePosition_CCameraPositionChangePtr.asFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraPositionChange)>();
late final _CBaseCamera_setDevicePpi_CDevicePpi_CDeviceDensityPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CBaseCamera, _CDevicePpi, _CDeviceDensity)>>('CBaseCamera_setDevicePpi_CDevicePpi_CDeviceDensity');
late final _CBaseCamera_setDevicePpi_CDevicePpi_CDeviceDensity = _CBaseCamera_setDevicePpi_CDevicePpi_CDeviceDensityPtr.asFunction<void Function(_CBaseCamera, _CDevicePpi, _CDeviceDensity)>();
late final _CBaseCamera_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CBaseCamera)>>('CBaseCamera_cg_getSelector');
late final _CBaseCamera_cg_getSelector = _CBaseCamera_cg_getSelectorPtr.asFunction<int Function(_CBaseCamera)>();

late final _CBaseCamera_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CBaseCamera_release');
late final _CBaseCamera_release = _CBaseCamera_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CBaseCamera_retainPtr = _lookup<ffi.NativeFunction<_CBaseCamera Function(ffi.Pointer<ffi.Void>)>>('CBaseCamera_retain');
late final _CBaseCamera_retain = _CBaseCamera_retainPtr.asFunction<_CBaseCamera Function(ffi.Pointer<ffi.Void>)>();
late final _CBaseCameraMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBaseCamera Function()>>('CBaseCameraMakeDefault');
late final _CBaseCameraMakeDefault = _CBaseCameraMakeDefaultPtr.asFunction<_CBaseCamera Function()>();


late final _CStatefulChannel_CCameraPositionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraPosition Function()>>('CStatefulChannel_CCameraPositionMakeDefault');
late final _CStatefulChannel_CCameraPositionMakeDefault = _CStatefulChannel_CCameraPositionMakeDefaultPtr.asFunction<_CStatefulChannel_CCameraPosition Function()>();
late final _CStatefulChannel_CCameraPosition_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CCameraPosition)>>('CStatefulChannel_CCameraPosition_release');
late final _CStatefulChannel_CCameraPosition_release = _CStatefulChannel_CCameraPosition_releasePtr.asFunction<void Function(_CStatefulChannel_CCameraPosition)>();
late final _CStatefulChannel_CCameraPosition_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraPosition Function(_CStatefulChannel_CCameraPosition)>>('CStatefulChannel_CCameraPosition_retain');
late final _CStatefulChannel_CCameraPosition_retain = _CStatefulChannel_CCameraPosition_retainPtr.asFunction<_CStatefulChannel_CCameraPosition Function(_CStatefulChannel_CCameraPosition)>();
late final _CStatefulChannel_CCameraPositionGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CStatefulChannel_CCameraPosition)>>('CStatefulChannel_CCameraPosition_getCurrentValue');
late final _CStatefulChannel_CCameraPositionGetCurrentValue = _CStatefulChannel_CCameraPositionGetCurrentValuePtr.asFunction<_CCameraPosition Function(_CStatefulChannel_CCameraPosition)>();
late final _CStatefulChannel_CCameraPositionConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraPosition,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraPosition, ffi.Int64)>>
  )
>>('CStatefulChannel_CCameraPosition_connect');
late final _CStatefulChannel_CCameraPositionConnect = _CStatefulChannel_CCameraPositionConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraPosition,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraPosition, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CCameraZoomRestrictionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraZoomRestrictions Function()>>('CStatefulChannel_CCameraZoomRestrictionsMakeDefault');
late final _CStatefulChannel_CCameraZoomRestrictionsMakeDefault = _CStatefulChannel_CCameraZoomRestrictionsMakeDefaultPtr.asFunction<_CStatefulChannel_CCameraZoomRestrictions Function()>();
late final _CStatefulChannel_CCameraZoomRestrictions_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CCameraZoomRestrictions)>>('CStatefulChannel_CCameraZoomRestrictions_release');
late final _CStatefulChannel_CCameraZoomRestrictions_release = _CStatefulChannel_CCameraZoomRestrictions_releasePtr.asFunction<void Function(_CStatefulChannel_CCameraZoomRestrictions)>();
late final _CStatefulChannel_CCameraZoomRestrictions_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraZoomRestrictions Function(_CStatefulChannel_CCameraZoomRestrictions)>>('CStatefulChannel_CCameraZoomRestrictions_retain');
late final _CStatefulChannel_CCameraZoomRestrictions_retain = _CStatefulChannel_CCameraZoomRestrictions_retainPtr.asFunction<_CStatefulChannel_CCameraZoomRestrictions Function(_CStatefulChannel_CCameraZoomRestrictions)>();
late final _CStatefulChannel_CCameraZoomRestrictionsGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CCameraZoomRestrictions Function(_CStatefulChannel_CCameraZoomRestrictions)>>('CStatefulChannel_CCameraZoomRestrictions_getCurrentValue');
late final _CStatefulChannel_CCameraZoomRestrictionsGetCurrentValue = _CStatefulChannel_CCameraZoomRestrictionsGetCurrentValuePtr.asFunction<_CCameraZoomRestrictions Function(_CStatefulChannel_CCameraZoomRestrictions)>();
late final _CStatefulChannel_CCameraZoomRestrictionsConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraZoomRestrictions,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraZoomRestrictions, ffi.Int64)>>
  )
>>('CStatefulChannel_CCameraZoomRestrictions_connect');
late final _CStatefulChannel_CCameraZoomRestrictionsConnect = _CStatefulChannel_CCameraZoomRestrictionsConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraZoomRestrictions,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraZoomRestrictions, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CDevicePpiMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDevicePpi Function()>>('CStatefulChannel_CDevicePpiMakeDefault');
late final _CStatefulChannel_CDevicePpiMakeDefault = _CStatefulChannel_CDevicePpiMakeDefaultPtr.asFunction<_CStatefulChannel_CDevicePpi Function()>();
late final _CStatefulChannel_CDevicePpi_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CDevicePpi)>>('CStatefulChannel_CDevicePpi_release');
late final _CStatefulChannel_CDevicePpi_release = _CStatefulChannel_CDevicePpi_releasePtr.asFunction<void Function(_CStatefulChannel_CDevicePpi)>();
late final _CStatefulChannel_CDevicePpi_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDevicePpi Function(_CStatefulChannel_CDevicePpi)>>('CStatefulChannel_CDevicePpi_retain');
late final _CStatefulChannel_CDevicePpi_retain = _CStatefulChannel_CDevicePpi_retainPtr.asFunction<_CStatefulChannel_CDevicePpi Function(_CStatefulChannel_CDevicePpi)>();
late final _CStatefulChannel_CDevicePpiGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CDevicePpi Function(_CStatefulChannel_CDevicePpi)>>('CStatefulChannel_CDevicePpi_getCurrentValue');
late final _CStatefulChannel_CDevicePpiGetCurrentValue = _CStatefulChannel_CDevicePpiGetCurrentValuePtr.asFunction<_CDevicePpi Function(_CStatefulChannel_CDevicePpi)>();
late final _CStatefulChannel_CDevicePpiConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CDevicePpi,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDevicePpi, ffi.Int64)>>
  )
>>('CStatefulChannel_CDevicePpi_connect');
late final _CStatefulChannel_CDevicePpiConnect = _CStatefulChannel_CDevicePpiConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CDevicePpi,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDevicePpi, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CDeviceDensityMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDeviceDensity Function()>>('CStatefulChannel_CDeviceDensityMakeDefault');
late final _CStatefulChannel_CDeviceDensityMakeDefault = _CStatefulChannel_CDeviceDensityMakeDefaultPtr.asFunction<_CStatefulChannel_CDeviceDensity Function()>();
late final _CStatefulChannel_CDeviceDensity_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CDeviceDensity)>>('CStatefulChannel_CDeviceDensity_release');
late final _CStatefulChannel_CDeviceDensity_release = _CStatefulChannel_CDeviceDensity_releasePtr.asFunction<void Function(_CStatefulChannel_CDeviceDensity)>();
late final _CStatefulChannel_CDeviceDensity_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDeviceDensity Function(_CStatefulChannel_CDeviceDensity)>>('CStatefulChannel_CDeviceDensity_retain');
late final _CStatefulChannel_CDeviceDensity_retain = _CStatefulChannel_CDeviceDensity_retainPtr.asFunction<_CStatefulChannel_CDeviceDensity Function(_CStatefulChannel_CDeviceDensity)>();
late final _CStatefulChannel_CDeviceDensityGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CDeviceDensity Function(_CStatefulChannel_CDeviceDensity)>>('CStatefulChannel_CDeviceDensity_getCurrentValue');
late final _CStatefulChannel_CDeviceDensityGetCurrentValue = _CStatefulChannel_CDeviceDensityGetCurrentValuePtr.asFunction<_CDeviceDensity Function(_CStatefulChannel_CDeviceDensity)>();
late final _CStatefulChannel_CDeviceDensityConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CDeviceDensity,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDeviceDensity, ffi.Int64)>>
  )
>>('CStatefulChannel_CDeviceDensity_connect');
late final _CStatefulChannel_CDeviceDensityConnect = _CStatefulChannel_CDeviceDensityConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CDeviceDensity,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDeviceDensity, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CScreenSizeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CScreenSize Function()>>('CStatefulChannel_CScreenSizeMakeDefault');
late final _CStatefulChannel_CScreenSizeMakeDefault = _CStatefulChannel_CScreenSizeMakeDefaultPtr.asFunction<_CStatefulChannel_CScreenSize Function()>();
late final _CStatefulChannel_CScreenSize_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CScreenSize)>>('CStatefulChannel_CScreenSize_release');
late final _CStatefulChannel_CScreenSize_release = _CStatefulChannel_CScreenSize_releasePtr.asFunction<void Function(_CStatefulChannel_CScreenSize)>();
late final _CStatefulChannel_CScreenSize_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CScreenSize Function(_CStatefulChannel_CScreenSize)>>('CStatefulChannel_CScreenSize_retain');
late final _CStatefulChannel_CScreenSize_retain = _CStatefulChannel_CScreenSize_retainPtr.asFunction<_CStatefulChannel_CScreenSize Function(_CStatefulChannel_CScreenSize)>();
late final _CStatefulChannel_CScreenSizeGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CScreenSize Function(_CStatefulChannel_CScreenSize)>>('CStatefulChannel_CScreenSize_getCurrentValue');
late final _CStatefulChannel_CScreenSizeGetCurrentValue = _CStatefulChannel_CScreenSizeGetCurrentValuePtr.asFunction<_CScreenSize Function(_CStatefulChannel_CScreenSize)>();
late final _CStatefulChannel_CScreenSizeConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CScreenSize,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CScreenSize, ffi.Int64)>>
  )
>>('CStatefulChannel_CScreenSize_connect');
late final _CStatefulChannel_CScreenSizeConnect = _CStatefulChannel_CScreenSizeConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CScreenSize,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CScreenSize, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CPaddingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CPadding Function()>>('CStatefulChannel_CPaddingMakeDefault');
late final _CStatefulChannel_CPaddingMakeDefault = _CStatefulChannel_CPaddingMakeDefaultPtr.asFunction<_CStatefulChannel_CPadding Function()>();
late final _CStatefulChannel_CPadding_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CPadding)>>('CStatefulChannel_CPadding_release');
late final _CStatefulChannel_CPadding_release = _CStatefulChannel_CPadding_releasePtr.asFunction<void Function(_CStatefulChannel_CPadding)>();
late final _CStatefulChannel_CPadding_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CPadding Function(_CStatefulChannel_CPadding)>>('CStatefulChannel_CPadding_retain');
late final _CStatefulChannel_CPadding_retain = _CStatefulChannel_CPadding_retainPtr.asFunction<_CStatefulChannel_CPadding Function(_CStatefulChannel_CPadding)>();
late final _CStatefulChannel_CPaddingGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CPadding Function(_CStatefulChannel_CPadding)>>('CStatefulChannel_CPadding_getCurrentValue');
late final _CStatefulChannel_CPaddingGetCurrentValue = _CStatefulChannel_CPaddingGetCurrentValuePtr.asFunction<_CPadding Function(_CStatefulChannel_CPadding)>();
late final _CStatefulChannel_CPaddingConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CPadding,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPadding, ffi.Int64)>>
  )
>>('CStatefulChannel_CPadding_connect');
late final _CStatefulChannel_CPaddingConnect = _CStatefulChannel_CPaddingConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CPadding,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPadding, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CCameraPositionPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraPositionPoint Function()>>('CStatefulChannel_CCameraPositionPointMakeDefault');
late final _CStatefulChannel_CCameraPositionPointMakeDefault = _CStatefulChannel_CCameraPositionPointMakeDefaultPtr.asFunction<_CStatefulChannel_CCameraPositionPoint Function()>();
late final _CStatefulChannel_CCameraPositionPoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CCameraPositionPoint)>>('CStatefulChannel_CCameraPositionPoint_release');
late final _CStatefulChannel_CCameraPositionPoint_release = _CStatefulChannel_CCameraPositionPoint_releasePtr.asFunction<void Function(_CStatefulChannel_CCameraPositionPoint)>();
late final _CStatefulChannel_CCameraPositionPoint_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraPositionPoint Function(_CStatefulChannel_CCameraPositionPoint)>>('CStatefulChannel_CCameraPositionPoint_retain');
late final _CStatefulChannel_CCameraPositionPoint_retain = _CStatefulChannel_CCameraPositionPoint_retainPtr.asFunction<_CStatefulChannel_CCameraPositionPoint Function(_CStatefulChannel_CCameraPositionPoint)>();
late final _CStatefulChannel_CCameraPositionPointGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CCameraPositionPoint Function(_CStatefulChannel_CCameraPositionPoint)>>('CStatefulChannel_CCameraPositionPoint_getCurrentValue');
late final _CStatefulChannel_CCameraPositionPointGetCurrentValue = _CStatefulChannel_CCameraPositionPointGetCurrentValuePtr.asFunction<_CCameraPositionPoint Function(_CStatefulChannel_CCameraPositionPoint)>();
late final _CStatefulChannel_CCameraPositionPointConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraPositionPoint,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraPositionPoint, ffi.Int64)>>
  )
>>('CStatefulChannel_CCameraPositionPoint_connect');
late final _CStatefulChannel_CCameraPositionPointConnect = _CStatefulChannel_CCameraPositionPointConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraPositionPoint,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraPositionPoint, ffi.Int64)>>
  )
>();

late final _COptional_CCameraViewPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CCameraViewPoint Function()>>('COptional_CCameraViewPointMakeDefault');
late final _COptional_CCameraViewPointMakeDefault = _COptional_CCameraViewPointMakeDefaultPtr.asFunction<_COptional_CCameraViewPoint Function()>();

late final _CStatefulChannel_CGeoRectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeoRect Function()>>('CStatefulChannel_CGeoRectMakeDefault');
late final _CStatefulChannel_CGeoRectMakeDefault = _CStatefulChannel_CGeoRectMakeDefaultPtr.asFunction<_CStatefulChannel_CGeoRect Function()>();
late final _CStatefulChannel_CGeoRect_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CGeoRect)>>('CStatefulChannel_CGeoRect_release');
late final _CStatefulChannel_CGeoRect_release = _CStatefulChannel_CGeoRect_releasePtr.asFunction<void Function(_CStatefulChannel_CGeoRect)>();
late final _CStatefulChannel_CGeoRect_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeoRect Function(_CStatefulChannel_CGeoRect)>>('CStatefulChannel_CGeoRect_retain');
late final _CStatefulChannel_CGeoRect_retain = _CStatefulChannel_CGeoRect_retainPtr.asFunction<_CStatefulChannel_CGeoRect Function(_CStatefulChannel_CGeoRect)>();
late final _CStatefulChannel_CGeoRectGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CStatefulChannel_CGeoRect)>>('CStatefulChannel_CGeoRect_getCurrentValue');
late final _CStatefulChannel_CGeoRectGetCurrentValue = _CStatefulChannel_CGeoRectGetCurrentValuePtr.asFunction<_CGeoRect Function(_CStatefulChannel_CGeoRect)>();
late final _CStatefulChannel_CGeoRectConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CGeoRect,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeoRect, ffi.Int64)>>
  )
>>('CStatefulChannel_CGeoRect_connect');
late final _CStatefulChannel_CGeoRectConnect = _CStatefulChannel_CGeoRectConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CGeoRect,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeoRect, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_COptional_CStyleZoomToTiltRelationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CStyleZoomToTiltRelation Function()>>('CStatefulChannel_COptional_CStyleZoomToTiltRelationMakeDefault');
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelationMakeDefault = _CStatefulChannel_COptional_CStyleZoomToTiltRelationMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CStyleZoomToTiltRelation Function()>();
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelation_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CStyleZoomToTiltRelation)>>('CStatefulChannel_COptional_CStyleZoomToTiltRelation_release');
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelation_release = _CStatefulChannel_COptional_CStyleZoomToTiltRelation_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CStyleZoomToTiltRelation)>();
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelation_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CStyleZoomToTiltRelation Function(_CStatefulChannel_COptional_CStyleZoomToTiltRelation)>>('CStatefulChannel_COptional_CStyleZoomToTiltRelation_retain');
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelation_retain = _CStatefulChannel_COptional_CStyleZoomToTiltRelation_retainPtr.asFunction<_CStatefulChannel_COptional_CStyleZoomToTiltRelation Function(_CStatefulChannel_COptional_CStyleZoomToTiltRelation)>();
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelationGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CStyleZoomToTiltRelation Function(_CStatefulChannel_COptional_CStyleZoomToTiltRelation)>>('CStatefulChannel_COptional_CStyleZoomToTiltRelation_getCurrentValue');
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelationGetCurrentValue = _CStatefulChannel_COptional_CStyleZoomToTiltRelationGetCurrentValuePtr.asFunction<_COptional_CStyleZoomToTiltRelation Function(_CStatefulChannel_COptional_CStyleZoomToTiltRelation)>();
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelationConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CStyleZoomToTiltRelation,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CStyleZoomToTiltRelation, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CStyleZoomToTiltRelation_connect');
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelationConnect = _CStatefulChannel_COptional_CStyleZoomToTiltRelationConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CStyleZoomToTiltRelation,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CStyleZoomToTiltRelation, ffi.Int64)>>
  )
>();

late final _COptional_CStyleZoomToTiltRelationMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CStyleZoomToTiltRelation Function()>>('COptional_CStyleZoomToTiltRelationMakeDefault');
late final _COptional_CStyleZoomToTiltRelationMakeDefault = _COptional_CStyleZoomToTiltRelationMakeDefaultPtr.asFunction<_COptional_CStyleZoomToTiltRelation Function()>();

late final _COptional_CStyleZoomToTiltRelation_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CStyleZoomToTiltRelation)>>('COptional_CStyleZoomToTiltRelation_release');
late final _COptional_CStyleZoomToTiltRelation_release = _COptional_CStyleZoomToTiltRelation_releasePtr.asFunction<void Function(_COptional_CStyleZoomToTiltRelation)>();

late final _CStatefulChannel_COptional_CGeoRectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGeoRect Function()>>('CStatefulChannel_COptional_CGeoRectMakeDefault');
late final _CStatefulChannel_COptional_CGeoRectMakeDefault = _CStatefulChannel_COptional_CGeoRectMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CGeoRect Function()>();
late final _CStatefulChannel_COptional_CGeoRect_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CGeoRect)>>('CStatefulChannel_COptional_CGeoRect_release');
late final _CStatefulChannel_COptional_CGeoRect_release = _CStatefulChannel_COptional_CGeoRect_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CGeoRect)>();
late final _CStatefulChannel_COptional_CGeoRect_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGeoRect Function(_CStatefulChannel_COptional_CGeoRect)>>('CStatefulChannel_COptional_CGeoRect_retain');
late final _CStatefulChannel_COptional_CGeoRect_retain = _CStatefulChannel_COptional_CGeoRect_retainPtr.asFunction<_CStatefulChannel_COptional_CGeoRect Function(_CStatefulChannel_COptional_CGeoRect)>();
late final _CStatefulChannel_COptional_CGeoRectGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CGeoRect Function(_CStatefulChannel_COptional_CGeoRect)>>('CStatefulChannel_COptional_CGeoRect_getCurrentValue');
late final _CStatefulChannel_COptional_CGeoRectGetCurrentValue = _CStatefulChannel_COptional_CGeoRectGetCurrentValuePtr.asFunction<_COptional_CGeoRect Function(_CStatefulChannel_COptional_CGeoRect)>();
late final _CStatefulChannel_COptional_CGeoRectConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CGeoRect,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CGeoRect, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CGeoRect_connect');
late final _CStatefulChannel_COptional_CGeoRectConnect = _CStatefulChannel_COptional_CGeoRectConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CGeoRect,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CGeoRect, ffi.Int64)>>
  )
>();
late final _CSimpleMapObject_isVisiblePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CSimpleMapObject)>>('CSimpleMapObject_isVisible');
late final _CSimpleMapObject_isVisible = _CSimpleMapObject_isVisiblePtr.asFunction<bool Function(_CSimpleMapObject)>();
late final _CSimpleMapObject_setVisible_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleMapObject, ffi.Bool)>>('CSimpleMapObject_setVisible_bool');
late final _CSimpleMapObject_setVisible_bool = _CSimpleMapObject_setVisible_boolPtr.asFunction<void Function(_CSimpleMapObject, bool)>();
late final _CSimpleMapObject_zIndexPtr = _lookup<ffi.NativeFunction<_CZIndex Function(_CSimpleMapObject)>>('CSimpleMapObject_zIndex');
late final _CSimpleMapObject_zIndex = _CSimpleMapObject_zIndexPtr.asFunction<_CZIndex Function(_CSimpleMapObject)>();
late final _CSimpleMapObject_setZIndex_CZIndexPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleMapObject, _CZIndex)>>('CSimpleMapObject_setZIndex_CZIndex');
late final _CSimpleMapObject_setZIndex_CZIndex = _CSimpleMapObject_setZIndex_CZIndexPtr.asFunction<void Function(_CSimpleMapObject, _CZIndex)>();
late final _CSimpleMapObject_levelIdPtr = _lookup<ffi.NativeFunction<_COptional_CLevelId Function(_CSimpleMapObject)>>('CSimpleMapObject_levelId');
late final _CSimpleMapObject_levelId = _CSimpleMapObject_levelIdPtr.asFunction<_COptional_CLevelId Function(_CSimpleMapObject)>();
late final _CSimpleMapObject_setLevelId_COptional_CLevelIdPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleMapObject, _COptional_CLevelId)>>('CSimpleMapObject_setLevelId_COptional_CLevelId');
late final _CSimpleMapObject_setLevelId_COptional_CLevelId = _CSimpleMapObject_setLevelId_COptional_CLevelIdPtr.asFunction<void Function(_CSimpleMapObject, _COptional_CLevelId)>();
late final _CSimpleMapObject_boundsPtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CSimpleMapObject)>>('CSimpleMapObject_bounds');
late final _CSimpleMapObject_bounds = _CSimpleMapObject_boundsPtr.asFunction<_CGeoRect Function(_CSimpleMapObject)>();

late final _CSimpleMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSimpleMapObject_cg_objectIdentifier');
late final _CSimpleMapObject_cg_objectIdentifier = _CSimpleMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSimpleMapObject_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CSimpleMapObject)>>('CSimpleMapObject_cg_getSelector');
late final _CSimpleMapObject_cg_getSelector = _CSimpleMapObject_cg_getSelectorPtr.asFunction<int Function(_CSimpleMapObject)>();

late final _CSimpleMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSimpleMapObject_release');
late final _CSimpleMapObject_release = _CSimpleMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleMapObject_retainPtr = _lookup<ffi.NativeFunction<_CSimpleMapObject Function(ffi.Pointer<ffi.Void>)>>('CSimpleMapObject_retain');
late final _CSimpleMapObject_retain = _CSimpleMapObject_retainPtr.asFunction<_CSimpleMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimpleMapObject Function()>>('CSimpleMapObjectMakeDefault');
late final _CSimpleMapObjectMakeDefault = _CSimpleMapObjectMakeDefaultPtr.asFunction<_CSimpleMapObject Function()>();

late final _CMapObjectManager_isVisiblePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMapObjectManager)>>('CMapObjectManager_isVisible');
late final _CMapObjectManager_isVisible = _CMapObjectManager_isVisiblePtr.asFunction<bool Function(_CMapObjectManager)>();
late final _CMapObjectManager_setVisible_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager, ffi.Bool)>>('CMapObjectManager_setVisible_bool');
late final _CMapObjectManager_setVisible_bool = _CMapObjectManager_setVisible_boolPtr.asFunction<void Function(_CMapObjectManager, bool)>();

late final _CMapObjectManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapObjectManager_cg_objectIdentifier');
late final _CMapObjectManager_cg_objectIdentifier = _CMapObjectManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapObjectManager_S_withClustering_CMap_CLogicalPixel_CZoom_CSimpleClusterRenderer_CZoom_COptional_CStringPtr = _lookup<ffi.NativeFunction<_CMapObjectManager Function(_CMap, _CLogicalPixel, _CZoom, _CSimpleClusterRenderer, _CZoom, _COptional_CString)>>('CMapObjectManager_S_withClustering_CMap_CLogicalPixel_CZoom_CSimpleClusterRenderer_CZoom_COptional_CString');
late final _CMapObjectManager_S_withClustering_CMap_CLogicalPixel_CZoom_CSimpleClusterRenderer_CZoom_COptional_CString = _CMapObjectManager_S_withClustering_CMap_CLogicalPixel_CZoom_CSimpleClusterRenderer_CZoom_COptional_CStringPtr.asFunction<_CMapObjectManager Function(_CMap, _CLogicalPixel, _CZoom, _CSimpleClusterRenderer, _CZoom, _COptional_CString)>();
late final _CMapObjectManager_S_withGeneralization_CMap_CLogicalPixel_CZoom_CZoom_COptional_CStringPtr = _lookup<ffi.NativeFunction<_CMapObjectManager Function(_CMap, _CLogicalPixel, _CZoom, _CZoom, _COptional_CString)>>('CMapObjectManager_S_withGeneralization_CMap_CLogicalPixel_CZoom_CZoom_COptional_CString');
late final _CMapObjectManager_S_withGeneralization_CMap_CLogicalPixel_CZoom_CZoom_COptional_CString = _CMapObjectManager_S_withGeneralization_CMap_CLogicalPixel_CZoom_CZoom_COptional_CStringPtr.asFunction<_CMapObjectManager Function(_CMap, _CLogicalPixel, _CZoom, _CZoom, _COptional_CString)>();
late final _CMapObjectManager_addObject_CSimpleMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager, _CSimpleMapObject)>>('CMapObjectManager_addObject_CSimpleMapObject');
late final _CMapObjectManager_addObject_CSimpleMapObject = _CMapObjectManager_addObject_CSimpleMapObjectPtr.asFunction<void Function(_CMapObjectManager, _CSimpleMapObject)>();
late final _CMapObjectManager_removeObject_CSimpleMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager, _CSimpleMapObject)>>('CMapObjectManager_removeObject_CSimpleMapObject');
late final _CMapObjectManager_removeObject_CSimpleMapObject = _CMapObjectManager_removeObject_CSimpleMapObjectPtr.asFunction<void Function(_CMapObjectManager, _CSimpleMapObject)>();
late final _CMapObjectManager_addObjects_CArray_CSimpleMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager, _CArray_CSimpleMapObject)>>('CMapObjectManager_addObjects_CArray_CSimpleMapObject');
late final _CMapObjectManager_addObjects_CArray_CSimpleMapObject = _CMapObjectManager_addObjects_CArray_CSimpleMapObjectPtr.asFunction<void Function(_CMapObjectManager, _CArray_CSimpleMapObject)>();
late final _CMapObjectManager_removeObjects_CArray_CSimpleMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager, _CArray_CSimpleMapObject)>>('CMapObjectManager_removeObjects_CArray_CSimpleMapObject');
late final _CMapObjectManager_removeObjects_CArray_CSimpleMapObject = _CMapObjectManager_removeObjects_CArray_CSimpleMapObjectPtr.asFunction<void Function(_CMapObjectManager, _CArray_CSimpleMapObject)>();
late final _CMapObjectManager_removeAndAddObjects_CArray_CSimpleMapObject_CArray_CSimpleMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager, _CArray_CSimpleMapObject, _CArray_CSimpleMapObject)>>('CMapObjectManager_removeAndAddObjects_CArray_CSimpleMapObject_CArray_CSimpleMapObject');
late final _CMapObjectManager_removeAndAddObjects_CArray_CSimpleMapObject_CArray_CSimpleMapObject = _CMapObjectManager_removeAndAddObjects_CArray_CSimpleMapObject_CArray_CSimpleMapObjectPtr.asFunction<void Function(_CMapObjectManager, _CArray_CSimpleMapObject, _CArray_CSimpleMapObject)>();
late final _CMapObjectManager_removeAllPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager)>>('CMapObjectManager_removeAll');
late final _CMapObjectManager_removeAll = _CMapObjectManager_removeAllPtr.asFunction<void Function(_CMapObjectManager)>();
late final _CMapObjectManager_clusteringObjects_CCameraPositionPtr = _lookup<ffi.NativeFunction<_CArray_CMapObject Function(_CMapObjectManager, _CCameraPosition)>>('CMapObjectManager_clusteringObjects_CCameraPosition');
late final _CMapObjectManager_clusteringObjects_CCameraPosition = _CMapObjectManager_clusteringObjects_CCameraPositionPtr.asFunction<_CArray_CMapObject Function(_CMapObjectManager, _CCameraPosition)>();
late final _CMapObjectManager_C_createWith_CMap_COptional_CStringPtr = _lookup<ffi.NativeFunction<_CMapObjectManager Function(_CMap, _COptional_CString)>>('CMapObjectManager_C_createWith_CMap_COptional_CString');
late final _CMapObjectManager_C_createWith_CMap_COptional_CString = _CMapObjectManager_C_createWith_CMap_COptional_CStringPtr.asFunction<_CMapObjectManager Function(_CMap, _COptional_CString)>();

late final _CMapObjectManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapObjectManager_release');
late final _CMapObjectManager_release = _CMapObjectManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapObjectManager_retainPtr = _lookup<ffi.NativeFunction<_CMapObjectManager Function(ffi.Pointer<ffi.Void>)>>('CMapObjectManager_retain');
late final _CMapObjectManager_retain = _CMapObjectManager_retainPtr.asFunction<_CMapObjectManager Function(ffi.Pointer<ffi.Void>)>();
late final _CMapObjectManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapObjectManager Function()>>('CMapObjectManagerMakeDefault');
late final _CMapObjectManagerMakeDefault = _CMapObjectManagerMakeDefaultPtr.asFunction<_CMapObjectManager Function()>();


late final _CArray_CSimpleMapObjectmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSimpleMapObject Function()>>('CArray_CSimpleMapObject_makeEmpty');
late final _CArray_CSimpleMapObjectmakeEmpty = _CArray_CSimpleMapObjectmakeEmptyPtr.asFunction<_CArray_CSimpleMapObject Function()>();
late final _CArray_CSimpleMapObjectaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSimpleMapObject, _CSimpleMapObject)>>('CArray_CSimpleMapObject_addElement');
late final _CArray_CSimpleMapObjectaddElement = _CArray_CSimpleMapObjectaddElementPtr.asFunction<void Function(_CArray_CSimpleMapObject, _CSimpleMapObject)>();
late final _forEach_CArray_CSimpleMapObjectPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSimpleMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSimpleMapObject)>>)
>>('CArray_CSimpleMapObject_forEachWithFunctionPointer');
late final _forEach_CArray_CSimpleMapObject = _forEach_CArray_CSimpleMapObjectPtr.asFunction<
  void Function(_CArray_CSimpleMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSimpleMapObject)
>>)>();
late final _CArray_CSimpleMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSimpleMapObject)>>('CArray_CSimpleMapObject_release');
late final _CArray_CSimpleMapObject_release = _CArray_CSimpleMapObject_releasePtr.asFunction<void Function(_CArray_CSimpleMapObject)>();

late final _CSimpleClusterRendererCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSimpleClusterRendererCpp_cg_objectIdentifier');
late final _CSimpleClusterRendererCpp_cg_objectIdentifier = _CSimpleClusterRendererCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSimpleClusterRendererCpp_renderCluster_CSimpleClusterObjectPtr = _lookup<ffi.NativeFunction<_CSimpleClusterOptions Function(_CSimpleClusterRendererCpp, _CSimpleClusterObject)>>('CSimpleClusterRendererCpp_renderCluster_CSimpleClusterObject');
late final _CSimpleClusterRendererCpp_renderCluster_CSimpleClusterObject = _CSimpleClusterRendererCpp_renderCluster_CSimpleClusterObjectPtr.asFunction<_CSimpleClusterOptions Function(_CSimpleClusterRendererCpp, _CSimpleClusterObject)>();

late final _CSimpleClusterRendererCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSimpleClusterRendererCpp_release');
late final _CSimpleClusterRendererCpp_release = _CSimpleClusterRendererCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleClusterRendererCpp_retainPtr = _lookup<ffi.NativeFunction<_CSimpleClusterRendererCpp Function(ffi.Pointer<ffi.Void>)>>('CSimpleClusterRendererCpp_retain');
late final _CSimpleClusterRendererCpp_retain = _CSimpleClusterRendererCpp_retainPtr.asFunction<_CSimpleClusterRendererCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleClusterRendererCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimpleClusterRendererCpp Function()>>('CSimpleClusterRendererCppMakeDefault');
late final _CSimpleClusterRendererCppMakeDefault = _CSimpleClusterRendererCppMakeDefaultPtr.asFunction<_CSimpleClusterRendererCpp Function()>();


late final _COptional_CImageMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CImage Function()>>('COptional_CImageMakeDefault');
late final _COptional_CImageMakeDefault = _COptional_CImageMakeDefaultPtr.asFunction<_COptional_CImage Function()>();

late final _COptional_CImage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CImage)>>('COptional_CImage_release');
late final _COptional_CImage_release = _COptional_CImage_releasePtr.asFunction<void Function(_COptional_CImage)>();

late final _COptional_CMapDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CMapDirection Function()>>('COptional_CMapDirectionMakeDefault');
late final _COptional_CMapDirectionMakeDefault = _COptional_CMapDirectionMakeDefaultPtr.asFunction<_COptional_CMapDirection Function()>();

late final _COptional_CTextStyleMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CTextStyle Function()>>('COptional_CTextStyleMakeDefault');
late final _COptional_CTextStyleMakeDefault = _COptional_CTextStyleMakeDefaultPtr.asFunction<_COptional_CTextStyle Function()>();

late final _COptional_CTextStyle_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CTextStyle)>>('COptional_CTextStyle_release');
late final _COptional_CTextStyle_release = _COptional_CTextStyle_releasePtr.asFunction<void Function(_COptional_CTextStyle)>();

late final _CSimpleClusterOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimpleClusterOptions Function()>>('CSimpleClusterOptionsMakeDefault');
late final _CSimpleClusterOptionsMakeDefault = _CSimpleClusterOptionsMakeDefaultPtr.asFunction<_CSimpleClusterOptions Function()>();

late final _CSimpleClusterObject_positionPtr = _lookup<ffi.NativeFunction<_CGeoPointWithElevation Function(_CSimpleClusterObject)>>('CSimpleClusterObject_position');
late final _CSimpleClusterObject_position = _CSimpleClusterObject_positionPtr.asFunction<_CGeoPointWithElevation Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_objectCountPtr = _lookup<ffi.NativeFunction<ffi.Uint32 Function(_CSimpleClusterObject)>>('CSimpleClusterObject_objectCount');
late final _CSimpleClusterObject_objectCount = _CSimpleClusterObject_objectCountPtr.asFunction<int Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_objectsPtr = _lookup<ffi.NativeFunction<_CArray_CSimpleMapObject Function(_CSimpleClusterObject)>>('CSimpleClusterObject_objects');
late final _CSimpleClusterObject_objects = _CSimpleClusterObject_objectsPtr.asFunction<_CArray_CSimpleMapObject Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_anchorPtr = _lookup<ffi.NativeFunction<_CAnchor Function(_CSimpleClusterObject)>>('CSimpleClusterObject_anchor');
late final _CSimpleClusterObject_anchor = _CSimpleClusterObject_anchorPtr.asFunction<_CAnchor Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setAnchor_CAnchorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _CAnchor)>>('CSimpleClusterObject_setAnchor_CAnchor');
late final _CSimpleClusterObject_setAnchor_CAnchor = _CSimpleClusterObject_setAnchor_CAnchorPtr.asFunction<void Function(_CSimpleClusterObject, _CAnchor)>();
late final _CSimpleClusterObject_iconOpacityPtr = _lookup<ffi.NativeFunction<_COpacity Function(_CSimpleClusterObject)>>('CSimpleClusterObject_iconOpacity');
late final _CSimpleClusterObject_iconOpacity = _CSimpleClusterObject_iconOpacityPtr.asFunction<_COpacity Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setIconOpacity_COpacityPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _COpacity)>>('CSimpleClusterObject_setIconOpacity_COpacity');
late final _CSimpleClusterObject_setIconOpacity_COpacity = _CSimpleClusterObject_setIconOpacity_COpacityPtr.asFunction<void Function(_CSimpleClusterObject, _COpacity)>();
late final _CSimpleClusterObject_textPtr = _lookup<ffi.NativeFunction<_CString Function(_CSimpleClusterObject)>>('CSimpleClusterObject_text');
late final _CSimpleClusterObject_text = _CSimpleClusterObject_textPtr.asFunction<_CString Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setText_CStringPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _CString)>>('CSimpleClusterObject_setText_CString');
late final _CSimpleClusterObject_setText_CString = _CSimpleClusterObject_setText_CStringPtr.asFunction<void Function(_CSimpleClusterObject, _CString)>();
late final _CSimpleClusterObject_textStylePtr = _lookup<ffi.NativeFunction<_CTextStyle Function(_CSimpleClusterObject)>>('CSimpleClusterObject_textStyle');
late final _CSimpleClusterObject_textStyle = _CSimpleClusterObject_textStylePtr.asFunction<_CTextStyle Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setTextStyle_CTextStylePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _CTextStyle)>>('CSimpleClusterObject_setTextStyle_CTextStyle');
late final _CSimpleClusterObject_setTextStyle_CTextStyle = _CSimpleClusterObject_setTextStyle_CTextStylePtr.asFunction<void Function(_CSimpleClusterObject, _CTextStyle)>();
late final _CSimpleClusterObject_iconWidthPtr = _lookup<ffi.NativeFunction<_CLogicalPixel Function(_CSimpleClusterObject)>>('CSimpleClusterObject_iconWidth');
late final _CSimpleClusterObject_iconWidth = _CSimpleClusterObject_iconWidthPtr.asFunction<_CLogicalPixel Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setIconWidth_CLogicalPixelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _CLogicalPixel)>>('CSimpleClusterObject_setIconWidth_CLogicalPixel');
late final _CSimpleClusterObject_setIconWidth_CLogicalPixel = _CSimpleClusterObject_setIconWidth_CLogicalPixelPtr.asFunction<void Function(_CSimpleClusterObject, _CLogicalPixel)>();
late final _CSimpleClusterObject_iconMapDirectionPtr = _lookup<ffi.NativeFunction<_COptional_CMapDirection Function(_CSimpleClusterObject)>>('CSimpleClusterObject_iconMapDirection');
late final _CSimpleClusterObject_iconMapDirection = _CSimpleClusterObject_iconMapDirectionPtr.asFunction<_COptional_CMapDirection Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setIconMapDirection_COptional_CMapDirectionPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _COptional_CMapDirection)>>('CSimpleClusterObject_setIconMapDirection_COptional_CMapDirection');
late final _CSimpleClusterObject_setIconMapDirection_COptional_CMapDirection = _CSimpleClusterObject_setIconMapDirection_COptional_CMapDirectionPtr.asFunction<void Function(_CSimpleClusterObject, _COptional_CMapDirection)>();
late final _CSimpleClusterObject_animatedAppearancePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CSimpleClusterObject)>>('CSimpleClusterObject_animatedAppearance');
late final _CSimpleClusterObject_animatedAppearance = _CSimpleClusterObject_animatedAppearancePtr.asFunction<bool Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setAnimatedAppearance_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, ffi.Bool)>>('CSimpleClusterObject_setAnimatedAppearance_bool');
late final _CSimpleClusterObject_setAnimatedAppearance_bool = _CSimpleClusterObject_setAnimatedAppearance_boolPtr.asFunction<void Function(_CSimpleClusterObject, bool)>();
late final _CSimpleClusterObject_zIndexPtr = _lookup<ffi.NativeFunction<_CZIndex Function(_CSimpleClusterObject)>>('CSimpleClusterObject_zIndex');
late final _CSimpleClusterObject_zIndex = _CSimpleClusterObject_zIndexPtr.asFunction<_CZIndex Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setZIndex_CZIndexPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _CZIndex)>>('CSimpleClusterObject_setZIndex_CZIndex');
late final _CSimpleClusterObject_setZIndex_CZIndex = _CSimpleClusterObject_setZIndex_CZIndexPtr.asFunction<void Function(_CSimpleClusterObject, _CZIndex)>();

late final _CSimpleClusterObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSimpleClusterObject_cg_objectIdentifier');
late final _CSimpleClusterObject_cg_objectIdentifier = _CSimpleClusterObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSimpleClusterObject_setIcon_COptional_CImagePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _COptional_CImage)>>('CSimpleClusterObject_setIcon_COptional_CImage');
late final _CSimpleClusterObject_setIcon_COptional_CImage = _CSimpleClusterObject_setIcon_COptional_CImagePtr.asFunction<void Function(_CSimpleClusterObject, _COptional_CImage)>();

late final _CSimpleClusterObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSimpleClusterObject_release');
late final _CSimpleClusterObject_release = _CSimpleClusterObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleClusterObject_retainPtr = _lookup<ffi.NativeFunction<_CSimpleClusterObject Function(ffi.Pointer<ffi.Void>)>>('CSimpleClusterObject_retain');
late final _CSimpleClusterObject_retain = _CSimpleClusterObject_retainPtr.asFunction<_CSimpleClusterObject Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleClusterObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimpleClusterObject Function()>>('CSimpleClusterObjectMakeDefault');
late final _CSimpleClusterObjectMakeDefault = _CSimpleClusterObjectMakeDefaultPtr.asFunction<_CSimpleClusterObject Function()>();


late final _CSimpleClusterRendererMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimpleClusterRenderer Function()>>('CSimpleClusterRendererMakeDefault');
late final _CSimpleClusterRendererMakeDefault = _CSimpleClusterRendererMakeDefaultPtr.asFunction<_CSimpleClusterRenderer Function()>();
late final _CSimpleClusterRenderer_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterRenderer)>>('CSimpleClusterRenderer_release');
late final _CSimpleClusterRenderer_release = _CSimpleClusterRenderer_releasePtr.asFunction<void Function(_CSimpleClusterRenderer)>();
late final _CMarker_positionPtr = _lookup<ffi.NativeFunction<_CGeoPointWithElevation Function(_CMarker)>>('CMarker_position');
late final _CMarker_position = _CMarker_positionPtr.asFunction<_CGeoPointWithElevation Function(_CMarker)>();
late final _CMarker_setPosition_CGeoPointWithElevationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _CGeoPointWithElevation)>>('CMarker_setPosition_CGeoPointWithElevation');
late final _CMarker_setPosition_CGeoPointWithElevation = _CMarker_setPosition_CGeoPointWithElevationPtr.asFunction<void Function(_CMarker, _CGeoPointWithElevation)>();
late final _CMarker_iconPtr = _lookup<ffi.NativeFunction<_COptional_CImage Function(_CMarker)>>('CMarker_icon');
late final _CMarker_icon = _CMarker_iconPtr.asFunction<_COptional_CImage Function(_CMarker)>();
late final _CMarker_setIcon_COptional_CImagePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _COptional_CImage)>>('CMarker_setIcon_COptional_CImage');
late final _CMarker_setIcon_COptional_CImage = _CMarker_setIcon_COptional_CImagePtr.asFunction<void Function(_CMarker, _COptional_CImage)>();
late final _CMarker_anchorPtr = _lookup<ffi.NativeFunction<_CAnchor Function(_CMarker)>>('CMarker_anchor');
late final _CMarker_anchor = _CMarker_anchorPtr.asFunction<_CAnchor Function(_CMarker)>();
late final _CMarker_setAnchor_CAnchorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _CAnchor)>>('CMarker_setAnchor_CAnchor');
late final _CMarker_setAnchor_CAnchor = _CMarker_setAnchor_CAnchorPtr.asFunction<void Function(_CMarker, _CAnchor)>();
late final _CMarker_iconOpacityPtr = _lookup<ffi.NativeFunction<_COpacity Function(_CMarker)>>('CMarker_iconOpacity');
late final _CMarker_iconOpacity = _CMarker_iconOpacityPtr.asFunction<_COpacity Function(_CMarker)>();
late final _CMarker_setIconOpacity_COpacityPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _COpacity)>>('CMarker_setIconOpacity_COpacity');
late final _CMarker_setIconOpacity_COpacity = _CMarker_setIconOpacity_COpacityPtr.asFunction<void Function(_CMarker, _COpacity)>();
late final _CMarker_textPtr = _lookup<ffi.NativeFunction<_CString Function(_CMarker)>>('CMarker_text');
late final _CMarker_text = _CMarker_textPtr.asFunction<_CString Function(_CMarker)>();
late final _CMarker_setText_CStringPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _CString)>>('CMarker_setText_CString');
late final _CMarker_setText_CString = _CMarker_setText_CStringPtr.asFunction<void Function(_CMarker, _CString)>();
late final _CMarker_textStylePtr = _lookup<ffi.NativeFunction<_CTextStyle Function(_CMarker)>>('CMarker_textStyle');
late final _CMarker_textStyle = _CMarker_textStylePtr.asFunction<_CTextStyle Function(_CMarker)>();
late final _CMarker_setTextStyle_CTextStylePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _CTextStyle)>>('CMarker_setTextStyle_CTextStyle');
late final _CMarker_setTextStyle_CTextStyle = _CMarker_setTextStyle_CTextStylePtr.asFunction<void Function(_CMarker, _CTextStyle)>();
late final _CMarker_isDraggablePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMarker)>>('CMarker_isDraggable');
late final _CMarker_isDraggable = _CMarker_isDraggablePtr.asFunction<bool Function(_CMarker)>();
late final _CMarker_setDraggable_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, ffi.Bool)>>('CMarker_setDraggable_bool');
late final _CMarker_setDraggable_bool = _CMarker_setDraggable_boolPtr.asFunction<void Function(_CMarker, bool)>();
late final _CMarker_iconWidthPtr = _lookup<ffi.NativeFunction<_CLogicalPixel Function(_CMarker)>>('CMarker_iconWidth');
late final _CMarker_iconWidth = _CMarker_iconWidthPtr.asFunction<_CLogicalPixel Function(_CMarker)>();
late final _CMarker_setIconWidth_CLogicalPixelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _CLogicalPixel)>>('CMarker_setIconWidth_CLogicalPixel');
late final _CMarker_setIconWidth_CLogicalPixel = _CMarker_setIconWidth_CLogicalPixelPtr.asFunction<void Function(_CMarker, _CLogicalPixel)>();
late final _CMarker_iconMapDirectionPtr = _lookup<ffi.NativeFunction<_COptional_CMapDirection Function(_CMarker)>>('CMarker_iconMapDirection');
late final _CMarker_iconMapDirection = _CMarker_iconMapDirectionPtr.asFunction<_COptional_CMapDirection Function(_CMarker)>();
late final _CMarker_setIconMapDirection_COptional_CMapDirectionPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _COptional_CMapDirection)>>('CMarker_setIconMapDirection_COptional_CMapDirection');
late final _CMarker_setIconMapDirection_COptional_CMapDirection = _CMarker_setIconMapDirection_COptional_CMapDirectionPtr.asFunction<void Function(_CMarker, _COptional_CMapDirection)>();
late final _CMarker_animatedAppearancePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMarker)>>('CMarker_animatedAppearance');
late final _CMarker_animatedAppearance = _CMarker_animatedAppearancePtr.asFunction<bool Function(_CMarker)>();
late final _CMarker_setAnimatedAppearance_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, ffi.Bool)>>('CMarker_setAnimatedAppearance_bool');
late final _CMarker_setAnimatedAppearance_bool = _CMarker_setAnimatedAppearance_boolPtr.asFunction<void Function(_CMarker, bool)>();
late final _CMarker_iconAnimationModePtr = _lookup<ffi.NativeFunction<_CAnimationMode Function(_CMarker)>>('CMarker_iconAnimationMode');
late final _CMarker_iconAnimationMode = _CMarker_iconAnimationModePtr.asFunction<_CAnimationMode Function(_CMarker)>();
late final _CMarker_setIconAnimationMode_CAnimationModePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _CAnimationMode)>>('CMarker_setIconAnimationMode_CAnimationMode');
late final _CMarker_setIconAnimationMode_CAnimationMode = _CMarker_setIconAnimationMode_CAnimationModePtr.asFunction<void Function(_CMarker, _CAnimationMode)>();

late final _CMarker_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMarker_cg_objectIdentifier');
late final _CMarker_cg_objectIdentifier = _CMarker_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMarker_C_createWith_CMarkerOptionsPtr = _lookup<ffi.NativeFunction<_CResult_CMarker Function(_CMarkerOptions)>>('CMarker_C_createWith_CMarkerOptions');
late final _CMarker_C_createWith_CMarkerOptions = _CMarker_C_createWith_CMarkerOptionsPtr.asFunction<_CResult_CMarker Function(_CMarkerOptions)>();

late final _CMarker_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMarker_release');
late final _CMarker_release = _CMarker_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMarker_retainPtr = _lookup<ffi.NativeFunction<_CMarker Function(ffi.Pointer<ffi.Void>)>>('CMarker_retain');
late final _CMarker_retain = _CMarker_retainPtr.asFunction<_CMarker Function(ffi.Pointer<ffi.Void>)>();
late final _CMarkerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMarker Function()>>('CMarkerMakeDefault');
late final _CMarkerMakeDefault = _CMarkerMakeDefaultPtr.asFunction<_CMarker Function()>();


late final _CMarkerOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMarkerOptions Function()>>('CMarkerOptionsMakeDefault');
late final _CMarkerOptionsMakeDefault = _CMarkerOptionsMakeDefaultPtr.asFunction<_CMarkerOptions Function()>();


late final _CResult_CMarker_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CMarker)>>('CResult_CMarker_release');
late final _CResult_CMarker_release = _CResult_CMarker_releasePtr.asFunction<void Function(_CResult_CMarker)>();

late final _CModelDataLoaderCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CModelDataLoaderCpp_cg_objectIdentifier');
late final _CModelDataLoaderCpp_cg_objectIdentifier = _CModelDataLoaderCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CModelDataLoaderCpp_loadPtr = _lookup<ffi.NativeFunction<_CData Function(_CModelDataLoaderCpp)>>('CModelDataLoaderCpp_load');
late final _CModelDataLoaderCpp_load = _CModelDataLoaderCpp_loadPtr.asFunction<_CData Function(_CModelDataLoaderCpp)>();

late final _CModelDataLoaderCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CModelDataLoaderCpp_release');
late final _CModelDataLoaderCpp_release = _CModelDataLoaderCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CModelDataLoaderCpp_retainPtr = _lookup<ffi.NativeFunction<_CModelDataLoaderCpp Function(ffi.Pointer<ffi.Void>)>>('CModelDataLoaderCpp_retain');
late final _CModelDataLoaderCpp_retain = _CModelDataLoaderCpp_retainPtr.asFunction<_CModelDataLoaderCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CModelDataLoaderCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelDataLoaderCpp Function()>>('CModelDataLoaderCppMakeDefault');
late final _CModelDataLoaderCppMakeDefault = _CModelDataLoaderCppMakeDefaultPtr.asFunction<_CModelDataLoaderCpp Function()>();


late final _CModelDataLoaderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelDataLoader Function()>>('CModelDataLoaderMakeDefault');
late final _CModelDataLoaderMakeDefault = _CModelDataLoaderMakeDefaultPtr.asFunction<_CModelDataLoader Function()>();
late final _CModelDataLoader_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelDataLoader)>>('CModelDataLoader_release');
late final _CModelDataLoader_release = _CModelDataLoader_releasePtr.asFunction<void Function(_CModelDataLoader)>();

late final _CModelSize_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelSize)>>('CModelSize_release');
late final _CModelSize_release = _CModelSize_releasePtr.asFunction<void Function(_CModelSize)>();
late final _CModelSizeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelSize Function()>>('CModelSizeMakeDefault');
late final _CModelSizeMakeDefault = _CModelSizeMakeDefaultPtr.asFunction<_CModelSize Function()>();

late final _CModelMapObjectOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelMapObjectOptions Function()>>('CModelMapObjectOptionsMakeDefault');
late final _CModelMapObjectOptionsMakeDefault = _CModelMapObjectOptionsMakeDefaultPtr.asFunction<_CModelMapObjectOptions Function()>();

late final _CModelMapObject_positionPtr = _lookup<ffi.NativeFunction<_CGeoPointWithElevation Function(_CModelMapObject)>>('CModelMapObject_position');
late final _CModelMapObject_position = _CModelMapObject_positionPtr.asFunction<_CGeoPointWithElevation Function(_CModelMapObject)>();
late final _CModelMapObject_setPosition_CGeoPointWithElevationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelMapObject, _CGeoPointWithElevation)>>('CModelMapObject_setPosition_CGeoPointWithElevation');
late final _CModelMapObject_setPosition_CGeoPointWithElevation = _CModelMapObject_setPosition_CGeoPointWithElevationPtr.asFunction<void Function(_CModelMapObject, _CGeoPointWithElevation)>();
late final _CModelMapObject_modelDataPtr = _lookup<ffi.NativeFunction<_COptional_CModelData Function(_CModelMapObject)>>('CModelMapObject_modelData');
late final _CModelMapObject_modelData = _CModelMapObject_modelDataPtr.asFunction<_COptional_CModelData Function(_CModelMapObject)>();
late final _CModelMapObject_setModelData_COptional_CModelDataPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelMapObject, _COptional_CModelData)>>('CModelMapObject_setModelData_COptional_CModelData');
late final _CModelMapObject_setModelData_COptional_CModelData = _CModelMapObject_setModelData_COptional_CModelDataPtr.asFunction<void Function(_CModelMapObject, _COptional_CModelData)>();
late final _CModelMapObject_opacityPtr = _lookup<ffi.NativeFunction<_COpacity Function(_CModelMapObject)>>('CModelMapObject_opacity');
late final _CModelMapObject_opacity = _CModelMapObject_opacityPtr.asFunction<_COpacity Function(_CModelMapObject)>();
late final _CModelMapObject_setOpacity_COpacityPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelMapObject, _COpacity)>>('CModelMapObject_setOpacity_COpacity');
late final _CModelMapObject_setOpacity_COpacity = _CModelMapObject_setOpacity_COpacityPtr.asFunction<void Function(_CModelMapObject, _COpacity)>();
late final _CModelMapObject_sizePtr = _lookup<ffi.NativeFunction<_CModelSize Function(_CModelMapObject)>>('CModelMapObject_size');
late final _CModelMapObject_size = _CModelMapObject_sizePtr.asFunction<_CModelSize Function(_CModelMapObject)>();
late final _CModelMapObject_setSize_CModelSizePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelMapObject, _CModelSize)>>('CModelMapObject_setSize_CModelSize');
late final _CModelMapObject_setSize_CModelSize = _CModelMapObject_setSize_CModelSizePtr.asFunction<void Function(_CModelMapObject, _CModelSize)>();
late final _CModelMapObject_mapDirectionPtr = _lookup<ffi.NativeFunction<_COptional_CMapDirection Function(_CModelMapObject)>>('CModelMapObject_mapDirection');
late final _CModelMapObject_mapDirection = _CModelMapObject_mapDirectionPtr.asFunction<_COptional_CMapDirection Function(_CModelMapObject)>();
late final _CModelMapObject_setMapDirection_COptional_CMapDirectionPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelMapObject, _COptional_CMapDirection)>>('CModelMapObject_setMapDirection_COptional_CMapDirection');
late final _CModelMapObject_setMapDirection_COptional_CMapDirection = _CModelMapObject_setMapDirection_COptional_CMapDirectionPtr.asFunction<void Function(_CModelMapObject, _COptional_CMapDirection)>();
late final _CModelMapObject_animationSettingsPtr = _lookup<ffi.NativeFunction<_CAnimationSettings Function(_CModelMapObject)>>('CModelMapObject_animationSettings');
late final _CModelMapObject_animationSettings = _CModelMapObject_animationSettingsPtr.asFunction<_CAnimationSettings Function(_CModelMapObject)>();

late final _CModelMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CModelMapObject_cg_objectIdentifier');
late final _CModelMapObject_cg_objectIdentifier = _CModelMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CModelMapObject_C_createWith_CModelMapObjectOptionsPtr = _lookup<ffi.NativeFunction<_CResult_CModelMapObject Function(_CModelMapObjectOptions)>>('CModelMapObject_C_createWith_CModelMapObjectOptions');
late final _CModelMapObject_C_createWith_CModelMapObjectOptions = _CModelMapObject_C_createWith_CModelMapObjectOptionsPtr.asFunction<_CResult_CModelMapObject Function(_CModelMapObjectOptions)>();

late final _CModelMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CModelMapObject_release');
late final _CModelMapObject_release = _CModelMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CModelMapObject_retainPtr = _lookup<ffi.NativeFunction<_CModelMapObject Function(ffi.Pointer<ffi.Void>)>>('CModelMapObject_retain');
late final _CModelMapObject_retain = _CModelMapObject_retainPtr.asFunction<_CModelMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CModelMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelMapObject Function()>>('CModelMapObjectMakeDefault');
late final _CModelMapObjectMakeDefault = _CModelMapObjectMakeDefaultPtr.asFunction<_CModelMapObject Function()>();


late final _CResult_CModelMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CModelMapObject)>>('CResult_CModelMapObject_release');
late final _CResult_CModelMapObject_release = _CResult_CModelMapObject_releasePtr.asFunction<void Function(_CResult_CModelMapObject)>();
late final _CFunction_G_createModelData_With_CContext_CModelDataLoaderPtr = _lookup<ffi.NativeFunction<_CModelData Function(_CContext, _CModelDataLoader)>>('CFunction_G_createModelData_With_CContext_CModelDataLoader');
late final _CFunction_G_createModelData_With_CContext_CModelDataLoader = _CFunction_G_createModelData_With_CContext_CModelDataLoaderPtr.asFunction<_CModelData Function(_CContext, _CModelDataLoader)>();
late final _CFunction_G_parseGeoJsonFile_With_CStringPtr = _lookup<ffi.NativeFunction<_CArray_CGeometryMapObject Function(_CString)>>('CFunction_G_parseGeoJsonFile_With_CString');
late final _CFunction_G_parseGeoJsonFile_With_CString = _CFunction_G_parseGeoJsonFile_With_CStringPtr.asFunction<_CArray_CGeometryMapObject Function(_CString)>();
late final _CFunction_G_parseGeoJson_With_CStringPtr = _lookup<ffi.NativeFunction<_CArray_CGeometryMapObject Function(_CString)>>('CFunction_G_parseGeoJson_With_CString');
late final _CFunction_G_parseGeoJson_With_CString = _CFunction_G_parseGeoJson_With_CStringPtr.asFunction<_CArray_CGeometryMapObject Function(_CString)>();
late final _CFunction_G_calcPositionForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSizePtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CBaseCamera, _CGeometry, _COptional_CStyleZoomToTiltRelation, _COptional_CPadding, _COptional_CTilt, _COptional_CBearing, _COptional_CScreenSize)>>('CFunction_G_calcPositionForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSize');
late final _CFunction_G_calcPositionForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSize = _CFunction_G_calcPositionForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSizePtr.asFunction<_CCameraPosition Function(_CBaseCamera, _CGeometry, _COptional_CStyleZoomToTiltRelation, _COptional_CPadding, _COptional_CTilt, _COptional_CBearing, _COptional_CScreenSize)>();

late final _COptional_CPaddingMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CPadding Function()>>('COptional_CPaddingMakeDefault');
late final _COptional_CPaddingMakeDefault = _COptional_CPaddingMakeDefaultPtr.asFunction<_COptional_CPadding Function()>();

late final _COptional_CScreenSizeMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CScreenSize Function()>>('COptional_CScreenSizeMakeDefault');
late final _COptional_CScreenSizeMakeDefault = _COptional_CScreenSizeMakeDefaultPtr.asFunction<_COptional_CScreenSize Function()>();
late final _CFunction_G_calcPositionForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSizePtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CBaseCamera, _CArray_CSimpleMapObject, _COptional_CStyleZoomToTiltRelation, _COptional_CPadding, _COptional_CTilt, _COptional_CBearing, _COptional_CScreenSize)>>('CFunction_G_calcPositionForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSize');
late final _CFunction_G_calcPositionForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSize = _CFunction_G_calcPositionForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSizePtr.asFunction<_CCameraPosition Function(_CBaseCamera, _CArray_CSimpleMapObject, _COptional_CStyleZoomToTiltRelation, _COptional_CPadding, _COptional_CTilt, _COptional_CBearing, _COptional_CScreenSize)>();
late final _CFunction_G_zoomOutToFitForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CScreenSizePtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CBaseCamera, _CGeometry, _COptional_CStyleZoomToTiltRelation, _COptional_CScreenSize)>>('CFunction_G_zoomOutToFitForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CScreenSize');
late final _CFunction_G_zoomOutToFitForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CScreenSize = _CFunction_G_zoomOutToFitForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CScreenSizePtr.asFunction<_CCameraPosition Function(_CBaseCamera, _CGeometry, _COptional_CStyleZoomToTiltRelation, _COptional_CScreenSize)>();
late final _CFunction_G_zoomOutToFitForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CScreenSizePtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CBaseCamera, _CArray_CSimpleMapObject, _COptional_CStyleZoomToTiltRelation, _COptional_CScreenSize)>>('CFunction_G_zoomOutToFitForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CScreenSize');
late final _CFunction_G_zoomOutToFitForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CScreenSize = _CFunction_G_zoomOutToFitForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CScreenSizePtr.asFunction<_CCameraPosition Function(_CBaseCamera, _CArray_CSimpleMapObject, _COptional_CStyleZoomToTiltRelation, _COptional_CScreenSize)>();
late final _CFunction_G_createImage_With_CContext_CImageLoaderPtr = _lookup<ffi.NativeFunction<_CImage Function(_CContext, _CImageLoader)>>('CFunction_G_createImage_With_CContext_CImageLoader');
late final _CFunction_G_createImage_With_CContext_CImageLoader = _CFunction_G_createImage_With_CContext_CImageLoaderPtr.asFunction<_CImage Function(_CContext, _CImageLoader)>();
late final _CFunction_G_createDefaultMaxTiltRestrictionPtr = _lookup<ffi.NativeFunction<_CStyleZoomToTiltRelation Function()>>('CFunction_G_createDefaultMaxTiltRestriction');
late final _CFunction_G_createDefaultMaxTiltRestriction = _CFunction_G_createDefaultMaxTiltRestrictionPtr.asFunction<_CStyleZoomToTiltRelation Function()>();
late final _CFunction_G_createDefaultStyleZoomToTiltRelationPtr = _lookup<ffi.NativeFunction<_CStyleZoomToTiltRelation Function()>>('CFunction_G_createDefaultStyleZoomToTiltRelation');
late final _CFunction_G_createDefaultStyleZoomToTiltRelation = _CFunction_G_createDefaultStyleZoomToTiltRelationPtr.asFunction<_CStyleZoomToTiltRelation Function()>();
late final _CFunction_G_createStyleZoomToTiltRelation_With_CDictionary_CStyleZoom_CTiltPtr = _lookup<ffi.NativeFunction<_CStyleZoomToTiltRelation Function(_CDictionary_CStyleZoom_CTilt)>>('CFunction_G_createStyleZoomToTiltRelation_With_CDictionary_CStyleZoom_CTilt');
late final _CFunction_G_createStyleZoomToTiltRelation_With_CDictionary_CStyleZoom_CTilt = _CFunction_G_createStyleZoomToTiltRelation_With_CDictionary_CStyleZoom_CTiltPtr.asFunction<_CStyleZoomToTiltRelation Function(_CDictionary_CStyleZoom_CTilt)>();

late final _CDictionary_CStyleZoom_CTiltmakeEmptyPtr = _lookup<ffi.NativeFunction<_CDictionary_CStyleZoom_CTilt Function()>>('CDictionary_CStyleZoom_CTilt_makeEmpty');
late final _CDictionary_CStyleZoom_CTiltmakeEmpty = _CDictionary_CStyleZoom_CTiltmakeEmptyPtr.asFunction<_CDictionary_CStyleZoom_CTilt Function()>();
late final _CDictionary_CStyleZoom_CTiltaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDictionary_CStyleZoom_CTilt, _CStyleZoom, _CTilt)>>('CDictionary_CStyleZoom_CTilt_addElement');
late final _CDictionary_CStyleZoom_CTiltaddElement = _CDictionary_CStyleZoom_CTiltaddElementPtr.asFunction<void Function(_CDictionary_CStyleZoom_CTilt, _CStyleZoom, _CTilt)>();
late final _forEach_CDictionary_CStyleZoom_CTiltPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CDictionary_CStyleZoom_CTilt, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStyleZoom, _CTilt)>>)
>>('CDictionary_CStyleZoom_CTilt_forEachKeyValueWithFunctionPointer');
late final _forEach_CDictionary_CStyleZoom_CTilt = _forEach_CDictionary_CStyleZoom_CTiltPtr.asFunction<
  void Function(_CDictionary_CStyleZoom_CTilt, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStyleZoom, _CTilt)
>>)>();
late final _CDictionary_CStyleZoom_CTilt_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDictionary_CStyleZoom_CTilt)>>('CDictionary_CStyleZoom_CTilt_release');
late final _CDictionary_CStyleZoom_CTilt_release = _CDictionary_CStyleZoom_CTilt_releasePtr.asFunction<void Function(_CDictionary_CStyleZoom_CTilt)>();
late final _CFunction_G_projectionZToStyleZ_With_CZoom_CLatitudePtr = _lookup<ffi.NativeFunction<_CStyleZoom Function(_CZoom, _CLatitude)>>('CFunction_G_projectionZToStyleZ_With_CZoom_CLatitude');
late final _CFunction_G_projectionZToStyleZ_With_CZoom_CLatitude = _CFunction_G_projectionZToStyleZ_With_CZoom_CLatitudePtr.asFunction<_CStyleZoom Function(_CZoom, _CLatitude)>();
late final _CFunction_G_styleZToProjectionZ_With_CStyleZoom_CLatitudePtr = _lookup<ffi.NativeFunction<_CZoom Function(_CStyleZoom, _CLatitude)>>('CFunction_G_styleZToProjectionZ_With_CStyleZoom_CLatitude');
late final _CFunction_G_styleZToProjectionZ_With_CStyleZoom_CLatitude = _CFunction_G_styleZToProjectionZ_With_CStyleZoom_CLatitudePtr.asFunction<_CZoom Function(_CStyleZoom, _CLatitude)>();
late final _CFunction_G_toMapGeometry_With_CGeoPointRouteAttributePtr = _lookup<ffi.NativeFunction<_CGeometry Function(_CGeoPointRouteAttribute)>>('CFunction_G_toMapGeometry_With_CGeoPointRouteAttribute');
late final _CFunction_G_toMapGeometry_With_CGeoPointRouteAttribute = _CFunction_G_toMapGeometry_With_CGeoPointRouteAttributePtr.asFunction<_CGeometry Function(_CGeoPointRouteAttribute)>();
late final _CGeoPointRouteAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CGeoPointRouteAttribute)>>('CGeoPointRouteAttribute_size');
late final _CGeoPointRouteAttribute_size = _CGeoPointRouteAttribute_sizePtr.asFunction<int Function(_CGeoPointRouteAttribute)>();
late final _CGeoPointRouteAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoPointRouteAttribute)>>('CGeoPointRouteAttribute_isEmpty');
late final _CGeoPointRouteAttribute_isEmpty = _CGeoPointRouteAttribute_isEmptyPtr.asFunction<bool Function(_CGeoPointRouteAttribute)>();
late final _CGeoPointRouteAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPointRouteEntry Function(_CGeoPointRouteAttribute)>>('CGeoPointRouteAttribute_first');
late final _CGeoPointRouteAttribute_first = _CGeoPointRouteAttribute_firstPtr.asFunction<_COptional_CGeoPointRouteEntry Function(_CGeoPointRouteAttribute)>();
late final _CGeoPointRouteAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPointRouteEntry Function(_CGeoPointRouteAttribute)>>('CGeoPointRouteAttribute_last');
late final _CGeoPointRouteAttribute_last = _CGeoPointRouteAttribute_lastPtr.asFunction<_COptional_CGeoPointRouteEntry Function(_CGeoPointRouteAttribute)>();
late final _CGeoPointRouteAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CGeoPointRouteEntry Function(_CGeoPointRouteAttribute)>>('CGeoPointRouteAttribute_entries');
late final _CGeoPointRouteAttribute_entries = _CGeoPointRouteAttribute_entriesPtr.asFunction<_CArray_CGeoPointRouteEntry Function(_CGeoPointRouteAttribute)>();
late final _CGeoPointRouteAttribute_lengthPtr = _lookup<ffi.NativeFunction<_CRouteDistance Function(_CGeoPointRouteAttribute)>>('CGeoPointRouteAttribute_length');
late final _CGeoPointRouteAttribute_length = _CGeoPointRouteAttribute_lengthPtr.asFunction<_CRouteDistance Function(_CGeoPointRouteAttribute)>();

late final _CGeoPointRouteAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGeoPointRouteAttribute_cg_objectIdentifier');
late final _CGeoPointRouteAttribute_cg_objectIdentifier = _CGeoPointRouteAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CGeoPointRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CGeoPointRouteEntry Function(_CGeoPointRouteAttribute, _CRoutePoint, _CRoutePoint)>>('CGeoPointRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CGeoPointRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CGeoPointRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CGeoPointRouteEntry Function(_CGeoPointRouteAttribute, _CRoutePoint, _CRoutePoint)>();
late final _CGeoPointRouteAttribute_findNearBackward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPointRouteEntry Function(_CGeoPointRouteAttribute, _CRoutePoint)>>('CGeoPointRouteAttribute_findNearBackward_CRoutePoint');
late final _CGeoPointRouteAttribute_findNearBackward_CRoutePoint = _CGeoPointRouteAttribute_findNearBackward_CRoutePointPtr.asFunction<_COptional_CGeoPointRouteEntry Function(_CGeoPointRouteAttribute, _CRoutePoint)>();
late final _CGeoPointRouteAttribute_findNearForward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPointRouteEntry Function(_CGeoPointRouteAttribute, _CRoutePoint)>>('CGeoPointRouteAttribute_findNearForward_CRoutePoint');
late final _CGeoPointRouteAttribute_findNearForward_CRoutePoint = _CGeoPointRouteAttribute_findNearForward_CRoutePointPtr.asFunction<_COptional_CGeoPointRouteEntry Function(_CGeoPointRouteAttribute, _CRoutePoint)>();
late final _CGeoPointRouteAttribute_calculateGeoPoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CSegmentGeoPoint Function(_CGeoPointRouteAttribute, _CRoutePoint)>>('CGeoPointRouteAttribute_calculateGeoPoint_CRoutePoint');
late final _CGeoPointRouteAttribute_calculateGeoPoint_CRoutePoint = _CGeoPointRouteAttribute_calculateGeoPoint_CRoutePointPtr.asFunction<_COptional_CSegmentGeoPoint Function(_CGeoPointRouteAttribute, _CRoutePoint)>();
late final _CGeoPointRouteAttribute_calculateClosestPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<_COptional_CRoutePoint Function(_CGeoPointRouteAttribute, _CGeoPoint)>>('CGeoPointRouteAttribute_calculateClosestPoint_CGeoPoint');
late final _CGeoPointRouteAttribute_calculateClosestPoint_CGeoPoint = _CGeoPointRouteAttribute_calculateClosestPoint_CGeoPointPtr.asFunction<_COptional_CRoutePoint Function(_CGeoPointRouteAttribute, _CGeoPoint)>();

late final _CGeoPointRouteAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGeoPointRouteAttribute_release');
late final _CGeoPointRouteAttribute_release = _CGeoPointRouteAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGeoPointRouteAttribute_retainPtr = _lookup<ffi.NativeFunction<_CGeoPointRouteAttribute Function(ffi.Pointer<ffi.Void>)>>('CGeoPointRouteAttribute_retain');
late final _CGeoPointRouteAttribute_retain = _CGeoPointRouteAttribute_retainPtr.asFunction<_CGeoPointRouteAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CGeoPointRouteAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeoPointRouteAttribute Function()>>('CGeoPointRouteAttributeMakeDefault');
late final _CGeoPointRouteAttributeMakeDefault = _CGeoPointRouteAttributeMakeDefaultPtr.asFunction<_CGeoPointRouteAttribute Function()>();


late final _CRouteDistanceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteDistance Function()>>('CRouteDistanceMakeDefault');
late final _CRouteDistanceMakeDefault = _CRouteDistanceMakeDefaultPtr.asFunction<_CRouteDistance Function()>();


late final _CRoutePointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoutePoint Function()>>('CRoutePointMakeDefault');
late final _CRoutePointMakeDefault = _CRoutePointMakeDefaultPtr.asFunction<_CRoutePoint Function()>();


late final _CGeoPointRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeoPointRouteEntry Function()>>('CGeoPointRouteEntryMakeDefault');
late final _CGeoPointRouteEntryMakeDefault = _CGeoPointRouteEntryMakeDefaultPtr.asFunction<_CGeoPointRouteEntry Function()>();


late final _COptional_CGeoPointRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPointRouteEntry Function()>>('COptional_CGeoPointRouteEntryMakeDefault');
late final _COptional_CGeoPointRouteEntryMakeDefault = _COptional_CGeoPointRouteEntryMakeDefaultPtr.asFunction<_COptional_CGeoPointRouteEntry Function()>();

late final _CArray_CGeoPointRouteEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CGeoPointRouteEntry Function()>>('CArray_CGeoPointRouteEntry_makeEmpty');
late final _CArray_CGeoPointRouteEntrymakeEmpty = _CArray_CGeoPointRouteEntrymakeEmptyPtr.asFunction<_CArray_CGeoPointRouteEntry Function()>();
late final _CArray_CGeoPointRouteEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeoPointRouteEntry, _CGeoPointRouteEntry)>>('CArray_CGeoPointRouteEntry_addElement');
late final _CArray_CGeoPointRouteEntryaddElement = _CArray_CGeoPointRouteEntryaddElementPtr.asFunction<void Function(_CArray_CGeoPointRouteEntry, _CGeoPointRouteEntry)>();
late final _forEach_CArray_CGeoPointRouteEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CGeoPointRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeoPointRouteEntry)>>)
>>('CArray_CGeoPointRouteEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CGeoPointRouteEntry = _forEach_CArray_CGeoPointRouteEntryPtr.asFunction<
  void Function(_CArray_CGeoPointRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeoPointRouteEntry)
>>)>();
late final _CArray_CGeoPointRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeoPointRouteEntry)>>('CArray_CGeoPointRouteEntry_release');
late final _CArray_CGeoPointRouteEntry_release = _CArray_CGeoPointRouteEntry_releasePtr.asFunction<void Function(_CArray_CGeoPointRouteEntry)>();

late final _CSegmentGeoPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSegmentGeoPoint Function()>>('CSegmentGeoPointMakeDefault');
late final _CSegmentGeoPointMakeDefault = _CSegmentGeoPointMakeDefaultPtr.asFunction<_CSegmentGeoPoint Function()>();


late final _COptional_CSegmentGeoPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CSegmentGeoPoint Function()>>('COptional_CSegmentGeoPointMakeDefault');
late final _COptional_CSegmentGeoPointMakeDefault = _COptional_CSegmentGeoPointMakeDefaultPtr.asFunction<_COptional_CSegmentGeoPoint Function()>();

late final _COptional_CRoutePointMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRoutePoint Function()>>('COptional_CRoutePointMakeDefault');
late final _COptional_CRoutePointMakeDefault = _COptional_CRoutePointMakeDefaultPtr.asFunction<_COptional_CRoutePoint Function()>();

late final _CDashedStrokeCircleOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDashedStrokeCircleOptions Function()>>('CDashedStrokeCircleOptionsMakeDefault');
late final _CDashedStrokeCircleOptionsMakeDefault = _CDashedStrokeCircleOptionsMakeDefaultPtr.asFunction<_CDashedStrokeCircleOptions Function()>();

late final _CCircle_positionPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CCircle)>>('CCircle_position');
late final _CCircle_position = _CCircle_positionPtr.asFunction<_CGeoPoint Function(_CCircle)>();
late final _CCircle_setPosition_CGeoPointPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CCircle, _CGeoPoint)>>('CCircle_setPosition_CGeoPoint');
late final _CCircle_setPosition_CGeoPoint = _CCircle_setPosition_CGeoPointPtr.asFunction<_CResult_CEmpty Function(_CCircle, _CGeoPoint)>();
late final _CCircle_radiusPtr = _lookup<ffi.NativeFunction<_CMeter Function(_CCircle)>>('CCircle_radius');
late final _CCircle_radius = _CCircle_radiusPtr.asFunction<_CMeter Function(_CCircle)>();
late final _CCircle_setRadius_CMeterPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CCircle, _CMeter)>>('CCircle_setRadius_CMeter');
late final _CCircle_setRadius_CMeter = _CCircle_setRadius_CMeterPtr.asFunction<_CResult_CEmpty Function(_CCircle, _CMeter)>();
late final _CCircle_colorPtr = _lookup<ffi.NativeFunction<_CColor Function(_CCircle)>>('CCircle_color');
late final _CCircle_color = _CCircle_colorPtr.asFunction<_CColor Function(_CCircle)>();
late final _CCircle_setColor_CColorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCircle, _CColor)>>('CCircle_setColor_CColor');
late final _CCircle_setColor_CColor = _CCircle_setColor_CColorPtr.asFunction<void Function(_CCircle, _CColor)>();
late final _CCircle_strokeWidthPtr = _lookup<ffi.NativeFunction<_CLogicalPixel Function(_CCircle)>>('CCircle_strokeWidth');
late final _CCircle_strokeWidth = _CCircle_strokeWidthPtr.asFunction<_CLogicalPixel Function(_CCircle)>();
late final _CCircle_setStrokeWidth_CLogicalPixelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCircle, _CLogicalPixel)>>('CCircle_setStrokeWidth_CLogicalPixel');
late final _CCircle_setStrokeWidth_CLogicalPixel = _CCircle_setStrokeWidth_CLogicalPixelPtr.asFunction<void Function(_CCircle, _CLogicalPixel)>();
late final _CCircle_strokeColorPtr = _lookup<ffi.NativeFunction<_CColor Function(_CCircle)>>('CCircle_strokeColor');
late final _CCircle_strokeColor = _CCircle_strokeColorPtr.asFunction<_CColor Function(_CCircle)>();
late final _CCircle_setStrokeColor_CColorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCircle, _CColor)>>('CCircle_setStrokeColor_CColor');
late final _CCircle_setStrokeColor_CColor = _CCircle_setStrokeColor_CColorPtr.asFunction<void Function(_CCircle, _CColor)>();
late final _CCircle_dashedStrokeOptionsPtr = _lookup<ffi.NativeFunction<_COptional_CDashedStrokeCircleOptions Function(_CCircle)>>('CCircle_dashedStrokeOptions');
late final _CCircle_dashedStrokeOptions = _CCircle_dashedStrokeOptionsPtr.asFunction<_COptional_CDashedStrokeCircleOptions Function(_CCircle)>();
late final _CCircle_setDashedStrokeOptions_COptional_CDashedStrokeCircleOptionsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCircle, _COptional_CDashedStrokeCircleOptions)>>('CCircle_setDashedStrokeOptions_COptional_CDashedStrokeCircleOptions');
late final _CCircle_setDashedStrokeOptions_COptional_CDashedStrokeCircleOptions = _CCircle_setDashedStrokeOptions_COptional_CDashedStrokeCircleOptionsPtr.asFunction<void Function(_CCircle, _COptional_CDashedStrokeCircleOptions)>();

late final _CCircle_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCircle_cg_objectIdentifier');
late final _CCircle_cg_objectIdentifier = _CCircle_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCircle_C_createWith_CCircleOptionsPtr = _lookup<ffi.NativeFunction<_CResult_CCircle Function(_CCircleOptions)>>('CCircle_C_createWith_CCircleOptions');
late final _CCircle_C_createWith_CCircleOptions = _CCircle_C_createWith_CCircleOptionsPtr.asFunction<_CResult_CCircle Function(_CCircleOptions)>();

late final _CCircle_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCircle_release');
late final _CCircle_release = _CCircle_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCircle_retainPtr = _lookup<ffi.NativeFunction<_CCircle Function(ffi.Pointer<ffi.Void>)>>('CCircle_retain');
late final _CCircle_retain = _CCircle_retainPtr.asFunction<_CCircle Function(ffi.Pointer<ffi.Void>)>();
late final _CCircleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCircle Function()>>('CCircleMakeDefault');
late final _CCircleMakeDefault = _CCircleMakeDefaultPtr.asFunction<_CCircle Function()>();


late final _COptional_CDashedStrokeCircleOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CDashedStrokeCircleOptions Function()>>('COptional_CDashedStrokeCircleOptionsMakeDefault');
late final _COptional_CDashedStrokeCircleOptionsMakeDefault = _COptional_CDashedStrokeCircleOptionsMakeDefaultPtr.asFunction<_COptional_CDashedStrokeCircleOptions Function()>();

late final _CCircleOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCircleOptions Function()>>('CCircleOptionsMakeDefault');
late final _CCircleOptionsMakeDefault = _CCircleOptionsMakeDefaultPtr.asFunction<_CCircleOptions Function()>();


late final _CResult_CCircle_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CCircle)>>('CResult_CCircle_release');
late final _CResult_CCircle_release = _CResult_CCircle_releasePtr.asFunction<void Function(_CResult_CCircle)>();
late final _CPolygon_contoursPtr = _lookup<ffi.NativeFunction<_CArray_CArray_CGeoPoint Function(_CPolygon)>>('CPolygon_contours');
late final _CPolygon_contours = _CPolygon_contoursPtr.asFunction<_CArray_CArray_CGeoPoint Function(_CPolygon)>();
late final _CPolygon_setContours_CArray_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolygon, _CArray_CArray_CGeoPoint)>>('CPolygon_setContours_CArray_CArray_CGeoPoint');
late final _CPolygon_setContours_CArray_CArray_CGeoPoint = _CPolygon_setContours_CArray_CArray_CGeoPointPtr.asFunction<void Function(_CPolygon, _CArray_CArray_CGeoPoint)>();
late final _CPolygon_colorPtr = _lookup<ffi.NativeFunction<_CColor Function(_CPolygon)>>('CPolygon_color');
late final _CPolygon_color = _CPolygon_colorPtr.asFunction<_CColor Function(_CPolygon)>();
late final _CPolygon_setColor_CColorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolygon, _CColor)>>('CPolygon_setColor_CColor');
late final _CPolygon_setColor_CColor = _CPolygon_setColor_CColorPtr.asFunction<void Function(_CPolygon, _CColor)>();
late final _CPolygon_strokeWidthPtr = _lookup<ffi.NativeFunction<_CLogicalPixel Function(_CPolygon)>>('CPolygon_strokeWidth');
late final _CPolygon_strokeWidth = _CPolygon_strokeWidthPtr.asFunction<_CLogicalPixel Function(_CPolygon)>();
late final _CPolygon_setStrokeWidth_CLogicalPixelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolygon, _CLogicalPixel)>>('CPolygon_setStrokeWidth_CLogicalPixel');
late final _CPolygon_setStrokeWidth_CLogicalPixel = _CPolygon_setStrokeWidth_CLogicalPixelPtr.asFunction<void Function(_CPolygon, _CLogicalPixel)>();
late final _CPolygon_strokeColorPtr = _lookup<ffi.NativeFunction<_CColor Function(_CPolygon)>>('CPolygon_strokeColor');
late final _CPolygon_strokeColor = _CPolygon_strokeColorPtr.asFunction<_CColor Function(_CPolygon)>();
late final _CPolygon_setStrokeColor_CColorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolygon, _CColor)>>('CPolygon_setStrokeColor_CColor');
late final _CPolygon_setStrokeColor_CColor = _CPolygon_setStrokeColor_CColorPtr.asFunction<void Function(_CPolygon, _CColor)>();

late final _CPolygon_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPolygon_cg_objectIdentifier');
late final _CPolygon_cg_objectIdentifier = _CPolygon_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPolygon_C_createWith_CPolygonOptionsPtr = _lookup<ffi.NativeFunction<_CResult_CPolygon Function(_CPolygonOptions)>>('CPolygon_C_createWith_CPolygonOptions');
late final _CPolygon_C_createWith_CPolygonOptions = _CPolygon_C_createWith_CPolygonOptionsPtr.asFunction<_CResult_CPolygon Function(_CPolygonOptions)>();

late final _CPolygon_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPolygon_release');
late final _CPolygon_release = _CPolygon_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPolygon_retainPtr = _lookup<ffi.NativeFunction<_CPolygon Function(ffi.Pointer<ffi.Void>)>>('CPolygon_retain');
late final _CPolygon_retain = _CPolygon_retainPtr.asFunction<_CPolygon Function(ffi.Pointer<ffi.Void>)>();
late final _CPolygonMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPolygon Function()>>('CPolygonMakeDefault');
late final _CPolygonMakeDefault = _CPolygonMakeDefaultPtr.asFunction<_CPolygon Function()>();


late final _CPolygonOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPolygonOptions Function()>>('CPolygonOptionsMakeDefault');
late final _CPolygonOptionsMakeDefault = _CPolygonOptionsMakeDefaultPtr.asFunction<_CPolygonOptions Function()>();


late final _CResult_CPolygon_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CPolygon)>>('CResult_CPolygon_release');
late final _CResult_CPolygon_release = _CResult_CPolygon_releasePtr.asFunction<void Function(_CResult_CPolygon)>();

late final _CDashedPolylineOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDashedPolylineOptions Function()>>('CDashedPolylineOptionsMakeDefault');
late final _CDashedPolylineOptionsMakeDefault = _CDashedPolylineOptionsMakeDefaultPtr.asFunction<_CDashedPolylineOptions Function()>();


late final _CArray_CColormakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CColor Function()>>('CArray_CColor_makeEmpty');
late final _CArray_CColormakeEmpty = _CArray_CColormakeEmptyPtr.asFunction<_CArray_CColor Function()>();
late final _CArray_CColoraddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CColor, _CColor)>>('CArray_CColor_addElement');
late final _CArray_CColoraddElement = _CArray_CColoraddElementPtr.asFunction<void Function(_CArray_CColor, _CColor)>();
late final _forEach_CArray_CColorPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CColor, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CColor)>>)
>>('CArray_CColor_forEachWithFunctionPointer');
late final _forEach_CArray_CColor = _forEach_CArray_CColorPtr.asFunction<
  void Function(_CArray_CColor, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CColor)
>>)>();
late final _CArray_CColor_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CColor)>>('CArray_CColor_release');
late final _CArray_CColor_release = _CArray_CColor_releasePtr.asFunction<void Function(_CArray_CColor)>();

late final _CGradientPolylineOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGradientPolylineOptions Function()>>('CGradientPolylineOptionsMakeDefault');
late final _CGradientPolylineOptionsMakeDefault = _CGradientPolylineOptionsMakeDefaultPtr.asFunction<_CGradientPolylineOptions Function()>();

late final _CPolyline_pointsPtr = _lookup<ffi.NativeFunction<_CArray_CGeoPoint Function(_CPolyline)>>('CPolyline_points');
late final _CPolyline_points = _CPolyline_pointsPtr.asFunction<_CArray_CGeoPoint Function(_CPolyline)>();
late final _CPolyline_setPoints_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolyline, _CArray_CGeoPoint)>>('CPolyline_setPoints_CArray_CGeoPoint');
late final _CPolyline_setPoints_CArray_CGeoPoint = _CPolyline_setPoints_CArray_CGeoPointPtr.asFunction<void Function(_CPolyline, _CArray_CGeoPoint)>();
late final _CPolyline_widthPtr = _lookup<ffi.NativeFunction<_CLogicalPixel Function(_CPolyline)>>('CPolyline_width');
late final _CPolyline_width = _CPolyline_widthPtr.asFunction<_CLogicalPixel Function(_CPolyline)>();
late final _CPolyline_setWidth_CLogicalPixelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolyline, _CLogicalPixel)>>('CPolyline_setWidth_CLogicalPixel');
late final _CPolyline_setWidth_CLogicalPixel = _CPolyline_setWidth_CLogicalPixelPtr.asFunction<void Function(_CPolyline, _CLogicalPixel)>();
late final _CPolyline_colorPtr = _lookup<ffi.NativeFunction<_CColor Function(_CPolyline)>>('CPolyline_color');
late final _CPolyline_color = _CPolyline_colorPtr.asFunction<_CColor Function(_CPolyline)>();
late final _CPolyline_setColor_CColorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolyline, _CColor)>>('CPolyline_setColor_CColor');
late final _CPolyline_setColor_CColor = _CPolyline_setColor_CColorPtr.asFunction<void Function(_CPolyline, _CColor)>();
late final _CPolyline_erasedPartPtr = _lookup<ffi.NativeFunction<ffi.Double Function(_CPolyline)>>('CPolyline_erasedPart');
late final _CPolyline_erasedPart = _CPolyline_erasedPartPtr.asFunction<double Function(_CPolyline)>();
late final _CPolyline_setErasedPart_doublePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolyline, ffi.Double)>>('CPolyline_setErasedPart_double');
late final _CPolyline_setErasedPart_double = _CPolyline_setErasedPart_doublePtr.asFunction<void Function(_CPolyline, double)>();
late final _CPolyline_dashedPolylineOptionsPtr = _lookup<ffi.NativeFunction<_COptional_CDashedPolylineOptions Function(_CPolyline)>>('CPolyline_dashedPolylineOptions');
late final _CPolyline_dashedPolylineOptions = _CPolyline_dashedPolylineOptionsPtr.asFunction<_COptional_CDashedPolylineOptions Function(_CPolyline)>();
late final _CPolyline_setDashedPolylineOptions_COptional_CDashedPolylineOptionsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolyline, _COptional_CDashedPolylineOptions)>>('CPolyline_setDashedPolylineOptions_COptional_CDashedPolylineOptions');
late final _CPolyline_setDashedPolylineOptions_COptional_CDashedPolylineOptions = _CPolyline_setDashedPolylineOptions_COptional_CDashedPolylineOptionsPtr.asFunction<void Function(_CPolyline, _COptional_CDashedPolylineOptions)>();
late final _CPolyline_gradientPolylineOptionsPtr = _lookup<ffi.NativeFunction<_COptional_CGradientPolylineOptions Function(_CPolyline)>>('CPolyline_gradientPolylineOptions');
late final _CPolyline_gradientPolylineOptions = _CPolyline_gradientPolylineOptionsPtr.asFunction<_COptional_CGradientPolylineOptions Function(_CPolyline)>();
late final _CPolyline_setGradientPolylineOptions_COptional_CGradientPolylineOptionsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolyline, _COptional_CGradientPolylineOptions)>>('CPolyline_setGradientPolylineOptions_COptional_CGradientPolylineOptions');
late final _CPolyline_setGradientPolylineOptions_COptional_CGradientPolylineOptions = _CPolyline_setGradientPolylineOptions_COptional_CGradientPolylineOptionsPtr.asFunction<void Function(_CPolyline, _COptional_CGradientPolylineOptions)>();

late final _CPolyline_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPolyline_cg_objectIdentifier');
late final _CPolyline_cg_objectIdentifier = _CPolyline_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPolyline_C_createWith_CPolylineOptionsPtr = _lookup<ffi.NativeFunction<_CResult_CPolyline Function(_CPolylineOptions)>>('CPolyline_C_createWith_CPolylineOptions');
late final _CPolyline_C_createWith_CPolylineOptions = _CPolyline_C_createWith_CPolylineOptionsPtr.asFunction<_CResult_CPolyline Function(_CPolylineOptions)>();

late final _CPolyline_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPolyline_release');
late final _CPolyline_release = _CPolyline_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPolyline_retainPtr = _lookup<ffi.NativeFunction<_CPolyline Function(ffi.Pointer<ffi.Void>)>>('CPolyline_retain');
late final _CPolyline_retain = _CPolyline_retainPtr.asFunction<_CPolyline Function(ffi.Pointer<ffi.Void>)>();
late final _CPolylineMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPolyline Function()>>('CPolylineMakeDefault');
late final _CPolylineMakeDefault = _CPolylineMakeDefaultPtr.asFunction<_CPolyline Function()>();


late final _COptional_CDashedPolylineOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CDashedPolylineOptions Function()>>('COptional_CDashedPolylineOptionsMakeDefault');
late final _COptional_CDashedPolylineOptionsMakeDefault = _COptional_CDashedPolylineOptionsMakeDefaultPtr.asFunction<_COptional_CDashedPolylineOptions Function()>();

late final _COptional_CGradientPolylineOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGradientPolylineOptions Function()>>('COptional_CGradientPolylineOptionsMakeDefault');
late final _COptional_CGradientPolylineOptionsMakeDefault = _COptional_CGradientPolylineOptionsMakeDefaultPtr.asFunction<_COptional_CGradientPolylineOptions Function()>();

late final _COptional_CGradientPolylineOptions_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CGradientPolylineOptions)>>('COptional_CGradientPolylineOptions_release');
late final _COptional_CGradientPolylineOptions_release = _COptional_CGradientPolylineOptions_releasePtr.asFunction<void Function(_COptional_CGradientPolylineOptions)>();

late final _CPolylineOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPolylineOptions Function()>>('CPolylineOptionsMakeDefault');
late final _CPolylineOptionsMakeDefault = _CPolylineOptionsMakeDefaultPtr.asFunction<_CPolylineOptions Function()>();


late final _CResult_CPolyline_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CPolyline)>>('CResult_CPolyline_release');
late final _CResult_CPolyline_release = _CResult_CPolyline_releasePtr.asFunction<void Function(_CResult_CPolyline)>();

late final _CCameraFollowStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraFollowState Function()>>('CCameraFollowStateMakeDefault');
late final _CCameraFollowStateMakeDefault = _CCameraFollowStateMakeDefaultPtr.asFunction<_CCameraFollowState Function()>();
late final _CMyLocationControlModel_isEnabledChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CMyLocationControlModel)>>('CMyLocationControlModel_isEnabledChannel');
late final _CMyLocationControlModel_isEnabledChannel = _CMyLocationControlModel_isEnabledChannelPtr.asFunction<_CStatefulChannel_bool Function(_CMyLocationControlModel)>();
late final _CMyLocationControlModel_isEnabledPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMyLocationControlModel)>>('CMyLocationControlModel_isEnabled');
late final _CMyLocationControlModel_isEnabled = _CMyLocationControlModel_isEnabledPtr.asFunction<bool Function(_CMyLocationControlModel)>();
late final _CMyLocationControlModel_followStateChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraFollowState Function(_CMyLocationControlModel)>>('CMyLocationControlModel_followStateChannel');
late final _CMyLocationControlModel_followStateChannel = _CMyLocationControlModel_followStateChannelPtr.asFunction<_CStatefulChannel_CCameraFollowState Function(_CMyLocationControlModel)>();
late final _CMyLocationControlModel_followStatePtr = _lookup<ffi.NativeFunction<_CCameraFollowState Function(_CMyLocationControlModel)>>('CMyLocationControlModel_followState');
late final _CMyLocationControlModel_followState = _CMyLocationControlModel_followStatePtr.asFunction<_CCameraFollowState Function(_CMyLocationControlModel)>();

late final _CMyLocationControlModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMyLocationControlModel_cg_objectIdentifier');
late final _CMyLocationControlModel_cg_objectIdentifier = _CMyLocationControlModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMyLocationControlModel_onClickedPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMyLocationControlModel)>>('CMyLocationControlModel_onClicked');
late final _CMyLocationControlModel_onClicked = _CMyLocationControlModel_onClickedPtr.asFunction<void Function(_CMyLocationControlModel)>();
late final _CMyLocationControlModel_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CMyLocationControlModel Function(_CMap)>>('CMyLocationControlModel_C_createWith_CMap');
late final _CMyLocationControlModel_C_createWith_CMap = _CMyLocationControlModel_C_createWith_CMapPtr.asFunction<_CMyLocationControlModel Function(_CMap)>();

late final _CMyLocationControlModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMyLocationControlModel_release');
late final _CMyLocationControlModel_release = _CMyLocationControlModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationControlModel_retainPtr = _lookup<ffi.NativeFunction<_CMyLocationControlModel Function(ffi.Pointer<ffi.Void>)>>('CMyLocationControlModel_retain');
late final _CMyLocationControlModel_retain = _CMyLocationControlModel_retainPtr.asFunction<_CMyLocationControlModel Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationControlModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMyLocationControlModel Function()>>('CMyLocationControlModelMakeDefault');
late final _CMyLocationControlModelMakeDefault = _CMyLocationControlModelMakeDefaultPtr.asFunction<_CMyLocationControlModel Function()>();


late final _CStatefulChannel_CCameraFollowStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraFollowState Function()>>('CStatefulChannel_CCameraFollowStateMakeDefault');
late final _CStatefulChannel_CCameraFollowStateMakeDefault = _CStatefulChannel_CCameraFollowStateMakeDefaultPtr.asFunction<_CStatefulChannel_CCameraFollowState Function()>();
late final _CStatefulChannel_CCameraFollowState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CCameraFollowState)>>('CStatefulChannel_CCameraFollowState_release');
late final _CStatefulChannel_CCameraFollowState_release = _CStatefulChannel_CCameraFollowState_releasePtr.asFunction<void Function(_CStatefulChannel_CCameraFollowState)>();
late final _CStatefulChannel_CCameraFollowState_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraFollowState Function(_CStatefulChannel_CCameraFollowState)>>('CStatefulChannel_CCameraFollowState_retain');
late final _CStatefulChannel_CCameraFollowState_retain = _CStatefulChannel_CCameraFollowState_retainPtr.asFunction<_CStatefulChannel_CCameraFollowState Function(_CStatefulChannel_CCameraFollowState)>();
late final _CStatefulChannel_CCameraFollowStateGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CCameraFollowState Function(_CStatefulChannel_CCameraFollowState)>>('CStatefulChannel_CCameraFollowState_getCurrentValue');
late final _CStatefulChannel_CCameraFollowStateGetCurrentValue = _CStatefulChannel_CCameraFollowStateGetCurrentValuePtr.asFunction<_CCameraFollowState Function(_CStatefulChannel_CCameraFollowState)>();
late final _CStatefulChannel_CCameraFollowStateConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraFollowState,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraFollowState, ffi.Int64)>>
  )
>>('CStatefulChannel_CCameraFollowState_connect');
late final _CStatefulChannel_CCameraFollowStateConnect = _CStatefulChannel_CCameraFollowStateConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraFollowState,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraFollowState, ffi.Int64)>>
  )
>();
late final _CCompassControlModel_bearingChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CBearing Function(_CCompassControlModel)>>('CCompassControlModel_bearingChannel');
late final _CCompassControlModel_bearingChannel = _CCompassControlModel_bearingChannelPtr.asFunction<_CStatefulChannel_CBearing Function(_CCompassControlModel)>();
late final _CCompassControlModel_bearingPtr = _lookup<ffi.NativeFunction<_CBearing Function(_CCompassControlModel)>>('CCompassControlModel_bearing');
late final _CCompassControlModel_bearing = _CCompassControlModel_bearingPtr.asFunction<_CBearing Function(_CCompassControlModel)>();

late final _CCompassControlModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCompassControlModel_cg_objectIdentifier');
late final _CCompassControlModel_cg_objectIdentifier = _CCompassControlModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCompassControlModel_onClickedPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCompassControlModel)>>('CCompassControlModel_onClicked');
late final _CCompassControlModel_onClicked = _CCompassControlModel_onClickedPtr.asFunction<void Function(_CCompassControlModel)>();
late final _CCompassControlModel_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CCompassControlModel Function(_CMap)>>('CCompassControlModel_C_createWith_CMap');
late final _CCompassControlModel_C_createWith_CMap = _CCompassControlModel_C_createWith_CMapPtr.asFunction<_CCompassControlModel Function(_CMap)>();

late final _CCompassControlModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCompassControlModel_release');
late final _CCompassControlModel_release = _CCompassControlModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCompassControlModel_retainPtr = _lookup<ffi.NativeFunction<_CCompassControlModel Function(ffi.Pointer<ffi.Void>)>>('CCompassControlModel_retain');
late final _CCompassControlModel_retain = _CCompassControlModel_retainPtr.asFunction<_CCompassControlModel Function(ffi.Pointer<ffi.Void>)>();
late final _CCompassControlModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCompassControlModel Function()>>('CCompassControlModelMakeDefault');
late final _CCompassControlModelMakeDefault = _CCompassControlModelMakeDefaultPtr.asFunction<_CCompassControlModel Function()>();


late final _CStatefulChannel_CBearingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CBearing Function()>>('CStatefulChannel_CBearingMakeDefault');
late final _CStatefulChannel_CBearingMakeDefault = _CStatefulChannel_CBearingMakeDefaultPtr.asFunction<_CStatefulChannel_CBearing Function()>();
late final _CStatefulChannel_CBearing_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CBearing)>>('CStatefulChannel_CBearing_release');
late final _CStatefulChannel_CBearing_release = _CStatefulChannel_CBearing_releasePtr.asFunction<void Function(_CStatefulChannel_CBearing)>();
late final _CStatefulChannel_CBearing_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CBearing Function(_CStatefulChannel_CBearing)>>('CStatefulChannel_CBearing_retain');
late final _CStatefulChannel_CBearing_retain = _CStatefulChannel_CBearing_retainPtr.asFunction<_CStatefulChannel_CBearing Function(_CStatefulChannel_CBearing)>();
late final _CStatefulChannel_CBearingGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CBearing Function(_CStatefulChannel_CBearing)>>('CStatefulChannel_CBearing_getCurrentValue');
late final _CStatefulChannel_CBearingGetCurrentValue = _CStatefulChannel_CBearingGetCurrentValuePtr.asFunction<_CBearing Function(_CStatefulChannel_CBearing)>();
late final _CStatefulChannel_CBearingConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CBearing,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CBearing, ffi.Int64)>>
  )
>>('CStatefulChannel_CBearing_connect');
late final _CStatefulChannel_CBearingConnect = _CStatefulChannel_CBearingConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CBearing,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CBearing, ffi.Int64)>>
  )
>();

late final _CZoomControlButtonMakeDefaultPtr = _lookup<ffi.NativeFunction<_CZoomControlButton Function()>>('CZoomControlButtonMakeDefault');
late final _CZoomControlButtonMakeDefault = _CZoomControlButtonMakeDefaultPtr.asFunction<_CZoomControlButton Function()>();

late final _CZoomControlModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CZoomControlModel_cg_objectIdentifier');
late final _CZoomControlModel_cg_objectIdentifier = _CZoomControlModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CZoomControlModel_isEnabled_CZoomControlButtonPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CZoomControlModel, _CZoomControlButton)>>('CZoomControlModel_isEnabled_CZoomControlButton');
late final _CZoomControlModel_isEnabled_CZoomControlButton = _CZoomControlModel_isEnabled_CZoomControlButtonPtr.asFunction<_CStatefulChannel_bool Function(_CZoomControlModel, _CZoomControlButton)>();
late final _CZoomControlModel_setPressed_CZoomControlButton_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CZoomControlModel, _CZoomControlButton, ffi.Bool)>>('CZoomControlModel_setPressed_CZoomControlButton_bool');
late final _CZoomControlModel_setPressed_CZoomControlButton_bool = _CZoomControlModel_setPressed_CZoomControlButton_boolPtr.asFunction<void Function(_CZoomControlModel, _CZoomControlButton, bool)>();
late final _CZoomControlModel_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CZoomControlModel Function(_CMap)>>('CZoomControlModel_C_createWith_CMap');
late final _CZoomControlModel_C_createWith_CMap = _CZoomControlModel_C_createWith_CMapPtr.asFunction<_CZoomControlModel Function(_CMap)>();

late final _CZoomControlModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CZoomControlModel_release');
late final _CZoomControlModel_release = _CZoomControlModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CZoomControlModel_retainPtr = _lookup<ffi.NativeFunction<_CZoomControlModel Function(ffi.Pointer<ffi.Void>)>>('CZoomControlModel_retain');
late final _CZoomControlModel_retain = _CZoomControlModel_retainPtr.asFunction<_CZoomControlModel Function(ffi.Pointer<ffi.Void>)>();
late final _CZoomControlModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CZoomControlModel Function()>>('CZoomControlModelMakeDefault');
late final _CZoomControlModelMakeDefault = _CZoomControlModelMakeDefaultPtr.asFunction<_CZoomControlModel Function()>();


late final _CDefaultRasterUrlTemplateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDefaultRasterUrlTemplate Function()>>('CDefaultRasterUrlTemplateMakeDefault');
late final _CDefaultRasterUrlTemplateMakeDefault = _CDefaultRasterUrlTemplateMakeDefaultPtr.asFunction<_CDefaultRasterUrlTemplate Function()>();


late final _CWmsRasterUrlTemplateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWmsRasterUrlTemplate Function()>>('CWmsRasterUrlTemplateMakeDefault');
late final _CWmsRasterUrlTemplateMakeDefault = _CWmsRasterUrlTemplateMakeDefaultPtr.asFunction<_CWmsRasterUrlTemplate Function()>();


late final _CRasterUrlTemplate_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRasterUrlTemplate)>>('CRasterUrlTemplate_release');
late final _CRasterUrlTemplate_release = _CRasterUrlTemplate_releasePtr.asFunction<void Function(_CRasterUrlTemplate)>();
late final _CRasterUrlTemplateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRasterUrlTemplate Function()>>('CRasterUrlTemplateMakeDefault');
late final _CRasterUrlTemplateMakeDefault = _CRasterUrlTemplateMakeDefaultPtr.asFunction<_CRasterUrlTemplate Function()>();

late final _CRasterTileSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRasterTileSource_cg_objectIdentifier');
late final _CRasterTileSource_cg_objectIdentifier = _CRasterTileSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRasterTileSource_setOpacity_COpacityPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRasterTileSource, _COpacity)>>('CRasterTileSource_setOpacity_COpacity');
late final _CRasterTileSource_setOpacity_COpacity = _CRasterTileSource_setOpacity_COpacityPtr.asFunction<void Function(_CRasterTileSource, _COpacity)>();
late final _CRasterTileSource_C_createWith_CContext_CString_CRasterUrlTemplatePtr = _lookup<ffi.NativeFunction<_CRasterTileSource Function(_CContext, _CString, _CRasterUrlTemplate)>>('CRasterTileSource_C_createWith_CContext_CString_CRasterUrlTemplate');
late final _CRasterTileSource_C_createWith_CContext_CString_CRasterUrlTemplate = _CRasterTileSource_C_createWith_CContext_CString_CRasterUrlTemplatePtr.asFunction<_CRasterTileSource Function(_CContext, _CString, _CRasterUrlTemplate)>();

late final _CRasterTileSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRasterTileSource_release');
late final _CRasterTileSource_release = _CRasterTileSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRasterTileSource_retainPtr = _lookup<ffi.NativeFunction<_CRasterTileSource Function(ffi.Pointer<ffi.Void>)>>('CRasterTileSource_retain');
late final _CRasterTileSource_retain = _CRasterTileSource_retainPtr.asFunction<_CRasterTileSource Function(ffi.Pointer<ffi.Void>)>();
late final _CRasterTileSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRasterTileSource Function()>>('CRasterTileSourceMakeDefault');
late final _CRasterTileSourceMakeDefault = _CRasterTileSourceMakeDefaultPtr.asFunction<_CRasterTileSource Function()>();

late final _CParkingControlModel_isEnabledChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CParkingControlModel)>>('CParkingControlModel_isEnabledChannel');
late final _CParkingControlModel_isEnabledChannel = _CParkingControlModel_isEnabledChannelPtr.asFunction<_CStatefulChannel_bool Function(_CParkingControlModel)>();
late final _CParkingControlModel_isEnabledPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CParkingControlModel)>>('CParkingControlModel_isEnabled');
late final _CParkingControlModel_isEnabled = _CParkingControlModel_isEnabledPtr.asFunction<bool Function(_CParkingControlModel)>();

late final _CParkingControlModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CParkingControlModel_cg_objectIdentifier');
late final _CParkingControlModel_cg_objectIdentifier = _CParkingControlModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CParkingControlModel_toggleParkingsVisibilityPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CParkingControlModel)>>('CParkingControlModel_toggleParkingsVisibility');
late final _CParkingControlModel_toggleParkingsVisibility = _CParkingControlModel_toggleParkingsVisibilityPtr.asFunction<void Function(_CParkingControlModel)>();
late final _CParkingControlModel_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CParkingControlModel Function(_CMap)>>('CParkingControlModel_C_createWith_CMap');
late final _CParkingControlModel_C_createWith_CMap = _CParkingControlModel_C_createWith_CMapPtr.asFunction<_CParkingControlModel Function(_CMap)>();

late final _CParkingControlModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CParkingControlModel_release');
late final _CParkingControlModel_release = _CParkingControlModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CParkingControlModel_retainPtr = _lookup<ffi.NativeFunction<_CParkingControlModel Function(ffi.Pointer<ffi.Void>)>>('CParkingControlModel_retain');
late final _CParkingControlModel_retain = _CParkingControlModel_retainPtr.asFunction<_CParkingControlModel Function(ffi.Pointer<ffi.Void>)>();
late final _CParkingControlModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingControlModel Function()>>('CParkingControlModelMakeDefault');
late final _CParkingControlModelMakeDefault = _CParkingControlModelMakeDefaultPtr.asFunction<_CParkingControlModel Function()>();

late final _CPackedMapState_showTrafficPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CPackedMapState)>>('CPackedMapState_showTraffic');
late final _CPackedMapState_showTraffic = _CPackedMapState_showTrafficPtr.asFunction<bool Function(_CPackedMapState)>();
late final _CPackedMapState_setShowTraffic_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackedMapState, ffi.Bool)>>('CPackedMapState_setShowTraffic_bool');
late final _CPackedMapState_setShowTraffic_bool = _CPackedMapState_setShowTraffic_boolPtr.asFunction<void Function(_CPackedMapState, bool)>();
late final _CPackedMapState_cameraPositionPtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CPackedMapState)>>('CPackedMapState_cameraPosition');
late final _CPackedMapState_cameraPosition = _CPackedMapState_cameraPositionPtr.asFunction<_CCameraPosition Function(_CPackedMapState)>();
late final _CPackedMapState_setCameraPosition_CCameraPositionPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackedMapState, _CCameraPosition)>>('CPackedMapState_setCameraPosition_CCameraPosition');
late final _CPackedMapState_setCameraPosition_CCameraPosition = _CPackedMapState_setCameraPosition_CCameraPositionPtr.asFunction<void Function(_CPackedMapState, _CCameraPosition)>();
late final _CPackedMapState_cameraBehaviourPtr = _lookup<ffi.NativeFunction<_CCameraBehaviour Function(_CPackedMapState)>>('CPackedMapState_cameraBehaviour');
late final _CPackedMapState_cameraBehaviour = _CPackedMapState_cameraBehaviourPtr.asFunction<_CCameraBehaviour Function(_CPackedMapState)>();
late final _CPackedMapState_setCameraBehaviour_CCameraBehaviourPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackedMapState, _CCameraBehaviour)>>('CPackedMapState_setCameraBehaviour_CCameraBehaviour');
late final _CPackedMapState_setCameraBehaviour_CCameraBehaviour = _CPackedMapState_setCameraBehaviour_CCameraBehaviourPtr.asFunction<void Function(_CPackedMapState, _CCameraBehaviour)>();

late final _CPackedMapState_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPackedMapState_cg_objectIdentifier');
late final _CPackedMapState_cg_objectIdentifier = _CPackedMapState_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPackedMapState_S_of_CCameraPosition_bool_CCameraBehaviourPtr = _lookup<ffi.NativeFunction<_CPackedMapState Function(_CCameraPosition, ffi.Bool, _CCameraBehaviour)>>('CPackedMapState_S_of_CCameraPosition_bool_CCameraBehaviour');
late final _CPackedMapState_S_of_CCameraPosition_bool_CCameraBehaviour = _CPackedMapState_S_of_CCameraPosition_bool_CCameraBehaviourPtr.asFunction<_CPackedMapState Function(_CCameraPosition, bool, _CCameraBehaviour)>();
late final _CPackedMapState_S_fromBytes_CDataPtr = _lookup<ffi.NativeFunction<_CResult_CPackedMapState Function(_CData)>>('CPackedMapState_S_fromBytes_CData');
late final _CPackedMapState_S_fromBytes_CData = _CPackedMapState_S_fromBytes_CDataPtr.asFunction<_CResult_CPackedMapState Function(_CData)>();
late final _CPackedMapState_S_fromMap_CMapPtr = _lookup<ffi.NativeFunction<_CPackedMapState Function(_CMap)>>('CPackedMapState_S_fromMap_CMap');
late final _CPackedMapState_S_fromMap_CMap = _CPackedMapState_S_fromMap_CMapPtr.asFunction<_CPackedMapState Function(_CMap)>();
late final _CPackedMapState_toBytesPtr = _lookup<ffi.NativeFunction<_CData Function(_CPackedMapState)>>('CPackedMapState_toBytes');
late final _CPackedMapState_toBytes = _CPackedMapState_toBytesPtr.asFunction<_CData Function(_CPackedMapState)>();

late final _CPackedMapState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPackedMapState_release');
late final _CPackedMapState_release = _CPackedMapState_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPackedMapState_retainPtr = _lookup<ffi.NativeFunction<_CPackedMapState Function(ffi.Pointer<ffi.Void>)>>('CPackedMapState_retain');
late final _CPackedMapState_retain = _CPackedMapState_retainPtr.asFunction<_CPackedMapState Function(ffi.Pointer<ffi.Void>)>();
late final _CPackedMapStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPackedMapState Function()>>('CPackedMapStateMakeDefault');
late final _CPackedMapStateMakeDefault = _CPackedMapStateMakeDefaultPtr.asFunction<_CPackedMapState Function()>();


late final _CResult_CPackedMapState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CPackedMapState)>>('CResult_CPackedMapState_release');
late final _CResult_CPackedMapState_release = _CResult_CPackedMapState_releasePtr.asFunction<void Function(_CResult_CPackedMapState)>();

late final _CCalloutMapPositionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCalloutMapPosition Function()>>('CCalloutMapPositionMakeDefault');
late final _CCalloutMapPositionMakeDefault = _CCalloutMapPositionMakeDefaultPtr.asFunction<_CCalloutMapPosition Function()>();


late final _CCalloutVisualizationModeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCalloutVisualizationMode Function()>>('CCalloutVisualizationModeMakeDefault');
late final _CCalloutVisualizationModeMakeDefault = _CCalloutVisualizationModeMakeDefaultPtr.asFunction<_CCalloutVisualizationMode Function()>();

late final _CLanesCalloutMapPositionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLanesCalloutMapPosition Function()>>('CLanesCalloutMapPositionMakeDefault');
late final _CLanesCalloutMapPositionMakeDefault = _CLanesCalloutMapPositionMakeDefaultPtr.asFunction<_CLanesCalloutMapPosition Function()>();

late final _CIndoorRouteLevelsGetter_levelIdsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CSet_CLevelId Function(_CIndoorRouteLevelsGetter)>>('CIndoorRouteLevelsGetter_levelIdsChannel');
late final _CIndoorRouteLevelsGetter_levelIdsChannel = _CIndoorRouteLevelsGetter_levelIdsChannelPtr.asFunction<_CStatefulChannel_CSet_CLevelId Function(_CIndoorRouteLevelsGetter)>();
late final _CIndoorRouteLevelsGetter_levelIdsPtr = _lookup<ffi.NativeFunction<_CSet_CLevelId Function(_CIndoorRouteLevelsGetter)>>('CIndoorRouteLevelsGetter_levelIds');
late final _CIndoorRouteLevelsGetter_levelIds = _CIndoorRouteLevelsGetter_levelIdsPtr.asFunction<_CSet_CLevelId Function(_CIndoorRouteLevelsGetter)>();

late final _CIndoorRouteLevelsGetter_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CIndoorRouteLevelsGetter_cg_objectIdentifier');
late final _CIndoorRouteLevelsGetter_cg_objectIdentifier = _CIndoorRouteLevelsGetter_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CIndoorRouteLevelsGetter_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CIndoorRouteLevelsGetter Function(_CMap)>>('CIndoorRouteLevelsGetter_C_createWith_CMap');
late final _CIndoorRouteLevelsGetter_C_createWith_CMap = _CIndoorRouteLevelsGetter_C_createWith_CMapPtr.asFunction<_CIndoorRouteLevelsGetter Function(_CMap)>();

late final _CIndoorRouteLevelsGetter_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CIndoorRouteLevelsGetter_release');
late final _CIndoorRouteLevelsGetter_release = _CIndoorRouteLevelsGetter_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorRouteLevelsGetter_retainPtr = _lookup<ffi.NativeFunction<_CIndoorRouteLevelsGetter Function(ffi.Pointer<ffi.Void>)>>('CIndoorRouteLevelsGetter_retain');
late final _CIndoorRouteLevelsGetter_retain = _CIndoorRouteLevelsGetter_retainPtr.asFunction<_CIndoorRouteLevelsGetter Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorRouteLevelsGetterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIndoorRouteLevelsGetter Function()>>('CIndoorRouteLevelsGetterMakeDefault');
late final _CIndoorRouteLevelsGetterMakeDefault = _CIndoorRouteLevelsGetterMakeDefaultPtr.asFunction<_CIndoorRouteLevelsGetter Function()>();


late final _CStatefulChannel_CSet_CLevelIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CSet_CLevelId Function()>>('CStatefulChannel_CSet_CLevelIdMakeDefault');
late final _CStatefulChannel_CSet_CLevelIdMakeDefault = _CStatefulChannel_CSet_CLevelIdMakeDefaultPtr.asFunction<_CStatefulChannel_CSet_CLevelId Function()>();
late final _CStatefulChannel_CSet_CLevelId_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CSet_CLevelId)>>('CStatefulChannel_CSet_CLevelId_release');
late final _CStatefulChannel_CSet_CLevelId_release = _CStatefulChannel_CSet_CLevelId_releasePtr.asFunction<void Function(_CStatefulChannel_CSet_CLevelId)>();
late final _CStatefulChannel_CSet_CLevelId_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CSet_CLevelId Function(_CStatefulChannel_CSet_CLevelId)>>('CStatefulChannel_CSet_CLevelId_retain');
late final _CStatefulChannel_CSet_CLevelId_retain = _CStatefulChannel_CSet_CLevelId_retainPtr.asFunction<_CStatefulChannel_CSet_CLevelId Function(_CStatefulChannel_CSet_CLevelId)>();
late final _CStatefulChannel_CSet_CLevelIdGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CSet_CLevelId Function(_CStatefulChannel_CSet_CLevelId)>>('CStatefulChannel_CSet_CLevelId_getCurrentValue');
late final _CStatefulChannel_CSet_CLevelIdGetCurrentValue = _CStatefulChannel_CSet_CLevelIdGetCurrentValuePtr.asFunction<_CSet_CLevelId Function(_CStatefulChannel_CSet_CLevelId)>();
late final _CStatefulChannel_CSet_CLevelIdConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CSet_CLevelId,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSet_CLevelId, ffi.Int64)>>
  )
>>('CStatefulChannel_CSet_CLevelId_connect');
late final _CStatefulChannel_CSet_CLevelIdConnect = _CStatefulChannel_CSet_CLevelIdConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CSet_CLevelId,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSet_CLevelId, ffi.Int64)>>
  )
>();

late final _CRouteMapObjectPassedDistanceVisualizationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteMapObjectPassedDistanceVisualization Function()>>('CRouteMapObjectPassedDistanceVisualizationMakeDefault');
late final _CRouteMapObjectPassedDistanceVisualizationMakeDefault = _CRouteMapObjectPassedDistanceVisualizationMakeDefaultPtr.asFunction<_CRouteMapObjectPassedDistanceVisualization Function()>();

late final _CRouteMapObjectDisplayFlagMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteMapObjectDisplayFlag Function()>>('CRouteMapObjectDisplayFlagMakeDefault');
late final _CRouteMapObjectDisplayFlagMakeDefault = _CRouteMapObjectDisplayFlagMakeDefaultPtr.asFunction<_CRouteMapObjectDisplayFlag Function()>();

late final _CRouteMapObjectPermanentDisplayFlagMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteMapObjectPermanentDisplayFlag Function()>>('CRouteMapObjectPermanentDisplayFlagMakeDefault');
late final _CRouteMapObjectPermanentDisplayFlagMakeDefault = _CRouteMapObjectPermanentDisplayFlagMakeDefaultPtr.asFunction<_CRouteMapObjectPermanentDisplayFlag Function()>();

late final _CRouteMapObjectCalloutLabelFlagMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteMapObjectCalloutLabelFlag Function()>>('CRouteMapObjectCalloutLabelFlagMakeDefault');
late final _CRouteMapObjectCalloutLabelFlagMakeDefault = _CRouteMapObjectCalloutLabelFlagMakeDefaultPtr.asFunction<_CRouteMapObjectCalloutLabelFlag Function()>();

late final _CRouteMapObjectCalloutLabelDisplayModeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteMapObjectCalloutLabelDisplayMode Function()>>('CRouteMapObjectCalloutLabelDisplayModeMakeDefault');
late final _CRouteMapObjectCalloutLabelDisplayModeMakeDefault = _CRouteMapObjectCalloutLabelDisplayModeMakeDefaultPtr.asFunction<_CRouteMapObjectCalloutLabelDisplayMode Function()>();
late final _CRouteMapObject_displayFlagsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag Function(_CRouteMapObject)>>('CRouteMapObject_displayFlagsChannel');
late final _CRouteMapObject_displayFlagsChannel = _CRouteMapObject_displayFlagsChannelPtr.asFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag Function(_CRouteMapObject)>();
late final _CRouteMapObject_displayFlagsPtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectDisplayFlag Function(_CRouteMapObject)>>('CRouteMapObject_displayFlags');
late final _CRouteMapObject_displayFlags = _CRouteMapObject_displayFlagsPtr.asFunction<_COptional_COptionSet_CRouteMapObjectDisplayFlag Function(_CRouteMapObject)>();
late final _CRouteMapObject_setDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapObject, _COptional_COptionSet_CRouteMapObjectDisplayFlag)>>('CRouteMapObject_setDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlag');
late final _CRouteMapObject_setDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlag = _CRouteMapObject_setDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlagPtr.asFunction<void Function(_CRouteMapObject, _COptional_COptionSet_CRouteMapObjectDisplayFlag)>();
late final _CRouteMapObject_permanentDisplayFlagsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CRouteMapObject)>>('CRouteMapObject_permanentDisplayFlagsChannel');
late final _CRouteMapObject_permanentDisplayFlagsChannel = _CRouteMapObject_permanentDisplayFlagsChannelPtr.asFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CRouteMapObject)>();
late final _CRouteMapObject_permanentDisplayFlagsPtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CRouteMapObject)>>('CRouteMapObject_permanentDisplayFlags');
late final _CRouteMapObject_permanentDisplayFlags = _CRouteMapObject_permanentDisplayFlagsPtr.asFunction<_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CRouteMapObject)>();
late final _CRouteMapObject_setPermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapObject, _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>>('CRouteMapObject_setPermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag');
late final _CRouteMapObject_setPermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag = _CRouteMapObject_setPermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr.asFunction<void Function(_CRouteMapObject, _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>();
late final _CRouteMapObject_isActiveChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CRouteMapObject)>>('CRouteMapObject_isActiveChannel');
late final _CRouteMapObject_isActiveChannel = _CRouteMapObject_isActiveChannelPtr.asFunction<_CStatefulChannel_bool Function(_CRouteMapObject)>();
late final _CRouteMapObject_isActivePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CRouteMapObject)>>('CRouteMapObject_isActive');
late final _CRouteMapObject_isActive = _CRouteMapObject_isActivePtr.asFunction<bool Function(_CRouteMapObject)>();
late final _CRouteMapObject_setActive_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapObject, ffi.Bool)>>('CRouteMapObject_setActive_bool');
late final _CRouteMapObject_setActive_bool = _CRouteMapObject_setActive_boolPtr.asFunction<void Function(_CRouteMapObject, bool)>();
late final _CRouteMapObject_routePtr = _lookup<ffi.NativeFunction<_CTrafficRoute Function(_CRouteMapObject)>>('CRouteMapObject_route');
late final _CRouteMapObject_route = _CRouteMapObject_routePtr.asFunction<_CTrafficRoute Function(_CRouteMapObject)>();
late final _CRouteMapObject_routeIndexPtr = _lookup<ffi.NativeFunction<_CRouteIndex Function(_CRouteMapObject)>>('CRouteMapObject_routeIndex');
late final _CRouteMapObject_routeIndex = _CRouteMapObject_routeIndexPtr.asFunction<_CRouteIndex Function(_CRouteMapObject)>();
late final _CRouteMapObject_passedDistanceChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteDistance Function(_CRouteMapObject)>>('CRouteMapObject_passedDistanceChannel');
late final _CRouteMapObject_passedDistanceChannel = _CRouteMapObject_passedDistanceChannelPtr.asFunction<_CStatefulChannel_CRouteDistance Function(_CRouteMapObject)>();
late final _CRouteMapObject_passedDistancePtr = _lookup<ffi.NativeFunction<_CRouteDistance Function(_CRouteMapObject)>>('CRouteMapObject_passedDistance');
late final _CRouteMapObject_passedDistance = _CRouteMapObject_passedDistancePtr.asFunction<_CRouteDistance Function(_CRouteMapObject)>();
late final _CRouteMapObject_setPassedDistance_CRouteDistancePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapObject, _CRouteDistance)>>('CRouteMapObject_setPassedDistance_CRouteDistance');
late final _CRouteMapObject_setPassedDistance_CRouteDistance = _CRouteMapObject_setPassedDistance_CRouteDistancePtr.asFunction<void Function(_CRouteMapObject, _CRouteDistance)>();
late final _CRouteMapObject_passedDistanceVisualizationChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization Function(_CRouteMapObject)>>('CRouteMapObject_passedDistanceVisualizationChannel');
late final _CRouteMapObject_passedDistanceVisualizationChannel = _CRouteMapObject_passedDistanceVisualizationChannelPtr.asFunction<_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization Function(_CRouteMapObject)>();
late final _CRouteMapObject_passedDistanceVisualizationPtr = _lookup<ffi.NativeFunction<_CRouteMapObjectPassedDistanceVisualization Function(_CRouteMapObject)>>('CRouteMapObject_passedDistanceVisualization');
late final _CRouteMapObject_passedDistanceVisualization = _CRouteMapObject_passedDistanceVisualizationPtr.asFunction<_CRouteMapObjectPassedDistanceVisualization Function(_CRouteMapObject)>();
late final _CRouteMapObject_setPassedDistanceVisualization_CRouteMapObjectPassedDistanceVisualizationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapObject, _CRouteMapObjectPassedDistanceVisualization)>>('CRouteMapObject_setPassedDistanceVisualization_CRouteMapObjectPassedDistanceVisualization');
late final _CRouteMapObject_setPassedDistanceVisualization_CRouteMapObjectPassedDistanceVisualization = _CRouteMapObject_setPassedDistanceVisualization_CRouteMapObjectPassedDistanceVisualizationPtr.asFunction<void Function(_CRouteMapObject, _CRouteMapObjectPassedDistanceVisualization)>();
late final _CRouteMapObject_calloutPositionChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CCalloutMapPosition Function(_CRouteMapObject)>>('CRouteMapObject_calloutPositionChannel');
late final _CRouteMapObject_calloutPositionChannel = _CRouteMapObject_calloutPositionChannelPtr.asFunction<_CStatefulChannel_CArray_CCalloutMapPosition Function(_CRouteMapObject)>();
late final _CRouteMapObject_calloutPositionPtr = _lookup<ffi.NativeFunction<_CArray_CCalloutMapPosition Function(_CRouteMapObject)>>('CRouteMapObject_calloutPosition');
late final _CRouteMapObject_calloutPosition = _CRouteMapObject_calloutPositionPtr.asFunction<_CArray_CCalloutMapPosition Function(_CRouteMapObject)>();
late final _CRouteMapObject_calloutLabelFlagsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function(_CRouteMapObject)>>('CRouteMapObject_calloutLabelFlagsChannel');
late final _CRouteMapObject_calloutLabelFlagsChannel = _CRouteMapObject_calloutLabelFlagsChannelPtr.asFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function(_CRouteMapObject)>();
late final _CRouteMapObject_calloutLabelFlagsPtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function(_CRouteMapObject)>>('CRouteMapObject_calloutLabelFlags');
late final _CRouteMapObject_calloutLabelFlags = _CRouteMapObject_calloutLabelFlagsPtr.asFunction<_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function(_CRouteMapObject)>();
late final _CRouteMapObject_setCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapObject, _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag)>>('CRouteMapObject_setCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag');
late final _CRouteMapObject_setCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag = _CRouteMapObject_setCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagPtr.asFunction<void Function(_CRouteMapObject, _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag)>();
late final _CRouteMapObject_calloutLabelDisplayModeChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode Function(_CRouteMapObject)>>('CRouteMapObject_calloutLabelDisplayModeChannel');
late final _CRouteMapObject_calloutLabelDisplayModeChannel = _CRouteMapObject_calloutLabelDisplayModeChannelPtr.asFunction<_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode Function(_CRouteMapObject)>();
late final _CRouteMapObject_calloutLabelDisplayModePtr = _lookup<ffi.NativeFunction<_CRouteMapObjectCalloutLabelDisplayMode Function(_CRouteMapObject)>>('CRouteMapObject_calloutLabelDisplayMode');
late final _CRouteMapObject_calloutLabelDisplayMode = _CRouteMapObject_calloutLabelDisplayModePtr.asFunction<_CRouteMapObjectCalloutLabelDisplayMode Function(_CRouteMapObject)>();
late final _CRouteMapObject_setCalloutLabelDisplayMode_CRouteMapObjectCalloutLabelDisplayModePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapObject, _CRouteMapObjectCalloutLabelDisplayMode)>>('CRouteMapObject_setCalloutLabelDisplayMode_CRouteMapObjectCalloutLabelDisplayMode');
late final _CRouteMapObject_setCalloutLabelDisplayMode_CRouteMapObjectCalloutLabelDisplayMode = _CRouteMapObject_setCalloutLabelDisplayMode_CRouteMapObjectCalloutLabelDisplayModePtr.asFunction<void Function(_CRouteMapObject, _CRouteMapObjectCalloutLabelDisplayMode)>();
late final _CRouteMapObject_lanesCalloutPositionsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CLanesCalloutMapPosition Function(_CRouteMapObject)>>('CRouteMapObject_lanesCalloutPositionsChannel');
late final _CRouteMapObject_lanesCalloutPositionsChannel = _CRouteMapObject_lanesCalloutPositionsChannelPtr.asFunction<_CStatefulChannel_CArray_CLanesCalloutMapPosition Function(_CRouteMapObject)>();
late final _CRouteMapObject_lanesCalloutPositionsPtr = _lookup<ffi.NativeFunction<_CArray_CLanesCalloutMapPosition Function(_CRouteMapObject)>>('CRouteMapObject_lanesCalloutPositions');
late final _CRouteMapObject_lanesCalloutPositions = _CRouteMapObject_lanesCalloutPositionsPtr.asFunction<_CArray_CLanesCalloutMapPosition Function(_CRouteMapObject)>();
late final _CRouteMapObject_roadEventObjectsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRoadEventMapObjectRouteAttribute Function(_CRouteMapObject)>>('CRouteMapObject_roadEventObjectsChannel');
late final _CRouteMapObject_roadEventObjectsChannel = _CRouteMapObject_roadEventObjectsChannelPtr.asFunction<_CStatefulChannel_CRoadEventMapObjectRouteAttribute Function(_CRouteMapObject)>();
late final _CRouteMapObject_roadEventObjectsPtr = _lookup<ffi.NativeFunction<_CRoadEventMapObjectRouteAttribute Function(_CRouteMapObject)>>('CRouteMapObject_roadEventObjects');
late final _CRouteMapObject_roadEventObjects = _CRouteMapObject_roadEventObjectsPtr.asFunction<_CRoadEventMapObjectRouteAttribute Function(_CRouteMapObject)>();

late final _CRouteMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRouteMapObject_cg_objectIdentifier');
late final _CRouteMapObject_cg_objectIdentifier = _CRouteMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRouteMapObject_C_createWith_CTrafficRoute_bool_CRouteIndex_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_CRouteMapObjectCalloutLabelDisplayMode_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr = _lookup<ffi.NativeFunction<_CRouteMapObject Function(_CTrafficRoute, ffi.Bool, _CRouteIndex, _COptional_COptionSet_CRouteMapObjectDisplayFlag, _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag, _CRouteMapObjectCalloutLabelDisplayMode, _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>>('CRouteMapObject_C_createWith_CTrafficRoute_bool_CRouteIndex_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_CRouteMapObjectCalloutLabelDisplayMode_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag');
late final _CRouteMapObject_C_createWith_CTrafficRoute_bool_CRouteIndex_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_CRouteMapObjectCalloutLabelDisplayMode_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag = _CRouteMapObject_C_createWith_CTrafficRoute_bool_CRouteIndex_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_CRouteMapObjectCalloutLabelDisplayMode_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr.asFunction<_CRouteMapObject Function(_CTrafficRoute, bool, _CRouteIndex, _COptional_COptionSet_CRouteMapObjectDisplayFlag, _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag, _CRouteMapObjectCalloutLabelDisplayMode, _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>();

late final _CRouteMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRouteMapObject_release');
late final _CRouteMapObject_release = _CRouteMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteMapObject_retainPtr = _lookup<ffi.NativeFunction<_CRouteMapObject Function(ffi.Pointer<ffi.Void>)>>('CRouteMapObject_retain');
late final _CRouteMapObject_retain = _CRouteMapObject_retainPtr.asFunction<_CRouteMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteMapObject Function()>>('CRouteMapObjectMakeDefault');
late final _CRouteMapObjectMakeDefault = _CRouteMapObjectMakeDefaultPtr.asFunction<_CRouteMapObject Function()>();


late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag Function()>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagMakeDefault');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagMakeDefault = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag Function()>();
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag)>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag_release');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag_release = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag)>();
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag)>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag_retain');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag_retain = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag_retainPtr.asFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag)>();
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectDisplayFlag Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag)>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag_getCurrentValue');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagGetCurrentValue = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagGetCurrentValuePtr.asFunction<_COptional_COptionSet_CRouteMapObjectDisplayFlag Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag)>();
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_COptionSet_CRouteMapObjectDisplayFlag, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag_connect');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagConnect = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlagConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_COptionSet_CRouteMapObjectDisplayFlag,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_COptionSet_CRouteMapObjectDisplayFlag, ffi.Int64)>>
  )
>();

late final _COptionSet_CRouteMapObjectDisplayFlagMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CRouteMapObjectDisplayFlag Function()>>('COptionSet_CRouteMapObjectDisplayFlagMakeDefault');
late final _COptionSet_CRouteMapObjectDisplayFlagMakeDefault = _COptionSet_CRouteMapObjectDisplayFlagMakeDefaultPtr.asFunction<_COptionSet_CRouteMapObjectDisplayFlag Function()>();

late final _COptional_COptionSet_CRouteMapObjectDisplayFlagMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectDisplayFlag Function()>>('COptional_COptionSet_CRouteMapObjectDisplayFlagMakeDefault');
late final _COptional_COptionSet_CRouteMapObjectDisplayFlagMakeDefault = _COptional_COptionSet_CRouteMapObjectDisplayFlagMakeDefaultPtr.asFunction<_COptional_COptionSet_CRouteMapObjectDisplayFlag Function()>();

late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function()>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefault');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefault = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function()>();
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_release');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_release = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>();
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_retain');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_retain = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_retainPtr.asFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>();
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_getCurrentValue');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagGetCurrentValue = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagGetCurrentValuePtr.asFunction<_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>();
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_connect');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagConnect = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag, ffi.Int64)>>
  )
>();

late final _COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CRouteMapObjectPermanentDisplayFlag Function()>>('COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefault');
late final _COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefault = _COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefaultPtr.asFunction<_COptionSet_CRouteMapObjectPermanentDisplayFlag Function()>();

late final _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function()>>('COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefault');
late final _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefault = _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagMakeDefaultPtr.asFunction<_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function()>();
late final _CTrafficRoute_routePtr = _lookup<ffi.NativeFunction<_CRoute Function(_CTrafficRoute)>>('CTrafficRoute_route');
late final _CTrafficRoute_route = _CTrafficRoute_routePtr.asFunction<_CRoute Function(_CTrafficRoute)>();
late final _CTrafficRoute_trafficPtr = _lookup<ffi.NativeFunction<_CTraffic Function(_CTrafficRoute)>>('CTrafficRoute_traffic');
late final _CTrafficRoute_traffic = _CTrafficRoute_trafficPtr.asFunction<_CTraffic Function(_CTrafficRoute)>();

late final _CTrafficRoute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTrafficRoute_cg_objectIdentifier');
late final _CTrafficRoute_cg_objectIdentifier = _CTrafficRoute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTrafficRoute_S_fromNavigationState_CPackedNavigationState_CContextPtr = _lookup<ffi.NativeFunction<_CTrafficRoute Function(_CPackedNavigationState, _CContext)>>('CTrafficRoute_S_fromNavigationState_CPackedNavigationState_CContext');
late final _CTrafficRoute_S_fromNavigationState_CPackedNavigationState_CContext = _CTrafficRoute_S_fromNavigationState_CPackedNavigationState_CContextPtr.asFunction<_CTrafficRoute Function(_CPackedNavigationState, _CContext)>();

late final _CTrafficRoute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTrafficRoute_release');
late final _CTrafficRoute_release = _CTrafficRoute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficRoute_retainPtr = _lookup<ffi.NativeFunction<_CTrafficRoute Function(ffi.Pointer<ffi.Void>)>>('CTrafficRoute_retain');
late final _CTrafficRoute_retain = _CTrafficRoute_retainPtr.asFunction<_CTrafficRoute Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficRouteMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficRoute Function()>>('CTrafficRouteMakeDefault');
late final _CTrafficRouteMakeDefault = _CTrafficRouteMakeDefaultPtr.asFunction<_CTrafficRoute Function()>();

late final _CRoute_geometryPtr = _lookup<ffi.NativeFunction<_CGeoPointRouteAttribute Function(_CRoute)>>('CRoute_geometry');
late final _CRoute_geometry = _CRoute_geometryPtr.asFunction<_CGeoPointRouteAttribute Function(_CRoute)>();
late final _CRoute_instructionsPtr = _lookup<ffi.NativeFunction<_CInstructionRouteAttribute Function(_CRoute)>>('CRoute_instructions');
late final _CRoute_instructions = _CRoute_instructionsPtr.asFunction<_CInstructionRouteAttribute Function(_CRoute)>();
late final _CRoute_intermediatePointsPtr = _lookup<ffi.NativeFunction<_CGeoPointRouteAttribute Function(_CRoute)>>('CRoute_intermediatePoints');
late final _CRoute_intermediatePoints = _CRoute_intermediatePointsPtr.asFunction<_CGeoPointRouteAttribute Function(_CRoute)>();
late final _CRoute_altitudesPtr = _lookup<ffi.NativeFunction<_CDoubleRouteAttribute Function(_CRoute)>>('CRoute_altitudes');
late final _CRoute_altitudes = _CRoute_altitudesPtr.asFunction<_CDoubleRouteAttribute Function(_CRoute)>();
late final _CRoute_badRoadsPtr = _lookup<ffi.NativeFunction<_CBoolRouteLongAttribute Function(_CRoute)>>('CRoute_badRoads');
late final _CRoute_badRoads = _CRoute_badRoadsPtr.asFunction<_CBoolRouteLongAttribute Function(_CRoute)>();
late final _CRoute_obstaclesPtr = _lookup<ffi.NativeFunction<_CObstacleInfoRouteAttribute Function(_CRoute)>>('CRoute_obstacles');
late final _CRoute_obstacles = _CRoute_obstaclesPtr.asFunction<_CObstacleInfoRouteAttribute Function(_CRoute)>();
late final _CRoute_roadNamesPtr = _lookup<ffi.NativeFunction<_CStringRouteLongAttribute Function(_CRoute)>>('CRoute_roadNames');
late final _CRoute_roadNames = _CRoute_roadNamesPtr.asFunction<_CStringRouteLongAttribute Function(_CRoute)>();
late final _CRoute_settlementsPtr = _lookup<ffi.NativeFunction<_CSettlementRouteLongAttribute Function(_CRoute)>>('CRoute_settlements');
late final _CRoute_settlements = _CRoute_settlementsPtr.asFunction<_CSettlementRouteLongAttribute Function(_CRoute)>();
late final _CRoute_transportTypesPtr = _lookup<ffi.NativeFunction<_CTransportTypeRouteLongAttribute Function(_CRoute)>>('CRoute_transportTypes');
late final _CRoute_transportTypes = _CRoute_transportTypesPtr.asFunction<_CTransportTypeRouteLongAttribute Function(_CRoute)>();
late final _CRoute_camerasPtr = _lookup<ffi.NativeFunction<_CCameraRouteAttribute Function(_CRoute)>>('CRoute_cameras');
late final _CRoute_cameras = _CRoute_camerasPtr.asFunction<_CCameraRouteAttribute Function(_CRoute)>();
late final _CRoute_carriagewaysWidthPtr = _lookup<ffi.NativeFunction<_CUIntRouteLongAttribute Function(_CRoute)>>('CRoute_carriagewaysWidth');
late final _CRoute_carriagewaysWidth = _CRoute_carriagewaysWidthPtr.asFunction<_CUIntRouteLongAttribute Function(_CRoute)>();
late final _CRoute_exitSignsPtr = _lookup<ffi.NativeFunction<_CRouteExitSignRouteAttribute Function(_CRoute)>>('CRoute_exitSigns');
late final _CRoute_exitSigns = _CRoute_exitSignsPtr.asFunction<_CRouteExitSignRouteAttribute Function(_CRoute)>();
late final _CRoute_humpsPtr = _lookup<ffi.NativeFunction<_CVoidRouteAttribute Function(_CRoute)>>('CRoute_humps');
late final _CRoute_humps = _CRoute_humpsPtr.asFunction<_CVoidRouteAttribute Function(_CRoute)>();
late final _CRoute_lanesPtr = _lookup<ffi.NativeFunction<_CLaneSignRouteLongAttribute Function(_CRoute)>>('CRoute_lanes');
late final _CRoute_lanes = _CRoute_lanesPtr.asFunction<_CLaneSignRouteLongAttribute Function(_CRoute)>();
late final _CRoute_levelsPtr = _lookup<ffi.NativeFunction<_CRouteLevelInfoRouteLongAttribute Function(_CRoute)>>('CRoute_levels');
late final _CRoute_levels = _CRoute_levelsPtr.asFunction<_CRouteLevelInfoRouteLongAttribute Function(_CRoute)>();
late final _CRoute_maxSpeedLimitsPtr = _lookup<ffi.NativeFunction<_CFloatRouteLongAttribute Function(_CRoute)>>('CRoute_maxSpeedLimits');
late final _CRoute_maxSpeedLimits = _CRoute_maxSpeedLimitsPtr.asFunction<_CFloatRouteLongAttribute Function(_CRoute)>();
late final _CRoute_roadRulesPtr = _lookup<ffi.NativeFunction<_CRoadRuleRouteLongAttribute Function(_CRoute)>>('CRoute_roadRules');
late final _CRoute_roadRules = _CRoute_roadRulesPtr.asFunction<_CRoadRuleRouteLongAttribute Function(_CRoute)>();
late final _CRoute_roadSubtypesPtr = _lookup<ffi.NativeFunction<_CRoadSubtypeRouteLongAttribute Function(_CRoute)>>('CRoute_roadSubtypes');
late final _CRoute_roadSubtypes = _CRoute_roadSubtypesPtr.asFunction<_CRoadSubtypeRouteLongAttribute Function(_CRoute)>();
late final _CRoute_roadSurfacesPtr = _lookup<ffi.NativeFunction<_CRoadSurfaceRouteLongAttribute Function(_CRoute)>>('CRoute_roadSurfaces');
late final _CRoute_roadSurfaces = _CRoute_roadSurfacesPtr.asFunction<_CRoadSurfaceRouteLongAttribute Function(_CRoute)>();
late final _CRoute_roadTypesPtr = _lookup<ffi.NativeFunction<_CRoadTypeRouteLongAttribute Function(_CRoute)>>('CRoute_roadTypes');
late final _CRoute_roadTypes = _CRoute_roadTypesPtr.asFunction<_CRoadTypeRouteLongAttribute Function(_CRoute)>();
late final _CRoute_tollsPtr = _lookup<ffi.NativeFunction<_CBoolRouteLongAttribute Function(_CRoute)>>('CRoute_tolls');
late final _CRoute_tolls = _CRoute_tollsPtr.asFunction<_CBoolRouteLongAttribute Function(_CRoute)>();
late final _CRoute_truckDataPtr = _lookup<ffi.NativeFunction<_CBoolRouteLongAttribute Function(_CRoute)>>('CRoute_truckData');
late final _CRoute_truckData = _CRoute_truckDataPtr.asFunction<_CBoolRouteLongAttribute Function(_CRoute)>();
late final _CRoute_truckPassZoneIdsPtr = _lookup<ffi.NativeFunction<_CTruckPassZoneIdRouteLongAttribute Function(_CRoute)>>('CRoute_truckPassZoneIds');
late final _CRoute_truckPassZoneIds = _CRoute_truckPassZoneIdsPtr.asFunction<_CTruckPassZoneIdRouteLongAttribute Function(_CRoute)>();
late final _CRoute_truckRestrictedAreasPtr = _lookup<ffi.NativeFunction<_CBoolRouteLongAttribute Function(_CRoute)>>('CRoute_truckRestrictedAreas');
late final _CRoute_truckRestrictedAreas = _CRoute_truckRestrictedAreasPtr.asFunction<_CBoolRouteLongAttribute Function(_CRoute)>();
late final _CRoute_vehicleRestrictedAreasPtr = _lookup<ffi.NativeFunction<_CBoolRouteLongAttribute Function(_CRoute)>>('CRoute_vehicleRestrictedAreas');
late final _CRoute_vehicleRestrictedAreas = _CRoute_vehicleRestrictedAreasPtr.asFunction<_CBoolRouteLongAttribute Function(_CRoute)>();
late final _CRoute_bicycleLanesPtr = _lookup<ffi.NativeFunction<_CBoolRouteLongAttribute Function(_CRoute)>>('CRoute_bicycleLanes');
late final _CRoute_bicycleLanes = _CRoute_bicycleLanesPtr.asFunction<_CBoolRouteLongAttribute Function(_CRoute)>();
late final _CRoute_trafficLightsPtr = _lookup<ffi.NativeFunction<_CVoidRouteAttribute Function(_CRoute)>>('CRoute_trafficLights');
late final _CRoute_trafficLights = _CRoute_trafficLightsPtr.asFunction<_CVoidRouteAttribute Function(_CRoute)>();
late final _CRoute_immersiveDataPtr = _lookup<ffi.NativeFunction<_CBoolRouteLongAttribute Function(_CRoute)>>('CRoute_immersiveData');
late final _CRoute_immersiveData = _CRoute_immersiveDataPtr.asFunction<_CBoolRouteLongAttribute Function(_CRoute)>();
late final _CRoute_publicTransportTransfersPtr = _lookup<ffi.NativeFunction<_CPublicTransportTransferRouteLongAttribute Function(_CRoute)>>('CRoute_publicTransportTransfers');
late final _CRoute_publicTransportTransfers = _CRoute_publicTransportTransfersPtr.asFunction<_CPublicTransportTransferRouteLongAttribute Function(_CRoute)>();

late final _CRoute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoute_cg_objectIdentifier');
late final _CRoute_cg_objectIdentifier = _CRoute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CRoute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoute_release');
late final _CRoute_release = _CRoute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoute_retainPtr = _lookup<ffi.NativeFunction<_CRoute Function(ffi.Pointer<ffi.Void>)>>('CRoute_retain');
late final _CRoute_retain = _CRoute_retainPtr.asFunction<_CRoute Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoute Function()>>('CRouteMakeDefault');
late final _CRouteMakeDefault = _CRouteMakeDefaultPtr.asFunction<_CRoute Function()>();

late final _CInstructionRouteAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CInstructionRouteAttribute)>>('CInstructionRouteAttribute_size');
late final _CInstructionRouteAttribute_size = _CInstructionRouteAttribute_sizePtr.asFunction<int Function(_CInstructionRouteAttribute)>();
late final _CInstructionRouteAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CInstructionRouteAttribute)>>('CInstructionRouteAttribute_isEmpty');
late final _CInstructionRouteAttribute_isEmpty = _CInstructionRouteAttribute_isEmptyPtr.asFunction<bool Function(_CInstructionRouteAttribute)>();
late final _CInstructionRouteAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CInstructionRouteEntry Function(_CInstructionRouteAttribute)>>('CInstructionRouteAttribute_first');
late final _CInstructionRouteAttribute_first = _CInstructionRouteAttribute_firstPtr.asFunction<_COptional_CInstructionRouteEntry Function(_CInstructionRouteAttribute)>();
late final _CInstructionRouteAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CInstructionRouteEntry Function(_CInstructionRouteAttribute)>>('CInstructionRouteAttribute_last');
late final _CInstructionRouteAttribute_last = _CInstructionRouteAttribute_lastPtr.asFunction<_COptional_CInstructionRouteEntry Function(_CInstructionRouteAttribute)>();
late final _CInstructionRouteAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CInstructionRouteEntry Function(_CInstructionRouteAttribute)>>('CInstructionRouteAttribute_entries');
late final _CInstructionRouteAttribute_entries = _CInstructionRouteAttribute_entriesPtr.asFunction<_CArray_CInstructionRouteEntry Function(_CInstructionRouteAttribute)>();

late final _CInstructionRouteAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CInstructionRouteAttribute_cg_objectIdentifier');
late final _CInstructionRouteAttribute_cg_objectIdentifier = _CInstructionRouteAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CInstructionRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CInstructionRouteEntry Function(_CInstructionRouteAttribute, _CRoutePoint, _CRoutePoint)>>('CInstructionRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CInstructionRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CInstructionRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CInstructionRouteEntry Function(_CInstructionRouteAttribute, _CRoutePoint, _CRoutePoint)>();
late final _CInstructionRouteAttribute_findNearBackward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CInstructionRouteEntry Function(_CInstructionRouteAttribute, _CRoutePoint)>>('CInstructionRouteAttribute_findNearBackward_CRoutePoint');
late final _CInstructionRouteAttribute_findNearBackward_CRoutePoint = _CInstructionRouteAttribute_findNearBackward_CRoutePointPtr.asFunction<_COptional_CInstructionRouteEntry Function(_CInstructionRouteAttribute, _CRoutePoint)>();
late final _CInstructionRouteAttribute_findNearForward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CInstructionRouteEntry Function(_CInstructionRouteAttribute, _CRoutePoint)>>('CInstructionRouteAttribute_findNearForward_CRoutePoint');
late final _CInstructionRouteAttribute_findNearForward_CRoutePoint = _CInstructionRouteAttribute_findNearForward_CRoutePointPtr.asFunction<_COptional_CInstructionRouteEntry Function(_CInstructionRouteAttribute, _CRoutePoint)>();

late final _CInstructionRouteAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CInstructionRouteAttribute_release');
late final _CInstructionRouteAttribute_release = _CInstructionRouteAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CInstructionRouteAttribute_retainPtr = _lookup<ffi.NativeFunction<_CInstructionRouteAttribute Function(ffi.Pointer<ffi.Void>)>>('CInstructionRouteAttribute_retain');
late final _CInstructionRouteAttribute_retain = _CInstructionRouteAttribute_retainPtr.asFunction<_CInstructionRouteAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CInstructionRouteAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CInstructionRouteAttribute Function()>>('CInstructionRouteAttributeMakeDefault');
late final _CInstructionRouteAttributeMakeDefault = _CInstructionRouteAttributeMakeDefaultPtr.asFunction<_CInstructionRouteAttribute Function()>();


late final _CBicycleInstructionStartMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBicycleInstructionStart Function()>>('CBicycleInstructionStartMakeDefault');
late final _CBicycleInstructionStartMakeDefault = _CBicycleInstructionStartMakeDefaultPtr.asFunction<_CBicycleInstructionStart Function()>();


late final _CBicycleInstructionFinishMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBicycleInstructionFinish Function()>>('CBicycleInstructionFinishMakeDefault');
late final _CBicycleInstructionFinishMakeDefault = _CBicycleInstructionFinishMakeDefaultPtr.asFunction<_CBicycleInstructionFinish Function()>();


late final _CBicycleInstructionCrossroadLandmarkMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBicycleInstructionCrossroadLandmark Function()>>('CBicycleInstructionCrossroadLandmarkMakeDefault');
late final _CBicycleInstructionCrossroadLandmarkMakeDefault = _CBicycleInstructionCrossroadLandmarkMakeDefaultPtr.asFunction<_CBicycleInstructionCrossroadLandmark Function()>();

late final _CArray_CBicycleInstructionCrossroadManeuvermakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CBicycleInstructionCrossroadManeuver Function()>>('CArray_CBicycleInstructionCrossroadManeuver_makeEmpty');
late final _CArray_CBicycleInstructionCrossroadManeuvermakeEmpty = _CArray_CBicycleInstructionCrossroadManeuvermakeEmptyPtr.asFunction<_CArray_CBicycleInstructionCrossroadManeuver Function()>();
late final _CArray_CBicycleInstructionCrossroadManeuveraddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CBicycleInstructionCrossroadManeuver, _CBicycleInstructionCrossroadManeuver)>>('CArray_CBicycleInstructionCrossroadManeuver_addElement');
late final _CArray_CBicycleInstructionCrossroadManeuveraddElement = _CArray_CBicycleInstructionCrossroadManeuveraddElementPtr.asFunction<void Function(_CArray_CBicycleInstructionCrossroadManeuver, _CBicycleInstructionCrossroadManeuver)>();
late final _forEach_CArray_CBicycleInstructionCrossroadManeuverPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CBicycleInstructionCrossroadManeuver, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CBicycleInstructionCrossroadManeuver)>>)
>>('CArray_CBicycleInstructionCrossroadManeuver_forEachWithFunctionPointer');
late final _forEach_CArray_CBicycleInstructionCrossroadManeuver = _forEach_CArray_CBicycleInstructionCrossroadManeuverPtr.asFunction<
  void Function(_CArray_CBicycleInstructionCrossroadManeuver, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CBicycleInstructionCrossroadManeuver)
>>)>();
late final _CArray_CBicycleInstructionCrossroadManeuver_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CBicycleInstructionCrossroadManeuver)>>('CArray_CBicycleInstructionCrossroadManeuver_release');
late final _CArray_CBicycleInstructionCrossroadManeuver_release = _CArray_CBicycleInstructionCrossroadManeuver_releasePtr.asFunction<void Function(_CArray_CBicycleInstructionCrossroadManeuver)>();

late final _CBicycleInstructionCrossroadMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBicycleInstructionCrossroad Function()>>('CBicycleInstructionCrossroadMakeDefault');
late final _CBicycleInstructionCrossroadMakeDefault = _CBicycleInstructionCrossroadMakeDefaultPtr.asFunction<_CBicycleInstructionCrossroad Function()>();


late final _CCarInstructionStartMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCarInstructionStart Function()>>('CCarInstructionStartMakeDefault');
late final _CCarInstructionStartMakeDefault = _CCarInstructionStartMakeDefaultPtr.asFunction<_CCarInstructionStart Function()>();


late final _CCarInstructionFinishMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCarInstructionFinish Function()>>('CCarInstructionFinishMakeDefault');
late final _CCarInstructionFinishMakeDefault = _CCarInstructionFinishMakeDefaultPtr.asFunction<_CCarInstructionFinish Function()>();


late final _CCarInstructionCrossroadDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCarInstructionCrossroadDirection Function()>>('CCarInstructionCrossroadDirectionMakeDefault');
late final _CCarInstructionCrossroadDirectionMakeDefault = _CCarInstructionCrossroadDirectionMakeDefaultPtr.asFunction<_CCarInstructionCrossroadDirection Function()>();

late final _CCarInstructionCrossroadLandmarkMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCarInstructionCrossroadLandmark Function()>>('CCarInstructionCrossroadLandmarkMakeDefault');
late final _CCarInstructionCrossroadLandmarkMakeDefault = _CCarInstructionCrossroadLandmarkMakeDefaultPtr.asFunction<_CCarInstructionCrossroadLandmark Function()>();

late final _CCarInstructionCrossroadMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCarInstructionCrossroad Function()>>('CCarInstructionCrossroadMakeDefault');
late final _CCarInstructionCrossroadMakeDefault = _CCarInstructionCrossroadMakeDefaultPtr.asFunction<_CCarInstructionCrossroad Function()>();


late final _CCarInstructionRoundaboutTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCarInstructionRoundaboutType Function()>>('CCarInstructionRoundaboutTypeMakeDefault');
late final _CCarInstructionRoundaboutTypeMakeDefault = _CCarInstructionRoundaboutTypeMakeDefaultPtr.asFunction<_CCarInstructionRoundaboutType Function()>();

late final _CCarInstructionRoundaboutMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCarInstructionRoundabout Function()>>('CCarInstructionRoundaboutMakeDefault');
late final _CCarInstructionRoundaboutMakeDefault = _CCarInstructionRoundaboutMakeDefaultPtr.asFunction<_CCarInstructionRoundabout Function()>();


late final _CCarInstructionUTurnMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCarInstructionUTurn Function()>>('CCarInstructionUTurnMakeDefault');
late final _CCarInstructionUTurnMakeDefault = _CCarInstructionUTurnMakeDefaultPtr.asFunction<_CCarInstructionUTurn Function()>();


late final _CPedestrianInstructionStartMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPedestrianInstructionStart Function()>>('CPedestrianInstructionStartMakeDefault');
late final _CPedestrianInstructionStartMakeDefault = _CPedestrianInstructionStartMakeDefaultPtr.asFunction<_CPedestrianInstructionStart Function()>();


late final _CPedestrianInstructionFinishMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPedestrianInstructionFinish Function()>>('CPedestrianInstructionFinishMakeDefault');
late final _CPedestrianInstructionFinishMakeDefault = _CPedestrianInstructionFinishMakeDefaultPtr.asFunction<_CPedestrianInstructionFinish Function()>();


late final _CPedestrianInstructionCrossroadLandmarkMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPedestrianInstructionCrossroadLandmark Function()>>('CPedestrianInstructionCrossroadLandmarkMakeDefault');
late final _CPedestrianInstructionCrossroadLandmarkMakeDefault = _CPedestrianInstructionCrossroadLandmarkMakeDefaultPtr.asFunction<_CPedestrianInstructionCrossroadLandmark Function()>();

late final _CArray_CPedestrianInstructionCrossroadManeuvermakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CPedestrianInstructionCrossroadManeuver Function()>>('CArray_CPedestrianInstructionCrossroadManeuver_makeEmpty');
late final _CArray_CPedestrianInstructionCrossroadManeuvermakeEmpty = _CArray_CPedestrianInstructionCrossroadManeuvermakeEmptyPtr.asFunction<_CArray_CPedestrianInstructionCrossroadManeuver Function()>();
late final _CArray_CPedestrianInstructionCrossroadManeuveraddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPedestrianInstructionCrossroadManeuver, _CPedestrianInstructionCrossroadManeuver)>>('CArray_CPedestrianInstructionCrossroadManeuver_addElement');
late final _CArray_CPedestrianInstructionCrossroadManeuveraddElement = _CArray_CPedestrianInstructionCrossroadManeuveraddElementPtr.asFunction<void Function(_CArray_CPedestrianInstructionCrossroadManeuver, _CPedestrianInstructionCrossroadManeuver)>();
late final _forEach_CArray_CPedestrianInstructionCrossroadManeuverPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CPedestrianInstructionCrossroadManeuver, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPedestrianInstructionCrossroadManeuver)>>)
>>('CArray_CPedestrianInstructionCrossroadManeuver_forEachWithFunctionPointer');
late final _forEach_CArray_CPedestrianInstructionCrossroadManeuver = _forEach_CArray_CPedestrianInstructionCrossroadManeuverPtr.asFunction<
  void Function(_CArray_CPedestrianInstructionCrossroadManeuver, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPedestrianInstructionCrossroadManeuver)
>>)>();
late final _CArray_CPedestrianInstructionCrossroadManeuver_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPedestrianInstructionCrossroadManeuver)>>('CArray_CPedestrianInstructionCrossroadManeuver_release');
late final _CArray_CPedestrianInstructionCrossroadManeuver_release = _CArray_CPedestrianInstructionCrossroadManeuver_releasePtr.asFunction<void Function(_CArray_CPedestrianInstructionCrossroadManeuver)>();

late final _CPedestrianInstructionCrossroadMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPedestrianInstructionCrossroad Function()>>('CPedestrianInstructionCrossroadMakeDefault');
late final _CPedestrianInstructionCrossroadMakeDefault = _CPedestrianInstructionCrossroadMakeDefaultPtr.asFunction<_CPedestrianInstructionCrossroad Function()>();


late final _CPedestrianInstructionIndoorFloorChangeTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPedestrianInstructionIndoorFloorChangeType Function()>>('CPedestrianInstructionIndoorFloorChangeTypeMakeDefault');
late final _CPedestrianInstructionIndoorFloorChangeTypeMakeDefault = _CPedestrianInstructionIndoorFloorChangeTypeMakeDefaultPtr.asFunction<_CPedestrianInstructionIndoorFloorChangeType Function()>();

late final _CPedestrianInstructionIndoorFloorChangeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPedestrianInstructionIndoorFloorChange Function()>>('CPedestrianInstructionIndoorFloorChangeMakeDefault');
late final _CPedestrianInstructionIndoorFloorChangeMakeDefault = _CPedestrianInstructionIndoorFloorChangeMakeDefaultPtr.asFunction<_CPedestrianInstructionIndoorFloorChange Function()>();


late final _CPedestrianInstructionIndoorEnterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPedestrianInstructionIndoorEnter Function()>>('CPedestrianInstructionIndoorEnterMakeDefault');
late final _CPedestrianInstructionIndoorEnterMakeDefault = _CPedestrianInstructionIndoorEnterMakeDefaultPtr.asFunction<_CPedestrianInstructionIndoorEnter Function()>();


late final _CPedestrianInstructionIndoorExitMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPedestrianInstructionIndoorExit Function()>>('CPedestrianInstructionIndoorExitMakeDefault');
late final _CPedestrianInstructionIndoorExitMakeDefault = _CPedestrianInstructionIndoorExitMakeDefaultPtr.asFunction<_CPedestrianInstructionIndoorExit Function()>();


late final _CScooterInstructionStartMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScooterInstructionStart Function()>>('CScooterInstructionStartMakeDefault');
late final _CScooterInstructionStartMakeDefault = _CScooterInstructionStartMakeDefaultPtr.asFunction<_CScooterInstructionStart Function()>();


late final _CScooterInstructionFinishMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScooterInstructionFinish Function()>>('CScooterInstructionFinishMakeDefault');
late final _CScooterInstructionFinishMakeDefault = _CScooterInstructionFinishMakeDefaultPtr.asFunction<_CScooterInstructionFinish Function()>();


late final _CScooterInstructionCrossroadLandmarkMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScooterInstructionCrossroadLandmark Function()>>('CScooterInstructionCrossroadLandmarkMakeDefault');
late final _CScooterInstructionCrossroadLandmarkMakeDefault = _CScooterInstructionCrossroadLandmarkMakeDefaultPtr.asFunction<_CScooterInstructionCrossroadLandmark Function()>();

late final _CArray_CScooterInstructionCrossroadManeuvermakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CScooterInstructionCrossroadManeuver Function()>>('CArray_CScooterInstructionCrossroadManeuver_makeEmpty');
late final _CArray_CScooterInstructionCrossroadManeuvermakeEmpty = _CArray_CScooterInstructionCrossroadManeuvermakeEmptyPtr.asFunction<_CArray_CScooterInstructionCrossroadManeuver Function()>();
late final _CArray_CScooterInstructionCrossroadManeuveraddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CScooterInstructionCrossroadManeuver, _CScooterInstructionCrossroadManeuver)>>('CArray_CScooterInstructionCrossroadManeuver_addElement');
late final _CArray_CScooterInstructionCrossroadManeuveraddElement = _CArray_CScooterInstructionCrossroadManeuveraddElementPtr.asFunction<void Function(_CArray_CScooterInstructionCrossroadManeuver, _CScooterInstructionCrossroadManeuver)>();
late final _forEach_CArray_CScooterInstructionCrossroadManeuverPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CScooterInstructionCrossroadManeuver, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CScooterInstructionCrossroadManeuver)>>)
>>('CArray_CScooterInstructionCrossroadManeuver_forEachWithFunctionPointer');
late final _forEach_CArray_CScooterInstructionCrossroadManeuver = _forEach_CArray_CScooterInstructionCrossroadManeuverPtr.asFunction<
  void Function(_CArray_CScooterInstructionCrossroadManeuver, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CScooterInstructionCrossroadManeuver)
>>)>();
late final _CArray_CScooterInstructionCrossroadManeuver_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CScooterInstructionCrossroadManeuver)>>('CArray_CScooterInstructionCrossroadManeuver_release');
late final _CArray_CScooterInstructionCrossroadManeuver_release = _CArray_CScooterInstructionCrossroadManeuver_releasePtr.asFunction<void Function(_CArray_CScooterInstructionCrossroadManeuver)>();

late final _CScooterInstructionCrossroadMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScooterInstructionCrossroad Function()>>('CScooterInstructionCrossroadMakeDefault');
late final _CScooterInstructionCrossroadMakeDefault = _CScooterInstructionCrossroadMakeDefaultPtr.asFunction<_CScooterInstructionCrossroad Function()>();


late final _CExtraInstructionInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CExtraInstructionInfo)>>('CExtraInstructionInfo_release');
late final _CExtraInstructionInfo_release = _CExtraInstructionInfo_releasePtr.asFunction<void Function(_CExtraInstructionInfo)>();
late final _CExtraInstructionInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CExtraInstructionInfo Function()>>('CExtraInstructionInfoMakeDefault');
late final _CExtraInstructionInfoMakeDefault = _CExtraInstructionInfoMakeDefaultPtr.asFunction<_CExtraInstructionInfo Function()>();

late final _CRouteInstructionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteInstruction Function()>>('CRouteInstructionMakeDefault');
late final _CRouteInstructionMakeDefault = _CRouteInstructionMakeDefaultPtr.asFunction<_CRouteInstruction Function()>();


late final _CInstructionRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CInstructionRouteEntry Function()>>('CInstructionRouteEntryMakeDefault');
late final _CInstructionRouteEntryMakeDefault = _CInstructionRouteEntryMakeDefaultPtr.asFunction<_CInstructionRouteEntry Function()>();


late final _COptional_CInstructionRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CInstructionRouteEntry Function()>>('COptional_CInstructionRouteEntryMakeDefault');
late final _COptional_CInstructionRouteEntryMakeDefault = _COptional_CInstructionRouteEntryMakeDefaultPtr.asFunction<_COptional_CInstructionRouteEntry Function()>();

late final _COptional_CInstructionRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CInstructionRouteEntry)>>('COptional_CInstructionRouteEntry_release');
late final _COptional_CInstructionRouteEntry_release = _COptional_CInstructionRouteEntry_releasePtr.asFunction<void Function(_COptional_CInstructionRouteEntry)>();

late final _CBicycleInstructionCrossroadManeuverDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBicycleInstructionCrossroadManeuverDirection Function()>>('CBicycleInstructionCrossroadManeuverDirectionMakeDefault');
late final _CBicycleInstructionCrossroadManeuverDirectionMakeDefault = _CBicycleInstructionCrossroadManeuverDirectionMakeDefaultPtr.asFunction<_CBicycleInstructionCrossroadManeuverDirection Function()>();

late final _CBicycleInstructionCrossroadManeuverMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBicycleInstructionCrossroadManeuver Function()>>('CBicycleInstructionCrossroadManeuverMakeDefault');
late final _CBicycleInstructionCrossroadManeuverMakeDefault = _CBicycleInstructionCrossroadManeuverMakeDefaultPtr.asFunction<_CBicycleInstructionCrossroadManeuver Function()>();


late final _CPedestrianInstructionCrossroadManeuverDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPedestrianInstructionCrossroadManeuverDirection Function()>>('CPedestrianInstructionCrossroadManeuverDirectionMakeDefault');
late final _CPedestrianInstructionCrossroadManeuverDirectionMakeDefault = _CPedestrianInstructionCrossroadManeuverDirectionMakeDefaultPtr.asFunction<_CPedestrianInstructionCrossroadManeuverDirection Function()>();

late final _CPedestrianInstructionCrossroadManeuverMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPedestrianInstructionCrossroadManeuver Function()>>('CPedestrianInstructionCrossroadManeuverMakeDefault');
late final _CPedestrianInstructionCrossroadManeuverMakeDefault = _CPedestrianInstructionCrossroadManeuverMakeDefaultPtr.asFunction<_CPedestrianInstructionCrossroadManeuver Function()>();


late final _CScooterInstructionCrossroadManeuverDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScooterInstructionCrossroadManeuverDirection Function()>>('CScooterInstructionCrossroadManeuverDirectionMakeDefault');
late final _CScooterInstructionCrossroadManeuverDirectionMakeDefault = _CScooterInstructionCrossroadManeuverDirectionMakeDefaultPtr.asFunction<_CScooterInstructionCrossroadManeuverDirection Function()>();

late final _CScooterInstructionCrossroadManeuverMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScooterInstructionCrossroadManeuver Function()>>('CScooterInstructionCrossroadManeuverMakeDefault');
late final _CScooterInstructionCrossroadManeuverMakeDefault = _CScooterInstructionCrossroadManeuverMakeDefaultPtr.asFunction<_CScooterInstructionCrossroadManeuver Function()>();


late final _CArray_CInstructionRouteEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CInstructionRouteEntry Function()>>('CArray_CInstructionRouteEntry_makeEmpty');
late final _CArray_CInstructionRouteEntrymakeEmpty = _CArray_CInstructionRouteEntrymakeEmptyPtr.asFunction<_CArray_CInstructionRouteEntry Function()>();
late final _CArray_CInstructionRouteEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CInstructionRouteEntry, _CInstructionRouteEntry)>>('CArray_CInstructionRouteEntry_addElement');
late final _CArray_CInstructionRouteEntryaddElement = _CArray_CInstructionRouteEntryaddElementPtr.asFunction<void Function(_CArray_CInstructionRouteEntry, _CInstructionRouteEntry)>();
late final _forEach_CArray_CInstructionRouteEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CInstructionRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CInstructionRouteEntry)>>)
>>('CArray_CInstructionRouteEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CInstructionRouteEntry = _forEach_CArray_CInstructionRouteEntryPtr.asFunction<
  void Function(_CArray_CInstructionRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CInstructionRouteEntry)
>>)>();
late final _CArray_CInstructionRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CInstructionRouteEntry)>>('CArray_CInstructionRouteEntry_release');
late final _CArray_CInstructionRouteEntry_release = _CArray_CInstructionRouteEntry_releasePtr.asFunction<void Function(_CArray_CInstructionRouteEntry)>();
late final _CDoubleRouteAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CDoubleRouteAttribute)>>('CDoubleRouteAttribute_size');
late final _CDoubleRouteAttribute_size = _CDoubleRouteAttribute_sizePtr.asFunction<int Function(_CDoubleRouteAttribute)>();
late final _CDoubleRouteAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CDoubleRouteAttribute)>>('CDoubleRouteAttribute_isEmpty');
late final _CDoubleRouteAttribute_isEmpty = _CDoubleRouteAttribute_isEmptyPtr.asFunction<bool Function(_CDoubleRouteAttribute)>();
late final _CDoubleRouteAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CDoubleRouteEntry Function(_CDoubleRouteAttribute)>>('CDoubleRouteAttribute_first');
late final _CDoubleRouteAttribute_first = _CDoubleRouteAttribute_firstPtr.asFunction<_COptional_CDoubleRouteEntry Function(_CDoubleRouteAttribute)>();
late final _CDoubleRouteAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CDoubleRouteEntry Function(_CDoubleRouteAttribute)>>('CDoubleRouteAttribute_last');
late final _CDoubleRouteAttribute_last = _CDoubleRouteAttribute_lastPtr.asFunction<_COptional_CDoubleRouteEntry Function(_CDoubleRouteAttribute)>();
late final _CDoubleRouteAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CDoubleRouteEntry Function(_CDoubleRouteAttribute)>>('CDoubleRouteAttribute_entries');
late final _CDoubleRouteAttribute_entries = _CDoubleRouteAttribute_entriesPtr.asFunction<_CArray_CDoubleRouteEntry Function(_CDoubleRouteAttribute)>();

late final _CDoubleRouteAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDoubleRouteAttribute_cg_objectIdentifier');
late final _CDoubleRouteAttribute_cg_objectIdentifier = _CDoubleRouteAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDoubleRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CDoubleRouteEntry Function(_CDoubleRouteAttribute, _CRoutePoint, _CRoutePoint)>>('CDoubleRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CDoubleRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CDoubleRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CDoubleRouteEntry Function(_CDoubleRouteAttribute, _CRoutePoint, _CRoutePoint)>();
late final _CDoubleRouteAttribute_findNearBackward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CDoubleRouteEntry Function(_CDoubleRouteAttribute, _CRoutePoint)>>('CDoubleRouteAttribute_findNearBackward_CRoutePoint');
late final _CDoubleRouteAttribute_findNearBackward_CRoutePoint = _CDoubleRouteAttribute_findNearBackward_CRoutePointPtr.asFunction<_COptional_CDoubleRouteEntry Function(_CDoubleRouteAttribute, _CRoutePoint)>();
late final _CDoubleRouteAttribute_findNearForward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CDoubleRouteEntry Function(_CDoubleRouteAttribute, _CRoutePoint)>>('CDoubleRouteAttribute_findNearForward_CRoutePoint');
late final _CDoubleRouteAttribute_findNearForward_CRoutePoint = _CDoubleRouteAttribute_findNearForward_CRoutePointPtr.asFunction<_COptional_CDoubleRouteEntry Function(_CDoubleRouteAttribute, _CRoutePoint)>();

late final _CDoubleRouteAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDoubleRouteAttribute_release');
late final _CDoubleRouteAttribute_release = _CDoubleRouteAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDoubleRouteAttribute_retainPtr = _lookup<ffi.NativeFunction<_CDoubleRouteAttribute Function(ffi.Pointer<ffi.Void>)>>('CDoubleRouteAttribute_retain');
late final _CDoubleRouteAttribute_retain = _CDoubleRouteAttribute_retainPtr.asFunction<_CDoubleRouteAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CDoubleRouteAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDoubleRouteAttribute Function()>>('CDoubleRouteAttributeMakeDefault');
late final _CDoubleRouteAttributeMakeDefault = _CDoubleRouteAttributeMakeDefaultPtr.asFunction<_CDoubleRouteAttribute Function()>();


late final _CDoubleRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDoubleRouteEntry Function()>>('CDoubleRouteEntryMakeDefault');
late final _CDoubleRouteEntryMakeDefault = _CDoubleRouteEntryMakeDefaultPtr.asFunction<_CDoubleRouteEntry Function()>();


late final _COptional_CDoubleRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CDoubleRouteEntry Function()>>('COptional_CDoubleRouteEntryMakeDefault');
late final _COptional_CDoubleRouteEntryMakeDefault = _COptional_CDoubleRouteEntryMakeDefaultPtr.asFunction<_COptional_CDoubleRouteEntry Function()>();

late final _CArray_CDoubleRouteEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CDoubleRouteEntry Function()>>('CArray_CDoubleRouteEntry_makeEmpty');
late final _CArray_CDoubleRouteEntrymakeEmpty = _CArray_CDoubleRouteEntrymakeEmptyPtr.asFunction<_CArray_CDoubleRouteEntry Function()>();
late final _CArray_CDoubleRouteEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDoubleRouteEntry, _CDoubleRouteEntry)>>('CArray_CDoubleRouteEntry_addElement');
late final _CArray_CDoubleRouteEntryaddElement = _CArray_CDoubleRouteEntryaddElementPtr.asFunction<void Function(_CArray_CDoubleRouteEntry, _CDoubleRouteEntry)>();
late final _forEach_CArray_CDoubleRouteEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CDoubleRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDoubleRouteEntry)>>)
>>('CArray_CDoubleRouteEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CDoubleRouteEntry = _forEach_CArray_CDoubleRouteEntryPtr.asFunction<
  void Function(_CArray_CDoubleRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDoubleRouteEntry)
>>)>();
late final _CArray_CDoubleRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDoubleRouteEntry)>>('CArray_CDoubleRouteEntry_release');
late final _CArray_CDoubleRouteEntry_release = _CArray_CDoubleRouteEntry_releasePtr.asFunction<void Function(_CArray_CDoubleRouteEntry)>();
late final _CBoolRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CBoolRouteLongAttribute)>>('CBoolRouteLongAttribute_size');
late final _CBoolRouteLongAttribute_size = _CBoolRouteLongAttribute_sizePtr.asFunction<int Function(_CBoolRouteLongAttribute)>();
late final _CBoolRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CBoolRouteLongAttribute)>>('CBoolRouteLongAttribute_isEmpty');
late final _CBoolRouteLongAttribute_isEmpty = _CBoolRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CBoolRouteLongAttribute)>();
late final _CBoolRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CBoolRouteLongEntry Function(_CBoolRouteLongAttribute)>>('CBoolRouteLongAttribute_first');
late final _CBoolRouteLongAttribute_first = _CBoolRouteLongAttribute_firstPtr.asFunction<_COptional_CBoolRouteLongEntry Function(_CBoolRouteLongAttribute)>();
late final _CBoolRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CBoolRouteLongEntry Function(_CBoolRouteLongAttribute)>>('CBoolRouteLongAttribute_last');
late final _CBoolRouteLongAttribute_last = _CBoolRouteLongAttribute_lastPtr.asFunction<_COptional_CBoolRouteLongEntry Function(_CBoolRouteLongAttribute)>();
late final _CBoolRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CBoolRouteLongEntry Function(_CBoolRouteLongAttribute)>>('CBoolRouteLongAttribute_entries');
late final _CBoolRouteLongAttribute_entries = _CBoolRouteLongAttribute_entriesPtr.asFunction<_CArray_CBoolRouteLongEntry Function(_CBoolRouteLongAttribute)>();

late final _CBoolRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CBoolRouteLongAttribute_cg_objectIdentifier');
late final _CBoolRouteLongAttribute_cg_objectIdentifier = _CBoolRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CBoolRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CBoolRouteLongEntry Function(_CBoolRouteLongAttribute, _CRoutePoint)>>('CBoolRouteLongAttribute_entry_CRoutePoint');
late final _CBoolRouteLongAttribute_entry_CRoutePoint = _CBoolRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CBoolRouteLongEntry Function(_CBoolRouteLongAttribute, _CRoutePoint)>();
late final _CBoolRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CBoolRouteLongEntry Function(_CBoolRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CBoolRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CBoolRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CBoolRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CBoolRouteLongEntry Function(_CBoolRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CBoolRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CBoolRouteLongAttribute_release');
late final _CBoolRouteLongAttribute_release = _CBoolRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CBoolRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CBoolRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CBoolRouteLongAttribute_retain');
late final _CBoolRouteLongAttribute_retain = _CBoolRouteLongAttribute_retainPtr.asFunction<_CBoolRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CBoolRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBoolRouteLongAttribute Function()>>('CBoolRouteLongAttributeMakeDefault');
late final _CBoolRouteLongAttributeMakeDefault = _CBoolRouteLongAttributeMakeDefaultPtr.asFunction<_CBoolRouteLongAttribute Function()>();


late final _CBoolRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBoolRouteLongEntry Function()>>('CBoolRouteLongEntryMakeDefault');
late final _CBoolRouteLongEntryMakeDefault = _CBoolRouteLongEntryMakeDefaultPtr.asFunction<_CBoolRouteLongEntry Function()>();


late final _COptional_CBoolRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CBoolRouteLongEntry Function()>>('COptional_CBoolRouteLongEntryMakeDefault');
late final _COptional_CBoolRouteLongEntryMakeDefault = _COptional_CBoolRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CBoolRouteLongEntry Function()>();

late final _CArray_CBoolRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CBoolRouteLongEntry Function()>>('CArray_CBoolRouteLongEntry_makeEmpty');
late final _CArray_CBoolRouteLongEntrymakeEmpty = _CArray_CBoolRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CBoolRouteLongEntry Function()>();
late final _CArray_CBoolRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CBoolRouteLongEntry, _CBoolRouteLongEntry)>>('CArray_CBoolRouteLongEntry_addElement');
late final _CArray_CBoolRouteLongEntryaddElement = _CArray_CBoolRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CBoolRouteLongEntry, _CBoolRouteLongEntry)>();
late final _forEach_CArray_CBoolRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CBoolRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CBoolRouteLongEntry)>>)
>>('CArray_CBoolRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CBoolRouteLongEntry = _forEach_CArray_CBoolRouteLongEntryPtr.asFunction<
  void Function(_CArray_CBoolRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CBoolRouteLongEntry)
>>)>();
late final _CArray_CBoolRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CBoolRouteLongEntry)>>('CArray_CBoolRouteLongEntry_release');
late final _CArray_CBoolRouteLongEntry_release = _CArray_CBoolRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CBoolRouteLongEntry)>();
late final _CObstacleInfoRouteAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CObstacleInfoRouteAttribute)>>('CObstacleInfoRouteAttribute_size');
late final _CObstacleInfoRouteAttribute_size = _CObstacleInfoRouteAttribute_sizePtr.asFunction<int Function(_CObstacleInfoRouteAttribute)>();
late final _CObstacleInfoRouteAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CObstacleInfoRouteAttribute)>>('CObstacleInfoRouteAttribute_isEmpty');
late final _CObstacleInfoRouteAttribute_isEmpty = _CObstacleInfoRouteAttribute_isEmptyPtr.asFunction<bool Function(_CObstacleInfoRouteAttribute)>();
late final _CObstacleInfoRouteAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CObstacleInfoRouteEntry Function(_CObstacleInfoRouteAttribute)>>('CObstacleInfoRouteAttribute_first');
late final _CObstacleInfoRouteAttribute_first = _CObstacleInfoRouteAttribute_firstPtr.asFunction<_COptional_CObstacleInfoRouteEntry Function(_CObstacleInfoRouteAttribute)>();
late final _CObstacleInfoRouteAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CObstacleInfoRouteEntry Function(_CObstacleInfoRouteAttribute)>>('CObstacleInfoRouteAttribute_last');
late final _CObstacleInfoRouteAttribute_last = _CObstacleInfoRouteAttribute_lastPtr.asFunction<_COptional_CObstacleInfoRouteEntry Function(_CObstacleInfoRouteAttribute)>();
late final _CObstacleInfoRouteAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CObstacleInfoRouteEntry Function(_CObstacleInfoRouteAttribute)>>('CObstacleInfoRouteAttribute_entries');
late final _CObstacleInfoRouteAttribute_entries = _CObstacleInfoRouteAttribute_entriesPtr.asFunction<_CArray_CObstacleInfoRouteEntry Function(_CObstacleInfoRouteAttribute)>();

late final _CObstacleInfoRouteAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CObstacleInfoRouteAttribute_cg_objectIdentifier');
late final _CObstacleInfoRouteAttribute_cg_objectIdentifier = _CObstacleInfoRouteAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CObstacleInfoRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CObstacleInfoRouteEntry Function(_CObstacleInfoRouteAttribute, _CRoutePoint, _CRoutePoint)>>('CObstacleInfoRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CObstacleInfoRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CObstacleInfoRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CObstacleInfoRouteEntry Function(_CObstacleInfoRouteAttribute, _CRoutePoint, _CRoutePoint)>();
late final _CObstacleInfoRouteAttribute_findNearBackward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CObstacleInfoRouteEntry Function(_CObstacleInfoRouteAttribute, _CRoutePoint)>>('CObstacleInfoRouteAttribute_findNearBackward_CRoutePoint');
late final _CObstacleInfoRouteAttribute_findNearBackward_CRoutePoint = _CObstacleInfoRouteAttribute_findNearBackward_CRoutePointPtr.asFunction<_COptional_CObstacleInfoRouteEntry Function(_CObstacleInfoRouteAttribute, _CRoutePoint)>();
late final _CObstacleInfoRouteAttribute_findNearForward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CObstacleInfoRouteEntry Function(_CObstacleInfoRouteAttribute, _CRoutePoint)>>('CObstacleInfoRouteAttribute_findNearForward_CRoutePoint');
late final _CObstacleInfoRouteAttribute_findNearForward_CRoutePoint = _CObstacleInfoRouteAttribute_findNearForward_CRoutePointPtr.asFunction<_COptional_CObstacleInfoRouteEntry Function(_CObstacleInfoRouteAttribute, _CRoutePoint)>();

late final _CObstacleInfoRouteAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CObstacleInfoRouteAttribute_release');
late final _CObstacleInfoRouteAttribute_release = _CObstacleInfoRouteAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CObstacleInfoRouteAttribute_retainPtr = _lookup<ffi.NativeFunction<_CObstacleInfoRouteAttribute Function(ffi.Pointer<ffi.Void>)>>('CObstacleInfoRouteAttribute_retain');
late final _CObstacleInfoRouteAttribute_retain = _CObstacleInfoRouteAttribute_retainPtr.asFunction<_CObstacleInfoRouteAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CObstacleInfoRouteAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CObstacleInfoRouteAttribute Function()>>('CObstacleInfoRouteAttributeMakeDefault');
late final _CObstacleInfoRouteAttributeMakeDefault = _CObstacleInfoRouteAttributeMakeDefaultPtr.asFunction<_CObstacleInfoRouteAttribute Function()>();


late final _CObstacleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CObstacle Function()>>('CObstacleMakeDefault');
late final _CObstacleMakeDefault = _CObstacleMakeDefaultPtr.asFunction<_CObstacle Function()>();

late final _CObstaclePassLimitationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CObstaclePassLimitation Function()>>('CObstaclePassLimitationMakeDefault');
late final _CObstaclePassLimitationMakeDefault = _CObstaclePassLimitationMakeDefaultPtr.asFunction<_CObstaclePassLimitation Function()>();

late final _CObstacleInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CObstacleInfo Function()>>('CObstacleInfoMakeDefault');
late final _CObstacleInfoMakeDefault = _CObstacleInfoMakeDefaultPtr.asFunction<_CObstacleInfo Function()>();


late final _CObstacleInfoRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CObstacleInfoRouteEntry Function()>>('CObstacleInfoRouteEntryMakeDefault');
late final _CObstacleInfoRouteEntryMakeDefault = _CObstacleInfoRouteEntryMakeDefaultPtr.asFunction<_CObstacleInfoRouteEntry Function()>();


late final _COptional_CObstacleInfoRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CObstacleInfoRouteEntry Function()>>('COptional_CObstacleInfoRouteEntryMakeDefault');
late final _COptional_CObstacleInfoRouteEntryMakeDefault = _COptional_CObstacleInfoRouteEntryMakeDefaultPtr.asFunction<_COptional_CObstacleInfoRouteEntry Function()>();

late final _CArray_CObstacleInfoRouteEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CObstacleInfoRouteEntry Function()>>('CArray_CObstacleInfoRouteEntry_makeEmpty');
late final _CArray_CObstacleInfoRouteEntrymakeEmpty = _CArray_CObstacleInfoRouteEntrymakeEmptyPtr.asFunction<_CArray_CObstacleInfoRouteEntry Function()>();
late final _CArray_CObstacleInfoRouteEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CObstacleInfoRouteEntry, _CObstacleInfoRouteEntry)>>('CArray_CObstacleInfoRouteEntry_addElement');
late final _CArray_CObstacleInfoRouteEntryaddElement = _CArray_CObstacleInfoRouteEntryaddElementPtr.asFunction<void Function(_CArray_CObstacleInfoRouteEntry, _CObstacleInfoRouteEntry)>();
late final _forEach_CArray_CObstacleInfoRouteEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CObstacleInfoRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CObstacleInfoRouteEntry)>>)
>>('CArray_CObstacleInfoRouteEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CObstacleInfoRouteEntry = _forEach_CArray_CObstacleInfoRouteEntryPtr.asFunction<
  void Function(_CArray_CObstacleInfoRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CObstacleInfoRouteEntry)
>>)>();
late final _CArray_CObstacleInfoRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CObstacleInfoRouteEntry)>>('CArray_CObstacleInfoRouteEntry_release');
late final _CArray_CObstacleInfoRouteEntry_release = _CArray_CObstacleInfoRouteEntry_releasePtr.asFunction<void Function(_CArray_CObstacleInfoRouteEntry)>();
late final _CStringRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CStringRouteLongAttribute)>>('CStringRouteLongAttribute_size');
late final _CStringRouteLongAttribute_size = _CStringRouteLongAttribute_sizePtr.asFunction<int Function(_CStringRouteLongAttribute)>();
late final _CStringRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CStringRouteLongAttribute)>>('CStringRouteLongAttribute_isEmpty');
late final _CStringRouteLongAttribute_isEmpty = _CStringRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CStringRouteLongAttribute)>();
late final _CStringRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CStringRouteLongEntry Function(_CStringRouteLongAttribute)>>('CStringRouteLongAttribute_first');
late final _CStringRouteLongAttribute_first = _CStringRouteLongAttribute_firstPtr.asFunction<_COptional_CStringRouteLongEntry Function(_CStringRouteLongAttribute)>();
late final _CStringRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CStringRouteLongEntry Function(_CStringRouteLongAttribute)>>('CStringRouteLongAttribute_last');
late final _CStringRouteLongAttribute_last = _CStringRouteLongAttribute_lastPtr.asFunction<_COptional_CStringRouteLongEntry Function(_CStringRouteLongAttribute)>();
late final _CStringRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CStringRouteLongEntry Function(_CStringRouteLongAttribute)>>('CStringRouteLongAttribute_entries');
late final _CStringRouteLongAttribute_entries = _CStringRouteLongAttribute_entriesPtr.asFunction<_CArray_CStringRouteLongEntry Function(_CStringRouteLongAttribute)>();

late final _CStringRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CStringRouteLongAttribute_cg_objectIdentifier');
late final _CStringRouteLongAttribute_cg_objectIdentifier = _CStringRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CStringRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CStringRouteLongEntry Function(_CStringRouteLongAttribute, _CRoutePoint)>>('CStringRouteLongAttribute_entry_CRoutePoint');
late final _CStringRouteLongAttribute_entry_CRoutePoint = _CStringRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CStringRouteLongEntry Function(_CStringRouteLongAttribute, _CRoutePoint)>();
late final _CStringRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CStringRouteLongEntry Function(_CStringRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CStringRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CStringRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CStringRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CStringRouteLongEntry Function(_CStringRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CStringRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CStringRouteLongAttribute_release');
late final _CStringRouteLongAttribute_release = _CStringRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CStringRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CStringRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CStringRouteLongAttribute_retain');
late final _CStringRouteLongAttribute_retain = _CStringRouteLongAttribute_retainPtr.asFunction<_CStringRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CStringRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStringRouteLongAttribute Function()>>('CStringRouteLongAttributeMakeDefault');
late final _CStringRouteLongAttributeMakeDefault = _CStringRouteLongAttributeMakeDefaultPtr.asFunction<_CStringRouteLongAttribute Function()>();


late final _CStringRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStringRouteLongEntry Function()>>('CStringRouteLongEntryMakeDefault');
late final _CStringRouteLongEntryMakeDefault = _CStringRouteLongEntryMakeDefaultPtr.asFunction<_CStringRouteLongEntry Function()>();


late final _COptional_CStringRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CStringRouteLongEntry Function()>>('COptional_CStringRouteLongEntryMakeDefault');
late final _COptional_CStringRouteLongEntryMakeDefault = _COptional_CStringRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CStringRouteLongEntry Function()>();

late final _COptional_CStringRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CStringRouteLongEntry)>>('COptional_CStringRouteLongEntry_release');
late final _COptional_CStringRouteLongEntry_release = _COptional_CStringRouteLongEntry_releasePtr.asFunction<void Function(_COptional_CStringRouteLongEntry)>();

late final _CArray_CStringRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CStringRouteLongEntry Function()>>('CArray_CStringRouteLongEntry_makeEmpty');
late final _CArray_CStringRouteLongEntrymakeEmpty = _CArray_CStringRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CStringRouteLongEntry Function()>();
late final _CArray_CStringRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CStringRouteLongEntry, _CStringRouteLongEntry)>>('CArray_CStringRouteLongEntry_addElement');
late final _CArray_CStringRouteLongEntryaddElement = _CArray_CStringRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CStringRouteLongEntry, _CStringRouteLongEntry)>();
late final _forEach_CArray_CStringRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CStringRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStringRouteLongEntry)>>)
>>('CArray_CStringRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CStringRouteLongEntry = _forEach_CArray_CStringRouteLongEntryPtr.asFunction<
  void Function(_CArray_CStringRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStringRouteLongEntry)
>>)>();
late final _CArray_CStringRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CStringRouteLongEntry)>>('CArray_CStringRouteLongEntry_release');
late final _CArray_CStringRouteLongEntry_release = _CArray_CStringRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CStringRouteLongEntry)>();
late final _CSettlementRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CSettlementRouteLongAttribute)>>('CSettlementRouteLongAttribute_size');
late final _CSettlementRouteLongAttribute_size = _CSettlementRouteLongAttribute_sizePtr.asFunction<int Function(_CSettlementRouteLongAttribute)>();
late final _CSettlementRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CSettlementRouteLongAttribute)>>('CSettlementRouteLongAttribute_isEmpty');
late final _CSettlementRouteLongAttribute_isEmpty = _CSettlementRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CSettlementRouteLongAttribute)>();
late final _CSettlementRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CSettlementRouteLongEntry Function(_CSettlementRouteLongAttribute)>>('CSettlementRouteLongAttribute_first');
late final _CSettlementRouteLongAttribute_first = _CSettlementRouteLongAttribute_firstPtr.asFunction<_COptional_CSettlementRouteLongEntry Function(_CSettlementRouteLongAttribute)>();
late final _CSettlementRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CSettlementRouteLongEntry Function(_CSettlementRouteLongAttribute)>>('CSettlementRouteLongAttribute_last');
late final _CSettlementRouteLongAttribute_last = _CSettlementRouteLongAttribute_lastPtr.asFunction<_COptional_CSettlementRouteLongEntry Function(_CSettlementRouteLongAttribute)>();
late final _CSettlementRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CSettlementRouteLongEntry Function(_CSettlementRouteLongAttribute)>>('CSettlementRouteLongAttribute_entries');
late final _CSettlementRouteLongAttribute_entries = _CSettlementRouteLongAttribute_entriesPtr.asFunction<_CArray_CSettlementRouteLongEntry Function(_CSettlementRouteLongAttribute)>();

late final _CSettlementRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSettlementRouteLongAttribute_cg_objectIdentifier');
late final _CSettlementRouteLongAttribute_cg_objectIdentifier = _CSettlementRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSettlementRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CSettlementRouteLongEntry Function(_CSettlementRouteLongAttribute, _CRoutePoint)>>('CSettlementRouteLongAttribute_entry_CRoutePoint');
late final _CSettlementRouteLongAttribute_entry_CRoutePoint = _CSettlementRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CSettlementRouteLongEntry Function(_CSettlementRouteLongAttribute, _CRoutePoint)>();
late final _CSettlementRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CSettlementRouteLongEntry Function(_CSettlementRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CSettlementRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CSettlementRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CSettlementRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CSettlementRouteLongEntry Function(_CSettlementRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CSettlementRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSettlementRouteLongAttribute_release');
late final _CSettlementRouteLongAttribute_release = _CSettlementRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSettlementRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CSettlementRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CSettlementRouteLongAttribute_retain');
late final _CSettlementRouteLongAttribute_retain = _CSettlementRouteLongAttribute_retainPtr.asFunction<_CSettlementRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CSettlementRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSettlementRouteLongAttribute Function()>>('CSettlementRouteLongAttributeMakeDefault');
late final _CSettlementRouteLongAttributeMakeDefault = _CSettlementRouteLongAttributeMakeDefaultPtr.asFunction<_CSettlementRouteLongAttribute Function()>();


late final _CSettlementMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSettlement Function()>>('CSettlementMakeDefault');
late final _CSettlementMakeDefault = _CSettlementMakeDefaultPtr.asFunction<_CSettlement Function()>();

late final _CSettlementRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSettlementRouteLongEntry Function()>>('CSettlementRouteLongEntryMakeDefault');
late final _CSettlementRouteLongEntryMakeDefault = _CSettlementRouteLongEntryMakeDefaultPtr.asFunction<_CSettlementRouteLongEntry Function()>();


late final _COptional_CSettlementRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CSettlementRouteLongEntry Function()>>('COptional_CSettlementRouteLongEntryMakeDefault');
late final _COptional_CSettlementRouteLongEntryMakeDefault = _COptional_CSettlementRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CSettlementRouteLongEntry Function()>();

late final _CArray_CSettlementRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSettlementRouteLongEntry Function()>>('CArray_CSettlementRouteLongEntry_makeEmpty');
late final _CArray_CSettlementRouteLongEntrymakeEmpty = _CArray_CSettlementRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CSettlementRouteLongEntry Function()>();
late final _CArray_CSettlementRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSettlementRouteLongEntry, _CSettlementRouteLongEntry)>>('CArray_CSettlementRouteLongEntry_addElement');
late final _CArray_CSettlementRouteLongEntryaddElement = _CArray_CSettlementRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CSettlementRouteLongEntry, _CSettlementRouteLongEntry)>();
late final _forEach_CArray_CSettlementRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSettlementRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSettlementRouteLongEntry)>>)
>>('CArray_CSettlementRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CSettlementRouteLongEntry = _forEach_CArray_CSettlementRouteLongEntryPtr.asFunction<
  void Function(_CArray_CSettlementRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSettlementRouteLongEntry)
>>)>();
late final _CArray_CSettlementRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSettlementRouteLongEntry)>>('CArray_CSettlementRouteLongEntry_release');
late final _CArray_CSettlementRouteLongEntry_release = _CArray_CSettlementRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CSettlementRouteLongEntry)>();
late final _CTransportTypeRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CTransportTypeRouteLongAttribute)>>('CTransportTypeRouteLongAttribute_size');
late final _CTransportTypeRouteLongAttribute_size = _CTransportTypeRouteLongAttribute_sizePtr.asFunction<int Function(_CTransportTypeRouteLongAttribute)>();
late final _CTransportTypeRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CTransportTypeRouteLongAttribute)>>('CTransportTypeRouteLongAttribute_isEmpty');
late final _CTransportTypeRouteLongAttribute_isEmpty = _CTransportTypeRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CTransportTypeRouteLongAttribute)>();
late final _CTransportTypeRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CTransportTypeRouteLongEntry Function(_CTransportTypeRouteLongAttribute)>>('CTransportTypeRouteLongAttribute_first');
late final _CTransportTypeRouteLongAttribute_first = _CTransportTypeRouteLongAttribute_firstPtr.asFunction<_COptional_CTransportTypeRouteLongEntry Function(_CTransportTypeRouteLongAttribute)>();
late final _CTransportTypeRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CTransportTypeRouteLongEntry Function(_CTransportTypeRouteLongAttribute)>>('CTransportTypeRouteLongAttribute_last');
late final _CTransportTypeRouteLongAttribute_last = _CTransportTypeRouteLongAttribute_lastPtr.asFunction<_COptional_CTransportTypeRouteLongEntry Function(_CTransportTypeRouteLongAttribute)>();
late final _CTransportTypeRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CTransportTypeRouteLongEntry Function(_CTransportTypeRouteLongAttribute)>>('CTransportTypeRouteLongAttribute_entries');
late final _CTransportTypeRouteLongAttribute_entries = _CTransportTypeRouteLongAttribute_entriesPtr.asFunction<_CArray_CTransportTypeRouteLongEntry Function(_CTransportTypeRouteLongAttribute)>();

late final _CTransportTypeRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTransportTypeRouteLongAttribute_cg_objectIdentifier');
late final _CTransportTypeRouteLongAttribute_cg_objectIdentifier = _CTransportTypeRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTransportTypeRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CTransportTypeRouteLongEntry Function(_CTransportTypeRouteLongAttribute, _CRoutePoint)>>('CTransportTypeRouteLongAttribute_entry_CRoutePoint');
late final _CTransportTypeRouteLongAttribute_entry_CRoutePoint = _CTransportTypeRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CTransportTypeRouteLongEntry Function(_CTransportTypeRouteLongAttribute, _CRoutePoint)>();
late final _CTransportTypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CTransportTypeRouteLongEntry Function(_CTransportTypeRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CTransportTypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CTransportTypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CTransportTypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CTransportTypeRouteLongEntry Function(_CTransportTypeRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CTransportTypeRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTransportTypeRouteLongAttribute_release');
late final _CTransportTypeRouteLongAttribute_release = _CTransportTypeRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTransportTypeRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CTransportTypeRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CTransportTypeRouteLongAttribute_retain');
late final _CTransportTypeRouteLongAttribute_retain = _CTransportTypeRouteLongAttribute_retainPtr.asFunction<_CTransportTypeRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CTransportTypeRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTransportTypeRouteLongAttribute Function()>>('CTransportTypeRouteLongAttributeMakeDefault');
late final _CTransportTypeRouteLongAttributeMakeDefault = _CTransportTypeRouteLongAttributeMakeDefaultPtr.asFunction<_CTransportTypeRouteLongAttribute Function()>();


late final _CTransportTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTransportType Function()>>('CTransportTypeMakeDefault');
late final _CTransportTypeMakeDefault = _CTransportTypeMakeDefaultPtr.asFunction<_CTransportType Function()>();

late final _CTransportTypeRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTransportTypeRouteLongEntry Function()>>('CTransportTypeRouteLongEntryMakeDefault');
late final _CTransportTypeRouteLongEntryMakeDefault = _CTransportTypeRouteLongEntryMakeDefaultPtr.asFunction<_CTransportTypeRouteLongEntry Function()>();


late final _COptional_CTransportTypeRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CTransportTypeRouteLongEntry Function()>>('COptional_CTransportTypeRouteLongEntryMakeDefault');
late final _COptional_CTransportTypeRouteLongEntryMakeDefault = _COptional_CTransportTypeRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CTransportTypeRouteLongEntry Function()>();

late final _CArray_CTransportTypeRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CTransportTypeRouteLongEntry Function()>>('CArray_CTransportTypeRouteLongEntry_makeEmpty');
late final _CArray_CTransportTypeRouteLongEntrymakeEmpty = _CArray_CTransportTypeRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CTransportTypeRouteLongEntry Function()>();
late final _CArray_CTransportTypeRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CTransportTypeRouteLongEntry, _CTransportTypeRouteLongEntry)>>('CArray_CTransportTypeRouteLongEntry_addElement');
late final _CArray_CTransportTypeRouteLongEntryaddElement = _CArray_CTransportTypeRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CTransportTypeRouteLongEntry, _CTransportTypeRouteLongEntry)>();
late final _forEach_CArray_CTransportTypeRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CTransportTypeRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTransportTypeRouteLongEntry)>>)
>>('CArray_CTransportTypeRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CTransportTypeRouteLongEntry = _forEach_CArray_CTransportTypeRouteLongEntryPtr.asFunction<
  void Function(_CArray_CTransportTypeRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTransportTypeRouteLongEntry)
>>)>();
late final _CArray_CTransportTypeRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CTransportTypeRouteLongEntry)>>('CArray_CTransportTypeRouteLongEntry_release');
late final _CArray_CTransportTypeRouteLongEntry_release = _CArray_CTransportTypeRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CTransportTypeRouteLongEntry)>();
late final _CCameraRouteAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CCameraRouteAttribute)>>('CCameraRouteAttribute_size');
late final _CCameraRouteAttribute_size = _CCameraRouteAttribute_sizePtr.asFunction<int Function(_CCameraRouteAttribute)>();
late final _CCameraRouteAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CCameraRouteAttribute)>>('CCameraRouteAttribute_isEmpty');
late final _CCameraRouteAttribute_isEmpty = _CCameraRouteAttribute_isEmptyPtr.asFunction<bool Function(_CCameraRouteAttribute)>();
late final _CCameraRouteAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CCameraRouteEntry Function(_CCameraRouteAttribute)>>('CCameraRouteAttribute_first');
late final _CCameraRouteAttribute_first = _CCameraRouteAttribute_firstPtr.asFunction<_COptional_CCameraRouteEntry Function(_CCameraRouteAttribute)>();
late final _CCameraRouteAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CCameraRouteEntry Function(_CCameraRouteAttribute)>>('CCameraRouteAttribute_last');
late final _CCameraRouteAttribute_last = _CCameraRouteAttribute_lastPtr.asFunction<_COptional_CCameraRouteEntry Function(_CCameraRouteAttribute)>();
late final _CCameraRouteAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CCameraRouteEntry Function(_CCameraRouteAttribute)>>('CCameraRouteAttribute_entries');
late final _CCameraRouteAttribute_entries = _CCameraRouteAttribute_entriesPtr.asFunction<_CArray_CCameraRouteEntry Function(_CCameraRouteAttribute)>();

late final _CCameraRouteAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCameraRouteAttribute_cg_objectIdentifier');
late final _CCameraRouteAttribute_cg_objectIdentifier = _CCameraRouteAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCameraRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CCameraRouteEntry Function(_CCameraRouteAttribute, _CRoutePoint, _CRoutePoint)>>('CCameraRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CCameraRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CCameraRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CCameraRouteEntry Function(_CCameraRouteAttribute, _CRoutePoint, _CRoutePoint)>();
late final _CCameraRouteAttribute_findNearBackward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CCameraRouteEntry Function(_CCameraRouteAttribute, _CRoutePoint)>>('CCameraRouteAttribute_findNearBackward_CRoutePoint');
late final _CCameraRouteAttribute_findNearBackward_CRoutePoint = _CCameraRouteAttribute_findNearBackward_CRoutePointPtr.asFunction<_COptional_CCameraRouteEntry Function(_CCameraRouteAttribute, _CRoutePoint)>();
late final _CCameraRouteAttribute_findNearForward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CCameraRouteEntry Function(_CCameraRouteAttribute, _CRoutePoint)>>('CCameraRouteAttribute_findNearForward_CRoutePoint');
late final _CCameraRouteAttribute_findNearForward_CRoutePoint = _CCameraRouteAttribute_findNearForward_CRoutePointPtr.asFunction<_COptional_CCameraRouteEntry Function(_CCameraRouteAttribute, _CRoutePoint)>();

late final _CCameraRouteAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCameraRouteAttribute_release');
late final _CCameraRouteAttribute_release = _CCameraRouteAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCameraRouteAttribute_retainPtr = _lookup<ffi.NativeFunction<_CCameraRouteAttribute Function(ffi.Pointer<ffi.Void>)>>('CCameraRouteAttribute_retain');
late final _CCameraRouteAttribute_retain = _CCameraRouteAttribute_retainPtr.asFunction<_CCameraRouteAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CCameraRouteAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraRouteAttribute Function()>>('CCameraRouteAttributeMakeDefault');
late final _CCameraRouteAttributeMakeDefault = _CCameraRouteAttributeMakeDefaultPtr.asFunction<_CCameraRouteAttribute Function()>();


late final _CRouteCameraPurposeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteCameraPurpose Function()>>('CRouteCameraPurposeMakeDefault');
late final _CRouteCameraPurposeMakeDefault = _CRouteCameraPurposeMakeDefaultPtr.asFunction<_CRouteCameraPurpose Function()>();

late final _COptionSet_CRouteCameraPurposeMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CRouteCameraPurpose Function()>>('COptionSet_CRouteCameraPurposeMakeDefault');
late final _COptionSet_CRouteCameraPurposeMakeDefault = _COptionSet_CRouteCameraPurposeMakeDefaultPtr.asFunction<_COptionSet_CRouteCameraPurpose Function()>();

late final _CRouteCameraDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteCameraDirection Function()>>('CRouteCameraDirectionMakeDefault');
late final _CRouteCameraDirectionMakeDefault = _CRouteCameraDirectionMakeDefaultPtr.asFunction<_CRouteCameraDirection Function()>();

late final _CRouteCameraMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteCamera Function()>>('CRouteCameraMakeDefault');
late final _CRouteCameraMakeDefault = _CRouteCameraMakeDefaultPtr.asFunction<_CRouteCamera Function()>();


late final _CCameraRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraRouteEntry Function()>>('CCameraRouteEntryMakeDefault');
late final _CCameraRouteEntryMakeDefault = _CCameraRouteEntryMakeDefaultPtr.asFunction<_CCameraRouteEntry Function()>();


late final _COptional_CCameraRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CCameraRouteEntry Function()>>('COptional_CCameraRouteEntryMakeDefault');
late final _COptional_CCameraRouteEntryMakeDefault = _COptional_CCameraRouteEntryMakeDefaultPtr.asFunction<_COptional_CCameraRouteEntry Function()>();

late final _CArray_CCameraRouteEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CCameraRouteEntry Function()>>('CArray_CCameraRouteEntry_makeEmpty');
late final _CArray_CCameraRouteEntrymakeEmpty = _CArray_CCameraRouteEntrymakeEmptyPtr.asFunction<_CArray_CCameraRouteEntry Function()>();
late final _CArray_CCameraRouteEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CCameraRouteEntry, _CCameraRouteEntry)>>('CArray_CCameraRouteEntry_addElement');
late final _CArray_CCameraRouteEntryaddElement = _CArray_CCameraRouteEntryaddElementPtr.asFunction<void Function(_CArray_CCameraRouteEntry, _CCameraRouteEntry)>();
late final _forEach_CArray_CCameraRouteEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CCameraRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraRouteEntry)>>)
>>('CArray_CCameraRouteEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CCameraRouteEntry = _forEach_CArray_CCameraRouteEntryPtr.asFunction<
  void Function(_CArray_CCameraRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraRouteEntry)
>>)>();
late final _CArray_CCameraRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CCameraRouteEntry)>>('CArray_CCameraRouteEntry_release');
late final _CArray_CCameraRouteEntry_release = _CArray_CCameraRouteEntry_releasePtr.asFunction<void Function(_CArray_CCameraRouteEntry)>();
late final _CUIntRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CUIntRouteLongAttribute)>>('CUIntRouteLongAttribute_size');
late final _CUIntRouteLongAttribute_size = _CUIntRouteLongAttribute_sizePtr.asFunction<int Function(_CUIntRouteLongAttribute)>();
late final _CUIntRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CUIntRouteLongAttribute)>>('CUIntRouteLongAttribute_isEmpty');
late final _CUIntRouteLongAttribute_isEmpty = _CUIntRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CUIntRouteLongAttribute)>();
late final _CUIntRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CUIntRouteLongEntry Function(_CUIntRouteLongAttribute)>>('CUIntRouteLongAttribute_first');
late final _CUIntRouteLongAttribute_first = _CUIntRouteLongAttribute_firstPtr.asFunction<_COptional_CUIntRouteLongEntry Function(_CUIntRouteLongAttribute)>();
late final _CUIntRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CUIntRouteLongEntry Function(_CUIntRouteLongAttribute)>>('CUIntRouteLongAttribute_last');
late final _CUIntRouteLongAttribute_last = _CUIntRouteLongAttribute_lastPtr.asFunction<_COptional_CUIntRouteLongEntry Function(_CUIntRouteLongAttribute)>();
late final _CUIntRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CUIntRouteLongEntry Function(_CUIntRouteLongAttribute)>>('CUIntRouteLongAttribute_entries');
late final _CUIntRouteLongAttribute_entries = _CUIntRouteLongAttribute_entriesPtr.asFunction<_CArray_CUIntRouteLongEntry Function(_CUIntRouteLongAttribute)>();

late final _CUIntRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CUIntRouteLongAttribute_cg_objectIdentifier');
late final _CUIntRouteLongAttribute_cg_objectIdentifier = _CUIntRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CUIntRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CUIntRouteLongEntry Function(_CUIntRouteLongAttribute, _CRoutePoint)>>('CUIntRouteLongAttribute_entry_CRoutePoint');
late final _CUIntRouteLongAttribute_entry_CRoutePoint = _CUIntRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CUIntRouteLongEntry Function(_CUIntRouteLongAttribute, _CRoutePoint)>();
late final _CUIntRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CUIntRouteLongEntry Function(_CUIntRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CUIntRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CUIntRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CUIntRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CUIntRouteLongEntry Function(_CUIntRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CUIntRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CUIntRouteLongAttribute_release');
late final _CUIntRouteLongAttribute_release = _CUIntRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CUIntRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CUIntRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CUIntRouteLongAttribute_retain');
late final _CUIntRouteLongAttribute_retain = _CUIntRouteLongAttribute_retainPtr.asFunction<_CUIntRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CUIntRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CUIntRouteLongAttribute Function()>>('CUIntRouteLongAttributeMakeDefault');
late final _CUIntRouteLongAttributeMakeDefault = _CUIntRouteLongAttributeMakeDefaultPtr.asFunction<_CUIntRouteLongAttribute Function()>();


late final _CUIntRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CUIntRouteLongEntry Function()>>('CUIntRouteLongEntryMakeDefault');
late final _CUIntRouteLongEntryMakeDefault = _CUIntRouteLongEntryMakeDefaultPtr.asFunction<_CUIntRouteLongEntry Function()>();


late final _COptional_CUIntRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CUIntRouteLongEntry Function()>>('COptional_CUIntRouteLongEntryMakeDefault');
late final _COptional_CUIntRouteLongEntryMakeDefault = _COptional_CUIntRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CUIntRouteLongEntry Function()>();

late final _CArray_CUIntRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CUIntRouteLongEntry Function()>>('CArray_CUIntRouteLongEntry_makeEmpty');
late final _CArray_CUIntRouteLongEntrymakeEmpty = _CArray_CUIntRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CUIntRouteLongEntry Function()>();
late final _CArray_CUIntRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CUIntRouteLongEntry, _CUIntRouteLongEntry)>>('CArray_CUIntRouteLongEntry_addElement');
late final _CArray_CUIntRouteLongEntryaddElement = _CArray_CUIntRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CUIntRouteLongEntry, _CUIntRouteLongEntry)>();
late final _forEach_CArray_CUIntRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CUIntRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CUIntRouteLongEntry)>>)
>>('CArray_CUIntRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CUIntRouteLongEntry = _forEach_CArray_CUIntRouteLongEntryPtr.asFunction<
  void Function(_CArray_CUIntRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CUIntRouteLongEntry)
>>)>();
late final _CArray_CUIntRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CUIntRouteLongEntry)>>('CArray_CUIntRouteLongEntry_release');
late final _CArray_CUIntRouteLongEntry_release = _CArray_CUIntRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CUIntRouteLongEntry)>();
late final _CRouteExitSignRouteAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CRouteExitSignRouteAttribute)>>('CRouteExitSignRouteAttribute_size');
late final _CRouteExitSignRouteAttribute_size = _CRouteExitSignRouteAttribute_sizePtr.asFunction<int Function(_CRouteExitSignRouteAttribute)>();
late final _CRouteExitSignRouteAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CRouteExitSignRouteAttribute)>>('CRouteExitSignRouteAttribute_isEmpty');
late final _CRouteExitSignRouteAttribute_isEmpty = _CRouteExitSignRouteAttribute_isEmptyPtr.asFunction<bool Function(_CRouteExitSignRouteAttribute)>();
late final _CRouteExitSignRouteAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CRouteExitSignRouteEntry Function(_CRouteExitSignRouteAttribute)>>('CRouteExitSignRouteAttribute_first');
late final _CRouteExitSignRouteAttribute_first = _CRouteExitSignRouteAttribute_firstPtr.asFunction<_COptional_CRouteExitSignRouteEntry Function(_CRouteExitSignRouteAttribute)>();
late final _CRouteExitSignRouteAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CRouteExitSignRouteEntry Function(_CRouteExitSignRouteAttribute)>>('CRouteExitSignRouteAttribute_last');
late final _CRouteExitSignRouteAttribute_last = _CRouteExitSignRouteAttribute_lastPtr.asFunction<_COptional_CRouteExitSignRouteEntry Function(_CRouteExitSignRouteAttribute)>();
late final _CRouteExitSignRouteAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CRouteExitSignRouteEntry Function(_CRouteExitSignRouteAttribute)>>('CRouteExitSignRouteAttribute_entries');
late final _CRouteExitSignRouteAttribute_entries = _CRouteExitSignRouteAttribute_entriesPtr.asFunction<_CArray_CRouteExitSignRouteEntry Function(_CRouteExitSignRouteAttribute)>();

late final _CRouteExitSignRouteAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRouteExitSignRouteAttribute_cg_objectIdentifier');
late final _CRouteExitSignRouteAttribute_cg_objectIdentifier = _CRouteExitSignRouteAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRouteExitSignRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CRouteExitSignRouteEntry Function(_CRouteExitSignRouteAttribute, _CRoutePoint, _CRoutePoint)>>('CRouteExitSignRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CRouteExitSignRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CRouteExitSignRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CRouteExitSignRouteEntry Function(_CRouteExitSignRouteAttribute, _CRoutePoint, _CRoutePoint)>();
late final _CRouteExitSignRouteAttribute_findNearBackward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRouteExitSignRouteEntry Function(_CRouteExitSignRouteAttribute, _CRoutePoint)>>('CRouteExitSignRouteAttribute_findNearBackward_CRoutePoint');
late final _CRouteExitSignRouteAttribute_findNearBackward_CRoutePoint = _CRouteExitSignRouteAttribute_findNearBackward_CRoutePointPtr.asFunction<_COptional_CRouteExitSignRouteEntry Function(_CRouteExitSignRouteAttribute, _CRoutePoint)>();
late final _CRouteExitSignRouteAttribute_findNearForward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRouteExitSignRouteEntry Function(_CRouteExitSignRouteAttribute, _CRoutePoint)>>('CRouteExitSignRouteAttribute_findNearForward_CRoutePoint');
late final _CRouteExitSignRouteAttribute_findNearForward_CRoutePoint = _CRouteExitSignRouteAttribute_findNearForward_CRoutePointPtr.asFunction<_COptional_CRouteExitSignRouteEntry Function(_CRouteExitSignRouteAttribute, _CRoutePoint)>();

late final _CRouteExitSignRouteAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRouteExitSignRouteAttribute_release');
late final _CRouteExitSignRouteAttribute_release = _CRouteExitSignRouteAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteExitSignRouteAttribute_retainPtr = _lookup<ffi.NativeFunction<_CRouteExitSignRouteAttribute Function(ffi.Pointer<ffi.Void>)>>('CRouteExitSignRouteAttribute_retain');
late final _CRouteExitSignRouteAttribute_retain = _CRouteExitSignRouteAttribute_retainPtr.asFunction<_CRouteExitSignRouteAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteExitSignRouteAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteExitSignRouteAttribute Function()>>('CRouteExitSignRouteAttributeMakeDefault');
late final _CRouteExitSignRouteAttributeMakeDefault = _CRouteExitSignRouteAttributeMakeDefaultPtr.asFunction<_CRouteExitSignRouteAttribute Function()>();


late final _CRouteExitSignTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteExitSignType Function()>>('CRouteExitSignTypeMakeDefault');
late final _CRouteExitSignTypeMakeDefault = _CRouteExitSignTypeMakeDefaultPtr.asFunction<_CRouteExitSignType Function()>();

late final _CRouteExitSignTableColorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteExitSignTableColor Function()>>('CRouteExitSignTableColorMakeDefault');
late final _CRouteExitSignTableColorMakeDefault = _CRouteExitSignTableColorMakeDefaultPtr.asFunction<_CRouteExitSignTableColor Function()>();

late final _CRouteExitSignTableMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteExitSignTable Function()>>('CRouteExitSignTableMakeDefault');
late final _CRouteExitSignTableMakeDefault = _CRouteExitSignTableMakeDefaultPtr.asFunction<_CRouteExitSignTable Function()>();


late final _COptional_CRouteExitSignTableMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRouteExitSignTable Function()>>('COptional_CRouteExitSignTableMakeDefault');
late final _COptional_CRouteExitSignTableMakeDefault = _COptional_CRouteExitSignTableMakeDefaultPtr.asFunction<_COptional_CRouteExitSignTable Function()>();

late final _COptional_CRouteExitSignTable_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CRouteExitSignTable)>>('COptional_CRouteExitSignTable_release');
late final _COptional_CRouteExitSignTable_release = _COptional_CRouteExitSignTable_releasePtr.asFunction<void Function(_COptional_CRouteExitSignTable)>();

late final _CRouteExitSignMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteExitSign Function()>>('CRouteExitSignMakeDefault');
late final _CRouteExitSignMakeDefault = _CRouteExitSignMakeDefaultPtr.asFunction<_CRouteExitSign Function()>();


late final _CRouteExitSignRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteExitSignRouteEntry Function()>>('CRouteExitSignRouteEntryMakeDefault');
late final _CRouteExitSignRouteEntryMakeDefault = _CRouteExitSignRouteEntryMakeDefaultPtr.asFunction<_CRouteExitSignRouteEntry Function()>();


late final _COptional_CRouteExitSignRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRouteExitSignRouteEntry Function()>>('COptional_CRouteExitSignRouteEntryMakeDefault');
late final _COptional_CRouteExitSignRouteEntryMakeDefault = _COptional_CRouteExitSignRouteEntryMakeDefaultPtr.asFunction<_COptional_CRouteExitSignRouteEntry Function()>();

late final _COptional_CRouteExitSignRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CRouteExitSignRouteEntry)>>('COptional_CRouteExitSignRouteEntry_release');
late final _COptional_CRouteExitSignRouteEntry_release = _COptional_CRouteExitSignRouteEntry_releasePtr.asFunction<void Function(_COptional_CRouteExitSignRouteEntry)>();

late final _CArray_CRouteExitSignRouteEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRouteExitSignRouteEntry Function()>>('CArray_CRouteExitSignRouteEntry_makeEmpty');
late final _CArray_CRouteExitSignRouteEntrymakeEmpty = _CArray_CRouteExitSignRouteEntrymakeEmptyPtr.asFunction<_CArray_CRouteExitSignRouteEntry Function()>();
late final _CArray_CRouteExitSignRouteEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRouteExitSignRouteEntry, _CRouteExitSignRouteEntry)>>('CArray_CRouteExitSignRouteEntry_addElement');
late final _CArray_CRouteExitSignRouteEntryaddElement = _CArray_CRouteExitSignRouteEntryaddElementPtr.asFunction<void Function(_CArray_CRouteExitSignRouteEntry, _CRouteExitSignRouteEntry)>();
late final _forEach_CArray_CRouteExitSignRouteEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRouteExitSignRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteExitSignRouteEntry)>>)
>>('CArray_CRouteExitSignRouteEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CRouteExitSignRouteEntry = _forEach_CArray_CRouteExitSignRouteEntryPtr.asFunction<
  void Function(_CArray_CRouteExitSignRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteExitSignRouteEntry)
>>)>();
late final _CArray_CRouteExitSignRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRouteExitSignRouteEntry)>>('CArray_CRouteExitSignRouteEntry_release');
late final _CArray_CRouteExitSignRouteEntry_release = _CArray_CRouteExitSignRouteEntry_releasePtr.asFunction<void Function(_CArray_CRouteExitSignRouteEntry)>();
late final _CVoidRouteAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CVoidRouteAttribute)>>('CVoidRouteAttribute_size');
late final _CVoidRouteAttribute_size = _CVoidRouteAttribute_sizePtr.asFunction<int Function(_CVoidRouteAttribute)>();
late final _CVoidRouteAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CVoidRouteAttribute)>>('CVoidRouteAttribute_isEmpty');
late final _CVoidRouteAttribute_isEmpty = _CVoidRouteAttribute_isEmptyPtr.asFunction<bool Function(_CVoidRouteAttribute)>();
late final _CVoidRouteAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CRoutePoint Function(_CVoidRouteAttribute)>>('CVoidRouteAttribute_first');
late final _CVoidRouteAttribute_first = _CVoidRouteAttribute_firstPtr.asFunction<_COptional_CRoutePoint Function(_CVoidRouteAttribute)>();
late final _CVoidRouteAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CRoutePoint Function(_CVoidRouteAttribute)>>('CVoidRouteAttribute_last');
late final _CVoidRouteAttribute_last = _CVoidRouteAttribute_lastPtr.asFunction<_COptional_CRoutePoint Function(_CVoidRouteAttribute)>();
late final _CVoidRouteAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CRoutePoint Function(_CVoidRouteAttribute)>>('CVoidRouteAttribute_entries');
late final _CVoidRouteAttribute_entries = _CVoidRouteAttribute_entriesPtr.asFunction<_CArray_CRoutePoint Function(_CVoidRouteAttribute)>();

late final _CVoidRouteAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CVoidRouteAttribute_cg_objectIdentifier');
late final _CVoidRouteAttribute_cg_objectIdentifier = _CVoidRouteAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CVoidRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CRoutePoint Function(_CVoidRouteAttribute, _CRoutePoint, _CRoutePoint)>>('CVoidRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CVoidRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CVoidRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CRoutePoint Function(_CVoidRouteAttribute, _CRoutePoint, _CRoutePoint)>();
late final _CVoidRouteAttribute_findNearBackward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRoutePoint Function(_CVoidRouteAttribute, _CRoutePoint)>>('CVoidRouteAttribute_findNearBackward_CRoutePoint');
late final _CVoidRouteAttribute_findNearBackward_CRoutePoint = _CVoidRouteAttribute_findNearBackward_CRoutePointPtr.asFunction<_COptional_CRoutePoint Function(_CVoidRouteAttribute, _CRoutePoint)>();
late final _CVoidRouteAttribute_findNearForward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRoutePoint Function(_CVoidRouteAttribute, _CRoutePoint)>>('CVoidRouteAttribute_findNearForward_CRoutePoint');
late final _CVoidRouteAttribute_findNearForward_CRoutePoint = _CVoidRouteAttribute_findNearForward_CRoutePointPtr.asFunction<_COptional_CRoutePoint Function(_CVoidRouteAttribute, _CRoutePoint)>();

late final _CVoidRouteAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CVoidRouteAttribute_release');
late final _CVoidRouteAttribute_release = _CVoidRouteAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CVoidRouteAttribute_retainPtr = _lookup<ffi.NativeFunction<_CVoidRouteAttribute Function(ffi.Pointer<ffi.Void>)>>('CVoidRouteAttribute_retain');
late final _CVoidRouteAttribute_retain = _CVoidRouteAttribute_retainPtr.asFunction<_CVoidRouteAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CVoidRouteAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CVoidRouteAttribute Function()>>('CVoidRouteAttributeMakeDefault');
late final _CVoidRouteAttributeMakeDefault = _CVoidRouteAttributeMakeDefaultPtr.asFunction<_CVoidRouteAttribute Function()>();


late final _CArray_CRoutePointmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRoutePoint Function()>>('CArray_CRoutePoint_makeEmpty');
late final _CArray_CRoutePointmakeEmpty = _CArray_CRoutePointmakeEmptyPtr.asFunction<_CArray_CRoutePoint Function()>();
late final _CArray_CRoutePointaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoutePoint, _CRoutePoint)>>('CArray_CRoutePoint_addElement');
late final _CArray_CRoutePointaddElement = _CArray_CRoutePointaddElementPtr.asFunction<void Function(_CArray_CRoutePoint, _CRoutePoint)>();
late final _forEach_CArray_CRoutePointPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRoutePoint, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoutePoint)>>)
>>('CArray_CRoutePoint_forEachWithFunctionPointer');
late final _forEach_CArray_CRoutePoint = _forEach_CArray_CRoutePointPtr.asFunction<
  void Function(_CArray_CRoutePoint, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoutePoint)
>>)>();
late final _CArray_CRoutePoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoutePoint)>>('CArray_CRoutePoint_release');
late final _CArray_CRoutePoint_release = _CArray_CRoutePoint_releasePtr.asFunction<void Function(_CArray_CRoutePoint)>();
late final _CLaneSignRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CLaneSignRouteLongAttribute)>>('CLaneSignRouteLongAttribute_size');
late final _CLaneSignRouteLongAttribute_size = _CLaneSignRouteLongAttribute_sizePtr.asFunction<int Function(_CLaneSignRouteLongAttribute)>();
late final _CLaneSignRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CLaneSignRouteLongAttribute)>>('CLaneSignRouteLongAttribute_isEmpty');
late final _CLaneSignRouteLongAttribute_isEmpty = _CLaneSignRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CLaneSignRouteLongAttribute)>();
late final _CLaneSignRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CLaneSignRouteLongEntry Function(_CLaneSignRouteLongAttribute)>>('CLaneSignRouteLongAttribute_first');
late final _CLaneSignRouteLongAttribute_first = _CLaneSignRouteLongAttribute_firstPtr.asFunction<_COptional_CLaneSignRouteLongEntry Function(_CLaneSignRouteLongAttribute)>();
late final _CLaneSignRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CLaneSignRouteLongEntry Function(_CLaneSignRouteLongAttribute)>>('CLaneSignRouteLongAttribute_last');
late final _CLaneSignRouteLongAttribute_last = _CLaneSignRouteLongAttribute_lastPtr.asFunction<_COptional_CLaneSignRouteLongEntry Function(_CLaneSignRouteLongAttribute)>();
late final _CLaneSignRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CLaneSignRouteLongEntry Function(_CLaneSignRouteLongAttribute)>>('CLaneSignRouteLongAttribute_entries');
late final _CLaneSignRouteLongAttribute_entries = _CLaneSignRouteLongAttribute_entriesPtr.asFunction<_CArray_CLaneSignRouteLongEntry Function(_CLaneSignRouteLongAttribute)>();

late final _CLaneSignRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLaneSignRouteLongAttribute_cg_objectIdentifier');
late final _CLaneSignRouteLongAttribute_cg_objectIdentifier = _CLaneSignRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLaneSignRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CLaneSignRouteLongEntry Function(_CLaneSignRouteLongAttribute, _CRoutePoint)>>('CLaneSignRouteLongAttribute_entry_CRoutePoint');
late final _CLaneSignRouteLongAttribute_entry_CRoutePoint = _CLaneSignRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CLaneSignRouteLongEntry Function(_CLaneSignRouteLongAttribute, _CRoutePoint)>();
late final _CLaneSignRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CLaneSignRouteLongEntry Function(_CLaneSignRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CLaneSignRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CLaneSignRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CLaneSignRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CLaneSignRouteLongEntry Function(_CLaneSignRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CLaneSignRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLaneSignRouteLongAttribute_release');
late final _CLaneSignRouteLongAttribute_release = _CLaneSignRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLaneSignRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CLaneSignRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CLaneSignRouteLongAttribute_retain');
late final _CLaneSignRouteLongAttribute_retain = _CLaneSignRouteLongAttribute_retainPtr.asFunction<_CLaneSignRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CLaneSignRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLaneSignRouteLongAttribute Function()>>('CLaneSignRouteLongAttributeMakeDefault');
late final _CLaneSignRouteLongAttributeMakeDefault = _CLaneSignRouteLongAttributeMakeDefaultPtr.asFunction<_CLaneSignRouteLongAttribute Function()>();


late final _CArray_CRouteLanemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRouteLane Function()>>('CArray_CRouteLane_makeEmpty');
late final _CArray_CRouteLanemakeEmpty = _CArray_CRouteLanemakeEmptyPtr.asFunction<_CArray_CRouteLane Function()>();
late final _CArray_CRouteLaneaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRouteLane, _CRouteLane)>>('CArray_CRouteLane_addElement');
late final _CArray_CRouteLaneaddElement = _CArray_CRouteLaneaddElementPtr.asFunction<void Function(_CArray_CRouteLane, _CRouteLane)>();
late final _forEach_CArray_CRouteLanePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRouteLane, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteLane)>>)
>>('CArray_CRouteLane_forEachWithFunctionPointer');
late final _forEach_CArray_CRouteLane = _forEach_CArray_CRouteLanePtr.asFunction<
  void Function(_CArray_CRouteLane, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteLane)
>>)>();
late final _CArray_CRouteLane_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRouteLane)>>('CArray_CRouteLane_release');
late final _CArray_CRouteLane_release = _CArray_CRouteLane_releasePtr.asFunction<void Function(_CArray_CRouteLane)>();

late final _CRouteLaneSignMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteLaneSign Function()>>('CRouteLaneSignMakeDefault');
late final _CRouteLaneSignMakeDefault = _CRouteLaneSignMakeDefaultPtr.asFunction<_CRouteLaneSign Function()>();


late final _CLaneSignRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLaneSignRouteLongEntry Function()>>('CLaneSignRouteLongEntryMakeDefault');
late final _CLaneSignRouteLongEntryMakeDefault = _CLaneSignRouteLongEntryMakeDefaultPtr.asFunction<_CLaneSignRouteLongEntry Function()>();


late final _COptional_CLaneSignRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLaneSignRouteLongEntry Function()>>('COptional_CLaneSignRouteLongEntryMakeDefault');
late final _COptional_CLaneSignRouteLongEntryMakeDefault = _COptional_CLaneSignRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CLaneSignRouteLongEntry Function()>();

late final _COptional_CLaneSignRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CLaneSignRouteLongEntry)>>('COptional_CLaneSignRouteLongEntry_release');
late final _COptional_CLaneSignRouteLongEntry_release = _COptional_CLaneSignRouteLongEntry_releasePtr.asFunction<void Function(_COptional_CLaneSignRouteLongEntry)>();

late final _CRouteLaneManeuverMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteLaneManeuver Function()>>('CRouteLaneManeuverMakeDefault');
late final _CRouteLaneManeuverMakeDefault = _CRouteLaneManeuverMakeDefaultPtr.asFunction<_CRouteLaneManeuver Function()>();

late final _COptionSet_CRouteLaneManeuverMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CRouteLaneManeuver Function()>>('COptionSet_CRouteLaneManeuverMakeDefault');
late final _COptionSet_CRouteLaneManeuverMakeDefault = _COptionSet_CRouteLaneManeuverMakeDefaultPtr.asFunction<_COptionSet_CRouteLaneManeuver Function()>();

late final _CRouteLaneMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteLane Function()>>('CRouteLaneMakeDefault');
late final _CRouteLaneMakeDefault = _CRouteLaneMakeDefaultPtr.asFunction<_CRouteLane Function()>();


late final _CArray_CLaneSignRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CLaneSignRouteLongEntry Function()>>('CArray_CLaneSignRouteLongEntry_makeEmpty');
late final _CArray_CLaneSignRouteLongEntrymakeEmpty = _CArray_CLaneSignRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CLaneSignRouteLongEntry Function()>();
late final _CArray_CLaneSignRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLaneSignRouteLongEntry, _CLaneSignRouteLongEntry)>>('CArray_CLaneSignRouteLongEntry_addElement');
late final _CArray_CLaneSignRouteLongEntryaddElement = _CArray_CLaneSignRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CLaneSignRouteLongEntry, _CLaneSignRouteLongEntry)>();
late final _forEach_CArray_CLaneSignRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CLaneSignRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLaneSignRouteLongEntry)>>)
>>('CArray_CLaneSignRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CLaneSignRouteLongEntry = _forEach_CArray_CLaneSignRouteLongEntryPtr.asFunction<
  void Function(_CArray_CLaneSignRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLaneSignRouteLongEntry)
>>)>();
late final _CArray_CLaneSignRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLaneSignRouteLongEntry)>>('CArray_CLaneSignRouteLongEntry_release');
late final _CArray_CLaneSignRouteLongEntry_release = _CArray_CLaneSignRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CLaneSignRouteLongEntry)>();
late final _CRouteLevelInfoRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CRouteLevelInfoRouteLongAttribute)>>('CRouteLevelInfoRouteLongAttribute_size');
late final _CRouteLevelInfoRouteLongAttribute_size = _CRouteLevelInfoRouteLongAttribute_sizePtr.asFunction<int Function(_CRouteLevelInfoRouteLongAttribute)>();
late final _CRouteLevelInfoRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CRouteLevelInfoRouteLongAttribute)>>('CRouteLevelInfoRouteLongAttribute_isEmpty');
late final _CRouteLevelInfoRouteLongAttribute_isEmpty = _CRouteLevelInfoRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CRouteLevelInfoRouteLongAttribute)>();
late final _CRouteLevelInfoRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CRouteLevelInfoRouteLongEntry Function(_CRouteLevelInfoRouteLongAttribute)>>('CRouteLevelInfoRouteLongAttribute_first');
late final _CRouteLevelInfoRouteLongAttribute_first = _CRouteLevelInfoRouteLongAttribute_firstPtr.asFunction<_COptional_CRouteLevelInfoRouteLongEntry Function(_CRouteLevelInfoRouteLongAttribute)>();
late final _CRouteLevelInfoRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CRouteLevelInfoRouteLongEntry Function(_CRouteLevelInfoRouteLongAttribute)>>('CRouteLevelInfoRouteLongAttribute_last');
late final _CRouteLevelInfoRouteLongAttribute_last = _CRouteLevelInfoRouteLongAttribute_lastPtr.asFunction<_COptional_CRouteLevelInfoRouteLongEntry Function(_CRouteLevelInfoRouteLongAttribute)>();
late final _CRouteLevelInfoRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CRouteLevelInfoRouteLongEntry Function(_CRouteLevelInfoRouteLongAttribute)>>('CRouteLevelInfoRouteLongAttribute_entries');
late final _CRouteLevelInfoRouteLongAttribute_entries = _CRouteLevelInfoRouteLongAttribute_entriesPtr.asFunction<_CArray_CRouteLevelInfoRouteLongEntry Function(_CRouteLevelInfoRouteLongAttribute)>();

late final _CRouteLevelInfoRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRouteLevelInfoRouteLongAttribute_cg_objectIdentifier');
late final _CRouteLevelInfoRouteLongAttribute_cg_objectIdentifier = _CRouteLevelInfoRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRouteLevelInfoRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRouteLevelInfoRouteLongEntry Function(_CRouteLevelInfoRouteLongAttribute, _CRoutePoint)>>('CRouteLevelInfoRouteLongAttribute_entry_CRoutePoint');
late final _CRouteLevelInfoRouteLongAttribute_entry_CRoutePoint = _CRouteLevelInfoRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CRouteLevelInfoRouteLongEntry Function(_CRouteLevelInfoRouteLongAttribute, _CRoutePoint)>();
late final _CRouteLevelInfoRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CRouteLevelInfoRouteLongEntry Function(_CRouteLevelInfoRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CRouteLevelInfoRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CRouteLevelInfoRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CRouteLevelInfoRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CRouteLevelInfoRouteLongEntry Function(_CRouteLevelInfoRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CRouteLevelInfoRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRouteLevelInfoRouteLongAttribute_release');
late final _CRouteLevelInfoRouteLongAttribute_release = _CRouteLevelInfoRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteLevelInfoRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CRouteLevelInfoRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CRouteLevelInfoRouteLongAttribute_retain');
late final _CRouteLevelInfoRouteLongAttribute_retain = _CRouteLevelInfoRouteLongAttribute_retainPtr.asFunction<_CRouteLevelInfoRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteLevelInfoRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteLevelInfoRouteLongAttribute Function()>>('CRouteLevelInfoRouteLongAttributeMakeDefault');
late final _CRouteLevelInfoRouteLongAttributeMakeDefault = _CRouteLevelInfoRouteLongAttributeMakeDefaultPtr.asFunction<_CRouteLevelInfoRouteLongAttribute Function()>();


late final _CRouteLevelInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteLevelInfo Function()>>('CRouteLevelInfoMakeDefault');
late final _CRouteLevelInfoMakeDefault = _CRouteLevelInfoMakeDefaultPtr.asFunction<_CRouteLevelInfo Function()>();


late final _CRouteLevelInfoRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteLevelInfoRouteLongEntry Function()>>('CRouteLevelInfoRouteLongEntryMakeDefault');
late final _CRouteLevelInfoRouteLongEntryMakeDefault = _CRouteLevelInfoRouteLongEntryMakeDefaultPtr.asFunction<_CRouteLevelInfoRouteLongEntry Function()>();


late final _COptional_CRouteLevelInfoRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRouteLevelInfoRouteLongEntry Function()>>('COptional_CRouteLevelInfoRouteLongEntryMakeDefault');
late final _COptional_CRouteLevelInfoRouteLongEntryMakeDefault = _COptional_CRouteLevelInfoRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CRouteLevelInfoRouteLongEntry Function()>();

late final _COptional_CRouteLevelInfoRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CRouteLevelInfoRouteLongEntry)>>('COptional_CRouteLevelInfoRouteLongEntry_release');
late final _COptional_CRouteLevelInfoRouteLongEntry_release = _COptional_CRouteLevelInfoRouteLongEntry_releasePtr.asFunction<void Function(_COptional_CRouteLevelInfoRouteLongEntry)>();

late final _CArray_CRouteLevelInfoRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRouteLevelInfoRouteLongEntry Function()>>('CArray_CRouteLevelInfoRouteLongEntry_makeEmpty');
late final _CArray_CRouteLevelInfoRouteLongEntrymakeEmpty = _CArray_CRouteLevelInfoRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CRouteLevelInfoRouteLongEntry Function()>();
late final _CArray_CRouteLevelInfoRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRouteLevelInfoRouteLongEntry, _CRouteLevelInfoRouteLongEntry)>>('CArray_CRouteLevelInfoRouteLongEntry_addElement');
late final _CArray_CRouteLevelInfoRouteLongEntryaddElement = _CArray_CRouteLevelInfoRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CRouteLevelInfoRouteLongEntry, _CRouteLevelInfoRouteLongEntry)>();
late final _forEach_CArray_CRouteLevelInfoRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRouteLevelInfoRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteLevelInfoRouteLongEntry)>>)
>>('CArray_CRouteLevelInfoRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CRouteLevelInfoRouteLongEntry = _forEach_CArray_CRouteLevelInfoRouteLongEntryPtr.asFunction<
  void Function(_CArray_CRouteLevelInfoRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteLevelInfoRouteLongEntry)
>>)>();
late final _CArray_CRouteLevelInfoRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRouteLevelInfoRouteLongEntry)>>('CArray_CRouteLevelInfoRouteLongEntry_release');
late final _CArray_CRouteLevelInfoRouteLongEntry_release = _CArray_CRouteLevelInfoRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CRouteLevelInfoRouteLongEntry)>();
late final _CFloatRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CFloatRouteLongAttribute)>>('CFloatRouteLongAttribute_size');
late final _CFloatRouteLongAttribute_size = _CFloatRouteLongAttribute_sizePtr.asFunction<int Function(_CFloatRouteLongAttribute)>();
late final _CFloatRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CFloatRouteLongAttribute)>>('CFloatRouteLongAttribute_isEmpty');
late final _CFloatRouteLongAttribute_isEmpty = _CFloatRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CFloatRouteLongAttribute)>();
late final _CFloatRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CFloatRouteLongEntry Function(_CFloatRouteLongAttribute)>>('CFloatRouteLongAttribute_first');
late final _CFloatRouteLongAttribute_first = _CFloatRouteLongAttribute_firstPtr.asFunction<_COptional_CFloatRouteLongEntry Function(_CFloatRouteLongAttribute)>();
late final _CFloatRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CFloatRouteLongEntry Function(_CFloatRouteLongAttribute)>>('CFloatRouteLongAttribute_last');
late final _CFloatRouteLongAttribute_last = _CFloatRouteLongAttribute_lastPtr.asFunction<_COptional_CFloatRouteLongEntry Function(_CFloatRouteLongAttribute)>();
late final _CFloatRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CFloatRouteLongEntry Function(_CFloatRouteLongAttribute)>>('CFloatRouteLongAttribute_entries');
late final _CFloatRouteLongAttribute_entries = _CFloatRouteLongAttribute_entriesPtr.asFunction<_CArray_CFloatRouteLongEntry Function(_CFloatRouteLongAttribute)>();

late final _CFloatRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CFloatRouteLongAttribute_cg_objectIdentifier');
late final _CFloatRouteLongAttribute_cg_objectIdentifier = _CFloatRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CFloatRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CFloatRouteLongEntry Function(_CFloatRouteLongAttribute, _CRoutePoint)>>('CFloatRouteLongAttribute_entry_CRoutePoint');
late final _CFloatRouteLongAttribute_entry_CRoutePoint = _CFloatRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CFloatRouteLongEntry Function(_CFloatRouteLongAttribute, _CRoutePoint)>();
late final _CFloatRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CFloatRouteLongEntry Function(_CFloatRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CFloatRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CFloatRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CFloatRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CFloatRouteLongEntry Function(_CFloatRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CFloatRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CFloatRouteLongAttribute_release');
late final _CFloatRouteLongAttribute_release = _CFloatRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CFloatRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CFloatRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CFloatRouteLongAttribute_retain');
late final _CFloatRouteLongAttribute_retain = _CFloatRouteLongAttribute_retainPtr.asFunction<_CFloatRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CFloatRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFloatRouteLongAttribute Function()>>('CFloatRouteLongAttributeMakeDefault');
late final _CFloatRouteLongAttributeMakeDefault = _CFloatRouteLongAttributeMakeDefaultPtr.asFunction<_CFloatRouteLongAttribute Function()>();


late final _CFloatRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFloatRouteLongEntry Function()>>('CFloatRouteLongEntryMakeDefault');
late final _CFloatRouteLongEntryMakeDefault = _CFloatRouteLongEntryMakeDefaultPtr.asFunction<_CFloatRouteLongEntry Function()>();


late final _COptional_CFloatRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CFloatRouteLongEntry Function()>>('COptional_CFloatRouteLongEntryMakeDefault');
late final _COptional_CFloatRouteLongEntryMakeDefault = _COptional_CFloatRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CFloatRouteLongEntry Function()>();

late final _CArray_CFloatRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CFloatRouteLongEntry Function()>>('CArray_CFloatRouteLongEntry_makeEmpty');
late final _CArray_CFloatRouteLongEntrymakeEmpty = _CArray_CFloatRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CFloatRouteLongEntry Function()>();
late final _CArray_CFloatRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CFloatRouteLongEntry, _CFloatRouteLongEntry)>>('CArray_CFloatRouteLongEntry_addElement');
late final _CArray_CFloatRouteLongEntryaddElement = _CArray_CFloatRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CFloatRouteLongEntry, _CFloatRouteLongEntry)>();
late final _forEach_CArray_CFloatRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CFloatRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CFloatRouteLongEntry)>>)
>>('CArray_CFloatRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CFloatRouteLongEntry = _forEach_CArray_CFloatRouteLongEntryPtr.asFunction<
  void Function(_CArray_CFloatRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CFloatRouteLongEntry)
>>)>();
late final _CArray_CFloatRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CFloatRouteLongEntry)>>('CArray_CFloatRouteLongEntry_release');
late final _CArray_CFloatRouteLongEntry_release = _CArray_CFloatRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CFloatRouteLongEntry)>();
late final _CRoadRuleRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CRoadRuleRouteLongAttribute)>>('CRoadRuleRouteLongAttribute_size');
late final _CRoadRuleRouteLongAttribute_size = _CRoadRuleRouteLongAttribute_sizePtr.asFunction<int Function(_CRoadRuleRouteLongAttribute)>();
late final _CRoadRuleRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CRoadRuleRouteLongAttribute)>>('CRoadRuleRouteLongAttribute_isEmpty');
late final _CRoadRuleRouteLongAttribute_isEmpty = _CRoadRuleRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CRoadRuleRouteLongAttribute)>();
late final _CRoadRuleRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CRoadRuleRouteLongEntry Function(_CRoadRuleRouteLongAttribute)>>('CRoadRuleRouteLongAttribute_first');
late final _CRoadRuleRouteLongAttribute_first = _CRoadRuleRouteLongAttribute_firstPtr.asFunction<_COptional_CRoadRuleRouteLongEntry Function(_CRoadRuleRouteLongAttribute)>();
late final _CRoadRuleRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CRoadRuleRouteLongEntry Function(_CRoadRuleRouteLongAttribute)>>('CRoadRuleRouteLongAttribute_last');
late final _CRoadRuleRouteLongAttribute_last = _CRoadRuleRouteLongAttribute_lastPtr.asFunction<_COptional_CRoadRuleRouteLongEntry Function(_CRoadRuleRouteLongAttribute)>();
late final _CRoadRuleRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CRoadRuleRouteLongEntry Function(_CRoadRuleRouteLongAttribute)>>('CRoadRuleRouteLongAttribute_entries');
late final _CRoadRuleRouteLongAttribute_entries = _CRoadRuleRouteLongAttribute_entriesPtr.asFunction<_CArray_CRoadRuleRouteLongEntry Function(_CRoadRuleRouteLongAttribute)>();

late final _CRoadRuleRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadRuleRouteLongAttribute_cg_objectIdentifier');
late final _CRoadRuleRouteLongAttribute_cg_objectIdentifier = _CRoadRuleRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadRuleRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRoadRuleRouteLongEntry Function(_CRoadRuleRouteLongAttribute, _CRoutePoint)>>('CRoadRuleRouteLongAttribute_entry_CRoutePoint');
late final _CRoadRuleRouteLongAttribute_entry_CRoutePoint = _CRoadRuleRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CRoadRuleRouteLongEntry Function(_CRoadRuleRouteLongAttribute, _CRoutePoint)>();
late final _CRoadRuleRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CRoadRuleRouteLongEntry Function(_CRoadRuleRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CRoadRuleRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CRoadRuleRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CRoadRuleRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CRoadRuleRouteLongEntry Function(_CRoadRuleRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CRoadRuleRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadRuleRouteLongAttribute_release');
late final _CRoadRuleRouteLongAttribute_release = _CRoadRuleRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadRuleRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CRoadRuleRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CRoadRuleRouteLongAttribute_retain');
late final _CRoadRuleRouteLongAttribute_retain = _CRoadRuleRouteLongAttribute_retainPtr.asFunction<_CRoadRuleRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadRuleRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadRuleRouteLongAttribute Function()>>('CRoadRuleRouteLongAttributeMakeDefault');
late final _CRoadRuleRouteLongAttributeMakeDefault = _CRoadRuleRouteLongAttributeMakeDefaultPtr.asFunction<_CRoadRuleRouteLongAttribute Function()>();


late final _CRoadRuleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadRule Function()>>('CRoadRuleMakeDefault');
late final _CRoadRuleMakeDefault = _CRoadRuleMakeDefaultPtr.asFunction<_CRoadRule Function()>();

late final _CRoadRuleRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadRuleRouteLongEntry Function()>>('CRoadRuleRouteLongEntryMakeDefault');
late final _CRoadRuleRouteLongEntryMakeDefault = _CRoadRuleRouteLongEntryMakeDefaultPtr.asFunction<_CRoadRuleRouteLongEntry Function()>();


late final _COptional_CRoadRuleRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRoadRuleRouteLongEntry Function()>>('COptional_CRoadRuleRouteLongEntryMakeDefault');
late final _COptional_CRoadRuleRouteLongEntryMakeDefault = _COptional_CRoadRuleRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CRoadRuleRouteLongEntry Function()>();

late final _CArray_CRoadRuleRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRoadRuleRouteLongEntry Function()>>('CArray_CRoadRuleRouteLongEntry_makeEmpty');
late final _CArray_CRoadRuleRouteLongEntrymakeEmpty = _CArray_CRoadRuleRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CRoadRuleRouteLongEntry Function()>();
late final _CArray_CRoadRuleRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadRuleRouteLongEntry, _CRoadRuleRouteLongEntry)>>('CArray_CRoadRuleRouteLongEntry_addElement');
late final _CArray_CRoadRuleRouteLongEntryaddElement = _CArray_CRoadRuleRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CRoadRuleRouteLongEntry, _CRoadRuleRouteLongEntry)>();
late final _forEach_CArray_CRoadRuleRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRoadRuleRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadRuleRouteLongEntry)>>)
>>('CArray_CRoadRuleRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CRoadRuleRouteLongEntry = _forEach_CArray_CRoadRuleRouteLongEntryPtr.asFunction<
  void Function(_CArray_CRoadRuleRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadRuleRouteLongEntry)
>>)>();
late final _CArray_CRoadRuleRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadRuleRouteLongEntry)>>('CArray_CRoadRuleRouteLongEntry_release');
late final _CArray_CRoadRuleRouteLongEntry_release = _CArray_CRoadRuleRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CRoadRuleRouteLongEntry)>();
late final _CRoadSubtypeRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CRoadSubtypeRouteLongAttribute)>>('CRoadSubtypeRouteLongAttribute_size');
late final _CRoadSubtypeRouteLongAttribute_size = _CRoadSubtypeRouteLongAttribute_sizePtr.asFunction<int Function(_CRoadSubtypeRouteLongAttribute)>();
late final _CRoadSubtypeRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CRoadSubtypeRouteLongAttribute)>>('CRoadSubtypeRouteLongAttribute_isEmpty');
late final _CRoadSubtypeRouteLongAttribute_isEmpty = _CRoadSubtypeRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CRoadSubtypeRouteLongAttribute)>();
late final _CRoadSubtypeRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CRoadSubtypeRouteLongEntry Function(_CRoadSubtypeRouteLongAttribute)>>('CRoadSubtypeRouteLongAttribute_first');
late final _CRoadSubtypeRouteLongAttribute_first = _CRoadSubtypeRouteLongAttribute_firstPtr.asFunction<_COptional_CRoadSubtypeRouteLongEntry Function(_CRoadSubtypeRouteLongAttribute)>();
late final _CRoadSubtypeRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CRoadSubtypeRouteLongEntry Function(_CRoadSubtypeRouteLongAttribute)>>('CRoadSubtypeRouteLongAttribute_last');
late final _CRoadSubtypeRouteLongAttribute_last = _CRoadSubtypeRouteLongAttribute_lastPtr.asFunction<_COptional_CRoadSubtypeRouteLongEntry Function(_CRoadSubtypeRouteLongAttribute)>();
late final _CRoadSubtypeRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CRoadSubtypeRouteLongEntry Function(_CRoadSubtypeRouteLongAttribute)>>('CRoadSubtypeRouteLongAttribute_entries');
late final _CRoadSubtypeRouteLongAttribute_entries = _CRoadSubtypeRouteLongAttribute_entriesPtr.asFunction<_CArray_CRoadSubtypeRouteLongEntry Function(_CRoadSubtypeRouteLongAttribute)>();

late final _CRoadSubtypeRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadSubtypeRouteLongAttribute_cg_objectIdentifier');
late final _CRoadSubtypeRouteLongAttribute_cg_objectIdentifier = _CRoadSubtypeRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadSubtypeRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRoadSubtypeRouteLongEntry Function(_CRoadSubtypeRouteLongAttribute, _CRoutePoint)>>('CRoadSubtypeRouteLongAttribute_entry_CRoutePoint');
late final _CRoadSubtypeRouteLongAttribute_entry_CRoutePoint = _CRoadSubtypeRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CRoadSubtypeRouteLongEntry Function(_CRoadSubtypeRouteLongAttribute, _CRoutePoint)>();
late final _CRoadSubtypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CRoadSubtypeRouteLongEntry Function(_CRoadSubtypeRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CRoadSubtypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CRoadSubtypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CRoadSubtypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CRoadSubtypeRouteLongEntry Function(_CRoadSubtypeRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CRoadSubtypeRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadSubtypeRouteLongAttribute_release');
late final _CRoadSubtypeRouteLongAttribute_release = _CRoadSubtypeRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadSubtypeRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CRoadSubtypeRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CRoadSubtypeRouteLongAttribute_retain');
late final _CRoadSubtypeRouteLongAttribute_retain = _CRoadSubtypeRouteLongAttribute_retainPtr.asFunction<_CRoadSubtypeRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadSubtypeRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadSubtypeRouteLongAttribute Function()>>('CRoadSubtypeRouteLongAttributeMakeDefault');
late final _CRoadSubtypeRouteLongAttributeMakeDefault = _CRoadSubtypeRouteLongAttributeMakeDefaultPtr.asFunction<_CRoadSubtypeRouteLongAttribute Function()>();


late final _CRoadSubtypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadSubtype Function()>>('CRoadSubtypeMakeDefault');
late final _CRoadSubtypeMakeDefault = _CRoadSubtypeMakeDefaultPtr.asFunction<_CRoadSubtype Function()>();

late final _CRoadSubtypeRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadSubtypeRouteLongEntry Function()>>('CRoadSubtypeRouteLongEntryMakeDefault');
late final _CRoadSubtypeRouteLongEntryMakeDefault = _CRoadSubtypeRouteLongEntryMakeDefaultPtr.asFunction<_CRoadSubtypeRouteLongEntry Function()>();


late final _COptional_CRoadSubtypeRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRoadSubtypeRouteLongEntry Function()>>('COptional_CRoadSubtypeRouteLongEntryMakeDefault');
late final _COptional_CRoadSubtypeRouteLongEntryMakeDefault = _COptional_CRoadSubtypeRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CRoadSubtypeRouteLongEntry Function()>();

late final _CArray_CRoadSubtypeRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRoadSubtypeRouteLongEntry Function()>>('CArray_CRoadSubtypeRouteLongEntry_makeEmpty');
late final _CArray_CRoadSubtypeRouteLongEntrymakeEmpty = _CArray_CRoadSubtypeRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CRoadSubtypeRouteLongEntry Function()>();
late final _CArray_CRoadSubtypeRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadSubtypeRouteLongEntry, _CRoadSubtypeRouteLongEntry)>>('CArray_CRoadSubtypeRouteLongEntry_addElement');
late final _CArray_CRoadSubtypeRouteLongEntryaddElement = _CArray_CRoadSubtypeRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CRoadSubtypeRouteLongEntry, _CRoadSubtypeRouteLongEntry)>();
late final _forEach_CArray_CRoadSubtypeRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRoadSubtypeRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadSubtypeRouteLongEntry)>>)
>>('CArray_CRoadSubtypeRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CRoadSubtypeRouteLongEntry = _forEach_CArray_CRoadSubtypeRouteLongEntryPtr.asFunction<
  void Function(_CArray_CRoadSubtypeRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadSubtypeRouteLongEntry)
>>)>();
late final _CArray_CRoadSubtypeRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadSubtypeRouteLongEntry)>>('CArray_CRoadSubtypeRouteLongEntry_release');
late final _CArray_CRoadSubtypeRouteLongEntry_release = _CArray_CRoadSubtypeRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CRoadSubtypeRouteLongEntry)>();
late final _CRoadSurfaceRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CRoadSurfaceRouteLongAttribute)>>('CRoadSurfaceRouteLongAttribute_size');
late final _CRoadSurfaceRouteLongAttribute_size = _CRoadSurfaceRouteLongAttribute_sizePtr.asFunction<int Function(_CRoadSurfaceRouteLongAttribute)>();
late final _CRoadSurfaceRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CRoadSurfaceRouteLongAttribute)>>('CRoadSurfaceRouteLongAttribute_isEmpty');
late final _CRoadSurfaceRouteLongAttribute_isEmpty = _CRoadSurfaceRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CRoadSurfaceRouteLongAttribute)>();
late final _CRoadSurfaceRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CRoadSurfaceRouteLongEntry Function(_CRoadSurfaceRouteLongAttribute)>>('CRoadSurfaceRouteLongAttribute_first');
late final _CRoadSurfaceRouteLongAttribute_first = _CRoadSurfaceRouteLongAttribute_firstPtr.asFunction<_COptional_CRoadSurfaceRouteLongEntry Function(_CRoadSurfaceRouteLongAttribute)>();
late final _CRoadSurfaceRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CRoadSurfaceRouteLongEntry Function(_CRoadSurfaceRouteLongAttribute)>>('CRoadSurfaceRouteLongAttribute_last');
late final _CRoadSurfaceRouteLongAttribute_last = _CRoadSurfaceRouteLongAttribute_lastPtr.asFunction<_COptional_CRoadSurfaceRouteLongEntry Function(_CRoadSurfaceRouteLongAttribute)>();
late final _CRoadSurfaceRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CRoadSurfaceRouteLongEntry Function(_CRoadSurfaceRouteLongAttribute)>>('CRoadSurfaceRouteLongAttribute_entries');
late final _CRoadSurfaceRouteLongAttribute_entries = _CRoadSurfaceRouteLongAttribute_entriesPtr.asFunction<_CArray_CRoadSurfaceRouteLongEntry Function(_CRoadSurfaceRouteLongAttribute)>();

late final _CRoadSurfaceRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadSurfaceRouteLongAttribute_cg_objectIdentifier');
late final _CRoadSurfaceRouteLongAttribute_cg_objectIdentifier = _CRoadSurfaceRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadSurfaceRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRoadSurfaceRouteLongEntry Function(_CRoadSurfaceRouteLongAttribute, _CRoutePoint)>>('CRoadSurfaceRouteLongAttribute_entry_CRoutePoint');
late final _CRoadSurfaceRouteLongAttribute_entry_CRoutePoint = _CRoadSurfaceRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CRoadSurfaceRouteLongEntry Function(_CRoadSurfaceRouteLongAttribute, _CRoutePoint)>();
late final _CRoadSurfaceRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CRoadSurfaceRouteLongEntry Function(_CRoadSurfaceRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CRoadSurfaceRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CRoadSurfaceRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CRoadSurfaceRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CRoadSurfaceRouteLongEntry Function(_CRoadSurfaceRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CRoadSurfaceRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadSurfaceRouteLongAttribute_release');
late final _CRoadSurfaceRouteLongAttribute_release = _CRoadSurfaceRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadSurfaceRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CRoadSurfaceRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CRoadSurfaceRouteLongAttribute_retain');
late final _CRoadSurfaceRouteLongAttribute_retain = _CRoadSurfaceRouteLongAttribute_retainPtr.asFunction<_CRoadSurfaceRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadSurfaceRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadSurfaceRouteLongAttribute Function()>>('CRoadSurfaceRouteLongAttributeMakeDefault');
late final _CRoadSurfaceRouteLongAttributeMakeDefault = _CRoadSurfaceRouteLongAttributeMakeDefaultPtr.asFunction<_CRoadSurfaceRouteLongAttribute Function()>();


late final _CRoadSurfaceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadSurface Function()>>('CRoadSurfaceMakeDefault');
late final _CRoadSurfaceMakeDefault = _CRoadSurfaceMakeDefaultPtr.asFunction<_CRoadSurface Function()>();

late final _CRoadSurfaceRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadSurfaceRouteLongEntry Function()>>('CRoadSurfaceRouteLongEntryMakeDefault');
late final _CRoadSurfaceRouteLongEntryMakeDefault = _CRoadSurfaceRouteLongEntryMakeDefaultPtr.asFunction<_CRoadSurfaceRouteLongEntry Function()>();


late final _COptional_CRoadSurfaceRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRoadSurfaceRouteLongEntry Function()>>('COptional_CRoadSurfaceRouteLongEntryMakeDefault');
late final _COptional_CRoadSurfaceRouteLongEntryMakeDefault = _COptional_CRoadSurfaceRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CRoadSurfaceRouteLongEntry Function()>();

late final _CArray_CRoadSurfaceRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRoadSurfaceRouteLongEntry Function()>>('CArray_CRoadSurfaceRouteLongEntry_makeEmpty');
late final _CArray_CRoadSurfaceRouteLongEntrymakeEmpty = _CArray_CRoadSurfaceRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CRoadSurfaceRouteLongEntry Function()>();
late final _CArray_CRoadSurfaceRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadSurfaceRouteLongEntry, _CRoadSurfaceRouteLongEntry)>>('CArray_CRoadSurfaceRouteLongEntry_addElement');
late final _CArray_CRoadSurfaceRouteLongEntryaddElement = _CArray_CRoadSurfaceRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CRoadSurfaceRouteLongEntry, _CRoadSurfaceRouteLongEntry)>();
late final _forEach_CArray_CRoadSurfaceRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRoadSurfaceRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadSurfaceRouteLongEntry)>>)
>>('CArray_CRoadSurfaceRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CRoadSurfaceRouteLongEntry = _forEach_CArray_CRoadSurfaceRouteLongEntryPtr.asFunction<
  void Function(_CArray_CRoadSurfaceRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadSurfaceRouteLongEntry)
>>)>();
late final _CArray_CRoadSurfaceRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadSurfaceRouteLongEntry)>>('CArray_CRoadSurfaceRouteLongEntry_release');
late final _CArray_CRoadSurfaceRouteLongEntry_release = _CArray_CRoadSurfaceRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CRoadSurfaceRouteLongEntry)>();
late final _CRoadTypeRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CRoadTypeRouteLongAttribute)>>('CRoadTypeRouteLongAttribute_size');
late final _CRoadTypeRouteLongAttribute_size = _CRoadTypeRouteLongAttribute_sizePtr.asFunction<int Function(_CRoadTypeRouteLongAttribute)>();
late final _CRoadTypeRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CRoadTypeRouteLongAttribute)>>('CRoadTypeRouteLongAttribute_isEmpty');
late final _CRoadTypeRouteLongAttribute_isEmpty = _CRoadTypeRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CRoadTypeRouteLongAttribute)>();
late final _CRoadTypeRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CRoadTypeRouteLongEntry Function(_CRoadTypeRouteLongAttribute)>>('CRoadTypeRouteLongAttribute_first');
late final _CRoadTypeRouteLongAttribute_first = _CRoadTypeRouteLongAttribute_firstPtr.asFunction<_COptional_CRoadTypeRouteLongEntry Function(_CRoadTypeRouteLongAttribute)>();
late final _CRoadTypeRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CRoadTypeRouteLongEntry Function(_CRoadTypeRouteLongAttribute)>>('CRoadTypeRouteLongAttribute_last');
late final _CRoadTypeRouteLongAttribute_last = _CRoadTypeRouteLongAttribute_lastPtr.asFunction<_COptional_CRoadTypeRouteLongEntry Function(_CRoadTypeRouteLongAttribute)>();
late final _CRoadTypeRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CRoadTypeRouteLongEntry Function(_CRoadTypeRouteLongAttribute)>>('CRoadTypeRouteLongAttribute_entries');
late final _CRoadTypeRouteLongAttribute_entries = _CRoadTypeRouteLongAttribute_entriesPtr.asFunction<_CArray_CRoadTypeRouteLongEntry Function(_CRoadTypeRouteLongAttribute)>();

late final _CRoadTypeRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadTypeRouteLongAttribute_cg_objectIdentifier');
late final _CRoadTypeRouteLongAttribute_cg_objectIdentifier = _CRoadTypeRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadTypeRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRoadTypeRouteLongEntry Function(_CRoadTypeRouteLongAttribute, _CRoutePoint)>>('CRoadTypeRouteLongAttribute_entry_CRoutePoint');
late final _CRoadTypeRouteLongAttribute_entry_CRoutePoint = _CRoadTypeRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CRoadTypeRouteLongEntry Function(_CRoadTypeRouteLongAttribute, _CRoutePoint)>();
late final _CRoadTypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CRoadTypeRouteLongEntry Function(_CRoadTypeRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CRoadTypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CRoadTypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CRoadTypeRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CRoadTypeRouteLongEntry Function(_CRoadTypeRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CRoadTypeRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadTypeRouteLongAttribute_release');
late final _CRoadTypeRouteLongAttribute_release = _CRoadTypeRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadTypeRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CRoadTypeRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CRoadTypeRouteLongAttribute_retain');
late final _CRoadTypeRouteLongAttribute_retain = _CRoadTypeRouteLongAttribute_retainPtr.asFunction<_CRoadTypeRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadTypeRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadTypeRouteLongAttribute Function()>>('CRoadTypeRouteLongAttributeMakeDefault');
late final _CRoadTypeRouteLongAttributeMakeDefault = _CRoadTypeRouteLongAttributeMakeDefaultPtr.asFunction<_CRoadTypeRouteLongAttribute Function()>();


late final _CRoadTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadType Function()>>('CRoadTypeMakeDefault');
late final _CRoadTypeMakeDefault = _CRoadTypeMakeDefaultPtr.asFunction<_CRoadType Function()>();

late final _CRoadTypeRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadTypeRouteLongEntry Function()>>('CRoadTypeRouteLongEntryMakeDefault');
late final _CRoadTypeRouteLongEntryMakeDefault = _CRoadTypeRouteLongEntryMakeDefaultPtr.asFunction<_CRoadTypeRouteLongEntry Function()>();


late final _COptional_CRoadTypeRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRoadTypeRouteLongEntry Function()>>('COptional_CRoadTypeRouteLongEntryMakeDefault');
late final _COptional_CRoadTypeRouteLongEntryMakeDefault = _COptional_CRoadTypeRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CRoadTypeRouteLongEntry Function()>();

late final _CArray_CRoadTypeRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRoadTypeRouteLongEntry Function()>>('CArray_CRoadTypeRouteLongEntry_makeEmpty');
late final _CArray_CRoadTypeRouteLongEntrymakeEmpty = _CArray_CRoadTypeRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CRoadTypeRouteLongEntry Function()>();
late final _CArray_CRoadTypeRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadTypeRouteLongEntry, _CRoadTypeRouteLongEntry)>>('CArray_CRoadTypeRouteLongEntry_addElement');
late final _CArray_CRoadTypeRouteLongEntryaddElement = _CArray_CRoadTypeRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CRoadTypeRouteLongEntry, _CRoadTypeRouteLongEntry)>();
late final _forEach_CArray_CRoadTypeRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRoadTypeRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadTypeRouteLongEntry)>>)
>>('CArray_CRoadTypeRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CRoadTypeRouteLongEntry = _forEach_CArray_CRoadTypeRouteLongEntryPtr.asFunction<
  void Function(_CArray_CRoadTypeRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadTypeRouteLongEntry)
>>)>();
late final _CArray_CRoadTypeRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadTypeRouteLongEntry)>>('CArray_CRoadTypeRouteLongEntry_release');
late final _CArray_CRoadTypeRouteLongEntry_release = _CArray_CRoadTypeRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CRoadTypeRouteLongEntry)>();
late final _CTruckPassZoneIdRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CTruckPassZoneIdRouteLongAttribute)>>('CTruckPassZoneIdRouteLongAttribute_size');
late final _CTruckPassZoneIdRouteLongAttribute_size = _CTruckPassZoneIdRouteLongAttribute_sizePtr.asFunction<int Function(_CTruckPassZoneIdRouteLongAttribute)>();
late final _CTruckPassZoneIdRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CTruckPassZoneIdRouteLongAttribute)>>('CTruckPassZoneIdRouteLongAttribute_isEmpty');
late final _CTruckPassZoneIdRouteLongAttribute_isEmpty = _CTruckPassZoneIdRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CTruckPassZoneIdRouteLongAttribute)>();
late final _CTruckPassZoneIdRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CTruckPassZoneIdRouteLongEntry Function(_CTruckPassZoneIdRouteLongAttribute)>>('CTruckPassZoneIdRouteLongAttribute_first');
late final _CTruckPassZoneIdRouteLongAttribute_first = _CTruckPassZoneIdRouteLongAttribute_firstPtr.asFunction<_COptional_CTruckPassZoneIdRouteLongEntry Function(_CTruckPassZoneIdRouteLongAttribute)>();
late final _CTruckPassZoneIdRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CTruckPassZoneIdRouteLongEntry Function(_CTruckPassZoneIdRouteLongAttribute)>>('CTruckPassZoneIdRouteLongAttribute_last');
late final _CTruckPassZoneIdRouteLongAttribute_last = _CTruckPassZoneIdRouteLongAttribute_lastPtr.asFunction<_COptional_CTruckPassZoneIdRouteLongEntry Function(_CTruckPassZoneIdRouteLongAttribute)>();
late final _CTruckPassZoneIdRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CTruckPassZoneIdRouteLongEntry Function(_CTruckPassZoneIdRouteLongAttribute)>>('CTruckPassZoneIdRouteLongAttribute_entries');
late final _CTruckPassZoneIdRouteLongAttribute_entries = _CTruckPassZoneIdRouteLongAttribute_entriesPtr.asFunction<_CArray_CTruckPassZoneIdRouteLongEntry Function(_CTruckPassZoneIdRouteLongAttribute)>();

late final _CTruckPassZoneIdRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTruckPassZoneIdRouteLongAttribute_cg_objectIdentifier');
late final _CTruckPassZoneIdRouteLongAttribute_cg_objectIdentifier = _CTruckPassZoneIdRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTruckPassZoneIdRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CTruckPassZoneIdRouteLongEntry Function(_CTruckPassZoneIdRouteLongAttribute, _CRoutePoint)>>('CTruckPassZoneIdRouteLongAttribute_entry_CRoutePoint');
late final _CTruckPassZoneIdRouteLongAttribute_entry_CRoutePoint = _CTruckPassZoneIdRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CTruckPassZoneIdRouteLongEntry Function(_CTruckPassZoneIdRouteLongAttribute, _CRoutePoint)>();
late final _CTruckPassZoneIdRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CTruckPassZoneIdRouteLongEntry Function(_CTruckPassZoneIdRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CTruckPassZoneIdRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CTruckPassZoneIdRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CTruckPassZoneIdRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CTruckPassZoneIdRouteLongEntry Function(_CTruckPassZoneIdRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CTruckPassZoneIdRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTruckPassZoneIdRouteLongAttribute_release');
late final _CTruckPassZoneIdRouteLongAttribute_release = _CTruckPassZoneIdRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTruckPassZoneIdRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CTruckPassZoneIdRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CTruckPassZoneIdRouteLongAttribute_retain');
late final _CTruckPassZoneIdRouteLongAttribute_retain = _CTruckPassZoneIdRouteLongAttribute_retainPtr.asFunction<_CTruckPassZoneIdRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CTruckPassZoneIdRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTruckPassZoneIdRouteLongAttribute Function()>>('CTruckPassZoneIdRouteLongAttributeMakeDefault');
late final _CTruckPassZoneIdRouteLongAttributeMakeDefault = _CTruckPassZoneIdRouteLongAttributeMakeDefaultPtr.asFunction<_CTruckPassZoneIdRouteLongAttribute Function()>();


late final _CTruckPassZoneIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTruckPassZoneId Function()>>('CTruckPassZoneIdMakeDefault');
late final _CTruckPassZoneIdMakeDefault = _CTruckPassZoneIdMakeDefaultPtr.asFunction<_CTruckPassZoneId Function()>();


late final _CTruckPassZoneIdRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTruckPassZoneIdRouteLongEntry Function()>>('CTruckPassZoneIdRouteLongEntryMakeDefault');
late final _CTruckPassZoneIdRouteLongEntryMakeDefault = _CTruckPassZoneIdRouteLongEntryMakeDefaultPtr.asFunction<_CTruckPassZoneIdRouteLongEntry Function()>();


late final _COptional_CTruckPassZoneIdRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CTruckPassZoneIdRouteLongEntry Function()>>('COptional_CTruckPassZoneIdRouteLongEntryMakeDefault');
late final _COptional_CTruckPassZoneIdRouteLongEntryMakeDefault = _COptional_CTruckPassZoneIdRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CTruckPassZoneIdRouteLongEntry Function()>();

late final _CArray_CTruckPassZoneIdRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CTruckPassZoneIdRouteLongEntry Function()>>('CArray_CTruckPassZoneIdRouteLongEntry_makeEmpty');
late final _CArray_CTruckPassZoneIdRouteLongEntrymakeEmpty = _CArray_CTruckPassZoneIdRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CTruckPassZoneIdRouteLongEntry Function()>();
late final _CArray_CTruckPassZoneIdRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CTruckPassZoneIdRouteLongEntry, _CTruckPassZoneIdRouteLongEntry)>>('CArray_CTruckPassZoneIdRouteLongEntry_addElement');
late final _CArray_CTruckPassZoneIdRouteLongEntryaddElement = _CArray_CTruckPassZoneIdRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CTruckPassZoneIdRouteLongEntry, _CTruckPassZoneIdRouteLongEntry)>();
late final _forEach_CArray_CTruckPassZoneIdRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CTruckPassZoneIdRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTruckPassZoneIdRouteLongEntry)>>)
>>('CArray_CTruckPassZoneIdRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CTruckPassZoneIdRouteLongEntry = _forEach_CArray_CTruckPassZoneIdRouteLongEntryPtr.asFunction<
  void Function(_CArray_CTruckPassZoneIdRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTruckPassZoneIdRouteLongEntry)
>>)>();
late final _CArray_CTruckPassZoneIdRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CTruckPassZoneIdRouteLongEntry)>>('CArray_CTruckPassZoneIdRouteLongEntry_release');
late final _CArray_CTruckPassZoneIdRouteLongEntry_release = _CArray_CTruckPassZoneIdRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CTruckPassZoneIdRouteLongEntry)>();
late final _CPublicTransportTransferRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CPublicTransportTransferRouteLongAttribute)>>('CPublicTransportTransferRouteLongAttribute_size');
late final _CPublicTransportTransferRouteLongAttribute_size = _CPublicTransportTransferRouteLongAttribute_sizePtr.asFunction<int Function(_CPublicTransportTransferRouteLongAttribute)>();
late final _CPublicTransportTransferRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CPublicTransportTransferRouteLongAttribute)>>('CPublicTransportTransferRouteLongAttribute_isEmpty');
late final _CPublicTransportTransferRouteLongAttribute_isEmpty = _CPublicTransportTransferRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CPublicTransportTransferRouteLongAttribute)>();
late final _CPublicTransportTransferRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CPublicTransportTransferRouteLongEntry Function(_CPublicTransportTransferRouteLongAttribute)>>('CPublicTransportTransferRouteLongAttribute_first');
late final _CPublicTransportTransferRouteLongAttribute_first = _CPublicTransportTransferRouteLongAttribute_firstPtr.asFunction<_COptional_CPublicTransportTransferRouteLongEntry Function(_CPublicTransportTransferRouteLongAttribute)>();
late final _CPublicTransportTransferRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CPublicTransportTransferRouteLongEntry Function(_CPublicTransportTransferRouteLongAttribute)>>('CPublicTransportTransferRouteLongAttribute_last');
late final _CPublicTransportTransferRouteLongAttribute_last = _CPublicTransportTransferRouteLongAttribute_lastPtr.asFunction<_COptional_CPublicTransportTransferRouteLongEntry Function(_CPublicTransportTransferRouteLongAttribute)>();
late final _CPublicTransportTransferRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CPublicTransportTransferRouteLongEntry Function(_CPublicTransportTransferRouteLongAttribute)>>('CPublicTransportTransferRouteLongAttribute_entries');
late final _CPublicTransportTransferRouteLongAttribute_entries = _CPublicTransportTransferRouteLongAttribute_entriesPtr.asFunction<_CArray_CPublicTransportTransferRouteLongEntry Function(_CPublicTransportTransferRouteLongAttribute)>();

late final _CPublicTransportTransferRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPublicTransportTransferRouteLongAttribute_cg_objectIdentifier');
late final _CPublicTransportTransferRouteLongAttribute_cg_objectIdentifier = _CPublicTransportTransferRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPublicTransportTransferRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CPublicTransportTransferRouteLongEntry Function(_CPublicTransportTransferRouteLongAttribute, _CRoutePoint)>>('CPublicTransportTransferRouteLongAttribute_entry_CRoutePoint');
late final _CPublicTransportTransferRouteLongAttribute_entry_CRoutePoint = _CPublicTransportTransferRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CPublicTransportTransferRouteLongEntry Function(_CPublicTransportTransferRouteLongAttribute, _CRoutePoint)>();
late final _CPublicTransportTransferRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CPublicTransportTransferRouteLongEntry Function(_CPublicTransportTransferRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CPublicTransportTransferRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CPublicTransportTransferRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CPublicTransportTransferRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CPublicTransportTransferRouteLongEntry Function(_CPublicTransportTransferRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CPublicTransportTransferRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPublicTransportTransferRouteLongAttribute_release');
late final _CPublicTransportTransferRouteLongAttribute_release = _CPublicTransportTransferRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPublicTransportTransferRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CPublicTransportTransferRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CPublicTransportTransferRouteLongAttribute_retain');
late final _CPublicTransportTransferRouteLongAttribute_retain = _CPublicTransportTransferRouteLongAttribute_retainPtr.asFunction<_CPublicTransportTransferRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CPublicTransportTransferRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPublicTransportTransferRouteLongAttribute Function()>>('CPublicTransportTransferRouteLongAttributeMakeDefault');
late final _CPublicTransportTransferRouteLongAttributeMakeDefault = _CPublicTransportTransferRouteLongAttributeMakeDefaultPtr.asFunction<_CPublicTransportTransferRouteLongAttribute Function()>();


late final _CArray_CPublicRoutePartmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CPublicRoutePart Function()>>('CArray_CPublicRoutePart_makeEmpty');
late final _CArray_CPublicRoutePartmakeEmpty = _CArray_CPublicRoutePartmakeEmptyPtr.asFunction<_CArray_CPublicRoutePart Function()>();
late final _CArray_CPublicRoutePartaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPublicRoutePart, _CPublicRoutePart)>>('CArray_CPublicRoutePart_addElement');
late final _CArray_CPublicRoutePartaddElement = _CArray_CPublicRoutePartaddElementPtr.asFunction<void Function(_CArray_CPublicRoutePart, _CPublicRoutePart)>();
late final _forEach_CArray_CPublicRoutePartPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CPublicRoutePart, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPublicRoutePart)>>)
>>('CArray_CPublicRoutePart_forEachWithFunctionPointer');
late final _forEach_CArray_CPublicRoutePart = _forEach_CArray_CPublicRoutePartPtr.asFunction<
  void Function(_CArray_CPublicRoutePart, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPublicRoutePart)
>>)>();
late final _CArray_CPublicRoutePart_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPublicRoutePart)>>('CArray_CPublicRoutePart_release');
late final _CArray_CPublicRoutePart_release = _CArray_CPublicRoutePart_releasePtr.asFunction<void Function(_CArray_CPublicRoutePart)>();

late final _CPublicTransportTransferMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPublicTransportTransfer Function()>>('CPublicTransportTransferMakeDefault');
late final _CPublicTransportTransferMakeDefault = _CPublicTransportTransferMakeDefaultPtr.asFunction<_CPublicTransportTransfer Function()>();


late final _CPublicTransportTransferRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPublicTransportTransferRouteLongEntry Function()>>('CPublicTransportTransferRouteLongEntryMakeDefault');
late final _CPublicTransportTransferRouteLongEntryMakeDefault = _CPublicTransportTransferRouteLongEntryMakeDefaultPtr.asFunction<_CPublicTransportTransferRouteLongEntry Function()>();


late final _COptional_CPublicTransportTransferRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CPublicTransportTransferRouteLongEntry Function()>>('COptional_CPublicTransportTransferRouteLongEntryMakeDefault');
late final _COptional_CPublicTransportTransferRouteLongEntryMakeDefault = _COptional_CPublicTransportTransferRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CPublicTransportTransferRouteLongEntry Function()>();

late final _COptional_CPublicTransportTransferRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CPublicTransportTransferRouteLongEntry)>>('COptional_CPublicTransportTransferRouteLongEntry_release');
late final _COptional_CPublicTransportTransferRouteLongEntry_release = _COptional_CPublicTransportTransferRouteLongEntry_releasePtr.asFunction<void Function(_COptional_CPublicTransportTransferRouteLongEntry)>();

late final _CArray_CPublicTransportInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CPublicTransportInfo Function()>>('CArray_CPublicTransportInfo_makeEmpty');
late final _CArray_CPublicTransportInfomakeEmpty = _CArray_CPublicTransportInfomakeEmptyPtr.asFunction<_CArray_CPublicTransportInfo Function()>();
late final _CArray_CPublicTransportInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPublicTransportInfo, _CPublicTransportInfo)>>('CArray_CPublicTransportInfo_addElement');
late final _CArray_CPublicTransportInfoaddElement = _CArray_CPublicTransportInfoaddElementPtr.asFunction<void Function(_CArray_CPublicTransportInfo, _CPublicTransportInfo)>();
late final _forEach_CArray_CPublicTransportInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CPublicTransportInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPublicTransportInfo)>>)
>>('CArray_CPublicTransportInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CPublicTransportInfo = _forEach_CArray_CPublicTransportInfoPtr.asFunction<
  void Function(_CArray_CPublicTransportInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPublicTransportInfo)
>>)>();
late final _CArray_CPublicTransportInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPublicTransportInfo)>>('CArray_CPublicTransportInfo_release');
late final _CArray_CPublicTransportInfo_release = _CArray_CPublicTransportInfo_releasePtr.asFunction<void Function(_CArray_CPublicTransportInfo)>();

late final _CArray_CPublicTransportStopmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CPublicTransportStop Function()>>('CArray_CPublicTransportStop_makeEmpty');
late final _CArray_CPublicTransportStopmakeEmpty = _CArray_CPublicTransportStopmakeEmptyPtr.asFunction<_CArray_CPublicTransportStop Function()>();
late final _CArray_CPublicTransportStopaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPublicTransportStop, _CPublicTransportStop)>>('CArray_CPublicTransportStop_addElement');
late final _CArray_CPublicTransportStopaddElement = _CArray_CPublicTransportStopaddElementPtr.asFunction<void Function(_CArray_CPublicTransportStop, _CPublicTransportStop)>();
late final _forEach_CArray_CPublicTransportStopPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CPublicTransportStop, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPublicTransportStop)>>)
>>('CArray_CPublicTransportStop_forEachWithFunctionPointer');
late final _forEach_CArray_CPublicTransportStop = _forEach_CArray_CPublicTransportStopPtr.asFunction<
  void Function(_CArray_CPublicTransportStop, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPublicTransportStop)
>>)>();
late final _CArray_CPublicTransportStop_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPublicTransportStop)>>('CArray_CPublicTransportStop_release');
late final _CArray_CPublicTransportStop_release = _CArray_CPublicTransportStop_releasePtr.asFunction<void Function(_CArray_CPublicTransportStop)>();

late final _CPublicRoutePartMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPublicRoutePart Function()>>('CPublicRoutePartMakeDefault');
late final _CPublicRoutePartMakeDefault = _CPublicRoutePartMakeDefaultPtr.asFunction<_CPublicRoutePart Function()>();


late final _CPublicTransportTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPublicTransportType Function()>>('CPublicTransportTypeMakeDefault');
late final _CPublicTransportTypeMakeDefault = _CPublicTransportTypeMakeDefaultPtr.asFunction<_CPublicTransportType Function()>();

late final _CArray_uint32_tmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_uint32_t Function()>>('CArray_uint32_t_makeEmpty');
late final _CArray_uint32_tmakeEmpty = _CArray_uint32_tmakeEmptyPtr.asFunction<_CArray_uint32_t Function()>();
late final _CArray_uint32_taddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_uint32_t, ffi.Uint32)>>('CArray_uint32_t_addElement');
late final _CArray_uint32_taddElement = _CArray_uint32_taddElementPtr.asFunction<void Function(_CArray_uint32_t, int)>();
late final _forEach_CArray_uint32_tPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_uint32_t, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>)
>>('CArray_uint32_t_forEachWithFunctionPointer');
late final _forEach_CArray_uint32_t = _forEach_CArray_uint32_tPtr.asFunction<
  void Function(_CArray_uint32_t, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)
>>)>();
late final _CArray_uint32_t_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_uint32_t)>>('CArray_uint32_t_release');
late final _CArray_uint32_t_release = _CArray_uint32_t_releasePtr.asFunction<void Function(_CArray_uint32_t)>();

late final _CPublicTransportInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPublicTransportInfo Function()>>('CPublicTransportInfoMakeDefault');
late final _CPublicTransportInfoMakeDefault = _CPublicTransportInfoMakeDefaultPtr.asFunction<_CPublicTransportInfo Function()>();


late final _CPublicTransportStopMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPublicTransportStop Function()>>('CPublicTransportStopMakeDefault');
late final _CPublicTransportStopMakeDefault = _CPublicTransportStopMakeDefaultPtr.asFunction<_CPublicTransportStop Function()>();


late final _CArray_CPublicTransportTransferRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CPublicTransportTransferRouteLongEntry Function()>>('CArray_CPublicTransportTransferRouteLongEntry_makeEmpty');
late final _CArray_CPublicTransportTransferRouteLongEntrymakeEmpty = _CArray_CPublicTransportTransferRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CPublicTransportTransferRouteLongEntry Function()>();
late final _CArray_CPublicTransportTransferRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPublicTransportTransferRouteLongEntry, _CPublicTransportTransferRouteLongEntry)>>('CArray_CPublicTransportTransferRouteLongEntry_addElement');
late final _CArray_CPublicTransportTransferRouteLongEntryaddElement = _CArray_CPublicTransportTransferRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CPublicTransportTransferRouteLongEntry, _CPublicTransportTransferRouteLongEntry)>();
late final _forEach_CArray_CPublicTransportTransferRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CPublicTransportTransferRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPublicTransportTransferRouteLongEntry)>>)
>>('CArray_CPublicTransportTransferRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CPublicTransportTransferRouteLongEntry = _forEach_CArray_CPublicTransportTransferRouteLongEntryPtr.asFunction<
  void Function(_CArray_CPublicTransportTransferRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPublicTransportTransferRouteLongEntry)
>>)>();
late final _CArray_CPublicTransportTransferRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPublicTransportTransferRouteLongEntry)>>('CArray_CPublicTransportTransferRouteLongEntry_release');
late final _CArray_CPublicTransportTransferRouteLongEntry_release = _CArray_CPublicTransportTransferRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CPublicTransportTransferRouteLongEntry)>();
late final _CTraffic_durationsPtr = _lookup<ffi.NativeFunction<_CMillisecondsRouteAttribute Function(_CTraffic)>>('CTraffic_durations');
late final _CTraffic_durations = _CTraffic_durationsPtr.asFunction<_CMillisecondsRouteAttribute Function(_CTraffic)>();
late final _CTraffic_speedColorsPtr = _lookup<ffi.NativeFunction<_CTrafficSpeedColorRouteLongAttribute Function(_CTraffic)>>('CTraffic_speedColors');
late final _CTraffic_speedColors = _CTraffic_speedColorsPtr.asFunction<_CTrafficSpeedColorRouteLongAttribute Function(_CTraffic)>();

late final _CTraffic_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTraffic_cg_objectIdentifier');
late final _CTraffic_cg_objectIdentifier = _CTraffic_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CTraffic_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTraffic_release');
late final _CTraffic_release = _CTraffic_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTraffic_retainPtr = _lookup<ffi.NativeFunction<_CTraffic Function(ffi.Pointer<ffi.Void>)>>('CTraffic_retain');
late final _CTraffic_retain = _CTraffic_retainPtr.asFunction<_CTraffic Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTraffic Function()>>('CTrafficMakeDefault');
late final _CTrafficMakeDefault = _CTrafficMakeDefaultPtr.asFunction<_CTraffic Function()>();

late final _CMillisecondsRouteAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CMillisecondsRouteAttribute)>>('CMillisecondsRouteAttribute_size');
late final _CMillisecondsRouteAttribute_size = _CMillisecondsRouteAttribute_sizePtr.asFunction<int Function(_CMillisecondsRouteAttribute)>();
late final _CMillisecondsRouteAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMillisecondsRouteAttribute)>>('CMillisecondsRouteAttribute_isEmpty');
late final _CMillisecondsRouteAttribute_isEmpty = _CMillisecondsRouteAttribute_isEmptyPtr.asFunction<bool Function(_CMillisecondsRouteAttribute)>();
late final _CMillisecondsRouteAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CMillisecondsRouteEntry Function(_CMillisecondsRouteAttribute)>>('CMillisecondsRouteAttribute_first');
late final _CMillisecondsRouteAttribute_first = _CMillisecondsRouteAttribute_firstPtr.asFunction<_COptional_CMillisecondsRouteEntry Function(_CMillisecondsRouteAttribute)>();
late final _CMillisecondsRouteAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CMillisecondsRouteEntry Function(_CMillisecondsRouteAttribute)>>('CMillisecondsRouteAttribute_last');
late final _CMillisecondsRouteAttribute_last = _CMillisecondsRouteAttribute_lastPtr.asFunction<_COptional_CMillisecondsRouteEntry Function(_CMillisecondsRouteAttribute)>();
late final _CMillisecondsRouteAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CMillisecondsRouteEntry Function(_CMillisecondsRouteAttribute)>>('CMillisecondsRouteAttribute_entries');
late final _CMillisecondsRouteAttribute_entries = _CMillisecondsRouteAttribute_entriesPtr.asFunction<_CArray_CMillisecondsRouteEntry Function(_CMillisecondsRouteAttribute)>();
late final _CMillisecondsRouteAttribute_durationPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CMillisecondsRouteAttribute)>>('CMillisecondsRouteAttribute_duration');
late final _CMillisecondsRouteAttribute_duration = _CMillisecondsRouteAttribute_durationPtr.asFunction<_CTimeInterval Function(_CMillisecondsRouteAttribute)>();

late final _CMillisecondsRouteAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMillisecondsRouteAttribute_cg_objectIdentifier');
late final _CMillisecondsRouteAttribute_cg_objectIdentifier = _CMillisecondsRouteAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMillisecondsRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CMillisecondsRouteEntry Function(_CMillisecondsRouteAttribute, _CRoutePoint, _CRoutePoint)>>('CMillisecondsRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CMillisecondsRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CMillisecondsRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CMillisecondsRouteEntry Function(_CMillisecondsRouteAttribute, _CRoutePoint, _CRoutePoint)>();
late final _CMillisecondsRouteAttribute_findNearBackward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CMillisecondsRouteEntry Function(_CMillisecondsRouteAttribute, _CRoutePoint)>>('CMillisecondsRouteAttribute_findNearBackward_CRoutePoint');
late final _CMillisecondsRouteAttribute_findNearBackward_CRoutePoint = _CMillisecondsRouteAttribute_findNearBackward_CRoutePointPtr.asFunction<_COptional_CMillisecondsRouteEntry Function(_CMillisecondsRouteAttribute, _CRoutePoint)>();
late final _CMillisecondsRouteAttribute_findNearForward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CMillisecondsRouteEntry Function(_CMillisecondsRouteAttribute, _CRoutePoint)>>('CMillisecondsRouteAttribute_findNearForward_CRoutePoint');
late final _CMillisecondsRouteAttribute_findNearForward_CRoutePoint = _CMillisecondsRouteAttribute_findNearForward_CRoutePointPtr.asFunction<_COptional_CMillisecondsRouteEntry Function(_CMillisecondsRouteAttribute, _CRoutePoint)>();
late final _CMillisecondsRouteAttribute_calculateDurationToRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CMillisecondsRouteAttribute, _CRoutePoint)>>('CMillisecondsRouteAttribute_calculateDurationToRoutePoint_CRoutePoint');
late final _CMillisecondsRouteAttribute_calculateDurationToRoutePoint_CRoutePoint = _CMillisecondsRouteAttribute_calculateDurationToRoutePoint_CRoutePointPtr.asFunction<_CTimeInterval Function(_CMillisecondsRouteAttribute, _CRoutePoint)>();
late final _CMillisecondsRouteAttribute_calculateDuration_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CMillisecondsRouteAttribute, _CRoutePoint, _CRoutePoint)>>('CMillisecondsRouteAttribute_calculateDuration_CRoutePoint_CRoutePoint');
late final _CMillisecondsRouteAttribute_calculateDuration_CRoutePoint_CRoutePoint = _CMillisecondsRouteAttribute_calculateDuration_CRoutePoint_CRoutePointPtr.asFunction<_CTimeInterval Function(_CMillisecondsRouteAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CMillisecondsRouteAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMillisecondsRouteAttribute_release');
late final _CMillisecondsRouteAttribute_release = _CMillisecondsRouteAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMillisecondsRouteAttribute_retainPtr = _lookup<ffi.NativeFunction<_CMillisecondsRouteAttribute Function(ffi.Pointer<ffi.Void>)>>('CMillisecondsRouteAttribute_retain');
late final _CMillisecondsRouteAttribute_retain = _CMillisecondsRouteAttribute_retainPtr.asFunction<_CMillisecondsRouteAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CMillisecondsRouteAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMillisecondsRouteAttribute Function()>>('CMillisecondsRouteAttributeMakeDefault');
late final _CMillisecondsRouteAttributeMakeDefault = _CMillisecondsRouteAttributeMakeDefaultPtr.asFunction<_CMillisecondsRouteAttribute Function()>();


late final _CMillisecondsRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMillisecondsRouteEntry Function()>>('CMillisecondsRouteEntryMakeDefault');
late final _CMillisecondsRouteEntryMakeDefault = _CMillisecondsRouteEntryMakeDefaultPtr.asFunction<_CMillisecondsRouteEntry Function()>();


late final _COptional_CMillisecondsRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CMillisecondsRouteEntry Function()>>('COptional_CMillisecondsRouteEntryMakeDefault');
late final _COptional_CMillisecondsRouteEntryMakeDefault = _COptional_CMillisecondsRouteEntryMakeDefaultPtr.asFunction<_COptional_CMillisecondsRouteEntry Function()>();

late final _CArray_CMillisecondsRouteEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CMillisecondsRouteEntry Function()>>('CArray_CMillisecondsRouteEntry_makeEmpty');
late final _CArray_CMillisecondsRouteEntrymakeEmpty = _CArray_CMillisecondsRouteEntrymakeEmptyPtr.asFunction<_CArray_CMillisecondsRouteEntry Function()>();
late final _CArray_CMillisecondsRouteEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CMillisecondsRouteEntry, _CMillisecondsRouteEntry)>>('CArray_CMillisecondsRouteEntry_addElement');
late final _CArray_CMillisecondsRouteEntryaddElement = _CArray_CMillisecondsRouteEntryaddElementPtr.asFunction<void Function(_CArray_CMillisecondsRouteEntry, _CMillisecondsRouteEntry)>();
late final _forEach_CArray_CMillisecondsRouteEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CMillisecondsRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMillisecondsRouteEntry)>>)
>>('CArray_CMillisecondsRouteEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CMillisecondsRouteEntry = _forEach_CArray_CMillisecondsRouteEntryPtr.asFunction<
  void Function(_CArray_CMillisecondsRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMillisecondsRouteEntry)
>>)>();
late final _CArray_CMillisecondsRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CMillisecondsRouteEntry)>>('CArray_CMillisecondsRouteEntry_release');
late final _CArray_CMillisecondsRouteEntry_release = _CArray_CMillisecondsRouteEntry_releasePtr.asFunction<void Function(_CArray_CMillisecondsRouteEntry)>();
late final _CTrafficSpeedColorRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CTrafficSpeedColorRouteLongAttribute)>>('CTrafficSpeedColorRouteLongAttribute_size');
late final _CTrafficSpeedColorRouteLongAttribute_size = _CTrafficSpeedColorRouteLongAttribute_sizePtr.asFunction<int Function(_CTrafficSpeedColorRouteLongAttribute)>();
late final _CTrafficSpeedColorRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CTrafficSpeedColorRouteLongAttribute)>>('CTrafficSpeedColorRouteLongAttribute_isEmpty');
late final _CTrafficSpeedColorRouteLongAttribute_isEmpty = _CTrafficSpeedColorRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CTrafficSpeedColorRouteLongAttribute)>();
late final _CTrafficSpeedColorRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CTrafficSpeedColorRouteLongEntry Function(_CTrafficSpeedColorRouteLongAttribute)>>('CTrafficSpeedColorRouteLongAttribute_first');
late final _CTrafficSpeedColorRouteLongAttribute_first = _CTrafficSpeedColorRouteLongAttribute_firstPtr.asFunction<_COptional_CTrafficSpeedColorRouteLongEntry Function(_CTrafficSpeedColorRouteLongAttribute)>();
late final _CTrafficSpeedColorRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CTrafficSpeedColorRouteLongEntry Function(_CTrafficSpeedColorRouteLongAttribute)>>('CTrafficSpeedColorRouteLongAttribute_last');
late final _CTrafficSpeedColorRouteLongAttribute_last = _CTrafficSpeedColorRouteLongAttribute_lastPtr.asFunction<_COptional_CTrafficSpeedColorRouteLongEntry Function(_CTrafficSpeedColorRouteLongAttribute)>();
late final _CTrafficSpeedColorRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CTrafficSpeedColorRouteLongEntry Function(_CTrafficSpeedColorRouteLongAttribute)>>('CTrafficSpeedColorRouteLongAttribute_entries');
late final _CTrafficSpeedColorRouteLongAttribute_entries = _CTrafficSpeedColorRouteLongAttribute_entriesPtr.asFunction<_CArray_CTrafficSpeedColorRouteLongEntry Function(_CTrafficSpeedColorRouteLongAttribute)>();

late final _CTrafficSpeedColorRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTrafficSpeedColorRouteLongAttribute_cg_objectIdentifier');
late final _CTrafficSpeedColorRouteLongAttribute_cg_objectIdentifier = _CTrafficSpeedColorRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTrafficSpeedColorRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CTrafficSpeedColorRouteLongEntry Function(_CTrafficSpeedColorRouteLongAttribute, _CRoutePoint)>>('CTrafficSpeedColorRouteLongAttribute_entry_CRoutePoint');
late final _CTrafficSpeedColorRouteLongAttribute_entry_CRoutePoint = _CTrafficSpeedColorRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CTrafficSpeedColorRouteLongEntry Function(_CTrafficSpeedColorRouteLongAttribute, _CRoutePoint)>();
late final _CTrafficSpeedColorRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CTrafficSpeedColorRouteLongEntry Function(_CTrafficSpeedColorRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CTrafficSpeedColorRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CTrafficSpeedColorRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CTrafficSpeedColorRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CTrafficSpeedColorRouteLongEntry Function(_CTrafficSpeedColorRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CTrafficSpeedColorRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTrafficSpeedColorRouteLongAttribute_release');
late final _CTrafficSpeedColorRouteLongAttribute_release = _CTrafficSpeedColorRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficSpeedColorRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CTrafficSpeedColorRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CTrafficSpeedColorRouteLongAttribute_retain');
late final _CTrafficSpeedColorRouteLongAttribute_retain = _CTrafficSpeedColorRouteLongAttribute_retainPtr.asFunction<_CTrafficSpeedColorRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficSpeedColorRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficSpeedColorRouteLongAttribute Function()>>('CTrafficSpeedColorRouteLongAttributeMakeDefault');
late final _CTrafficSpeedColorRouteLongAttributeMakeDefault = _CTrafficSpeedColorRouteLongAttributeMakeDefaultPtr.asFunction<_CTrafficSpeedColorRouteLongAttribute Function()>();


late final _CTrafficSpeedColorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficSpeedColor Function()>>('CTrafficSpeedColorMakeDefault');
late final _CTrafficSpeedColorMakeDefault = _CTrafficSpeedColorMakeDefaultPtr.asFunction<_CTrafficSpeedColor Function()>();

late final _CTrafficSpeedColorRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficSpeedColorRouteLongEntry Function()>>('CTrafficSpeedColorRouteLongEntryMakeDefault');
late final _CTrafficSpeedColorRouteLongEntryMakeDefault = _CTrafficSpeedColorRouteLongEntryMakeDefaultPtr.asFunction<_CTrafficSpeedColorRouteLongEntry Function()>();


late final _COptional_CTrafficSpeedColorRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CTrafficSpeedColorRouteLongEntry Function()>>('COptional_CTrafficSpeedColorRouteLongEntryMakeDefault');
late final _COptional_CTrafficSpeedColorRouteLongEntryMakeDefault = _COptional_CTrafficSpeedColorRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CTrafficSpeedColorRouteLongEntry Function()>();

late final _CArray_CTrafficSpeedColorRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CTrafficSpeedColorRouteLongEntry Function()>>('CArray_CTrafficSpeedColorRouteLongEntry_makeEmpty');
late final _CArray_CTrafficSpeedColorRouteLongEntrymakeEmpty = _CArray_CTrafficSpeedColorRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CTrafficSpeedColorRouteLongEntry Function()>();
late final _CArray_CTrafficSpeedColorRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CTrafficSpeedColorRouteLongEntry, _CTrafficSpeedColorRouteLongEntry)>>('CArray_CTrafficSpeedColorRouteLongEntry_addElement');
late final _CArray_CTrafficSpeedColorRouteLongEntryaddElement = _CArray_CTrafficSpeedColorRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CTrafficSpeedColorRouteLongEntry, _CTrafficSpeedColorRouteLongEntry)>();
late final _forEach_CArray_CTrafficSpeedColorRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CTrafficSpeedColorRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTrafficSpeedColorRouteLongEntry)>>)
>>('CArray_CTrafficSpeedColorRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CTrafficSpeedColorRouteLongEntry = _forEach_CArray_CTrafficSpeedColorRouteLongEntryPtr.asFunction<
  void Function(_CArray_CTrafficSpeedColorRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTrafficSpeedColorRouteLongEntry)
>>)>();
late final _CArray_CTrafficSpeedColorRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CTrafficSpeedColorRouteLongEntry)>>('CArray_CTrafficSpeedColorRouteLongEntry_release');
late final _CArray_CTrafficSpeedColorRouteLongEntry_release = _CArray_CTrafficSpeedColorRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CTrafficSpeedColorRouteLongEntry)>();

late final _CStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CState Function()>>('CStateMakeDefault');
late final _CStateMakeDefault = _CStateMakeDefaultPtr.asFunction<_CState Function()>();
late final _CPackedNavigationState_trafficRoutePtr = _lookup<ffi.NativeFunction<_CTrafficRoute Function(_CPackedNavigationState)>>('CPackedNavigationState_trafficRoute');
late final _CPackedNavigationState_trafficRoute = _CPackedNavigationState_trafficRoutePtr.asFunction<_CTrafficRoute Function(_CPackedNavigationState)>();
late final _CPackedNavigationState_setTrafficRoute_CTrafficRoutePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackedNavigationState, _CTrafficRoute)>>('CPackedNavigationState_setTrafficRoute_CTrafficRoute');
late final _CPackedNavigationState_setTrafficRoute_CTrafficRoute = _CPackedNavigationState_setTrafficRoute_CTrafficRoutePtr.asFunction<void Function(_CPackedNavigationState, _CTrafficRoute)>();
late final _CPackedNavigationState_finishPointPtr = _lookup<ffi.NativeFunction<_COptional_CRouteSearchPoint Function(_CPackedNavigationState)>>('CPackedNavigationState_finishPoint');
late final _CPackedNavigationState_finishPoint = _CPackedNavigationState_finishPointPtr.asFunction<_COptional_CRouteSearchPoint Function(_CPackedNavigationState)>();
late final _CPackedNavigationState_setFinishPoint_COptional_CRouteSearchPointPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackedNavigationState, _COptional_CRouteSearchPoint)>>('CPackedNavigationState_setFinishPoint_COptional_CRouteSearchPoint');
late final _CPackedNavigationState_setFinishPoint_COptional_CRouteSearchPoint = _CPackedNavigationState_setFinishPoint_COptional_CRouteSearchPointPtr.asFunction<void Function(_CPackedNavigationState, _COptional_CRouteSearchPoint)>();
late final _CPackedNavigationState_routeSearchOptionsPtr = _lookup<ffi.NativeFunction<_COptional_CRouteSearchOptions Function(_CPackedNavigationState)>>('CPackedNavigationState_routeSearchOptions');
late final _CPackedNavigationState_routeSearchOptions = _CPackedNavigationState_routeSearchOptionsPtr.asFunction<_COptional_CRouteSearchOptions Function(_CPackedNavigationState)>();
late final _CPackedNavigationState_setRouteSearchOptions_COptional_CRouteSearchOptionsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackedNavigationState, _COptional_CRouteSearchOptions)>>('CPackedNavigationState_setRouteSearchOptions_COptional_CRouteSearchOptions');
late final _CPackedNavigationState_setRouteSearchOptions_COptional_CRouteSearchOptions = _CPackedNavigationState_setRouteSearchOptions_COptional_CRouteSearchOptionsPtr.asFunction<void Function(_CPackedNavigationState, _COptional_CRouteSearchOptions)>();
late final _CPackedNavigationState_routePositionPtr = _lookup<ffi.NativeFunction<_COptional_CRoutePoint Function(_CPackedNavigationState)>>('CPackedNavigationState_routePosition');
late final _CPackedNavigationState_routePosition = _CPackedNavigationState_routePositionPtr.asFunction<_COptional_CRoutePoint Function(_CPackedNavigationState)>();
late final _CPackedNavigationState_setRoutePosition_COptional_CRoutePointPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackedNavigationState, _COptional_CRoutePoint)>>('CPackedNavigationState_setRoutePosition_COptional_CRoutePoint');
late final _CPackedNavigationState_setRoutePosition_COptional_CRoutePoint = _CPackedNavigationState_setRoutePosition_COptional_CRoutePointPtr.asFunction<void Function(_CPackedNavigationState, _COptional_CRoutePoint)>();
late final _CPackedNavigationState_statePtr = _lookup<ffi.NativeFunction<_CState Function(_CPackedNavigationState)>>('CPackedNavigationState_state');
late final _CPackedNavigationState_state = _CPackedNavigationState_statePtr.asFunction<_CState Function(_CPackedNavigationState)>();
late final _CPackedNavigationState_setState_CStatePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackedNavigationState, _CState)>>('CPackedNavigationState_setState_CState');
late final _CPackedNavigationState_setState_CState = _CPackedNavigationState_setState_CStatePtr.asFunction<void Function(_CPackedNavigationState, _CState)>();

late final _CPackedNavigationState_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPackedNavigationState_cg_objectIdentifier');
late final _CPackedNavigationState_cg_objectIdentifier = _CPackedNavigationState_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPackedNavigationState_S_of_CTrafficRoute_COptional_CRouteSearchOptions_COptional_CRouteSearchPoint_COptional_CRoutePoint_CStatePtr = _lookup<ffi.NativeFunction<_CPackedNavigationState Function(_CTrafficRoute, _COptional_CRouteSearchOptions, _COptional_CRouteSearchPoint, _COptional_CRoutePoint, _CState)>>('CPackedNavigationState_S_of_CTrafficRoute_COptional_CRouteSearchOptions_COptional_CRouteSearchPoint_COptional_CRoutePoint_CState');
late final _CPackedNavigationState_S_of_CTrafficRoute_COptional_CRouteSearchOptions_COptional_CRouteSearchPoint_COptional_CRoutePoint_CState = _CPackedNavigationState_S_of_CTrafficRoute_COptional_CRouteSearchOptions_COptional_CRouteSearchPoint_COptional_CRoutePoint_CStatePtr.asFunction<_CPackedNavigationState Function(_CTrafficRoute, _COptional_CRouteSearchOptions, _COptional_CRouteSearchPoint, _COptional_CRoutePoint, _CState)>();
late final _CPackedNavigationState_S_fromBytes_CDataPtr = _lookup<ffi.NativeFunction<_CResult_CPackedNavigationState Function(_CData)>>('CPackedNavigationState_S_fromBytes_CData');
late final _CPackedNavigationState_S_fromBytes_CData = _CPackedNavigationState_S_fromBytes_CDataPtr.asFunction<_CResult_CPackedNavigationState Function(_CData)>();
late final _CPackedNavigationState_S_fromModel_CModelPtr = _lookup<ffi.NativeFunction<_CPackedNavigationState Function(_CModel)>>('CPackedNavigationState_S_fromModel_CModel');
late final _CPackedNavigationState_S_fromModel_CModel = _CPackedNavigationState_S_fromModel_CModelPtr.asFunction<_CPackedNavigationState Function(_CModel)>();
late final _CPackedNavigationState_toBytesPtr = _lookup<ffi.NativeFunction<_CData Function(_CPackedNavigationState)>>('CPackedNavigationState_toBytes');
late final _CPackedNavigationState_toBytes = _CPackedNavigationState_toBytesPtr.asFunction<_CData Function(_CPackedNavigationState)>();

late final _CPackedNavigationState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPackedNavigationState_release');
late final _CPackedNavigationState_release = _CPackedNavigationState_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPackedNavigationState_retainPtr = _lookup<ffi.NativeFunction<_CPackedNavigationState Function(ffi.Pointer<ffi.Void>)>>('CPackedNavigationState_retain');
late final _CPackedNavigationState_retain = _CPackedNavigationState_retainPtr.asFunction<_CPackedNavigationState Function(ffi.Pointer<ffi.Void>)>();
late final _CPackedNavigationStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPackedNavigationState Function()>>('CPackedNavigationStateMakeDefault');
late final _CPackedNavigationStateMakeDefault = _CPackedNavigationStateMakeDefaultPtr.asFunction<_CPackedNavigationState Function()>();


late final _CArray_CExcludedAreamakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CExcludedArea Function()>>('CArray_CExcludedArea_makeEmpty');
late final _CArray_CExcludedAreamakeEmpty = _CArray_CExcludedAreamakeEmptyPtr.asFunction<_CArray_CExcludedArea Function()>();
late final _CArray_CExcludedAreaaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CExcludedArea, _CExcludedArea)>>('CArray_CExcludedArea_addElement');
late final _CArray_CExcludedAreaaddElement = _CArray_CExcludedAreaaddElementPtr.asFunction<void Function(_CArray_CExcludedArea, _CExcludedArea)>();
late final _forEach_CArray_CExcludedAreaPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CExcludedArea, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CExcludedArea)>>)
>>('CArray_CExcludedArea_forEachWithFunctionPointer');
late final _forEach_CArray_CExcludedArea = _forEach_CArray_CExcludedAreaPtr.asFunction<
  void Function(_CArray_CExcludedArea, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CExcludedArea)
>>)>();
late final _CArray_CExcludedArea_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CExcludedArea)>>('CArray_CExcludedArea_release');
late final _CArray_CExcludedArea_release = _CArray_CExcludedArea_releasePtr.asFunction<void Function(_CArray_CExcludedArea)>();

late final _CBicycleRouteSearchOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBicycleRouteSearchOptions Function()>>('CBicycleRouteSearchOptionsMakeDefault');
late final _CBicycleRouteSearchOptionsMakeDefault = _CBicycleRouteSearchOptionsMakeDefaultPtr.asFunction<_CBicycleRouteSearchOptions Function()>();


late final _CRouteSearchTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteSearchType Function()>>('CRouteSearchTypeMakeDefault');
late final _CRouteSearchTypeMakeDefault = _CRouteSearchTypeMakeDefaultPtr.asFunction<_CRouteSearchType Function()>();

late final _CCarRouteSearchOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCarRouteSearchOptions Function()>>('CCarRouteSearchOptionsMakeDefault');
late final _CCarRouteSearchOptionsMakeDefault = _CCarRouteSearchOptionsMakeDefaultPtr.asFunction<_CCarRouteSearchOptions Function()>();


late final _CPedestrianRouteSearchOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPedestrianRouteSearchOptions Function()>>('CPedestrianRouteSearchOptionsMakeDefault');
late final _CPedestrianRouteSearchOptionsMakeDefault = _CPedestrianRouteSearchOptionsMakeDefaultPtr.asFunction<_CPedestrianRouteSearchOptions Function()>();


late final _COptionSet_CPublicTransportTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CPublicTransportType Function()>>('COptionSet_CPublicTransportTypeMakeDefault');
late final _COptionSet_CPublicTransportTypeMakeDefault = _COptionSet_CPublicTransportTypeMakeDefaultPtr.asFunction<_COptionSet_CPublicTransportType Function()>();

late final _CPublicTransportRouteSearchOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPublicTransportRouteSearchOptions Function()>>('CPublicTransportRouteSearchOptionsMakeDefault');
late final _CPublicTransportRouteSearchOptionsMakeDefault = _CPublicTransportRouteSearchOptionsMakeDefaultPtr.asFunction<_CPublicTransportRouteSearchOptions Function()>();


late final _CScooterRouteSearchOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScooterRouteSearchOptions Function()>>('CScooterRouteSearchOptionsMakeDefault');
late final _CScooterRouteSearchOptionsMakeDefault = _CScooterRouteSearchOptionsMakeDefaultPtr.asFunction<_CScooterRouteSearchOptions Function()>();


late final _CTaxiRouteSearchOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTaxiRouteSearchOptions Function()>>('CTaxiRouteSearchOptionsMakeDefault');
late final _CTaxiRouteSearchOptionsMakeDefault = _CTaxiRouteSearchOptionsMakeDefaultPtr.asFunction<_CTaxiRouteSearchOptions Function()>();


late final _CSet_CTruckPassZonePassIdmakeEmptyPtr = _lookup<ffi.NativeFunction<_CSet_CTruckPassZonePassId Function()>>('CSet_CTruckPassZonePassId_makeEmpty');
late final _CSet_CTruckPassZonePassIdmakeEmpty = _CSet_CTruckPassZonePassIdmakeEmptyPtr.asFunction<_CSet_CTruckPassZonePassId Function()>();
late final _CSet_CTruckPassZonePassIdaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSet_CTruckPassZonePassId, _CTruckPassZonePassId)>>('CSet_CTruckPassZonePassId_addElement');
late final _CSet_CTruckPassZonePassIdaddElement = _CSet_CTruckPassZonePassIdaddElementPtr.asFunction<void Function(_CSet_CTruckPassZonePassId, _CTruckPassZonePassId)>();
late final _forEach_CSet_CTruckPassZonePassIdPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CSet_CTruckPassZonePassId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTruckPassZonePassId)>>)
>>('CSet_CTruckPassZonePassId_forEachWithFunctionPointer');
late final _forEach_CSet_CTruckPassZonePassId = _forEach_CSet_CTruckPassZonePassIdPtr.asFunction<
  void Function(_CSet_CTruckPassZonePassId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTruckPassZonePassId)
>>)>();
late final _CSet_CTruckPassZonePassId_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSet_CTruckPassZonePassId)>>('CSet_CTruckPassZonePassId_release');
late final _CSet_CTruckPassZonePassId_release = _CSet_CTruckPassZonePassId_releasePtr.asFunction<void Function(_CSet_CTruckPassZonePassId)>();

late final _CTruckRouteSearchOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTruckRouteSearchOptions Function()>>('CTruckRouteSearchOptionsMakeDefault');
late final _CTruckRouteSearchOptionsMakeDefault = _CTruckRouteSearchOptionsMakeDefaultPtr.asFunction<_CTruckRouteSearchOptions Function()>();


late final _CRouteSearchOptions_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteSearchOptions)>>('CRouteSearchOptions_release');
late final _CRouteSearchOptions_release = _CRouteSearchOptions_releasePtr.asFunction<void Function(_CRouteSearchOptions)>();
late final _CRouteSearchOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteSearchOptions Function()>>('CRouteSearchOptionsMakeDefault');
late final _CRouteSearchOptionsMakeDefault = _CRouteSearchOptionsMakeDefaultPtr.asFunction<_CRouteSearchOptions Function()>();

late final _COptional_CRouteSearchOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRouteSearchOptions Function()>>('COptional_CRouteSearchOptionsMakeDefault');
late final _COptional_CRouteSearchOptionsMakeDefault = _COptional_CRouteSearchOptionsMakeDefaultPtr.asFunction<_COptional_CRouteSearchOptions Function()>();

late final _COptional_CRouteSearchOptions_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CRouteSearchOptions)>>('COptional_CRouteSearchOptions_release');
late final _COptional_CRouteSearchOptions_release = _COptional_CRouteSearchOptions_releasePtr.asFunction<void Function(_COptional_CRouteSearchOptions)>();

late final _CExcludedAreaTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CExcludedAreaType Function()>>('CExcludedAreaTypeMakeDefault');
late final _CExcludedAreaTypeMakeDefault = _CExcludedAreaTypeMakeDefaultPtr.asFunction<_CExcludedAreaType Function()>();

late final _CExcludedAreaSeverityMakeDefaultPtr = _lookup<ffi.NativeFunction<_CExcludedAreaSeverity Function()>>('CExcludedAreaSeverityMakeDefault');
late final _CExcludedAreaSeverityMakeDefault = _CExcludedAreaSeverityMakeDefaultPtr.asFunction<_CExcludedAreaSeverity Function()>();

late final _CExcludedAreaMakeDefaultPtr = _lookup<ffi.NativeFunction<_CExcludedArea Function()>>('CExcludedAreaMakeDefault');
late final _CExcludedAreaMakeDefault = _CExcludedAreaMakeDefaultPtr.asFunction<_CExcludedArea Function()>();


late final _CTruckPassZonePassIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTruckPassZonePassId Function()>>('CTruckPassZonePassIdMakeDefault');
late final _CTruckPassZonePassIdMakeDefault = _CTruckPassZonePassIdMakeDefaultPtr.asFunction<_CTruckPassZonePassId Function()>();


late final _CRouteSearchPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteSearchPoint Function()>>('CRouteSearchPointMakeDefault');
late final _CRouteSearchPointMakeDefault = _CRouteSearchPointMakeDefaultPtr.asFunction<_CRouteSearchPoint Function()>();


late final _COptional_CRouteSearchPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRouteSearchPoint Function()>>('COptional_CRouteSearchPointMakeDefault');
late final _COptional_CRouteSearchPointMakeDefault = _COptional_CRouteSearchPointMakeDefaultPtr.asFunction<_COptional_CRouteSearchPoint Function()>();

late final _CResult_CPackedNavigationState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CPackedNavigationState)>>('CResult_CPackedNavigationState_release');
late final _CResult_CPackedNavigationState_release = _CResult_CPackedNavigationState_releasePtr.asFunction<void Function(_CResult_CPackedNavigationState)>();

late final _CBetterRouteResponseMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBetterRouteResponse Function()>>('CBetterRouteResponseMakeDefault');
late final _CBetterRouteResponseMakeDefault = _CBetterRouteResponseMakeDefaultPtr.asFunction<_CBetterRouteResponse Function()>();
late final _CModel_stateChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CState Function(_CModel)>>('CModel_stateChannel');
late final _CModel_stateChannel = _CModel_stateChannelPtr.asFunction<_CStatefulChannel_CState Function(_CModel)>();
late final _CModel_statePtr = _lookup<ffi.NativeFunction<_CState Function(_CModel)>>('CModel_state');
late final _CModel_state = _CModel_statePtr.asFunction<_CState Function(_CModel)>();
late final _CModel_locationChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CLocation Function(_CModel)>>('CModel_locationChannel');
late final _CModel_locationChannel = _CModel_locationChannelPtr.asFunction<_CStatefulChannel_COptional_CLocation Function(_CModel)>();
late final _CModel_locationPtr = _lookup<ffi.NativeFunction<_COptional_CLocation Function(_CModel)>>('CModel_location');
late final _CModel_location = _CModel_locationPtr.asFunction<_COptional_CLocation Function(_CModel)>();
late final _CModel_locationAvailableChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CModel)>>('CModel_locationAvailableChannel');
late final _CModel_locationAvailableChannel = _CModel_locationAvailableChannelPtr.asFunction<_CStatefulChannel_bool Function(_CModel)>();
late final _CModel_locationAvailablePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CModel)>>('CModel_locationAvailable');
late final _CModel_locationAvailable = _CModel_locationAvailablePtr.asFunction<bool Function(_CModel)>();
late final _CModel_routeChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteInfo Function(_CModel)>>('CModel_routeChannel');
late final _CModel_routeChannel = _CModel_routeChannelPtr.asFunction<_CStatefulChannel_CRouteInfo Function(_CModel)>();
late final _CModel_routePtr = _lookup<ffi.NativeFunction<_CRouteInfo Function(_CModel)>>('CModel_route');
late final _CModel_route = _CModel_routePtr.asFunction<_CRouteInfo Function(_CModel)>();
late final _CModel_dynamicRouteInfoChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDynamicRouteInfo Function(_CModel)>>('CModel_dynamicRouteInfoChannel');
late final _CModel_dynamicRouteInfoChannel = _CModel_dynamicRouteInfoChannelPtr.asFunction<_CStatefulChannel_CDynamicRouteInfo Function(_CModel)>();
late final _CModel_dynamicRouteInfoPtr = _lookup<ffi.NativeFunction<_CDynamicRouteInfo Function(_CModel)>>('CModel_dynamicRouteInfo');
late final _CModel_dynamicRouteInfo = _CModel_dynamicRouteInfoPtr.asFunction<_CDynamicRouteInfo Function(_CModel)>();
late final _CModel_routePositionChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CRoutePoint Function(_CModel)>>('CModel_routePositionChannel');
late final _CModel_routePositionChannel = _CModel_routePositionChannelPtr.asFunction<_CStatefulChannel_COptional_CRoutePoint Function(_CModel)>();
late final _CModel_routePositionPtr = _lookup<ffi.NativeFunction<_COptional_CRoutePoint Function(_CModel)>>('CModel_routePosition');
late final _CModel_routePosition = _CModel_routePositionPtr.asFunction<_COptional_CRoutePoint Function(_CModel)>();
late final _CModel_exceedingMaxSpeedLimitChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CModel)>>('CModel_exceedingMaxSpeedLimitChannel');
late final _CModel_exceedingMaxSpeedLimitChannel = _CModel_exceedingMaxSpeedLimitChannelPtr.asFunction<_CStatefulChannel_bool Function(_CModel)>();
late final _CModel_exceedingMaxSpeedLimitPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CModel)>>('CModel_exceedingMaxSpeedLimit');
late final _CModel_exceedingMaxSpeedLimit = _CModel_exceedingMaxSpeedLimitPtr.asFunction<bool Function(_CModel)>();
late final _CModel_betterRouteChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CBetterRouteInfo Function(_CModel)>>('CModel_betterRouteChannel');
late final _CModel_betterRouteChannel = _CModel_betterRouteChannelPtr.asFunction<_CStatefulChannel_COptional_CBetterRouteInfo Function(_CModel)>();
late final _CModel_betterRoutePtr = _lookup<ffi.NativeFunction<_COptional_CBetterRouteInfo Function(_CModel)>>('CModel_betterRoute');
late final _CModel_betterRoute = _CModel_betterRoutePtr.asFunction<_COptional_CBetterRouteInfo Function(_CModel)>();

late final _CModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CModel_cg_objectIdentifier');
late final _CModel_cg_objectIdentifier = _CModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CModel_betterRouteResponse_CBetterRouteResponsePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModel, _CBetterRouteResponse)>>('CModel_betterRouteResponse_CBetterRouteResponse');
late final _CModel_betterRouteResponse_CBetterRouteResponse = _CModel_betterRouteResponse_CBetterRouteResponsePtr.asFunction<void Function(_CModel, _CBetterRouteResponse)>();

late final _CModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CModel_release');
late final _CModel_release = _CModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CModel_retainPtr = _lookup<ffi.NativeFunction<_CModel Function(ffi.Pointer<ffi.Void>)>>('CModel_retain');
late final _CModel_retain = _CModel_retainPtr.asFunction<_CModel Function(ffi.Pointer<ffi.Void>)>();
late final _CModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModel Function()>>('CModelMakeDefault');
late final _CModelMakeDefault = _CModelMakeDefaultPtr.asFunction<_CModel Function()>();


late final _CStatefulChannel_CStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CState Function()>>('CStatefulChannel_CStateMakeDefault');
late final _CStatefulChannel_CStateMakeDefault = _CStatefulChannel_CStateMakeDefaultPtr.asFunction<_CStatefulChannel_CState Function()>();
late final _CStatefulChannel_CState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CState)>>('CStatefulChannel_CState_release');
late final _CStatefulChannel_CState_release = _CStatefulChannel_CState_releasePtr.asFunction<void Function(_CStatefulChannel_CState)>();
late final _CStatefulChannel_CState_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CState Function(_CStatefulChannel_CState)>>('CStatefulChannel_CState_retain');
late final _CStatefulChannel_CState_retain = _CStatefulChannel_CState_retainPtr.asFunction<_CStatefulChannel_CState Function(_CStatefulChannel_CState)>();
late final _CStatefulChannel_CStateGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CState Function(_CStatefulChannel_CState)>>('CStatefulChannel_CState_getCurrentValue');
late final _CStatefulChannel_CStateGetCurrentValue = _CStatefulChannel_CStateGetCurrentValuePtr.asFunction<_CState Function(_CStatefulChannel_CState)>();
late final _CStatefulChannel_CStateConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CState,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CState, ffi.Int64)>>
  )
>>('CStatefulChannel_CState_connect');
late final _CStatefulChannel_CStateConnect = _CStatefulChannel_CStateConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CState,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CState, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_COptional_CLocationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CLocation Function()>>('CStatefulChannel_COptional_CLocationMakeDefault');
late final _CStatefulChannel_COptional_CLocationMakeDefault = _CStatefulChannel_COptional_CLocationMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CLocation Function()>();
late final _CStatefulChannel_COptional_CLocation_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CLocation)>>('CStatefulChannel_COptional_CLocation_release');
late final _CStatefulChannel_COptional_CLocation_release = _CStatefulChannel_COptional_CLocation_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CLocation)>();
late final _CStatefulChannel_COptional_CLocation_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CLocation Function(_CStatefulChannel_COptional_CLocation)>>('CStatefulChannel_COptional_CLocation_retain');
late final _CStatefulChannel_COptional_CLocation_retain = _CStatefulChannel_COptional_CLocation_retainPtr.asFunction<_CStatefulChannel_COptional_CLocation Function(_CStatefulChannel_COptional_CLocation)>();
late final _CStatefulChannel_COptional_CLocationGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CLocation Function(_CStatefulChannel_COptional_CLocation)>>('CStatefulChannel_COptional_CLocation_getCurrentValue');
late final _CStatefulChannel_COptional_CLocationGetCurrentValue = _CStatefulChannel_COptional_CLocationGetCurrentValuePtr.asFunction<_COptional_CLocation Function(_CStatefulChannel_COptional_CLocation)>();
late final _CStatefulChannel_COptional_CLocationConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CLocation,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CLocation, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CLocation_connect');
late final _CStatefulChannel_COptional_CLocationConnect = _CStatefulChannel_COptional_CLocationConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CLocation,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CLocation, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteInfo Function()>>('CStatefulChannel_CRouteInfoMakeDefault');
late final _CStatefulChannel_CRouteInfoMakeDefault = _CStatefulChannel_CRouteInfoMakeDefaultPtr.asFunction<_CStatefulChannel_CRouteInfo Function()>();
late final _CStatefulChannel_CRouteInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CRouteInfo)>>('CStatefulChannel_CRouteInfo_release');
late final _CStatefulChannel_CRouteInfo_release = _CStatefulChannel_CRouteInfo_releasePtr.asFunction<void Function(_CStatefulChannel_CRouteInfo)>();
late final _CStatefulChannel_CRouteInfo_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteInfo Function(_CStatefulChannel_CRouteInfo)>>('CStatefulChannel_CRouteInfo_retain');
late final _CStatefulChannel_CRouteInfo_retain = _CStatefulChannel_CRouteInfo_retainPtr.asFunction<_CStatefulChannel_CRouteInfo Function(_CStatefulChannel_CRouteInfo)>();
late final _CStatefulChannel_CRouteInfoGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CRouteInfo Function(_CStatefulChannel_CRouteInfo)>>('CStatefulChannel_CRouteInfo_getCurrentValue');
late final _CStatefulChannel_CRouteInfoGetCurrentValue = _CStatefulChannel_CRouteInfoGetCurrentValuePtr.asFunction<_CRouteInfo Function(_CStatefulChannel_CRouteInfo)>();
late final _CStatefulChannel_CRouteInfoConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CRouteInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteInfo, ffi.Int64)>>
  )
>>('CStatefulChannel_CRouteInfo_connect');
late final _CStatefulChannel_CRouteInfoConnect = _CStatefulChannel_CRouteInfoConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CRouteInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteInfo, ffi.Int64)>>
  )
>();

late final _CRouteBuildOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteBuildOptions Function()>>('CRouteBuildOptionsMakeDefault');
late final _CRouteBuildOptionsMakeDefault = _CRouteBuildOptionsMakeDefaultPtr.asFunction<_CRouteBuildOptions Function()>();


late final _COptional_CRouteBuildOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRouteBuildOptions Function()>>('COptional_CRouteBuildOptionsMakeDefault');
late final _COptional_CRouteBuildOptionsMakeDefault = _COptional_CRouteBuildOptionsMakeDefaultPtr.asFunction<_COptional_CRouteBuildOptions Function()>();

late final _COptional_CRouteBuildOptions_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CRouteBuildOptions)>>('COptional_CRouteBuildOptions_release');
late final _COptional_CRouteBuildOptions_release = _COptional_CRouteBuildOptions_releasePtr.asFunction<void Function(_COptional_CRouteBuildOptions)>();

late final _CRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteInfo Function()>>('CRouteInfoMakeDefault');
late final _CRouteInfoMakeDefault = _CRouteInfoMakeDefaultPtr.asFunction<_CRouteInfo Function()>();


late final _CStatefulChannel_CDynamicRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDynamicRouteInfo Function()>>('CStatefulChannel_CDynamicRouteInfoMakeDefault');
late final _CStatefulChannel_CDynamicRouteInfoMakeDefault = _CStatefulChannel_CDynamicRouteInfoMakeDefaultPtr.asFunction<_CStatefulChannel_CDynamicRouteInfo Function()>();
late final _CStatefulChannel_CDynamicRouteInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CDynamicRouteInfo)>>('CStatefulChannel_CDynamicRouteInfo_release');
late final _CStatefulChannel_CDynamicRouteInfo_release = _CStatefulChannel_CDynamicRouteInfo_releasePtr.asFunction<void Function(_CStatefulChannel_CDynamicRouteInfo)>();
late final _CStatefulChannel_CDynamicRouteInfo_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDynamicRouteInfo Function(_CStatefulChannel_CDynamicRouteInfo)>>('CStatefulChannel_CDynamicRouteInfo_retain');
late final _CStatefulChannel_CDynamicRouteInfo_retain = _CStatefulChannel_CDynamicRouteInfo_retainPtr.asFunction<_CStatefulChannel_CDynamicRouteInfo Function(_CStatefulChannel_CDynamicRouteInfo)>();
late final _CStatefulChannel_CDynamicRouteInfoGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CDynamicRouteInfo Function(_CStatefulChannel_CDynamicRouteInfo)>>('CStatefulChannel_CDynamicRouteInfo_getCurrentValue');
late final _CStatefulChannel_CDynamicRouteInfoGetCurrentValue = _CStatefulChannel_CDynamicRouteInfoGetCurrentValuePtr.asFunction<_CDynamicRouteInfo Function(_CStatefulChannel_CDynamicRouteInfo)>();
late final _CStatefulChannel_CDynamicRouteInfoConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CDynamicRouteInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDynamicRouteInfo, ffi.Int64)>>
  )
>>('CStatefulChannel_CDynamicRouteInfo_connect');
late final _CStatefulChannel_CDynamicRouteInfoConnect = _CStatefulChannel_CDynamicRouteInfoConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CDynamicRouteInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDynamicRouteInfo, ffi.Int64)>>
  )
>();
late final _CRoadEventRouteAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CRoadEventRouteAttribute)>>('CRoadEventRouteAttribute_size');
late final _CRoadEventRouteAttribute_size = _CRoadEventRouteAttribute_sizePtr.asFunction<int Function(_CRoadEventRouteAttribute)>();
late final _CRoadEventRouteAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CRoadEventRouteAttribute)>>('CRoadEventRouteAttribute_isEmpty');
late final _CRoadEventRouteAttribute_isEmpty = _CRoadEventRouteAttribute_isEmptyPtr.asFunction<bool Function(_CRoadEventRouteAttribute)>();
late final _CRoadEventRouteAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CRoadEventRouteEntry Function(_CRoadEventRouteAttribute)>>('CRoadEventRouteAttribute_first');
late final _CRoadEventRouteAttribute_first = _CRoadEventRouteAttribute_firstPtr.asFunction<_COptional_CRoadEventRouteEntry Function(_CRoadEventRouteAttribute)>();
late final _CRoadEventRouteAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CRoadEventRouteEntry Function(_CRoadEventRouteAttribute)>>('CRoadEventRouteAttribute_last');
late final _CRoadEventRouteAttribute_last = _CRoadEventRouteAttribute_lastPtr.asFunction<_COptional_CRoadEventRouteEntry Function(_CRoadEventRouteAttribute)>();
late final _CRoadEventRouteAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CRoadEventRouteEntry Function(_CRoadEventRouteAttribute)>>('CRoadEventRouteAttribute_entries');
late final _CRoadEventRouteAttribute_entries = _CRoadEventRouteAttribute_entriesPtr.asFunction<_CArray_CRoadEventRouteEntry Function(_CRoadEventRouteAttribute)>();

late final _CRoadEventRouteAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEventRouteAttribute_cg_objectIdentifier');
late final _CRoadEventRouteAttribute_cg_objectIdentifier = _CRoadEventRouteAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadEventRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CRoadEventRouteEntry Function(_CRoadEventRouteAttribute, _CRoutePoint, _CRoutePoint)>>('CRoadEventRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CRoadEventRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CRoadEventRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CRoadEventRouteEntry Function(_CRoadEventRouteAttribute, _CRoutePoint, _CRoutePoint)>();
late final _CRoadEventRouteAttribute_findNearBackward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRoadEventRouteEntry Function(_CRoadEventRouteAttribute, _CRoutePoint)>>('CRoadEventRouteAttribute_findNearBackward_CRoutePoint');
late final _CRoadEventRouteAttribute_findNearBackward_CRoutePoint = _CRoadEventRouteAttribute_findNearBackward_CRoutePointPtr.asFunction<_COptional_CRoadEventRouteEntry Function(_CRoadEventRouteAttribute, _CRoutePoint)>();
late final _CRoadEventRouteAttribute_findNearForward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRoadEventRouteEntry Function(_CRoadEventRouteAttribute, _CRoutePoint)>>('CRoadEventRouteAttribute_findNearForward_CRoutePoint');
late final _CRoadEventRouteAttribute_findNearForward_CRoutePoint = _CRoadEventRouteAttribute_findNearForward_CRoutePointPtr.asFunction<_COptional_CRoadEventRouteEntry Function(_CRoadEventRouteAttribute, _CRoutePoint)>();

late final _CRoadEventRouteAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEventRouteAttribute_release');
late final _CRoadEventRouteAttribute_release = _CRoadEventRouteAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventRouteAttribute_retainPtr = _lookup<ffi.NativeFunction<_CRoadEventRouteAttribute Function(ffi.Pointer<ffi.Void>)>>('CRoadEventRouteAttribute_retain');
late final _CRoadEventRouteAttribute_retain = _CRoadEventRouteAttribute_retainPtr.asFunction<_CRoadEventRouteAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventRouteAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventRouteAttribute Function()>>('CRoadEventRouteAttributeMakeDefault');
late final _CRoadEventRouteAttributeMakeDefault = _CRoadEventRouteAttributeMakeDefaultPtr.asFunction<_CRoadEventRouteAttribute Function()>();


late final _CDynamicRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDynamicRouteInfo Function()>>('CDynamicRouteInfoMakeDefault');
late final _CDynamicRouteInfoMakeDefault = _CDynamicRouteInfoMakeDefaultPtr.asFunction<_CDynamicRouteInfo Function()>();


late final _CBriefRoadEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBriefRoadEvent Function()>>('CBriefRoadEventMakeDefault');
late final _CBriefRoadEventMakeDefault = _CBriefRoadEventMakeDefaultPtr.asFunction<_CBriefRoadEvent Function()>();


late final _CRoadEventRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventRouteEntry Function()>>('CRoadEventRouteEntryMakeDefault');
late final _CRoadEventRouteEntryMakeDefault = _CRoadEventRouteEntryMakeDefaultPtr.asFunction<_CRoadEventRouteEntry Function()>();


late final _COptional_CRoadEventRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRoadEventRouteEntry Function()>>('COptional_CRoadEventRouteEntryMakeDefault');
late final _COptional_CRoadEventRouteEntryMakeDefault = _COptional_CRoadEventRouteEntryMakeDefaultPtr.asFunction<_COptional_CRoadEventRouteEntry Function()>();

late final _CArray_CRoadEventRouteEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRoadEventRouteEntry Function()>>('CArray_CRoadEventRouteEntry_makeEmpty');
late final _CArray_CRoadEventRouteEntrymakeEmpty = _CArray_CRoadEventRouteEntrymakeEmptyPtr.asFunction<_CArray_CRoadEventRouteEntry Function()>();
late final _CArray_CRoadEventRouteEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventRouteEntry, _CRoadEventRouteEntry)>>('CArray_CRoadEventRouteEntry_addElement');
late final _CArray_CRoadEventRouteEntryaddElement = _CArray_CRoadEventRouteEntryaddElementPtr.asFunction<void Function(_CArray_CRoadEventRouteEntry, _CRoadEventRouteEntry)>();
late final _forEach_CArray_CRoadEventRouteEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRoadEventRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventRouteEntry)>>)
>>('CArray_CRoadEventRouteEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CRoadEventRouteEntry = _forEach_CArray_CRoadEventRouteEntryPtr.asFunction<
  void Function(_CArray_CRoadEventRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventRouteEntry)
>>)>();
late final _CArray_CRoadEventRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventRouteEntry)>>('CArray_CRoadEventRouteEntry_release');
late final _CArray_CRoadEventRouteEntry_release = _CArray_CRoadEventRouteEntry_releasePtr.asFunction<void Function(_CArray_CRoadEventRouteEntry)>();

late final _CStatefulChannel_COptional_CRoutePointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CRoutePoint Function()>>('CStatefulChannel_COptional_CRoutePointMakeDefault');
late final _CStatefulChannel_COptional_CRoutePointMakeDefault = _CStatefulChannel_COptional_CRoutePointMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CRoutePoint Function()>();
late final _CStatefulChannel_COptional_CRoutePoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CRoutePoint)>>('CStatefulChannel_COptional_CRoutePoint_release');
late final _CStatefulChannel_COptional_CRoutePoint_release = _CStatefulChannel_COptional_CRoutePoint_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CRoutePoint)>();
late final _CStatefulChannel_COptional_CRoutePoint_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CRoutePoint Function(_CStatefulChannel_COptional_CRoutePoint)>>('CStatefulChannel_COptional_CRoutePoint_retain');
late final _CStatefulChannel_COptional_CRoutePoint_retain = _CStatefulChannel_COptional_CRoutePoint_retainPtr.asFunction<_CStatefulChannel_COptional_CRoutePoint Function(_CStatefulChannel_COptional_CRoutePoint)>();
late final _CStatefulChannel_COptional_CRoutePointGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CRoutePoint Function(_CStatefulChannel_COptional_CRoutePoint)>>('CStatefulChannel_COptional_CRoutePoint_getCurrentValue');
late final _CStatefulChannel_COptional_CRoutePointGetCurrentValue = _CStatefulChannel_COptional_CRoutePointGetCurrentValuePtr.asFunction<_COptional_CRoutePoint Function(_CStatefulChannel_COptional_CRoutePoint)>();
late final _CStatefulChannel_COptional_CRoutePointConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CRoutePoint,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CRoutePoint, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CRoutePoint_connect');
late final _CStatefulChannel_COptional_CRoutePointConnect = _CStatefulChannel_COptional_CRoutePointConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CRoutePoint,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CRoutePoint, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_COptional_CBetterRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CBetterRouteInfo Function()>>('CStatefulChannel_COptional_CBetterRouteInfoMakeDefault');
late final _CStatefulChannel_COptional_CBetterRouteInfoMakeDefault = _CStatefulChannel_COptional_CBetterRouteInfoMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CBetterRouteInfo Function()>();
late final _CStatefulChannel_COptional_CBetterRouteInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CBetterRouteInfo)>>('CStatefulChannel_COptional_CBetterRouteInfo_release');
late final _CStatefulChannel_COptional_CBetterRouteInfo_release = _CStatefulChannel_COptional_CBetterRouteInfo_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CBetterRouteInfo)>();
late final _CStatefulChannel_COptional_CBetterRouteInfo_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CBetterRouteInfo Function(_CStatefulChannel_COptional_CBetterRouteInfo)>>('CStatefulChannel_COptional_CBetterRouteInfo_retain');
late final _CStatefulChannel_COptional_CBetterRouteInfo_retain = _CStatefulChannel_COptional_CBetterRouteInfo_retainPtr.asFunction<_CStatefulChannel_COptional_CBetterRouteInfo Function(_CStatefulChannel_COptional_CBetterRouteInfo)>();
late final _CStatefulChannel_COptional_CBetterRouteInfoGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CBetterRouteInfo Function(_CStatefulChannel_COptional_CBetterRouteInfo)>>('CStatefulChannel_COptional_CBetterRouteInfo_getCurrentValue');
late final _CStatefulChannel_COptional_CBetterRouteInfoGetCurrentValue = _CStatefulChannel_COptional_CBetterRouteInfoGetCurrentValuePtr.asFunction<_COptional_CBetterRouteInfo Function(_CStatefulChannel_COptional_CBetterRouteInfo)>();
late final _CStatefulChannel_COptional_CBetterRouteInfoConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CBetterRouteInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CBetterRouteInfo, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CBetterRouteInfo_connect');
late final _CStatefulChannel_COptional_CBetterRouteInfoConnect = _CStatefulChannel_COptional_CBetterRouteInfoConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CBetterRouteInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CBetterRouteInfo, ffi.Int64)>>
  )
>();

late final _CBetterRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBetterRouteInfo Function()>>('CBetterRouteInfoMakeDefault');
late final _CBetterRouteInfoMakeDefault = _CBetterRouteInfoMakeDefaultPtr.asFunction<_CBetterRouteInfo Function()>();


late final _COptional_CBetterRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CBetterRouteInfo Function()>>('COptional_CBetterRouteInfoMakeDefault');
late final _COptional_CBetterRouteInfoMakeDefault = _COptional_CBetterRouteInfoMakeDefaultPtr.asFunction<_COptional_CBetterRouteInfo Function()>();

late final _COptional_CBetterRouteInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CBetterRouteInfo)>>('COptional_CBetterRouteInfo_release');
late final _COptional_CBetterRouteInfo_release = _COptional_CBetterRouteInfo_releasePtr.asFunction<void Function(_COptional_CBetterRouteInfo)>();

late final _CRouteIndexMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteIndex Function()>>('CRouteIndexMakeDefault');
late final _CRouteIndexMakeDefault = _CRouteIndexMakeDefaultPtr.asFunction<_CRouteIndex Function()>();


late final _CStatefulChannel_CRouteDistanceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteDistance Function()>>('CStatefulChannel_CRouteDistanceMakeDefault');
late final _CStatefulChannel_CRouteDistanceMakeDefault = _CStatefulChannel_CRouteDistanceMakeDefaultPtr.asFunction<_CStatefulChannel_CRouteDistance Function()>();
late final _CStatefulChannel_CRouteDistance_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CRouteDistance)>>('CStatefulChannel_CRouteDistance_release');
late final _CStatefulChannel_CRouteDistance_release = _CStatefulChannel_CRouteDistance_releasePtr.asFunction<void Function(_CStatefulChannel_CRouteDistance)>();
late final _CStatefulChannel_CRouteDistance_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteDistance Function(_CStatefulChannel_CRouteDistance)>>('CStatefulChannel_CRouteDistance_retain');
late final _CStatefulChannel_CRouteDistance_retain = _CStatefulChannel_CRouteDistance_retainPtr.asFunction<_CStatefulChannel_CRouteDistance Function(_CStatefulChannel_CRouteDistance)>();
late final _CStatefulChannel_CRouteDistanceGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CRouteDistance Function(_CStatefulChannel_CRouteDistance)>>('CStatefulChannel_CRouteDistance_getCurrentValue');
late final _CStatefulChannel_CRouteDistanceGetCurrentValue = _CStatefulChannel_CRouteDistanceGetCurrentValuePtr.asFunction<_CRouteDistance Function(_CStatefulChannel_CRouteDistance)>();
late final _CStatefulChannel_CRouteDistanceConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CRouteDistance,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteDistance, ffi.Int64)>>
  )
>>('CStatefulChannel_CRouteDistance_connect');
late final _CStatefulChannel_CRouteDistanceConnect = _CStatefulChannel_CRouteDistanceConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CRouteDistance,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteDistance, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization Function()>>('CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationMakeDefault');
late final _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationMakeDefault = _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationMakeDefaultPtr.asFunction<_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization Function()>();
late final _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization)>>('CStatefulChannel_CRouteMapObjectPassedDistanceVisualization_release');
late final _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization_release = _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization_releasePtr.asFunction<void Function(_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization)>();
late final _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization Function(_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization)>>('CStatefulChannel_CRouteMapObjectPassedDistanceVisualization_retain');
late final _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization_retain = _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization_retainPtr.asFunction<_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization Function(_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization)>();
late final _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CRouteMapObjectPassedDistanceVisualization Function(_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization)>>('CStatefulChannel_CRouteMapObjectPassedDistanceVisualization_getCurrentValue');
late final _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationGetCurrentValue = _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationGetCurrentValuePtr.asFunction<_CRouteMapObjectPassedDistanceVisualization Function(_CStatefulChannel_CRouteMapObjectPassedDistanceVisualization)>();
late final _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteMapObjectPassedDistanceVisualization, ffi.Int64)>>
  )
>>('CStatefulChannel_CRouteMapObjectPassedDistanceVisualization_connect');
late final _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationConnect = _CStatefulChannel_CRouteMapObjectPassedDistanceVisualizationConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CRouteMapObjectPassedDistanceVisualization,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteMapObjectPassedDistanceVisualization, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CArray_CCalloutMapPositionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CCalloutMapPosition Function()>>('CStatefulChannel_CArray_CCalloutMapPositionMakeDefault');
late final _CStatefulChannel_CArray_CCalloutMapPositionMakeDefault = _CStatefulChannel_CArray_CCalloutMapPositionMakeDefaultPtr.asFunction<_CStatefulChannel_CArray_CCalloutMapPosition Function()>();
late final _CStatefulChannel_CArray_CCalloutMapPosition_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CArray_CCalloutMapPosition)>>('CStatefulChannel_CArray_CCalloutMapPosition_release');
late final _CStatefulChannel_CArray_CCalloutMapPosition_release = _CStatefulChannel_CArray_CCalloutMapPosition_releasePtr.asFunction<void Function(_CStatefulChannel_CArray_CCalloutMapPosition)>();
late final _CStatefulChannel_CArray_CCalloutMapPosition_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CCalloutMapPosition Function(_CStatefulChannel_CArray_CCalloutMapPosition)>>('CStatefulChannel_CArray_CCalloutMapPosition_retain');
late final _CStatefulChannel_CArray_CCalloutMapPosition_retain = _CStatefulChannel_CArray_CCalloutMapPosition_retainPtr.asFunction<_CStatefulChannel_CArray_CCalloutMapPosition Function(_CStatefulChannel_CArray_CCalloutMapPosition)>();
late final _CStatefulChannel_CArray_CCalloutMapPositionGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CArray_CCalloutMapPosition Function(_CStatefulChannel_CArray_CCalloutMapPosition)>>('CStatefulChannel_CArray_CCalloutMapPosition_getCurrentValue');
late final _CStatefulChannel_CArray_CCalloutMapPositionGetCurrentValue = _CStatefulChannel_CArray_CCalloutMapPositionGetCurrentValuePtr.asFunction<_CArray_CCalloutMapPosition Function(_CStatefulChannel_CArray_CCalloutMapPosition)>();
late final _CStatefulChannel_CArray_CCalloutMapPositionConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CCalloutMapPosition,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CCalloutMapPosition, ffi.Int64)>>
  )
>>('CStatefulChannel_CArray_CCalloutMapPosition_connect');
late final _CStatefulChannel_CArray_CCalloutMapPositionConnect = _CStatefulChannel_CArray_CCalloutMapPositionConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CCalloutMapPosition,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CCalloutMapPosition, ffi.Int64)>>
  )
>();

late final _CArray_CCalloutMapPositionmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CCalloutMapPosition Function()>>('CArray_CCalloutMapPosition_makeEmpty');
late final _CArray_CCalloutMapPositionmakeEmpty = _CArray_CCalloutMapPositionmakeEmptyPtr.asFunction<_CArray_CCalloutMapPosition Function()>();
late final _CArray_CCalloutMapPositionaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CCalloutMapPosition, _CCalloutMapPosition)>>('CArray_CCalloutMapPosition_addElement');
late final _CArray_CCalloutMapPositionaddElement = _CArray_CCalloutMapPositionaddElementPtr.asFunction<void Function(_CArray_CCalloutMapPosition, _CCalloutMapPosition)>();
late final _forEach_CArray_CCalloutMapPositionPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CCalloutMapPosition, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCalloutMapPosition)>>)
>>('CArray_CCalloutMapPosition_forEachWithFunctionPointer');
late final _forEach_CArray_CCalloutMapPosition = _forEach_CArray_CCalloutMapPositionPtr.asFunction<
  void Function(_CArray_CCalloutMapPosition, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCalloutMapPosition)
>>)>();
late final _CArray_CCalloutMapPosition_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CCalloutMapPosition)>>('CArray_CCalloutMapPosition_release');
late final _CArray_CCalloutMapPosition_release = _CArray_CCalloutMapPosition_releasePtr.asFunction<void Function(_CArray_CCalloutMapPosition)>();

late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function()>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefault');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefault = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function()>();
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag)>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_release');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_release = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag)>();
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag)>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_retain');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_retain = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_retainPtr.asFunction<_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag)>();
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag)>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_getCurrentValue');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagGetCurrentValue = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagGetCurrentValuePtr.asFunction<_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function(_CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag)>();
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_connect');
late final _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagConnect = _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag, ffi.Int64)>>
  )
>();

late final _COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CRouteMapObjectCalloutLabelFlag Function()>>('COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefault');
late final _COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefault = _COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefaultPtr.asFunction<_COptionSet_CRouteMapObjectCalloutLabelFlag Function()>();

late final _COptional_COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function()>>('COptional_COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefault');
late final _COptional_COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefault = _COptional_COptionSet_CRouteMapObjectCalloutLabelFlagMakeDefaultPtr.asFunction<_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function()>();

late final _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode Function()>>('CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeMakeDefault');
late final _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeMakeDefault = _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeMakeDefaultPtr.asFunction<_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode Function()>();
late final _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode)>>('CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode_release');
late final _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode_release = _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode_releasePtr.asFunction<void Function(_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode)>();
late final _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode Function(_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode)>>('CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode_retain');
late final _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode_retain = _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode_retainPtr.asFunction<_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode Function(_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode)>();
late final _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CRouteMapObjectCalloutLabelDisplayMode Function(_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode)>>('CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode_getCurrentValue');
late final _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeGetCurrentValue = _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeGetCurrentValuePtr.asFunction<_CRouteMapObjectCalloutLabelDisplayMode Function(_CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode)>();
late final _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteMapObjectCalloutLabelDisplayMode, ffi.Int64)>>
  )
>>('CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode_connect');
late final _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeConnect = _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayModeConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CRouteMapObjectCalloutLabelDisplayMode,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteMapObjectCalloutLabelDisplayMode, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CArray_CLanesCalloutMapPositionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CLanesCalloutMapPosition Function()>>('CStatefulChannel_CArray_CLanesCalloutMapPositionMakeDefault');
late final _CStatefulChannel_CArray_CLanesCalloutMapPositionMakeDefault = _CStatefulChannel_CArray_CLanesCalloutMapPositionMakeDefaultPtr.asFunction<_CStatefulChannel_CArray_CLanesCalloutMapPosition Function()>();
late final _CStatefulChannel_CArray_CLanesCalloutMapPosition_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CArray_CLanesCalloutMapPosition)>>('CStatefulChannel_CArray_CLanesCalloutMapPosition_release');
late final _CStatefulChannel_CArray_CLanesCalloutMapPosition_release = _CStatefulChannel_CArray_CLanesCalloutMapPosition_releasePtr.asFunction<void Function(_CStatefulChannel_CArray_CLanesCalloutMapPosition)>();
late final _CStatefulChannel_CArray_CLanesCalloutMapPosition_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CLanesCalloutMapPosition Function(_CStatefulChannel_CArray_CLanesCalloutMapPosition)>>('CStatefulChannel_CArray_CLanesCalloutMapPosition_retain');
late final _CStatefulChannel_CArray_CLanesCalloutMapPosition_retain = _CStatefulChannel_CArray_CLanesCalloutMapPosition_retainPtr.asFunction<_CStatefulChannel_CArray_CLanesCalloutMapPosition Function(_CStatefulChannel_CArray_CLanesCalloutMapPosition)>();
late final _CStatefulChannel_CArray_CLanesCalloutMapPositionGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CArray_CLanesCalloutMapPosition Function(_CStatefulChannel_CArray_CLanesCalloutMapPosition)>>('CStatefulChannel_CArray_CLanesCalloutMapPosition_getCurrentValue');
late final _CStatefulChannel_CArray_CLanesCalloutMapPositionGetCurrentValue = _CStatefulChannel_CArray_CLanesCalloutMapPositionGetCurrentValuePtr.asFunction<_CArray_CLanesCalloutMapPosition Function(_CStatefulChannel_CArray_CLanesCalloutMapPosition)>();
late final _CStatefulChannel_CArray_CLanesCalloutMapPositionConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CLanesCalloutMapPosition,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CLanesCalloutMapPosition, ffi.Int64)>>
  )
>>('CStatefulChannel_CArray_CLanesCalloutMapPosition_connect');
late final _CStatefulChannel_CArray_CLanesCalloutMapPositionConnect = _CStatefulChannel_CArray_CLanesCalloutMapPositionConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CLanesCalloutMapPosition,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CLanesCalloutMapPosition, ffi.Int64)>>
  )
>();

late final _CArray_CLanesCalloutMapPositionmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CLanesCalloutMapPosition Function()>>('CArray_CLanesCalloutMapPosition_makeEmpty');
late final _CArray_CLanesCalloutMapPositionmakeEmpty = _CArray_CLanesCalloutMapPositionmakeEmptyPtr.asFunction<_CArray_CLanesCalloutMapPosition Function()>();
late final _CArray_CLanesCalloutMapPositionaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLanesCalloutMapPosition, _CLanesCalloutMapPosition)>>('CArray_CLanesCalloutMapPosition_addElement');
late final _CArray_CLanesCalloutMapPositionaddElement = _CArray_CLanesCalloutMapPositionaddElementPtr.asFunction<void Function(_CArray_CLanesCalloutMapPosition, _CLanesCalloutMapPosition)>();
late final _forEach_CArray_CLanesCalloutMapPositionPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CLanesCalloutMapPosition, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLanesCalloutMapPosition)>>)
>>('CArray_CLanesCalloutMapPosition_forEachWithFunctionPointer');
late final _forEach_CArray_CLanesCalloutMapPosition = _forEach_CArray_CLanesCalloutMapPositionPtr.asFunction<
  void Function(_CArray_CLanesCalloutMapPosition, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLanesCalloutMapPosition)
>>)>();
late final _CArray_CLanesCalloutMapPosition_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLanesCalloutMapPosition)>>('CArray_CLanesCalloutMapPosition_release');
late final _CArray_CLanesCalloutMapPosition_release = _CArray_CLanesCalloutMapPosition_releasePtr.asFunction<void Function(_CArray_CLanesCalloutMapPosition)>();

late final _CStatefulChannel_CRoadEventMapObjectRouteAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRoadEventMapObjectRouteAttribute Function()>>('CStatefulChannel_CRoadEventMapObjectRouteAttributeMakeDefault');
late final _CStatefulChannel_CRoadEventMapObjectRouteAttributeMakeDefault = _CStatefulChannel_CRoadEventMapObjectRouteAttributeMakeDefaultPtr.asFunction<_CStatefulChannel_CRoadEventMapObjectRouteAttribute Function()>();
late final _CStatefulChannel_CRoadEventMapObjectRouteAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CRoadEventMapObjectRouteAttribute)>>('CStatefulChannel_CRoadEventMapObjectRouteAttribute_release');
late final _CStatefulChannel_CRoadEventMapObjectRouteAttribute_release = _CStatefulChannel_CRoadEventMapObjectRouteAttribute_releasePtr.asFunction<void Function(_CStatefulChannel_CRoadEventMapObjectRouteAttribute)>();
late final _CStatefulChannel_CRoadEventMapObjectRouteAttribute_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRoadEventMapObjectRouteAttribute Function(_CStatefulChannel_CRoadEventMapObjectRouteAttribute)>>('CStatefulChannel_CRoadEventMapObjectRouteAttribute_retain');
late final _CStatefulChannel_CRoadEventMapObjectRouteAttribute_retain = _CStatefulChannel_CRoadEventMapObjectRouteAttribute_retainPtr.asFunction<_CStatefulChannel_CRoadEventMapObjectRouteAttribute Function(_CStatefulChannel_CRoadEventMapObjectRouteAttribute)>();
late final _CStatefulChannel_CRoadEventMapObjectRouteAttributeGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CRoadEventMapObjectRouteAttribute Function(_CStatefulChannel_CRoadEventMapObjectRouteAttribute)>>('CStatefulChannel_CRoadEventMapObjectRouteAttribute_getCurrentValue');
late final _CStatefulChannel_CRoadEventMapObjectRouteAttributeGetCurrentValue = _CStatefulChannel_CRoadEventMapObjectRouteAttributeGetCurrentValuePtr.asFunction<_CRoadEventMapObjectRouteAttribute Function(_CStatefulChannel_CRoadEventMapObjectRouteAttribute)>();
late final _CStatefulChannel_CRoadEventMapObjectRouteAttributeConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CRoadEventMapObjectRouteAttribute,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventMapObjectRouteAttribute, ffi.Int64)>>
  )
>>('CStatefulChannel_CRoadEventMapObjectRouteAttribute_connect');
late final _CStatefulChannel_CRoadEventMapObjectRouteAttributeConnect = _CStatefulChannel_CRoadEventMapObjectRouteAttributeConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CRoadEventMapObjectRouteAttribute,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventMapObjectRouteAttribute, ffi.Int64)>>
  )
>();
late final _CRoadEventMapObjectRouteAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CRoadEventMapObjectRouteAttribute)>>('CRoadEventMapObjectRouteAttribute_size');
late final _CRoadEventMapObjectRouteAttribute_size = _CRoadEventMapObjectRouteAttribute_sizePtr.asFunction<int Function(_CRoadEventMapObjectRouteAttribute)>();
late final _CRoadEventMapObjectRouteAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CRoadEventMapObjectRouteAttribute)>>('CRoadEventMapObjectRouteAttribute_isEmpty');
late final _CRoadEventMapObjectRouteAttribute_isEmpty = _CRoadEventMapObjectRouteAttribute_isEmptyPtr.asFunction<bool Function(_CRoadEventMapObjectRouteAttribute)>();
late final _CRoadEventMapObjectRouteAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CRoadEventMapObjectRouteEntry Function(_CRoadEventMapObjectRouteAttribute)>>('CRoadEventMapObjectRouteAttribute_first');
late final _CRoadEventMapObjectRouteAttribute_first = _CRoadEventMapObjectRouteAttribute_firstPtr.asFunction<_COptional_CRoadEventMapObjectRouteEntry Function(_CRoadEventMapObjectRouteAttribute)>();
late final _CRoadEventMapObjectRouteAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CRoadEventMapObjectRouteEntry Function(_CRoadEventMapObjectRouteAttribute)>>('CRoadEventMapObjectRouteAttribute_last');
late final _CRoadEventMapObjectRouteAttribute_last = _CRoadEventMapObjectRouteAttribute_lastPtr.asFunction<_COptional_CRoadEventMapObjectRouteEntry Function(_CRoadEventMapObjectRouteAttribute)>();
late final _CRoadEventMapObjectRouteAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CRoadEventMapObjectRouteEntry Function(_CRoadEventMapObjectRouteAttribute)>>('CRoadEventMapObjectRouteAttribute_entries');
late final _CRoadEventMapObjectRouteAttribute_entries = _CRoadEventMapObjectRouteAttribute_entriesPtr.asFunction<_CArray_CRoadEventMapObjectRouteEntry Function(_CRoadEventMapObjectRouteAttribute)>();

late final _CRoadEventMapObjectRouteAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEventMapObjectRouteAttribute_cg_objectIdentifier');
late final _CRoadEventMapObjectRouteAttribute_cg_objectIdentifier = _CRoadEventMapObjectRouteAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadEventMapObjectRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CRoadEventMapObjectRouteEntry Function(_CRoadEventMapObjectRouteAttribute, _CRoutePoint, _CRoutePoint)>>('CRoadEventMapObjectRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CRoadEventMapObjectRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CRoadEventMapObjectRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CRoadEventMapObjectRouteEntry Function(_CRoadEventMapObjectRouteAttribute, _CRoutePoint, _CRoutePoint)>();
late final _CRoadEventMapObjectRouteAttribute_findNearBackward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRoadEventMapObjectRouteEntry Function(_CRoadEventMapObjectRouteAttribute, _CRoutePoint)>>('CRoadEventMapObjectRouteAttribute_findNearBackward_CRoutePoint');
late final _CRoadEventMapObjectRouteAttribute_findNearBackward_CRoutePoint = _CRoadEventMapObjectRouteAttribute_findNearBackward_CRoutePointPtr.asFunction<_COptional_CRoadEventMapObjectRouteEntry Function(_CRoadEventMapObjectRouteAttribute, _CRoutePoint)>();
late final _CRoadEventMapObjectRouteAttribute_findNearForward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CRoadEventMapObjectRouteEntry Function(_CRoadEventMapObjectRouteAttribute, _CRoutePoint)>>('CRoadEventMapObjectRouteAttribute_findNearForward_CRoutePoint');
late final _CRoadEventMapObjectRouteAttribute_findNearForward_CRoutePoint = _CRoadEventMapObjectRouteAttribute_findNearForward_CRoutePointPtr.asFunction<_COptional_CRoadEventMapObjectRouteEntry Function(_CRoadEventMapObjectRouteAttribute, _CRoutePoint)>();

late final _CRoadEventMapObjectRouteAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEventMapObjectRouteAttribute_release');
late final _CRoadEventMapObjectRouteAttribute_release = _CRoadEventMapObjectRouteAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventMapObjectRouteAttribute_retainPtr = _lookup<ffi.NativeFunction<_CRoadEventMapObjectRouteAttribute Function(ffi.Pointer<ffi.Void>)>>('CRoadEventMapObjectRouteAttribute_retain');
late final _CRoadEventMapObjectRouteAttribute_retain = _CRoadEventMapObjectRouteAttribute_retainPtr.asFunction<_CRoadEventMapObjectRouteAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventMapObjectRouteAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventMapObjectRouteAttribute Function()>>('CRoadEventMapObjectRouteAttributeMakeDefault');
late final _CRoadEventMapObjectRouteAttributeMakeDefault = _CRoadEventMapObjectRouteAttributeMakeDefaultPtr.asFunction<_CRoadEventMapObjectRouteAttribute Function()>();


late final _CRoadEventMapObjectRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventMapObjectRouteEntry Function()>>('CRoadEventMapObjectRouteEntryMakeDefault');
late final _CRoadEventMapObjectRouteEntryMakeDefault = _CRoadEventMapObjectRouteEntryMakeDefaultPtr.asFunction<_CRoadEventMapObjectRouteEntry Function()>();


late final _COptional_CRoadEventMapObjectRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRoadEventMapObjectRouteEntry Function()>>('COptional_CRoadEventMapObjectRouteEntryMakeDefault');
late final _COptional_CRoadEventMapObjectRouteEntryMakeDefault = _COptional_CRoadEventMapObjectRouteEntryMakeDefaultPtr.asFunction<_COptional_CRoadEventMapObjectRouteEntry Function()>();

late final _COptional_CRoadEventMapObjectRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CRoadEventMapObjectRouteEntry)>>('COptional_CRoadEventMapObjectRouteEntry_release');
late final _COptional_CRoadEventMapObjectRouteEntry_release = _COptional_CRoadEventMapObjectRouteEntry_releasePtr.asFunction<void Function(_COptional_CRoadEventMapObjectRouteEntry)>();

late final _CArray_CRoadEventMapObjectRouteEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRoadEventMapObjectRouteEntry Function()>>('CArray_CRoadEventMapObjectRouteEntry_makeEmpty');
late final _CArray_CRoadEventMapObjectRouteEntrymakeEmpty = _CArray_CRoadEventMapObjectRouteEntrymakeEmptyPtr.asFunction<_CArray_CRoadEventMapObjectRouteEntry Function()>();
late final _CArray_CRoadEventMapObjectRouteEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventMapObjectRouteEntry, _CRoadEventMapObjectRouteEntry)>>('CArray_CRoadEventMapObjectRouteEntry_addElement');
late final _CArray_CRoadEventMapObjectRouteEntryaddElement = _CArray_CRoadEventMapObjectRouteEntryaddElementPtr.asFunction<void Function(_CArray_CRoadEventMapObjectRouteEntry, _CRoadEventMapObjectRouteEntry)>();
late final _forEach_CArray_CRoadEventMapObjectRouteEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRoadEventMapObjectRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventMapObjectRouteEntry)>>)
>>('CArray_CRoadEventMapObjectRouteEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CRoadEventMapObjectRouteEntry = _forEach_CArray_CRoadEventMapObjectRouteEntryPtr.asFunction<
  void Function(_CArray_CRoadEventMapObjectRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventMapObjectRouteEntry)
>>)>();
late final _CArray_CRoadEventMapObjectRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventMapObjectRouteEntry)>>('CArray_CRoadEventMapObjectRouteEntry_release');
late final _CArray_CRoadEventMapObjectRouteEntry_release = _CArray_CRoadEventMapObjectRouteEntry_releasePtr.asFunction<void Function(_CArray_CRoadEventMapObjectRouteEntry)>();
late final _CRouteSourceSettings_getLargeScaleRingroadOffsetMetersPtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CRouteSourceSettings)>>('CRouteSourceSettings_getLargeScaleRingroadOffsetMeters');
late final _CRouteSourceSettings_getLargeScaleRingroadOffsetMeters = _CRouteSourceSettings_getLargeScaleRingroadOffsetMetersPtr.asFunction<double Function(_CRouteSourceSettings)>();
late final _CRouteSourceSettings_setLargeScaleRingroadOffsetMeters_floatPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteSourceSettings, ffi.Float)>>('CRouteSourceSettings_setLargeScaleRingroadOffsetMeters_float');
late final _CRouteSourceSettings_setLargeScaleRingroadOffsetMeters_float = _CRouteSourceSettings_setLargeScaleRingroadOffsetMeters_floatPtr.asFunction<void Function(_CRouteSourceSettings, double)>();
late final _CRouteSourceSettings_getSmallScaleRingroadOffsetMetersPtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CRouteSourceSettings)>>('CRouteSourceSettings_getSmallScaleRingroadOffsetMeters');
late final _CRouteSourceSettings_getSmallScaleRingroadOffsetMeters = _CRouteSourceSettings_getSmallScaleRingroadOffsetMetersPtr.asFunction<double Function(_CRouteSourceSettings)>();
late final _CRouteSourceSettings_setSmallScaleRingroadOffsetMeters_floatPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteSourceSettings, ffi.Float)>>('CRouteSourceSettings_setSmallScaleRingroadOffsetMeters_float');
late final _CRouteSourceSettings_setSmallScaleRingroadOffsetMeters_float = _CRouteSourceSettings_setSmallScaleRingroadOffsetMeters_floatPtr.asFunction<void Function(_CRouteSourceSettings, double)>();
late final _CRouteSourceSettings_calloutVisualizationModePtr = _lookup<ffi.NativeFunction<_CCalloutVisualizationMode Function(_CRouteSourceSettings)>>('CRouteSourceSettings_calloutVisualizationMode');
late final _CRouteSourceSettings_calloutVisualizationMode = _CRouteSourceSettings_calloutVisualizationModePtr.asFunction<_CCalloutVisualizationMode Function(_CRouteSourceSettings)>();
late final _CRouteSourceSettings_setCalloutVisualizationMode_CCalloutVisualizationModePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteSourceSettings, _CCalloutVisualizationMode)>>('CRouteSourceSettings_setCalloutVisualizationMode_CCalloutVisualizationMode');
late final _CRouteSourceSettings_setCalloutVisualizationMode_CCalloutVisualizationMode = _CRouteSourceSettings_setCalloutVisualizationMode_CCalloutVisualizationModePtr.asFunction<void Function(_CRouteSourceSettings, _CCalloutVisualizationMode)>();

late final _CRouteSourceSettings_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRouteSourceSettings_cg_objectIdentifier');
late final _CRouteSourceSettings_cg_objectIdentifier = _CRouteSourceSettings_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRouteSourceSettings_getLargeScaleMergeDistanceMeters_CTransportTypePtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CRouteSourceSettings, _CTransportType)>>('CRouteSourceSettings_getLargeScaleMergeDistanceMeters_CTransportType');
late final _CRouteSourceSettings_getLargeScaleMergeDistanceMeters_CTransportType = _CRouteSourceSettings_getLargeScaleMergeDistanceMeters_CTransportTypePtr.asFunction<double Function(_CRouteSourceSettings, _CTransportType)>();
late final _CRouteSourceSettings_setLargeScaleMergeDistanceMeters_float_CTransportTypePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteSourceSettings, ffi.Float, _CTransportType)>>('CRouteSourceSettings_setLargeScaleMergeDistanceMeters_float_CTransportType');
late final _CRouteSourceSettings_setLargeScaleMergeDistanceMeters_float_CTransportType = _CRouteSourceSettings_setLargeScaleMergeDistanceMeters_float_CTransportTypePtr.asFunction<void Function(_CRouteSourceSettings, double, _CTransportType)>();
late final _CRouteSourceSettings_getSmallScaleMergeDistanceMeters_CTransportTypePtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CRouteSourceSettings, _CTransportType)>>('CRouteSourceSettings_getSmallScaleMergeDistanceMeters_CTransportType');
late final _CRouteSourceSettings_getSmallScaleMergeDistanceMeters_CTransportType = _CRouteSourceSettings_getSmallScaleMergeDistanceMeters_CTransportTypePtr.asFunction<double Function(_CRouteSourceSettings, _CTransportType)>();
late final _CRouteSourceSettings_setSmallScaleMergeDistanceMeters_float_CTransportTypePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteSourceSettings, ffi.Float, _CTransportType)>>('CRouteSourceSettings_setSmallScaleMergeDistanceMeters_float_CTransportType');
late final _CRouteSourceSettings_setSmallScaleMergeDistanceMeters_float_CTransportType = _CRouteSourceSettings_setSmallScaleMergeDistanceMeters_float_CTransportTypePtr.asFunction<void Function(_CRouteSourceSettings, double, _CTransportType)>();
late final _CRouteSourceSettings_getLargeScaleCrossroadsOffsetMeters_CTransportTypePtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CRouteSourceSettings, _CTransportType)>>('CRouteSourceSettings_getLargeScaleCrossroadsOffsetMeters_CTransportType');
late final _CRouteSourceSettings_getLargeScaleCrossroadsOffsetMeters_CTransportType = _CRouteSourceSettings_getLargeScaleCrossroadsOffsetMeters_CTransportTypePtr.asFunction<double Function(_CRouteSourceSettings, _CTransportType)>();
late final _CRouteSourceSettings_setLargeScaleCrossroadsOffsetMeters_float_CTransportTypePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteSourceSettings, ffi.Float, _CTransportType)>>('CRouteSourceSettings_setLargeScaleCrossroadsOffsetMeters_float_CTransportType');
late final _CRouteSourceSettings_setLargeScaleCrossroadsOffsetMeters_float_CTransportType = _CRouteSourceSettings_setLargeScaleCrossroadsOffsetMeters_float_CTransportTypePtr.asFunction<void Function(_CRouteSourceSettings, double, _CTransportType)>();
late final _CRouteSourceSettings_getSmallScaleCrossroadsOffsetMeters_CTransportTypePtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CRouteSourceSettings, _CTransportType)>>('CRouteSourceSettings_getSmallScaleCrossroadsOffsetMeters_CTransportType');
late final _CRouteSourceSettings_getSmallScaleCrossroadsOffsetMeters_CTransportType = _CRouteSourceSettings_getSmallScaleCrossroadsOffsetMeters_CTransportTypePtr.asFunction<double Function(_CRouteSourceSettings, _CTransportType)>();
late final _CRouteSourceSettings_setSmallScaleCrossroadsOffsetMeters_float_CTransportTypePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteSourceSettings, ffi.Float, _CTransportType)>>('CRouteSourceSettings_setSmallScaleCrossroadsOffsetMeters_float_CTransportType');
late final _CRouteSourceSettings_setSmallScaleCrossroadsOffsetMeters_float_CTransportType = _CRouteSourceSettings_setSmallScaleCrossroadsOffsetMeters_float_CTransportTypePtr.asFunction<void Function(_CRouteSourceSettings, double, _CTransportType)>();

late final _CRouteSourceSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRouteSourceSettings_release');
late final _CRouteSourceSettings_release = _CRouteSourceSettings_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteSourceSettings_retainPtr = _lookup<ffi.NativeFunction<_CRouteSourceSettings Function(ffi.Pointer<ffi.Void>)>>('CRouteSourceSettings_retain');
late final _CRouteSourceSettings_retain = _CRouteSourceSettings_retainPtr.asFunction<_CRouteSourceSettings Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteSourceSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteSourceSettings Function()>>('CRouteSourceSettingsMakeDefault');
late final _CRouteSourceSettingsMakeDefault = _CRouteSourceSettingsMakeDefaultPtr.asFunction<_CRouteSourceSettings Function()>();

late final _CRouteEditorSource_objectsPtr = _lookup<ffi.NativeFunction<_CArray_CRouteMapObject Function(_CRouteEditorSource)>>('CRouteEditorSource_objects');
late final _CRouteEditorSource_objects = _CRouteEditorSource_objectsPtr.asFunction<_CArray_CRouteMapObject Function(_CRouteEditorSource)>();
late final _CRouteEditorSource_routeSourceSettingsPtr = _lookup<ffi.NativeFunction<_CRouteSourceSettings Function(_CRouteEditorSource)>>('CRouteEditorSource_routeSourceSettings');
late final _CRouteEditorSource_routeSourceSettings = _CRouteEditorSource_routeSourceSettingsPtr.asFunction<_CRouteSourceSettings Function(_CRouteEditorSource)>();
late final _CRouteEditorSource_activeDisplayFlagsPtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectDisplayFlag Function(_CRouteEditorSource)>>('CRouteEditorSource_activeDisplayFlags');
late final _CRouteEditorSource_activeDisplayFlags = _CRouteEditorSource_activeDisplayFlagsPtr.asFunction<_COptional_COptionSet_CRouteMapObjectDisplayFlag Function(_CRouteEditorSource)>();
late final _CRouteEditorSource_setActiveDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteEditorSource, _COptional_COptionSet_CRouteMapObjectDisplayFlag)>>('CRouteEditorSource_setActiveDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlag');
late final _CRouteEditorSource_setActiveDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlag = _CRouteEditorSource_setActiveDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlagPtr.asFunction<void Function(_CRouteEditorSource, _COptional_COptionSet_CRouteMapObjectDisplayFlag)>();
late final _CRouteEditorSource_inactiveDisplayFlagsPtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectDisplayFlag Function(_CRouteEditorSource)>>('CRouteEditorSource_inactiveDisplayFlags');
late final _CRouteEditorSource_inactiveDisplayFlags = _CRouteEditorSource_inactiveDisplayFlagsPtr.asFunction<_COptional_COptionSet_CRouteMapObjectDisplayFlag Function(_CRouteEditorSource)>();
late final _CRouteEditorSource_setInactiveDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteEditorSource, _COptional_COptionSet_CRouteMapObjectDisplayFlag)>>('CRouteEditorSource_setInactiveDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlag');
late final _CRouteEditorSource_setInactiveDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlag = _CRouteEditorSource_setInactiveDisplayFlags_COptional_COptionSet_CRouteMapObjectDisplayFlagPtr.asFunction<void Function(_CRouteEditorSource, _COptional_COptionSet_CRouteMapObjectDisplayFlag)>();
late final _CRouteEditorSource_activeCalloutLabelFlagsPtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function(_CRouteEditorSource)>>('CRouteEditorSource_activeCalloutLabelFlags');
late final _CRouteEditorSource_activeCalloutLabelFlags = _CRouteEditorSource_activeCalloutLabelFlagsPtr.asFunction<_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function(_CRouteEditorSource)>();
late final _CRouteEditorSource_setActiveCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteEditorSource, _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag)>>('CRouteEditorSource_setActiveCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag');
late final _CRouteEditorSource_setActiveCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag = _CRouteEditorSource_setActiveCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagPtr.asFunction<void Function(_CRouteEditorSource, _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag)>();
late final _CRouteEditorSource_inactiveCalloutLabelFlagsPtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function(_CRouteEditorSource)>>('CRouteEditorSource_inactiveCalloutLabelFlags');
late final _CRouteEditorSource_inactiveCalloutLabelFlags = _CRouteEditorSource_inactiveCalloutLabelFlagsPtr.asFunction<_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag Function(_CRouteEditorSource)>();
late final _CRouteEditorSource_setInactiveCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteEditorSource, _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag)>>('CRouteEditorSource_setInactiveCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag');
late final _CRouteEditorSource_setInactiveCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag = _CRouteEditorSource_setInactiveCalloutLabelFlags_COptional_COptionSet_CRouteMapObjectCalloutLabelFlagPtr.asFunction<void Function(_CRouteEditorSource, _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag)>();
late final _CRouteEditorSource_calloutLabelDisplayModePtr = _lookup<ffi.NativeFunction<_CRouteMapObjectCalloutLabelDisplayMode Function(_CRouteEditorSource)>>('CRouteEditorSource_calloutLabelDisplayMode');
late final _CRouteEditorSource_calloutLabelDisplayMode = _CRouteEditorSource_calloutLabelDisplayModePtr.asFunction<_CRouteMapObjectCalloutLabelDisplayMode Function(_CRouteEditorSource)>();
late final _CRouteEditorSource_setCalloutLabelDisplayMode_CRouteMapObjectCalloutLabelDisplayModePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteEditorSource, _CRouteMapObjectCalloutLabelDisplayMode)>>('CRouteEditorSource_setCalloutLabelDisplayMode_CRouteMapObjectCalloutLabelDisplayMode');
late final _CRouteEditorSource_setCalloutLabelDisplayMode_CRouteMapObjectCalloutLabelDisplayMode = _CRouteEditorSource_setCalloutLabelDisplayMode_CRouteMapObjectCalloutLabelDisplayModePtr.asFunction<void Function(_CRouteEditorSource, _CRouteMapObjectCalloutLabelDisplayMode)>();
late final _CRouteEditorSource_activePermanentDisplayFlagsPtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CRouteEditorSource)>>('CRouteEditorSource_activePermanentDisplayFlags');
late final _CRouteEditorSource_activePermanentDisplayFlags = _CRouteEditorSource_activePermanentDisplayFlagsPtr.asFunction<_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CRouteEditorSource)>();
late final _CRouteEditorSource_setActivePermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteEditorSource, _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>>('CRouteEditorSource_setActivePermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag');
late final _CRouteEditorSource_setActivePermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag = _CRouteEditorSource_setActivePermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr.asFunction<void Function(_CRouteEditorSource, _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>();
late final _CRouteEditorSource_inactivePermanentDisplayFlagsPtr = _lookup<ffi.NativeFunction<_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CRouteEditorSource)>>('CRouteEditorSource_inactivePermanentDisplayFlags');
late final _CRouteEditorSource_inactivePermanentDisplayFlags = _CRouteEditorSource_inactivePermanentDisplayFlagsPtr.asFunction<_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CRouteEditorSource)>();
late final _CRouteEditorSource_setInactivePermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteEditorSource, _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>>('CRouteEditorSource_setInactivePermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag');
late final _CRouteEditorSource_setInactivePermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag = _CRouteEditorSource_setInactivePermanentDisplayFlags_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr.asFunction<void Function(_CRouteEditorSource, _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>();

late final _CRouteEditorSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRouteEditorSource_cg_objectIdentifier');
late final _CRouteEditorSource_cg_objectIdentifier = _CRouteEditorSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRouteEditorSource_setRoutesVisible_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteEditorSource, ffi.Bool)>>('CRouteEditorSource_setRoutesVisible_bool');
late final _CRouteEditorSource_setRoutesVisible_bool = _CRouteEditorSource_setRoutesVisible_boolPtr.asFunction<void Function(_CRouteEditorSource, bool)>();
late final _CRouteEditorSource_setShowOnlyActiveRoute_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteEditorSource, ffi.Bool)>>('CRouteEditorSource_setShowOnlyActiveRoute_bool');
late final _CRouteEditorSource_setShowOnlyActiveRoute_bool = _CRouteEditorSource_setShowOnlyActiveRoute_boolPtr.asFunction<void Function(_CRouteEditorSource, bool)>();
late final _CRouteEditorSource_setPassedDistanceVisualization_CRouteMapObjectPassedDistanceVisualizationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteEditorSource, _CRouteMapObjectPassedDistanceVisualization)>>('CRouteEditorSource_setPassedDistanceVisualization_CRouteMapObjectPassedDistanceVisualization');
late final _CRouteEditorSource_setPassedDistanceVisualization_CRouteMapObjectPassedDistanceVisualization = _CRouteEditorSource_setPassedDistanceVisualization_CRouteMapObjectPassedDistanceVisualizationPtr.asFunction<void Function(_CRouteEditorSource, _CRouteMapObjectPassedDistanceVisualization)>();
late final _CRouteEditorSource_C_createWith_CContext_CRouteEditor_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_CRouteMapObjectCalloutLabelDisplayMode_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr = _lookup<ffi.NativeFunction<_CRouteEditorSource Function(_CContext, _CRouteEditor, _COptional_COptionSet_CRouteMapObjectDisplayFlag, _COptional_COptionSet_CRouteMapObjectDisplayFlag, _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag, _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag, _CRouteMapObjectCalloutLabelDisplayMode, _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag, _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>>('CRouteEditorSource_C_createWith_CContext_CRouteEditor_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_CRouteMapObjectCalloutLabelDisplayMode_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag');
late final _CRouteEditorSource_C_createWith_CContext_CRouteEditor_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_CRouteMapObjectCalloutLabelDisplayMode_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag = _CRouteEditorSource_C_createWith_CContext_CRouteEditor_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectDisplayFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_COptional_COptionSet_CRouteMapObjectCalloutLabelFlag_CRouteMapObjectCalloutLabelDisplayMode_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag_COptional_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr.asFunction<_CRouteEditorSource Function(_CContext, _CRouteEditor, _COptional_COptionSet_CRouteMapObjectDisplayFlag, _COptional_COptionSet_CRouteMapObjectDisplayFlag, _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag, _COptional_COptionSet_CRouteMapObjectCalloutLabelFlag, _CRouteMapObjectCalloutLabelDisplayMode, _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag, _COptional_COptionSet_CRouteMapObjectPermanentDisplayFlag)>();

late final _CRouteEditorSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRouteEditorSource_release');
late final _CRouteEditorSource_release = _CRouteEditorSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteEditorSource_retainPtr = _lookup<ffi.NativeFunction<_CRouteEditorSource Function(ffi.Pointer<ffi.Void>)>>('CRouteEditorSource_retain');
late final _CRouteEditorSource_retain = _CRouteEditorSource_retainPtr.asFunction<_CRouteEditorSource Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteEditorSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteEditorSource Function()>>('CRouteEditorSourceMakeDefault');
late final _CRouteEditorSourceMakeDefault = _CRouteEditorSourceMakeDefaultPtr.asFunction<_CRouteEditorSource Function()>();


late final _CArray_CRouteMapObjectmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRouteMapObject Function()>>('CArray_CRouteMapObject_makeEmpty');
late final _CArray_CRouteMapObjectmakeEmpty = _CArray_CRouteMapObjectmakeEmptyPtr.asFunction<_CArray_CRouteMapObject Function()>();
late final _CArray_CRouteMapObjectaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRouteMapObject, _CRouteMapObject)>>('CArray_CRouteMapObject_addElement');
late final _CArray_CRouteMapObjectaddElement = _CArray_CRouteMapObjectaddElementPtr.asFunction<void Function(_CArray_CRouteMapObject, _CRouteMapObject)>();
late final _forEach_CArray_CRouteMapObjectPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRouteMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteMapObject)>>)
>>('CArray_CRouteMapObject_forEachWithFunctionPointer');
late final _forEach_CArray_CRouteMapObject = _forEach_CArray_CRouteMapObjectPtr.asFunction<
  void Function(_CArray_CRouteMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteMapObject)
>>)>();
late final _CArray_CRouteMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRouteMapObject)>>('CArray_CRouteMapObject_release');
late final _CArray_CRouteMapObject_release = _CArray_CRouteMapObject_releasePtr.asFunction<void Function(_CArray_CRouteMapObject)>();
late final _CRouteEditor_routesInfoChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteEditorRoutesInfo Function(_CRouteEditor)>>('CRouteEditor_routesInfoChannel');
late final _CRouteEditor_routesInfoChannel = _CRouteEditor_routesInfoChannelPtr.asFunction<_CStatefulChannel_CRouteEditorRoutesInfo Function(_CRouteEditor)>();
late final _CRouteEditor_routesInfoPtr = _lookup<ffi.NativeFunction<_CRouteEditorRoutesInfo Function(_CRouteEditor)>>('CRouteEditor_routesInfo');
late final _CRouteEditor_routesInfo = _CRouteEditor_routesInfoPtr.asFunction<_CRouteEditorRoutesInfo Function(_CRouteEditor)>();
late final _CRouteEditor_activeRouteIndexChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CRouteIndex Function(_CRouteEditor)>>('CRouteEditor_activeRouteIndexChannel');
late final _CRouteEditor_activeRouteIndexChannel = _CRouteEditor_activeRouteIndexChannelPtr.asFunction<_CStatefulChannel_COptional_CRouteIndex Function(_CRouteEditor)>();
late final _CRouteEditor_activeRouteIndexPtr = _lookup<ffi.NativeFunction<_COptional_CRouteIndex Function(_CRouteEditor)>>('CRouteEditor_activeRouteIndex');
late final _CRouteEditor_activeRouteIndex = _CRouteEditor_activeRouteIndexPtr.asFunction<_COptional_CRouteIndex Function(_CRouteEditor)>();

late final _CRouteEditor_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRouteEditor_cg_objectIdentifier');
late final _CRouteEditor_cg_objectIdentifier = _CRouteEditor_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRouteEditor_setRouteParams_CRouteEditorRouteParamsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteEditor, _CRouteEditorRouteParams)>>('CRouteEditor_setRouteParams_CRouteEditorRouteParams');
late final _CRouteEditor_setRouteParams_CRouteEditorRouteParams = _CRouteEditor_setRouteParams_CRouteEditorRouteParamsPtr.asFunction<void Function(_CRouteEditor, _CRouteEditorRouteParams)>();
late final _CRouteEditor_setActiveRouteIndex_CRouteIndexPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteEditor, _CRouteIndex)>>('CRouteEditor_setActiveRouteIndex_CRouteIndex');
late final _CRouteEditor_setActiveRouteIndex_CRouteIndex = _CRouteEditor_setActiveRouteIndex_CRouteIndexPtr.asFunction<void Function(_CRouteEditor, _CRouteIndex)>();
late final _CRouteEditor_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CRouteEditor Function(_CContext)>>('CRouteEditor_C_createWith_CContext');
late final _CRouteEditor_C_createWith_CContext = _CRouteEditor_C_createWith_CContextPtr.asFunction<_CRouteEditor Function(_CContext)>();

late final _CRouteEditor_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRouteEditor_release');
late final _CRouteEditor_release = _CRouteEditor_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteEditor_retainPtr = _lookup<ffi.NativeFunction<_CRouteEditor Function(ffi.Pointer<ffi.Void>)>>('CRouteEditor_retain');
late final _CRouteEditor_retain = _CRouteEditor_retainPtr.asFunction<_CRouteEditor Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteEditorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteEditor Function()>>('CRouteEditorMakeDefault');
late final _CRouteEditorMakeDefault = _CRouteEditorMakeDefaultPtr.asFunction<_CRouteEditor Function()>();


late final _CStatefulChannel_CRouteEditorRoutesInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteEditorRoutesInfo Function()>>('CStatefulChannel_CRouteEditorRoutesInfoMakeDefault');
late final _CStatefulChannel_CRouteEditorRoutesInfoMakeDefault = _CStatefulChannel_CRouteEditorRoutesInfoMakeDefaultPtr.asFunction<_CStatefulChannel_CRouteEditorRoutesInfo Function()>();
late final _CStatefulChannel_CRouteEditorRoutesInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CRouteEditorRoutesInfo)>>('CStatefulChannel_CRouteEditorRoutesInfo_release');
late final _CStatefulChannel_CRouteEditorRoutesInfo_release = _CStatefulChannel_CRouteEditorRoutesInfo_releasePtr.asFunction<void Function(_CStatefulChannel_CRouteEditorRoutesInfo)>();
late final _CStatefulChannel_CRouteEditorRoutesInfo_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRouteEditorRoutesInfo Function(_CStatefulChannel_CRouteEditorRoutesInfo)>>('CStatefulChannel_CRouteEditorRoutesInfo_retain');
late final _CStatefulChannel_CRouteEditorRoutesInfo_retain = _CStatefulChannel_CRouteEditorRoutesInfo_retainPtr.asFunction<_CStatefulChannel_CRouteEditorRoutesInfo Function(_CStatefulChannel_CRouteEditorRoutesInfo)>();
late final _CStatefulChannel_CRouteEditorRoutesInfoGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CRouteEditorRoutesInfo Function(_CStatefulChannel_CRouteEditorRoutesInfo)>>('CStatefulChannel_CRouteEditorRoutesInfo_getCurrentValue');
late final _CStatefulChannel_CRouteEditorRoutesInfoGetCurrentValue = _CStatefulChannel_CRouteEditorRoutesInfoGetCurrentValuePtr.asFunction<_CRouteEditorRoutesInfo Function(_CStatefulChannel_CRouteEditorRoutesInfo)>();
late final _CStatefulChannel_CRouteEditorRoutesInfoConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CRouteEditorRoutesInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteEditorRoutesInfo, ffi.Int64)>>
  )
>>('CStatefulChannel_CRouteEditorRoutesInfo_connect');
late final _CStatefulChannel_CRouteEditorRoutesInfoConnect = _CStatefulChannel_CRouteEditorRoutesInfoConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CRouteEditorRoutesInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteEditorRoutesInfo, ffi.Int64)>>
  )
>();

late final _CArray_CTrafficRoutemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CTrafficRoute Function()>>('CArray_CTrafficRoute_makeEmpty');
late final _CArray_CTrafficRoutemakeEmpty = _CArray_CTrafficRoutemakeEmptyPtr.asFunction<_CArray_CTrafficRoute Function()>();
late final _CArray_CTrafficRouteaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CTrafficRoute, _CTrafficRoute)>>('CArray_CTrafficRoute_addElement');
late final _CArray_CTrafficRouteaddElement = _CArray_CTrafficRouteaddElementPtr.asFunction<void Function(_CArray_CTrafficRoute, _CTrafficRoute)>();
late final _forEach_CArray_CTrafficRoutePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CTrafficRoute, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTrafficRoute)>>)
>>('CArray_CTrafficRoute_forEachWithFunctionPointer');
late final _forEach_CArray_CTrafficRoute = _forEach_CArray_CTrafficRoutePtr.asFunction<
  void Function(_CArray_CTrafficRoute, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTrafficRoute)
>>)>();
late final _CArray_CTrafficRoute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CTrafficRoute)>>('CArray_CTrafficRoute_release');
late final _CArray_CTrafficRoute_release = _CArray_CTrafficRoute_releasePtr.asFunction<void Function(_CArray_CTrafficRoute)>();

late final _CArray_CRouteSearchPointmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRouteSearchPoint Function()>>('CArray_CRouteSearchPoint_makeEmpty');
late final _CArray_CRouteSearchPointmakeEmpty = _CArray_CRouteSearchPointmakeEmptyPtr.asFunction<_CArray_CRouteSearchPoint Function()>();
late final _CArray_CRouteSearchPointaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRouteSearchPoint, _CRouteSearchPoint)>>('CArray_CRouteSearchPoint_addElement');
late final _CArray_CRouteSearchPointaddElement = _CArray_CRouteSearchPointaddElementPtr.asFunction<void Function(_CArray_CRouteSearchPoint, _CRouteSearchPoint)>();
late final _forEach_CArray_CRouteSearchPointPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRouteSearchPoint, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteSearchPoint)>>)
>>('CArray_CRouteSearchPoint_forEachWithFunctionPointer');
late final _forEach_CArray_CRouteSearchPoint = _forEach_CArray_CRouteSearchPointPtr.asFunction<
  void Function(_CArray_CRouteSearchPoint, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRouteSearchPoint)
>>)>();
late final _CArray_CRouteSearchPoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRouteSearchPoint)>>('CArray_CRouteSearchPoint_release');
late final _CArray_CRouteSearchPoint_release = _CArray_CRouteSearchPoint_releasePtr.asFunction<void Function(_CArray_CRouteSearchPoint)>();

late final _CRouteEditorRouteParamsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteEditorRouteParams Function()>>('CRouteEditorRouteParamsMakeDefault');
late final _CRouteEditorRouteParamsMakeDefault = _CRouteEditorRouteParamsMakeDefaultPtr.asFunction<_CRouteEditorRouteParams Function()>();


late final _CRouteEditorRoutesInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteEditorRoutesInfo Function()>>('CRouteEditorRoutesInfoMakeDefault');
late final _CRouteEditorRoutesInfoMakeDefault = _CRouteEditorRoutesInfoMakeDefaultPtr.asFunction<_CRouteEditorRoutesInfo Function()>();


late final _CStatefulChannel_COptional_CRouteIndexMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CRouteIndex Function()>>('CStatefulChannel_COptional_CRouteIndexMakeDefault');
late final _CStatefulChannel_COptional_CRouteIndexMakeDefault = _CStatefulChannel_COptional_CRouteIndexMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CRouteIndex Function()>();
late final _CStatefulChannel_COptional_CRouteIndex_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CRouteIndex)>>('CStatefulChannel_COptional_CRouteIndex_release');
late final _CStatefulChannel_COptional_CRouteIndex_release = _CStatefulChannel_COptional_CRouteIndex_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CRouteIndex)>();
late final _CStatefulChannel_COptional_CRouteIndex_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CRouteIndex Function(_CStatefulChannel_COptional_CRouteIndex)>>('CStatefulChannel_COptional_CRouteIndex_retain');
late final _CStatefulChannel_COptional_CRouteIndex_retain = _CStatefulChannel_COptional_CRouteIndex_retainPtr.asFunction<_CStatefulChannel_COptional_CRouteIndex Function(_CStatefulChannel_COptional_CRouteIndex)>();
late final _CStatefulChannel_COptional_CRouteIndexGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CRouteIndex Function(_CStatefulChannel_COptional_CRouteIndex)>>('CStatefulChannel_COptional_CRouteIndex_getCurrentValue');
late final _CStatefulChannel_COptional_CRouteIndexGetCurrentValue = _CStatefulChannel_COptional_CRouteIndexGetCurrentValuePtr.asFunction<_COptional_CRouteIndex Function(_CStatefulChannel_COptional_CRouteIndex)>();
late final _CStatefulChannel_COptional_CRouteIndexConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CRouteIndex,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CRouteIndex, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CRouteIndex_connect');
late final _CStatefulChannel_COptional_CRouteIndexConnect = _CStatefulChannel_COptional_CRouteIndexConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CRouteIndex,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CRouteIndex, ffi.Int64)>>
  )
>();

late final _COptional_CRouteIndexMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRouteIndex Function()>>('COptional_CRouteIndexMakeDefault');
late final _COptional_CRouteIndexMakeDefault = _COptional_CRouteIndexMakeDefaultPtr.asFunction<_COptional_CRouteIndex Function()>();

late final _CRouteVisualizationTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteVisualizationType Function()>>('CRouteVisualizationTypeMakeDefault');
late final _CRouteVisualizationTypeMakeDefault = _CRouteVisualizationTypeMakeDefaultPtr.asFunction<_CRouteVisualizationType Function()>();
late final _CRouteMapObjectSource_objectsPtr = _lookup<ffi.NativeFunction<_CArray_CRouteMapObject Function(_CRouteMapObjectSource)>>('CRouteMapObjectSource_objects');
late final _CRouteMapObjectSource_objects = _CRouteMapObjectSource_objectsPtr.asFunction<_CArray_CRouteMapObject Function(_CRouteMapObjectSource)>();
late final _CRouteMapObjectSource_routeSourceSettingsPtr = _lookup<ffi.NativeFunction<_CRouteSourceSettings Function(_CRouteMapObjectSource)>>('CRouteMapObjectSource_routeSourceSettings');
late final _CRouteMapObjectSource_routeSourceSettings = _CRouteMapObjectSource_routeSourceSettingsPtr.asFunction<_CRouteSourceSettings Function(_CRouteMapObjectSource)>();

late final _CRouteMapObjectSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRouteMapObjectSource_cg_objectIdentifier');
late final _CRouteMapObjectSource_cg_objectIdentifier = _CRouteMapObjectSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRouteMapObjectSource_addObject_CRouteMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapObjectSource, _CRouteMapObject)>>('CRouteMapObjectSource_addObject_CRouteMapObject');
late final _CRouteMapObjectSource_addObject_CRouteMapObject = _CRouteMapObjectSource_addObject_CRouteMapObjectPtr.asFunction<void Function(_CRouteMapObjectSource, _CRouteMapObject)>();
late final _CRouteMapObjectSource_removeObject_CRouteMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapObjectSource, _CRouteMapObject)>>('CRouteMapObjectSource_removeObject_CRouteMapObject');
late final _CRouteMapObjectSource_removeObject_CRouteMapObject = _CRouteMapObjectSource_removeObject_CRouteMapObjectPtr.asFunction<void Function(_CRouteMapObjectSource, _CRouteMapObject)>();
late final _CRouteMapObjectSource_replaceObject_CRouteMapObject_CRouteMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapObjectSource, _CRouteMapObject, _CRouteMapObject)>>('CRouteMapObjectSource_replaceObject_CRouteMapObject_CRouteMapObject');
late final _CRouteMapObjectSource_replaceObject_CRouteMapObject_CRouteMapObject = _CRouteMapObjectSource_replaceObject_CRouteMapObject_CRouteMapObjectPtr.asFunction<void Function(_CRouteMapObjectSource, _CRouteMapObject, _CRouteMapObject)>();
late final _CRouteMapObjectSource_clearPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapObjectSource)>>('CRouteMapObjectSource_clear');
late final _CRouteMapObjectSource_clear = _CRouteMapObjectSource_clearPtr.asFunction<void Function(_CRouteMapObjectSource)>();
late final _CRouteMapObjectSource_replaceAllObjects_CArray_CRouteMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapObjectSource, _CArray_CRouteMapObject)>>('CRouteMapObjectSource_replaceAllObjects_CArray_CRouteMapObject');
late final _CRouteMapObjectSource_replaceAllObjects_CArray_CRouteMapObject = _CRouteMapObjectSource_replaceAllObjects_CArray_CRouteMapObjectPtr.asFunction<void Function(_CRouteMapObjectSource, _CArray_CRouteMapObject)>();
late final _CRouteMapObjectSource_C_createWith_CContext_CRouteVisualizationTypePtr = _lookup<ffi.NativeFunction<_CRouteMapObjectSource Function(_CContext, _CRouteVisualizationType)>>('CRouteMapObjectSource_C_createWith_CContext_CRouteVisualizationType');
late final _CRouteMapObjectSource_C_createWith_CContext_CRouteVisualizationType = _CRouteMapObjectSource_C_createWith_CContext_CRouteVisualizationTypePtr.asFunction<_CRouteMapObjectSource Function(_CContext, _CRouteVisualizationType)>();

late final _CRouteMapObjectSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRouteMapObjectSource_release');
late final _CRouteMapObjectSource_release = _CRouteMapObjectSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteMapObjectSource_retainPtr = _lookup<ffi.NativeFunction<_CRouteMapObjectSource Function(ffi.Pointer<ffi.Void>)>>('CRouteMapObjectSource_retain');
late final _CRouteMapObjectSource_retain = _CRouteMapObjectSource_retainPtr.asFunction<_CRouteMapObjectSource Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteMapObjectSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteMapObjectSource Function()>>('CRouteMapObjectSourceMakeDefault');
late final _CRouteMapObjectSourceMakeDefault = _CRouteMapObjectSourceMakeDefaultPtr.asFunction<_CRouteMapObjectSource Function()>();

late final _CRouteInfoCalloutMapObject_routePtr = _lookup<ffi.NativeFunction<_CTrafficRoute Function(_CRouteInfoCalloutMapObject)>>('CRouteInfoCalloutMapObject_route');
late final _CRouteInfoCalloutMapObject_route = _CRouteInfoCalloutMapObject_routePtr.asFunction<_CTrafficRoute Function(_CRouteInfoCalloutMapObject)>();
late final _CRouteInfoCalloutMapObject_routeIndexPtr = _lookup<ffi.NativeFunction<_CRouteIndex Function(_CRouteInfoCalloutMapObject)>>('CRouteInfoCalloutMapObject_routeIndex');
late final _CRouteInfoCalloutMapObject_routeIndex = _CRouteInfoCalloutMapObject_routeIndexPtr.asFunction<_CRouteIndex Function(_CRouteInfoCalloutMapObject)>();
late final _CRouteInfoCalloutMapObject_routePointPtr = _lookup<ffi.NativeFunction<_CRoutePoint Function(_CRouteInfoCalloutMapObject)>>('CRouteInfoCalloutMapObject_routePoint');
late final _CRouteInfoCalloutMapObject_routePoint = _CRouteInfoCalloutMapObject_routePointPtr.asFunction<_CRoutePoint Function(_CRouteInfoCalloutMapObject)>();

late final _CRouteInfoCalloutMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRouteInfoCalloutMapObject_cg_objectIdentifier');
late final _CRouteInfoCalloutMapObject_cg_objectIdentifier = _CRouteInfoCalloutMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CRouteInfoCalloutMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRouteInfoCalloutMapObject_release');
late final _CRouteInfoCalloutMapObject_release = _CRouteInfoCalloutMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteInfoCalloutMapObject_retainPtr = _lookup<ffi.NativeFunction<_CRouteInfoCalloutMapObject Function(ffi.Pointer<ffi.Void>)>>('CRouteInfoCalloutMapObject_retain');
late final _CRouteInfoCalloutMapObject_retain = _CRouteInfoCalloutMapObject_retainPtr.asFunction<_CRouteInfoCalloutMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteInfoCalloutMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteInfoCalloutMapObject Function()>>('CRouteInfoCalloutMapObjectMakeDefault');
late final _CRouteInfoCalloutMapObjectMakeDefault = _CRouteInfoCalloutMapObjectMakeDefaultPtr.asFunction<_CRouteInfoCalloutMapObject Function()>();


late final _CRoutePointKindMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoutePointKind Function()>>('CRoutePointKindMakeDefault');
late final _CRoutePointKindMakeDefault = _CRoutePointKindMakeDefaultPtr.asFunction<_CRoutePointKind Function()>();
late final _CRoutePointMapObject_routePtr = _lookup<ffi.NativeFunction<_CTrafficRoute Function(_CRoutePointMapObject)>>('CRoutePointMapObject_route');
late final _CRoutePointMapObject_route = _CRoutePointMapObject_routePtr.asFunction<_CTrafficRoute Function(_CRoutePointMapObject)>();
late final _CRoutePointMapObject_routeIndexPtr = _lookup<ffi.NativeFunction<_CRouteIndex Function(_CRoutePointMapObject)>>('CRoutePointMapObject_routeIndex');
late final _CRoutePointMapObject_routeIndex = _CRoutePointMapObject_routeIndexPtr.asFunction<_CRouteIndex Function(_CRoutePointMapObject)>();
late final _CRoutePointMapObject_kindPtr = _lookup<ffi.NativeFunction<_CRoutePointKind Function(_CRoutePointMapObject)>>('CRoutePointMapObject_kind');
late final _CRoutePointMapObject_kind = _CRoutePointMapObject_kindPtr.asFunction<_CRoutePointKind Function(_CRoutePointMapObject)>();
late final _CRoutePointMapObject_routePointPtr = _lookup<ffi.NativeFunction<_CRoutePoint Function(_CRoutePointMapObject)>>('CRoutePointMapObject_routePoint');
late final _CRoutePointMapObject_routePoint = _CRoutePointMapObject_routePointPtr.asFunction<_CRoutePoint Function(_CRoutePointMapObject)>();
late final _CRoutePointMapObject_pointChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeoPoint Function(_CRoutePointMapObject)>>('CRoutePointMapObject_pointChannel');
late final _CRoutePointMapObject_pointChannel = _CRoutePointMapObject_pointChannelPtr.asFunction<_CStatefulChannel_CGeoPoint Function(_CRoutePointMapObject)>();
late final _CRoutePointMapObject_pointPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CRoutePointMapObject)>>('CRoutePointMapObject_point');
late final _CRoutePointMapObject_point = _CRoutePointMapObject_pointPtr.asFunction<_CGeoPoint Function(_CRoutePointMapObject)>();
late final _CRoutePointMapObject_setPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRoutePointMapObject, _CGeoPoint)>>('CRoutePointMapObject_setPoint_CGeoPoint');
late final _CRoutePointMapObject_setPoint_CGeoPoint = _CRoutePointMapObject_setPoint_CGeoPointPtr.asFunction<void Function(_CRoutePointMapObject, _CGeoPoint)>();

late final _CRoutePointMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoutePointMapObject_cg_objectIdentifier');
late final _CRoutePointMapObject_cg_objectIdentifier = _CRoutePointMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CRoutePointMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoutePointMapObject_release');
late final _CRoutePointMapObject_release = _CRoutePointMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoutePointMapObject_retainPtr = _lookup<ffi.NativeFunction<_CRoutePointMapObject Function(ffi.Pointer<ffi.Void>)>>('CRoutePointMapObject_retain');
late final _CRoutePointMapObject_retain = _CRoutePointMapObject_retainPtr.asFunction<_CRoutePointMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CRoutePointMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoutePointMapObject Function()>>('CRoutePointMapObjectMakeDefault');
late final _CRoutePointMapObjectMakeDefault = _CRoutePointMapObjectMakeDefaultPtr.asFunction<_CRoutePointMapObject Function()>();


late final _CStatefulChannel_CGeoPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeoPoint Function()>>('CStatefulChannel_CGeoPointMakeDefault');
late final _CStatefulChannel_CGeoPointMakeDefault = _CStatefulChannel_CGeoPointMakeDefaultPtr.asFunction<_CStatefulChannel_CGeoPoint Function()>();
late final _CStatefulChannel_CGeoPoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CGeoPoint)>>('CStatefulChannel_CGeoPoint_release');
late final _CStatefulChannel_CGeoPoint_release = _CStatefulChannel_CGeoPoint_releasePtr.asFunction<void Function(_CStatefulChannel_CGeoPoint)>();
late final _CStatefulChannel_CGeoPoint_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeoPoint Function(_CStatefulChannel_CGeoPoint)>>('CStatefulChannel_CGeoPoint_retain');
late final _CStatefulChannel_CGeoPoint_retain = _CStatefulChannel_CGeoPoint_retainPtr.asFunction<_CStatefulChannel_CGeoPoint Function(_CStatefulChannel_CGeoPoint)>();
late final _CStatefulChannel_CGeoPointGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CStatefulChannel_CGeoPoint)>>('CStatefulChannel_CGeoPoint_getCurrentValue');
late final _CStatefulChannel_CGeoPointGetCurrentValue = _CStatefulChannel_CGeoPointGetCurrentValuePtr.asFunction<_CGeoPoint Function(_CStatefulChannel_CGeoPoint)>();
late final _CStatefulChannel_CGeoPointConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CGeoPoint,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeoPoint, ffi.Int64)>>
  )
>>('CStatefulChannel_CGeoPoint_connect');
late final _CStatefulChannel_CGeoPointConnect = _CStatefulChannel_CGeoPointConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CGeoPoint,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeoPoint, ffi.Int64)>>
  )
>();

late final _CFpsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFps Function()>>('CFpsMakeDefault');
late final _CFpsMakeDefault = _CFpsMakeDefaultPtr.asFunction<_CFps Function()>();

late final _CMapSurfaceProvider_idPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CMapSurfaceProvider)>>('CMapSurfaceProvider_id');
late final _CMapSurfaceProvider_id = _CMapSurfaceProvider_idPtr.asFunction<int Function(_CMapSurfaceProvider)>();

late final _CMapSurfaceProvider_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapSurfaceProvider_cg_objectIdentifier');
late final _CMapSurfaceProvider_cg_objectIdentifier = _CMapSurfaceProvider_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapSurfaceProvider_S_create_CMapPtr = _lookup<ffi.NativeFunction<_CMapSurfaceProvider Function(_CMap)>>('CMapSurfaceProvider_S_create_CMap');
late final _CMapSurfaceProvider_S_create_CMap = _CMapSurfaceProvider_S_create_CMapPtr.asFunction<_CMapSurfaceProvider Function(_CMap)>();
late final _CMapSurfaceProvider_setOffscreenSurface_CScreenSizePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapSurfaceProvider, _CScreenSize)>>('CMapSurfaceProvider_setOffscreenSurface_CScreenSize');
late final _CMapSurfaceProvider_setOffscreenSurface_CScreenSize = _CMapSurfaceProvider_setOffscreenSurface_CScreenSizePtr.asFunction<void Function(_CMapSurfaceProvider, _CScreenSize)>();
late final _CMapSurfaceProvider_destroySurfacePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapSurfaceProvider)>>('CMapSurfaceProvider_destroySurface');
late final _CMapSurfaceProvider_destroySurface = _CMapSurfaceProvider_destroySurfacePtr.asFunction<void Function(_CMapSurfaceProvider)>();
late final _CMapSurfaceProvider_destroySurfaceAsyncPtr = _lookup<ffi.NativeFunction<_CFuture_bool Function(_CMapSurfaceProvider)>>('CMapSurfaceProvider_destroySurfaceAsync');
late final _CMapSurfaceProvider_destroySurfaceAsync = _CMapSurfaceProvider_destroySurfaceAsyncPtr.asFunction<_CFuture_bool Function(_CMapSurfaceProvider)>();
late final _CMapSurfaceProvider_resizeSurface_CScreenSizePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapSurfaceProvider, _CScreenSize)>>('CMapSurfaceProvider_resizeSurface_CScreenSize');
late final _CMapSurfaceProvider_resizeSurface_CScreenSize = _CMapSurfaceProvider_resizeSurface_CScreenSizePtr.asFunction<void Function(_CMapSurfaceProvider, _CScreenSize)>();
late final _CMapSurfaceProvider_setActive_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapSurfaceProvider, ffi.Bool)>>('CMapSurfaceProvider_setActive_bool');
late final _CMapSurfaceProvider_setActive_bool = _CMapSurfaceProvider_setActive_boolPtr.asFunction<void Function(_CMapSurfaceProvider, bool)>();

late final _CMapSurfaceProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapSurfaceProvider_release');
late final _CMapSurfaceProvider_release = _CMapSurfaceProvider_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapSurfaceProvider_retainPtr = _lookup<ffi.NativeFunction<_CMapSurfaceProvider Function(ffi.Pointer<ffi.Void>)>>('CMapSurfaceProvider_retain');
late final _CMapSurfaceProvider_retain = _CMapSurfaceProvider_retainPtr.asFunction<_CMapSurfaceProvider Function(ffi.Pointer<ffi.Void>)>();
late final _CMapSurfaceProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapSurfaceProvider Function()>>('CMapSurfaceProviderMakeDefault');
late final _CMapSurfaceProviderMakeDefault = _CMapSurfaceProviderMakeDefaultPtr.asFunction<_CMapSurfaceProvider Function()>();


late final _CFuture_boolMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_bool Function()>>('CFuture_boolMakeDefault');
late final _CFuture_boolMakeDefault = _CFuture_boolMakeDefaultPtr.asFunction<_CFuture_bool Function()>();
late final _CFuture_bool_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_bool)>>('CFuture_bool_release');
late final _CFuture_bool_release = _CFuture_bool_releasePtr.asFunction<void Function(_CFuture_bool)>();
late final _CFuture_bool_retainPtr = _lookup<ffi.NativeFunction<_CFuture_bool Function(_CFuture_bool)>>('CFuture_bool_retain');
late final _CFuture_bool_retain = _CFuture_bool_retainPtr.asFunction<_CFuture_bool Function(_CFuture_bool)>();
late final _CFuture_boolReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_bool,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_bool_receive');
late final _CFuture_boolReceive = _CFuture_boolReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_bool,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();
late final _CMapRenderer_maxFpsPtr = _lookup<ffi.NativeFunction<_COptional_CFps Function(_CMapRenderer)>>('CMapRenderer_maxFps');
late final _CMapRenderer_maxFps = _CMapRenderer_maxFpsPtr.asFunction<_COptional_CFps Function(_CMapRenderer)>();
late final _CMapRenderer_powerSavingMaxFpsPtr = _lookup<ffi.NativeFunction<_COptional_CFps Function(_CMapRenderer)>>('CMapRenderer_powerSavingMaxFps');
late final _CMapRenderer_powerSavingMaxFps = _CMapRenderer_powerSavingMaxFpsPtr.asFunction<_COptional_CFps Function(_CMapRenderer)>();
late final _CMapRenderer_fpsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CFps Function(_CMapRenderer)>>('CMapRenderer_fpsChannel');
late final _CMapRenderer_fpsChannel = _CMapRenderer_fpsChannelPtr.asFunction<_CStatefulChannel_CFps Function(_CMapRenderer)>();
late final _CMapRenderer_fpsPtr = _lookup<ffi.NativeFunction<_CFps Function(_CMapRenderer)>>('CMapRenderer_fps');
late final _CMapRenderer_fps = _CMapRenderer_fpsPtr.asFunction<_CFps Function(_CMapRenderer)>();

late final _CMapRenderer_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapRenderer_cg_objectIdentifier');
late final _CMapRenderer_cg_objectIdentifier = _CMapRenderer_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapRenderer_S_create_CMapPtr = _lookup<ffi.NativeFunction<_CMapRenderer Function(_CMap)>>('CMapRenderer_S_create_CMap');
late final _CMapRenderer_S_create_CMap = _CMapRenderer_S_create_CMapPtr.asFunction<_CMapRenderer Function(_CMap)>();
late final _CMapRenderer_setMaxFps_COptional_CFps_COptional_CFpsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapRenderer, _COptional_CFps, _COptional_CFps)>>('CMapRenderer_setMaxFps_COptional_CFps_COptional_CFps');
late final _CMapRenderer_setMaxFps_COptional_CFps_COptional_CFps = _CMapRenderer_setMaxFps_COptional_CFps_COptional_CFpsPtr.asFunction<void Function(_CMapRenderer, _COptional_CFps, _COptional_CFps)>();
late final _CMapRenderer_waitForLoadingPtr = _lookup<ffi.NativeFunction<_CFuture_bool Function(_CMapRenderer)>>('CMapRenderer_waitForLoading');
late final _CMapRenderer_waitForLoading = _CMapRenderer_waitForLoadingPtr.asFunction<_CFuture_bool Function(_CMapRenderer)>();
late final _CMapRenderer_waitForRenderingPtr = _lookup<ffi.NativeFunction<_CFuture_bool Function(_CMapRenderer)>>('CMapRenderer_waitForRendering');
late final _CMapRenderer_waitForRendering = _CMapRenderer_waitForRenderingPtr.asFunction<_CFuture_bool Function(_CMapRenderer)>();
late final _CMapRenderer_takeSnapshot_CAlignmentPtr = _lookup<ffi.NativeFunction<_CFuture_CImageData Function(_CMapRenderer, _CAlignment)>>('CMapRenderer_takeSnapshot_CAlignment');
late final _CMapRenderer_takeSnapshot_CAlignment = _CMapRenderer_takeSnapshot_CAlignmentPtr.asFunction<_CFuture_CImageData Function(_CMapRenderer, _CAlignment)>();

late final _CMapRenderer_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapRenderer_release');
late final _CMapRenderer_release = _CMapRenderer_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapRenderer_retainPtr = _lookup<ffi.NativeFunction<_CMapRenderer Function(ffi.Pointer<ffi.Void>)>>('CMapRenderer_retain');
late final _CMapRenderer_retain = _CMapRenderer_retainPtr.asFunction<_CMapRenderer Function(ffi.Pointer<ffi.Void>)>();
late final _CMapRendererMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapRenderer Function()>>('CMapRendererMakeDefault');
late final _CMapRendererMakeDefault = _CMapRendererMakeDefaultPtr.asFunction<_CMapRenderer Function()>();


late final _COptional_CFpsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CFps Function()>>('COptional_CFpsMakeDefault');
late final _COptional_CFpsMakeDefault = _COptional_CFpsMakeDefaultPtr.asFunction<_COptional_CFps Function()>();

late final _CStatefulChannel_CFpsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CFps Function()>>('CStatefulChannel_CFpsMakeDefault');
late final _CStatefulChannel_CFpsMakeDefault = _CStatefulChannel_CFpsMakeDefaultPtr.asFunction<_CStatefulChannel_CFps Function()>();
late final _CStatefulChannel_CFps_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CFps)>>('CStatefulChannel_CFps_release');
late final _CStatefulChannel_CFps_release = _CStatefulChannel_CFps_releasePtr.asFunction<void Function(_CStatefulChannel_CFps)>();
late final _CStatefulChannel_CFps_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CFps Function(_CStatefulChannel_CFps)>>('CStatefulChannel_CFps_retain');
late final _CStatefulChannel_CFps_retain = _CStatefulChannel_CFps_retainPtr.asFunction<_CStatefulChannel_CFps Function(_CStatefulChannel_CFps)>();
late final _CStatefulChannel_CFpsGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CFps Function(_CStatefulChannel_CFps)>>('CStatefulChannel_CFps_getCurrentValue');
late final _CStatefulChannel_CFpsGetCurrentValue = _CStatefulChannel_CFpsGetCurrentValuePtr.asFunction<_CFps Function(_CStatefulChannel_CFps)>();
late final _CStatefulChannel_CFpsConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CFps,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CFps, ffi.Int64)>>
  )
>>('CStatefulChannel_CFps_connect');
late final _CStatefulChannel_CFpsConnect = _CStatefulChannel_CFpsConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CFps,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CFps, ffi.Int64)>>
  )
>();

late final _CFuture_CImageDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CImageData Function()>>('CFuture_CImageDataMakeDefault');
late final _CFuture_CImageDataMakeDefault = _CFuture_CImageDataMakeDefaultPtr.asFunction<_CFuture_CImageData Function()>();
late final _CFuture_CImageData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CImageData)>>('CFuture_CImageData_release');
late final _CFuture_CImageData_release = _CFuture_CImageData_releasePtr.asFunction<void Function(_CFuture_CImageData)>();
late final _CFuture_CImageData_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CImageData Function(_CFuture_CImageData)>>('CFuture_CImageData_retain');
late final _CFuture_CImageData_retain = _CFuture_CImageData_retainPtr.asFunction<_CFuture_CImageData Function(_CFuture_CImageData)>();
late final _CFuture_CImageDataReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CImageData,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CImageData, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CImageData_receive');
late final _CFuture_CImageDataReceive = _CFuture_CImageDataReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CImageData,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CImageData, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CMapBuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapBuilder_cg_objectIdentifier');
late final _CMapBuilder_cg_objectIdentifier = _CMapBuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapBuilder_setSize_CScreenSizePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CScreenSize)>>('CMapBuilder_setSize_CScreenSize');
late final _CMapBuilder_setSize_CScreenSize = _CMapBuilder_setSize_CScreenSizePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CScreenSize)>();
late final _CMapBuilder_setDevicePpi_CDevicePpi_CDeviceDensityPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CDevicePpi, _CDeviceDensity)>>('CMapBuilder_setDevicePpi_CDevicePpi_CDeviceDensity');
late final _CMapBuilder_setDevicePpi_CDevicePpi_CDeviceDensity = _CMapBuilder_setDevicePpi_CDevicePpi_CDeviceDensityPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CDevicePpi, _CDeviceDensity)>();
late final _CMapBuilder_setFontIconSizeMultiplier_floatPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, ffi.Float)>>('CMapBuilder_setFontIconSizeMultiplier_float');
late final _CMapBuilder_setFontIconSizeMultiplier_float = _CMapBuilder_setFontIconSizeMultiplier_floatPtr.asFunction<_CMapBuilder Function(_CMapBuilder, double)>();
late final _CMapBuilder_setSystemFontIconSizeMultiplier_floatPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, ffi.Float)>>('CMapBuilder_setSystemFontIconSizeMultiplier_float');
late final _CMapBuilder_setSystemFontIconSizeMultiplier_float = _CMapBuilder_setSystemFontIconSizeMultiplier_floatPtr.asFunction<_CMapBuilder Function(_CMapBuilder, double)>();
late final _CMapBuilder_setStyle_CStylePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CStyle)>>('CMapBuilder_setStyle_CStyle');
late final _CMapBuilder_setStyle_CStyle = _CMapBuilder_setStyle_CStylePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CStyle)>();
late final _CMapBuilder_setStyleFromFile_CContext_CFilePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CContext, _CFile)>>('CMapBuilder_setStyleFromFile_CContext_CFile');
late final _CMapBuilder_setStyleFromFile_CContext_CFile = _CMapBuilder_setStyleFromFile_CContext_CFilePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CContext, _CFile)>();
late final _CMapBuilder_setPosition_CCameraPositionPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CCameraPosition)>>('CMapBuilder_setPosition_CCameraPosition');
late final _CMapBuilder_setPosition_CCameraPosition = _CMapBuilder_setPosition_CCameraPositionPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CCameraPosition)>();
late final _CMapBuilder_setZoomRestrictions_CCameraZoomRestrictionsPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CCameraZoomRestrictions)>>('CMapBuilder_setZoomRestrictions_CCameraZoomRestrictions');
late final _CMapBuilder_setZoomRestrictions_CCameraZoomRestrictions = _CMapBuilder_setZoomRestrictions_CCameraZoomRestrictionsPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CCameraZoomRestrictions)>();
late final _CMapBuilder_setPositionPoint_CCameraPositionPointPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CCameraPositionPoint)>>('CMapBuilder_setPositionPoint_CCameraPositionPoint');
late final _CMapBuilder_setPositionPoint_CCameraPositionPoint = _CMapBuilder_setPositionPoint_CCameraPositionPointPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CCameraPositionPoint)>();
late final _CMapBuilder_setBehaviour_CCameraBehaviourPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CCameraBehaviour)>>('CMapBuilder_setBehaviour_CCameraBehaviour');
late final _CMapBuilder_setBehaviour_CCameraBehaviour = _CMapBuilder_setBehaviour_CCameraBehaviourPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CCameraBehaviour)>();
late final _CMapBuilder_setFollowController_CFollowControllerPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CFollowController)>>('CMapBuilder_setFollowController_CFollowController');
late final _CMapBuilder_setFollowController_CFollowController = _CMapBuilder_setFollowController_CFollowControllerPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CFollowController)>();
late final _CMapBuilder_setAttribute_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CString, _CAttributeValue)>>('CMapBuilder_setAttribute_CString_CAttributeValue');
late final _CMapBuilder_setAttribute_CString_CAttributeValue = _CMapBuilder_setAttribute_CString_CAttributeValuePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CString, _CAttributeValue)>();
late final _CMapBuilder_setAttributes_CDictionary_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CDictionary_CString_CAttributeValue)>>('CMapBuilder_setAttributes_CDictionary_CString_CAttributeValue');
late final _CMapBuilder_setAttributes_CDictionary_CString_CAttributeValue = _CMapBuilder_setAttributes_CDictionary_CString_CAttributeValuePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CDictionary_CString_CAttributeValue)>();
late final _CMapBuilder_setBackgroundColor_CColorPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CColor)>>('CMapBuilder_setBackgroundColor_CColor');
late final _CMapBuilder_setBackgroundColor_CColor = _CMapBuilder_setBackgroundColor_CColorPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CColor)>();
late final _CMapBuilder_setVisibilityState_CMapVisibilityStatePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CMapVisibilityState)>>('CMapBuilder_setVisibilityState_CMapVisibilityState');
late final _CMapBuilder_setVisibilityState_CMapVisibilityState = _CMapBuilder_setVisibilityState_CMapVisibilityStatePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CMapVisibilityState)>();
late final _CMapBuilder_setGraphicsPreset_CGraphicsPresetPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CGraphicsPreset)>>('CMapBuilder_setGraphicsPreset_CGraphicsPreset');
late final _CMapBuilder_setGraphicsPreset_CGraphicsPreset = _CMapBuilder_setGraphicsPreset_CGraphicsPresetPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CGraphicsPreset)>();
late final _CMapBuilder_addSource_CSourcePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CSource)>>('CMapBuilder_addSource_CSource');
late final _CMapBuilder_addSource_CSource = _CMapBuilder_addSource_CSourcePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CSource)>();
late final _CMapBuilder_createMap_CContextPtr = _lookup<ffi.NativeFunction<_CFuture_CMap Function(_CMapBuilder, _CContext)>>('CMapBuilder_createMap_CContext');
late final _CMapBuilder_createMap_CContext = _CMapBuilder_createMap_CContextPtr.asFunction<_CFuture_CMap Function(_CMapBuilder, _CContext)>();
late final _CMapBuilder_C_createPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function()>>('CMapBuilder_C_create');
late final _CMapBuilder_C_create = _CMapBuilder_C_createPtr.asFunction<_CMapBuilder Function()>();

late final _CMapBuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapBuilder_release');
late final _CMapBuilder_release = _CMapBuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapBuilder_retainPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(ffi.Pointer<ffi.Void>)>>('CMapBuilder_retain');
late final _CMapBuilder_retain = _CMapBuilder_retainPtr.asFunction<_CMapBuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CMapBuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function()>>('CMapBuilderMakeDefault');
late final _CMapBuilderMakeDefault = _CMapBuilderMakeDefaultPtr.asFunction<_CMapBuilder Function()>();


late final _CFuture_CMapMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CMap Function()>>('CFuture_CMapMakeDefault');
late final _CFuture_CMapMakeDefault = _CFuture_CMapMakeDefaultPtr.asFunction<_CFuture_CMap Function()>();
late final _CFuture_CMap_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CMap)>>('CFuture_CMap_release');
late final _CFuture_CMap_release = _CFuture_CMap_releasePtr.asFunction<void Function(_CFuture_CMap)>();
late final _CFuture_CMap_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CMap Function(_CFuture_CMap)>>('CFuture_CMap_retain');
late final _CFuture_CMap_retain = _CFuture_CMap_retainPtr.asFunction<_CFuture_CMap Function(_CFuture_CMap)>();
late final _CFuture_CMapReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CMap,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMap, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CMap_receive');
late final _CFuture_CMapReceive = _CFuture_CMapReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CMap,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMap, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CStyleBuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CStyleBuilder_cg_objectIdentifier');
late final _CStyleBuilder_cg_objectIdentifier = _CStyleBuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CStyleBuilder_setStyleAttribute_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CStyleBuilder Function(_CStyleBuilder, _CString, _CAttributeValue)>>('CStyleBuilder_setStyleAttribute_CString_CAttributeValue');
late final _CStyleBuilder_setStyleAttribute_CString_CAttributeValue = _CStyleBuilder_setStyleAttribute_CString_CAttributeValuePtr.asFunction<_CStyleBuilder Function(_CStyleBuilder, _CString, _CAttributeValue)>();
late final _CStyleBuilder_getDefaultStylePtr = _lookup<ffi.NativeFunction<_CFuture_CStyle Function(_CStyleBuilder)>>('CStyleBuilder_getDefaultStyle');
late final _CStyleBuilder_getDefaultStyle = _CStyleBuilder_getDefaultStylePtr.asFunction<_CFuture_CStyle Function(_CStyleBuilder)>();
late final _CStyleBuilder_loadStyle_CFilePtr = _lookup<ffi.NativeFunction<_CFuture_CStyle Function(_CStyleBuilder, _CFile)>>('CStyleBuilder_loadStyle_CFile');
late final _CStyleBuilder_loadStyle_CFile = _CStyleBuilder_loadStyle_CFilePtr.asFunction<_CFuture_CStyle Function(_CStyleBuilder, _CFile)>();
late final _CStyleBuilder_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CStyleBuilder Function(_CContext)>>('CStyleBuilder_C_createWith_CContext');
late final _CStyleBuilder_C_createWith_CContext = _CStyleBuilder_C_createWith_CContextPtr.asFunction<_CStyleBuilder Function(_CContext)>();

late final _CStyleBuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CStyleBuilder_release');
late final _CStyleBuilder_release = _CStyleBuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleBuilder_retainPtr = _lookup<ffi.NativeFunction<_CStyleBuilder Function(ffi.Pointer<ffi.Void>)>>('CStyleBuilder_retain');
late final _CStyleBuilder_retain = _CStyleBuilder_retainPtr.asFunction<_CStyleBuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleBuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyleBuilder Function()>>('CStyleBuilderMakeDefault');
late final _CStyleBuilderMakeDefault = _CStyleBuilderMakeDefaultPtr.asFunction<_CStyleBuilder Function()>();


late final _CFuture_CStyleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CStyle Function()>>('CFuture_CStyleMakeDefault');
late final _CFuture_CStyleMakeDefault = _CFuture_CStyleMakeDefaultPtr.asFunction<_CFuture_CStyle Function()>();
late final _CFuture_CStyle_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CStyle)>>('CFuture_CStyle_release');
late final _CFuture_CStyle_release = _CFuture_CStyle_releasePtr.asFunction<void Function(_CFuture_CStyle)>();
late final _CFuture_CStyle_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CStyle Function(_CFuture_CStyle)>>('CFuture_CStyle_retain');
late final _CFuture_CStyle_retain = _CFuture_CStyle_retainPtr.asFunction<_CFuture_CStyle Function(_CFuture_CStyle)>();
late final _CFuture_CStyleReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CStyle,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStyle, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CStyle_receive');
late final _CFuture_CStyleReceive = _CFuture_CStyleReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CStyle,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStyle, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CRotationCenterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRotationCenter Function()>>('CRotationCenterMakeDefault');
late final _CRotationCenterMakeDefault = _CRotationCenterMakeDefaultPtr.asFunction<_CRotationCenter Function()>();

late final _CScalingCenterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScalingCenter Function()>>('CScalingCenterMakeDefault');
late final _CScalingCenterMakeDefault = _CScalingCenterMakeDefaultPtr.asFunction<_CScalingCenter Function()>();

late final _CEventsProcessingSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CEventsProcessingSettings Function()>>('CEventsProcessingSettingsMakeDefault');
late final _CEventsProcessingSettingsMakeDefault = _CEventsProcessingSettingsMakeDefaultPtr.asFunction<_CEventsProcessingSettings Function()>();


late final _CDragBeginDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDragBeginData Function()>>('CDragBeginDataMakeDefault');
late final _CDragBeginDataMakeDefault = _CDragBeginDataMakeDefaultPtr.asFunction<_CDragBeginData Function()>();


late final _CGestureMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGesture Function()>>('CGestureMakeDefault');
late final _CGestureMakeDefault = _CGestureMakeDefaultPtr.asFunction<_CGesture Function()>();

late final _CScalingSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScalingSettings Function()>>('CScalingSettingsMakeDefault');
late final _CScalingSettingsMakeDefault = _CScalingSettingsMakeDefaultPtr.asFunction<_CScalingSettings Function()>();


late final _CRotationSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRotationSettings Function()>>('CRotationSettingsMakeDefault');
late final _CRotationSettingsMakeDefault = _CRotationSettingsMakeDefaultPtr.asFunction<_CRotationSettings Function()>();


late final _CMultiTouchShiftSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMultiTouchShiftSettings Function()>>('CMultiTouchShiftSettingsMakeDefault');
late final _CMultiTouchShiftSettingsMakeDefault = _CMultiTouchShiftSettingsMakeDefaultPtr.asFunction<_CMultiTouchShiftSettings Function()>();


late final _CTiltSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTiltSettings Function()>>('CTiltSettingsMakeDefault');
late final _CTiltSettingsMakeDefault = _CTiltSettingsMakeDefaultPtr.asFunction<_CTiltSettings Function()>();

late final _CGestureManager_enabledGesturesPtr = _lookup<ffi.NativeFunction<_COptionSet_CGesture Function(_CGestureManager)>>('CGestureManager_enabledGestures');
late final _CGestureManager_enabledGestures = _CGestureManager_enabledGesturesPtr.asFunction<_COptionSet_CGesture Function(_CGestureManager)>();
late final _CGestureManager_setEnabledGestures_COptionSet_CGesturePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _COptionSet_CGesture)>>('CGestureManager_setEnabledGestures_COptionSet_CGesture');
late final _CGestureManager_setEnabledGestures_COptionSet_CGesture = _CGestureManager_setEnabledGestures_COptionSet_CGesturePtr.asFunction<void Function(_CGestureManager, _COptionSet_CGesture)>();
late final _CGestureManager_scalingSettingsPtr = _lookup<ffi.NativeFunction<_CScalingSettings Function(_CGestureManager)>>('CGestureManager_scalingSettings');
late final _CGestureManager_scalingSettings = _CGestureManager_scalingSettingsPtr.asFunction<_CScalingSettings Function(_CGestureManager)>();
late final _CGestureManager_setScalingSettings_CScalingSettingsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CScalingSettings)>>('CGestureManager_setScalingSettings_CScalingSettings');
late final _CGestureManager_setScalingSettings_CScalingSettings = _CGestureManager_setScalingSettings_CScalingSettingsPtr.asFunction<void Function(_CGestureManager, _CScalingSettings)>();
late final _CGestureManager_rotationSettingsPtr = _lookup<ffi.NativeFunction<_CRotationSettings Function(_CGestureManager)>>('CGestureManager_rotationSettings');
late final _CGestureManager_rotationSettings = _CGestureManager_rotationSettingsPtr.asFunction<_CRotationSettings Function(_CGestureManager)>();
late final _CGestureManager_setRotationSettings_CRotationSettingsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CRotationSettings)>>('CGestureManager_setRotationSettings_CRotationSettings');
late final _CGestureManager_setRotationSettings_CRotationSettings = _CGestureManager_setRotationSettings_CRotationSettingsPtr.asFunction<void Function(_CGestureManager, _CRotationSettings)>();
late final _CGestureManager_multitouchShiftSettingsPtr = _lookup<ffi.NativeFunction<_CMultiTouchShiftSettings Function(_CGestureManager)>>('CGestureManager_multitouchShiftSettings');
late final _CGestureManager_multitouchShiftSettings = _CGestureManager_multitouchShiftSettingsPtr.asFunction<_CMultiTouchShiftSettings Function(_CGestureManager)>();
late final _CGestureManager_setMultitouchShiftSettings_CMultiTouchShiftSettingsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CMultiTouchShiftSettings)>>('CGestureManager_setMultitouchShiftSettings_CMultiTouchShiftSettings');
late final _CGestureManager_setMultitouchShiftSettings_CMultiTouchShiftSettings = _CGestureManager_setMultitouchShiftSettings_CMultiTouchShiftSettingsPtr.asFunction<void Function(_CGestureManager, _CMultiTouchShiftSettings)>();
late final _CGestureManager_tiltSettingsPtr = _lookup<ffi.NativeFunction<_CTiltSettings Function(_CGestureManager)>>('CGestureManager_tiltSettings');
late final _CGestureManager_tiltSettings = _CGestureManager_tiltSettingsPtr.asFunction<_CTiltSettings Function(_CGestureManager)>();
late final _CGestureManager_setTiltSettings_CTiltSettingsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CTiltSettings)>>('CGestureManager_setTiltSettings_CTiltSettings');
late final _CGestureManager_setTiltSettings_CTiltSettings = _CGestureManager_setTiltSettings_CTiltSettingsPtr.asFunction<void Function(_CGestureManager, _CTiltSettings)>();

late final _CGestureManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGestureManager_cg_objectIdentifier');
late final _CGestureManager_cg_objectIdentifier = _CGestureManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CGestureManager_enableGesture_CGesturePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CGesture)>>('CGestureManager_enableGesture_CGesture');
late final _CGestureManager_enableGesture_CGesture = _CGestureManager_enableGesture_CGesturePtr.asFunction<void Function(_CGestureManager, _CGesture)>();
late final _CGestureManager_disableGesture_CGesturePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CGesture)>>('CGestureManager_disableGesture_CGesture');
late final _CGestureManager_disableGesture_CGesture = _CGestureManager_disableGesture_CGesturePtr.asFunction<void Function(_CGestureManager, _CGesture)>();
late final _CGestureManager_gestureEnabled_CGesturePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGestureManager, _CGesture)>>('CGestureManager_gestureEnabled_CGesture');
late final _CGestureManager_gestureEnabled_CGesture = _CGestureManager_gestureEnabled_CGesturePtr.asFunction<bool Function(_CGestureManager, _CGesture)>();
late final _CGestureManager_setSettingsAboutMapPositionPoint_CEventsProcessingSettingsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CEventsProcessingSettings)>>('CGestureManager_setSettingsAboutMapPositionPoint_CEventsProcessingSettings');
late final _CGestureManager_setSettingsAboutMapPositionPoint_CEventsProcessingSettings = _CGestureManager_setSettingsAboutMapPositionPoint_CEventsProcessingSettingsPtr.asFunction<void Function(_CGestureManager, _CEventsProcessingSettings)>();
late final _CGestureManager_setTargetGeoPoint_COptional_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _COptional_CGeoPoint)>>('CGestureManager_setTargetGeoPoint_COptional_CGeoPoint');
late final _CGestureManager_setTargetGeoPoint_COptional_CGeoPoint = _CGestureManager_setTargetGeoPoint_COptional_CGeoPointPtr.asFunction<void Function(_CGestureManager, _COptional_CGeoPoint)>();
late final _CGestureManager_setMutuallyExclusiveGestures_CArray_COptionSet_CGesturePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CArray_COptionSet_CGesture)>>('CGestureManager_setMutuallyExclusiveGestures_CArray_COptionSet_CGesture');
late final _CGestureManager_setMutuallyExclusiveGestures_CArray_COptionSet_CGesture = _CGestureManager_setMutuallyExclusiveGestures_CArray_COptionSet_CGesturePtr.asFunction<void Function(_CGestureManager, _CArray_COptionSet_CGesture)>();

late final _CGestureManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGestureManager_release');
late final _CGestureManager_release = _CGestureManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGestureManager_retainPtr = _lookup<ffi.NativeFunction<_CGestureManager Function(ffi.Pointer<ffi.Void>)>>('CGestureManager_retain');
late final _CGestureManager_retain = _CGestureManager_retainPtr.asFunction<_CGestureManager Function(ffi.Pointer<ffi.Void>)>();
late final _CGestureManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGestureManager Function()>>('CGestureManagerMakeDefault');
late final _CGestureManagerMakeDefault = _CGestureManagerMakeDefaultPtr.asFunction<_CGestureManager Function()>();


late final _COptionSet_CGestureMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CGesture Function()>>('COptionSet_CGestureMakeDefault');
late final _COptionSet_CGestureMakeDefault = _COptionSet_CGestureMakeDefaultPtr.asFunction<_COptionSet_CGesture Function()>();

late final _CArray_COptionSet_CGesturemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_COptionSet_CGesture Function()>>('CArray_COptionSet_CGesture_makeEmpty');
late final _CArray_COptionSet_CGesturemakeEmpty = _CArray_COptionSet_CGesturemakeEmptyPtr.asFunction<_CArray_COptionSet_CGesture Function()>();
late final _CArray_COptionSet_CGestureaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_COptionSet_CGesture, _COptionSet_CGesture)>>('CArray_COptionSet_CGesture_addElement');
late final _CArray_COptionSet_CGestureaddElement = _CArray_COptionSet_CGestureaddElementPtr.asFunction<void Function(_CArray_COptionSet_CGesture, _COptionSet_CGesture)>();
late final _forEach_CArray_COptionSet_CGesturePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_COptionSet_CGesture, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptionSet_CGesture)>>)
>>('CArray_COptionSet_CGesture_forEachWithFunctionPointer');
late final _forEach_CArray_COptionSet_CGesture = _forEach_CArray_COptionSet_CGesturePtr.asFunction<
  void Function(_CArray_COptionSet_CGesture, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptionSet_CGesture)
>>)>();
late final _CArray_COptionSet_CGesture_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_COptionSet_CGesture)>>('CArray_COptionSet_CGesture_release');
late final _CArray_COptionSet_CGesture_release = _CArray_COptionSet_CGesture_releasePtr.asFunction<void Function(_CArray_COptionSet_CGesture)>();

late final _CTouchPointStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTouchPointState Function()>>('CTouchPointStateMakeDefault');
late final _CTouchPointStateMakeDefault = _CTouchPointStateMakeDefaultPtr.asFunction<_CTouchPointState Function()>();
late final _CMapGestureRecognizer_dragBeginPtr = _lookup<ffi.NativeFunction<_CChannel_CDragBeginData Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_dragBegin');
late final _CMapGestureRecognizer_dragBegin = _CMapGestureRecognizer_dragBeginPtr.asFunction<_CChannel_CDragBeginData Function(_CMapGestureRecognizer)>();
late final _CMapGestureRecognizer_dragEndPtr = _lookup<ffi.NativeFunction<_CChannel_bool Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_dragEnd');
late final _CMapGestureRecognizer_dragEnd = _CMapGestureRecognizer_dragEndPtr.asFunction<_CChannel_bool Function(_CMapGestureRecognizer)>();
late final _CMapGestureRecognizer_dragMovePtr = _lookup<ffi.NativeFunction<_CChannel_CScreenPoint Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_dragMove');
late final _CMapGestureRecognizer_dragMove = _CMapGestureRecognizer_dragMovePtr.asFunction<_CChannel_CScreenPoint Function(_CMapGestureRecognizer)>();
late final _CMapGestureRecognizer_tapPtr = _lookup<ffi.NativeFunction<_CChannel_CScreenPoint Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_tap');
late final _CMapGestureRecognizer_tap = _CMapGestureRecognizer_tapPtr.asFunction<_CChannel_CScreenPoint Function(_CMapGestureRecognizer)>();
late final _CMapGestureRecognizer_longTouchPtr = _lookup<ffi.NativeFunction<_CChannel_CScreenPoint Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_longTouch');
late final _CMapGestureRecognizer_longTouch = _CMapGestureRecognizer_longTouchPtr.asFunction<_CChannel_CScreenPoint Function(_CMapGestureRecognizer)>();
late final _CMapGestureRecognizer_gestureManagerPtr = _lookup<ffi.NativeFunction<_COptional_CGestureManager Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_gestureManager');
late final _CMapGestureRecognizer_gestureManager = _CMapGestureRecognizer_gestureManagerPtr.asFunction<_COptional_CGestureManager Function(_CMapGestureRecognizer)>();

late final _CMapGestureRecognizer_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapGestureRecognizer_cg_objectIdentifier');
late final _CMapGestureRecognizer_cg_objectIdentifier = _CMapGestureRecognizer_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapGestureRecognizer_S_create_CMapPtr = _lookup<ffi.NativeFunction<_CMapGestureRecognizer Function(_CMap)>>('CMapGestureRecognizer_S_create_CMap');
late final _CMapGestureRecognizer_S_create_CMap = _CMapGestureRecognizer_S_create_CMapPtr.asFunction<_CMapGestureRecognizer Function(_CMap)>();
late final _CMapGestureRecognizer_addTouchPoint_CScreenPoint_CTouchPointState_uint64_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapGestureRecognizer, _CScreenPoint, _CTouchPointState, ffi.Uint64)>>('CMapGestureRecognizer_addTouchPoint_CScreenPoint_CTouchPointState_uint64_t');
late final _CMapGestureRecognizer_addTouchPoint_CScreenPoint_CTouchPointState_uint64_t = _CMapGestureRecognizer_addTouchPoint_CScreenPoint_CTouchPointState_uint64_tPtr.asFunction<void Function(_CMapGestureRecognizer, _CScreenPoint, _CTouchPointState, int)>();
late final _CMapGestureRecognizer_processTouchEvent_CTimeIntervalPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMapGestureRecognizer, _CTimeInterval)>>('CMapGestureRecognizer_processTouchEvent_CTimeInterval');
late final _CMapGestureRecognizer_processTouchEvent_CTimeInterval = _CMapGestureRecognizer_processTouchEvent_CTimeIntervalPtr.asFunction<bool Function(_CMapGestureRecognizer, _CTimeInterval)>();
late final _CMapGestureRecognizer_cancelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_cancel');
late final _CMapGestureRecognizer_cancel = _CMapGestureRecognizer_cancelPtr.asFunction<void Function(_CMapGestureRecognizer)>();
late final _CMapGestureRecognizer_onDevicePpiChanged_CDevicePpiPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapGestureRecognizer, _CDevicePpi)>>('CMapGestureRecognizer_onDevicePpiChanged_CDevicePpi');
late final _CMapGestureRecognizer_onDevicePpiChanged_CDevicePpi = _CMapGestureRecognizer_onDevicePpiChanged_CDevicePpiPtr.asFunction<void Function(_CMapGestureRecognizer, _CDevicePpi)>();

late final _CMapGestureRecognizer_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapGestureRecognizer_release');
late final _CMapGestureRecognizer_release = _CMapGestureRecognizer_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapGestureRecognizer_retainPtr = _lookup<ffi.NativeFunction<_CMapGestureRecognizer Function(ffi.Pointer<ffi.Void>)>>('CMapGestureRecognizer_retain');
late final _CMapGestureRecognizer_retain = _CMapGestureRecognizer_retainPtr.asFunction<_CMapGestureRecognizer Function(ffi.Pointer<ffi.Void>)>();
late final _CMapGestureRecognizerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapGestureRecognizer Function()>>('CMapGestureRecognizerMakeDefault');
late final _CMapGestureRecognizerMakeDefault = _CMapGestureRecognizerMakeDefaultPtr.asFunction<_CMapGestureRecognizer Function()>();


late final _CChannel_CDragBeginDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChannel_CDragBeginData Function()>>('CChannel_CDragBeginDataMakeDefault');
late final _CChannel_CDragBeginDataMakeDefault = _CChannel_CDragBeginDataMakeDefaultPtr.asFunction<_CChannel_CDragBeginData Function()>();
late final _CChannel_CDragBeginData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CChannel_CDragBeginData)>>('CChannel_CDragBeginData_release');
late final _CChannel_CDragBeginData_release = _CChannel_CDragBeginData_releasePtr.asFunction<void Function(_CChannel_CDragBeginData)>();
late final _CChannel_CDragBeginData_retainPtr = _lookup<ffi.NativeFunction<_CChannel_CDragBeginData Function(_CChannel_CDragBeginData)>>('CChannel_CDragBeginData_retain');
late final _CChannel_CDragBeginData_retain = _CChannel_CDragBeginData_retainPtr.asFunction<_CChannel_CDragBeginData Function(_CChannel_CDragBeginData)>();
late final _CChannel_CDragBeginDataConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CChannel_CDragBeginData,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDragBeginData, ffi.Int64)>>
  )
>>('CChannel_CDragBeginData_connect');
late final _CChannel_CDragBeginDataConnect = _CChannel_CDragBeginDataConnectPtr.asFunction<
  _CCancellable Function(
    _CChannel_CDragBeginData,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDragBeginData, ffi.Int64)>>
  )
>();

late final _CChannel_CScreenPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChannel_CScreenPoint Function()>>('CChannel_CScreenPointMakeDefault');
late final _CChannel_CScreenPointMakeDefault = _CChannel_CScreenPointMakeDefaultPtr.asFunction<_CChannel_CScreenPoint Function()>();
late final _CChannel_CScreenPoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CChannel_CScreenPoint)>>('CChannel_CScreenPoint_release');
late final _CChannel_CScreenPoint_release = _CChannel_CScreenPoint_releasePtr.asFunction<void Function(_CChannel_CScreenPoint)>();
late final _CChannel_CScreenPoint_retainPtr = _lookup<ffi.NativeFunction<_CChannel_CScreenPoint Function(_CChannel_CScreenPoint)>>('CChannel_CScreenPoint_retain');
late final _CChannel_CScreenPoint_retain = _CChannel_CScreenPoint_retainPtr.asFunction<_CChannel_CScreenPoint Function(_CChannel_CScreenPoint)>();
late final _CChannel_CScreenPointConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CChannel_CScreenPoint,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CScreenPoint, ffi.Int64)>>
  )
>>('CChannel_CScreenPoint_connect');
late final _CChannel_CScreenPointConnect = _CChannel_CScreenPointConnectPtr.asFunction<
  _CCancellable Function(
    _CChannel_CScreenPoint,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CScreenPoint, ffi.Int64)>>
  )
>();

late final _COptional_CGestureManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGestureManager Function()>>('COptional_CGestureManagerMakeDefault');
late final _COptional_CGestureManagerMakeDefault = _COptional_CGestureManagerMakeDefaultPtr.asFunction<_COptional_CGestureManager Function()>();

late final _COptional_CGestureManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CGestureManager)>>('COptional_CGestureManager_release');
late final _COptional_CGestureManager_release = _COptional_CGestureManager_releasePtr.asFunction<void Function(_COptional_CGestureManager)>();
late final _CIndoorDetector_indoorChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CIndoorDetector)>>('CIndoorDetector_indoorChannel');
late final _CIndoorDetector_indoorChannel = _CIndoorDetector_indoorChannelPtr.asFunction<_CStatefulChannel_bool Function(_CIndoorDetector)>();
late final _CIndoorDetector_indoorPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CIndoorDetector)>>('CIndoorDetector_indoor');
late final _CIndoorDetector_indoor = _CIndoorDetector_indoorPtr.asFunction<bool Function(_CIndoorDetector)>();

late final _CIndoorDetector_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CIndoorDetector_cg_objectIdentifier');
late final _CIndoorDetector_cg_objectIdentifier = _CIndoorDetector_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CIndoorDetector_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CIndoorDetector_release');
late final _CIndoorDetector_release = _CIndoorDetector_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorDetector_retainPtr = _lookup<ffi.NativeFunction<_CIndoorDetector Function(ffi.Pointer<ffi.Void>)>>('CIndoorDetector_retain');
late final _CIndoorDetector_retain = _CIndoorDetector_retainPtr.asFunction<_CIndoorDetector Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorDetectorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIndoorDetector Function()>>('CIndoorDetectorMakeDefault');
late final _CIndoorDetectorMakeDefault = _CIndoorDetectorMakeDefaultPtr.asFunction<_CIndoorDetector Function()>();

late final _CNavigationFollowController_followReturnDelayPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CNavigationFollowController)>>('CNavigationFollowController_followReturnDelay');
late final _CNavigationFollowController_followReturnDelay = _CNavigationFollowController_followReturnDelayPtr.asFunction<_CTimeInterval Function(_CNavigationFollowController)>();
late final _CNavigationFollowController_setFollowReturnDelay_CTimeIntervalPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CNavigationFollowController, _CTimeInterval)>>('CNavigationFollowController_setFollowReturnDelay_CTimeInterval');
late final _CNavigationFollowController_setFollowReturnDelay_CTimeInterval = _CNavigationFollowController_setFollowReturnDelay_CTimeIntervalPtr.asFunction<void Function(_CNavigationFollowController, _CTimeInterval)>();
late final _CNavigationFollowController_cameraBehaviourPtr = _lookup<ffi.NativeFunction<_CCameraBehaviour Function(_CNavigationFollowController)>>('CNavigationFollowController_cameraBehaviour');
late final _CNavigationFollowController_cameraBehaviour = _CNavigationFollowController_cameraBehaviourPtr.asFunction<_CCameraBehaviour Function(_CNavigationFollowController)>();
late final _CNavigationFollowController_setCameraBehaviour_CCameraBehaviourPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CNavigationFollowController, _CCameraBehaviour)>>('CNavigationFollowController_setCameraBehaviour_CCameraBehaviour');
late final _CNavigationFollowController_setCameraBehaviour_CCameraBehaviour = _CNavigationFollowController_setCameraBehaviour_CCameraBehaviourPtr.asFunction<void Function(_CNavigationFollowController, _CCameraBehaviour)>();

late final _CNavigationFollowController_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CNavigationFollowController_cg_objectIdentifier');
late final _CNavigationFollowController_cg_objectIdentifier = _CNavigationFollowController_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CNavigationFollowController_setFollow_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CNavigationFollowController, ffi.Bool)>>('CNavigationFollowController_setFollow_bool');
late final _CNavigationFollowController_setFollow_bool = _CNavigationFollowController_setFollow_boolPtr.asFunction<void Function(_CNavigationFollowController, bool)>();

late final _CNavigationFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CNavigationFollowController_release');
late final _CNavigationFollowController_release = _CNavigationFollowController_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CNavigationFollowController_retainPtr = _lookup<ffi.NativeFunction<_CNavigationFollowController Function(ffi.Pointer<ffi.Void>)>>('CNavigationFollowController_retain');
late final _CNavigationFollowController_retain = _CNavigationFollowController_retainPtr.asFunction<_CNavigationFollowController Function(ffi.Pointer<ffi.Void>)>();
late final _CNavigationFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CNavigationFollowController Function()>>('CNavigationFollowControllerMakeDefault');
late final _CNavigationFollowControllerMakeDefault = _CNavigationFollowControllerMakeDefaultPtr.asFunction<_CNavigationFollowController Function()>();

late final _CMapLocationController_mapToNorthOrientationPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMapLocationController)>>('CMapLocationController_mapToNorthOrientation');
late final _CMapLocationController_mapToNorthOrientation = _CMapLocationController_mapToNorthOrientationPtr.asFunction<bool Function(_CMapLocationController)>();
late final _CMapLocationController_setMapToNorthOrientation_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapLocationController, ffi.Bool)>>('CMapLocationController_setMapToNorthOrientation_bool');
late final _CMapLocationController_setMapToNorthOrientation_bool = _CMapLocationController_setMapToNorthOrientation_boolPtr.asFunction<void Function(_CMapLocationController, bool)>();

late final _CMapLocationController_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapLocationController_cg_objectIdentifier');
late final _CMapLocationController_cg_objectIdentifier = _CMapLocationController_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CMapLocationController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapLocationController_release');
late final _CMapLocationController_release = _CMapLocationController_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapLocationController_retainPtr = _lookup<ffi.NativeFunction<_CMapLocationController Function(ffi.Pointer<ffi.Void>)>>('CMapLocationController_retain');
late final _CMapLocationController_retain = _CMapLocationController_retainPtr.asFunction<_CMapLocationController Function(ffi.Pointer<ffi.Void>)>();
late final _CMapLocationControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapLocationController Function()>>('CMapLocationControllerMakeDefault');
late final _CMapLocationControllerMakeDefault = _CMapLocationControllerMakeDefaultPtr.asFunction<_CMapLocationController Function()>();


late final _CMapManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapManager_cg_objectIdentifier');
late final _CMapManager_cg_objectIdentifier = _CMapManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapManager_addMap_CMapPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapManager, _CMap)>>('CMapManager_addMap_CMap');
late final _CMapManager_addMap_CMap = _CMapManager_addMap_CMapPtr.asFunction<void Function(_CMapManager, _CMap)>();
late final _CMapManager_removeMap_CMapPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapManager, _CMap)>>('CMapManager_removeMap_CMap');
late final _CMapManager_removeMap_CMap = _CMapManager_removeMap_CMapPtr.asFunction<void Function(_CMapManager, _CMap)>();

late final _CMapManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapManager_release');
late final _CMapManager_release = _CMapManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapManager_retainPtr = _lookup<ffi.NativeFunction<_CMapManager Function(ffi.Pointer<ffi.Void>)>>('CMapManager_retain');
late final _CMapManager_retain = _CMapManager_retainPtr.asFunction<_CMapManager Function(ffi.Pointer<ffi.Void>)>();
late final _CMapManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapManager Function()>>('CMapManagerMakeDefault');
late final _CMapManagerMakeDefault = _CMapManagerMakeDefaultPtr.asFunction<_CMapManager Function()>();


late final _CSpeedRangeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSpeedRange Function()>>('CSpeedRangeMakeDefault');
late final _CSpeedRangeMakeDefault = _CSpeedRangeMakeDefaultPtr.asFunction<_CSpeedRange Function()>();


late final _CSpeedRangeToStyleZoomMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSpeedRangeToStyleZoom Function()>>('CSpeedRangeToStyleZoomMakeDefault');
late final _CSpeedRangeToStyleZoomMakeDefault = _CSpeedRangeToStyleZoomMakeDefaultPtr.asFunction<_CSpeedRangeToStyleZoom Function()>();

late final _CZoomFollowSettings_getSpeedRangeToStyleZoomSequencePtr = _lookup<ffi.NativeFunction<_CArray_CSpeedRangeToStyleZoom Function(_CZoomFollowSettings)>>('CZoomFollowSettings_getSpeedRangeToStyleZoomSequence');
late final _CZoomFollowSettings_getSpeedRangeToStyleZoomSequence = _CZoomFollowSettings_getSpeedRangeToStyleZoomSequencePtr.asFunction<_CArray_CSpeedRangeToStyleZoom Function(_CZoomFollowSettings)>();
late final _CZoomFollowSettings_setSpeedRangeToStyleZoomSequence_CArray_CSpeedRangeToStyleZoomPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CZoomFollowSettings, _CArray_CSpeedRangeToStyleZoom)>>('CZoomFollowSettings_setSpeedRangeToStyleZoomSequence_CArray_CSpeedRangeToStyleZoom');
late final _CZoomFollowSettings_setSpeedRangeToStyleZoomSequence_CArray_CSpeedRangeToStyleZoom = _CZoomFollowSettings_setSpeedRangeToStyleZoomSequence_CArray_CSpeedRangeToStyleZoomPtr.asFunction<void Function(_CZoomFollowSettings, _CArray_CSpeedRangeToStyleZoom)>();
late final _CZoomFollowSettings_getSpeedRangeToStyleZoomFreeRoamSequencePtr = _lookup<ffi.NativeFunction<_CArray_CSpeedRangeToStyleZoom Function(_CZoomFollowSettings)>>('CZoomFollowSettings_getSpeedRangeToStyleZoomFreeRoamSequence');
late final _CZoomFollowSettings_getSpeedRangeToStyleZoomFreeRoamSequence = _CZoomFollowSettings_getSpeedRangeToStyleZoomFreeRoamSequencePtr.asFunction<_CArray_CSpeedRangeToStyleZoom Function(_CZoomFollowSettings)>();
late final _CZoomFollowSettings_setSpeedRangeToStyleZoomFreeRoamSequence_CArray_CSpeedRangeToStyleZoomPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CZoomFollowSettings, _CArray_CSpeedRangeToStyleZoom)>>('CZoomFollowSettings_setSpeedRangeToStyleZoomFreeRoamSequence_CArray_CSpeedRangeToStyleZoom');
late final _CZoomFollowSettings_setSpeedRangeToStyleZoomFreeRoamSequence_CArray_CSpeedRangeToStyleZoom = _CZoomFollowSettings_setSpeedRangeToStyleZoomFreeRoamSequence_CArray_CSpeedRangeToStyleZoomPtr.asFunction<void Function(_CZoomFollowSettings, _CArray_CSpeedRangeToStyleZoom)>();
late final _CZoomFollowSettings_getStyleZoomSpeedRangesAnimationDurationPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CZoomFollowSettings)>>('CZoomFollowSettings_getStyleZoomSpeedRangesAnimationDuration');
late final _CZoomFollowSettings_getStyleZoomSpeedRangesAnimationDuration = _CZoomFollowSettings_getStyleZoomSpeedRangesAnimationDurationPtr.asFunction<_CTimeInterval Function(_CZoomFollowSettings)>();
late final _CZoomFollowSettings_setStyleZoomSpeedRangesAnimationDuration_CTimeIntervalPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CZoomFollowSettings, _CTimeInterval)>>('CZoomFollowSettings_setStyleZoomSpeedRangesAnimationDuration_CTimeInterval');
late final _CZoomFollowSettings_setStyleZoomSpeedRangesAnimationDuration_CTimeInterval = _CZoomFollowSettings_setStyleZoomSpeedRangesAnimationDuration_CTimeIntervalPtr.asFunction<void Function(_CZoomFollowSettings, _CTimeInterval)>();
late final _CZoomFollowSettings_getZoomInBeforeManeuverAnimationDurationPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CZoomFollowSettings)>>('CZoomFollowSettings_getZoomInBeforeManeuverAnimationDuration');
late final _CZoomFollowSettings_getZoomInBeforeManeuverAnimationDuration = _CZoomFollowSettings_getZoomInBeforeManeuverAnimationDurationPtr.asFunction<_CTimeInterval Function(_CZoomFollowSettings)>();
late final _CZoomFollowSettings_setZoomInBeforeManeuverAnimationDuration_CTimeIntervalPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CZoomFollowSettings, _CTimeInterval)>>('CZoomFollowSettings_setZoomInBeforeManeuverAnimationDuration_CTimeInterval');
late final _CZoomFollowSettings_setZoomInBeforeManeuverAnimationDuration_CTimeInterval = _CZoomFollowSettings_setZoomInBeforeManeuverAnimationDuration_CTimeIntervalPtr.asFunction<void Function(_CZoomFollowSettings, _CTimeInterval)>();
late final _CZoomFollowSettings_getZoomOutAfterManeuverAnimationDurationPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CZoomFollowSettings)>>('CZoomFollowSettings_getZoomOutAfterManeuverAnimationDuration');
late final _CZoomFollowSettings_getZoomOutAfterManeuverAnimationDuration = _CZoomFollowSettings_getZoomOutAfterManeuverAnimationDurationPtr.asFunction<_CTimeInterval Function(_CZoomFollowSettings)>();
late final _CZoomFollowSettings_setZoomOutAfterManeuverAnimationDuration_CTimeIntervalPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CZoomFollowSettings, _CTimeInterval)>>('CZoomFollowSettings_setZoomOutAfterManeuverAnimationDuration_CTimeInterval');
late final _CZoomFollowSettings_setZoomOutAfterManeuverAnimationDuration_CTimeInterval = _CZoomFollowSettings_setZoomOutAfterManeuverAnimationDuration_CTimeIntervalPtr.asFunction<void Function(_CZoomFollowSettings, _CTimeInterval)>();
late final _CZoomFollowSettings_getMinSpeedToConsiderInZoomInBeforeManeuverAnimationPtr = _lookup<ffi.NativeFunction<ffi.Double Function(_CZoomFollowSettings)>>('CZoomFollowSettings_getMinSpeedToConsiderInZoomInBeforeManeuverAnimation');
late final _CZoomFollowSettings_getMinSpeedToConsiderInZoomInBeforeManeuverAnimation = _CZoomFollowSettings_getMinSpeedToConsiderInZoomInBeforeManeuverAnimationPtr.asFunction<double Function(_CZoomFollowSettings)>();
late final _CZoomFollowSettings_setMinSpeedToConsiderInZoomInBeforeManeuverAnimation_doublePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CZoomFollowSettings, ffi.Double)>>('CZoomFollowSettings_setMinSpeedToConsiderInZoomInBeforeManeuverAnimation_double');
late final _CZoomFollowSettings_setMinSpeedToConsiderInZoomInBeforeManeuverAnimation_double = _CZoomFollowSettings_setMinSpeedToConsiderInZoomInBeforeManeuverAnimation_doublePtr.asFunction<void Function(_CZoomFollowSettings, double)>();
late final _CZoomFollowSettings_getZoomInBeforeManeuverAnimationAccelerationPtr = _lookup<ffi.NativeFunction<ffi.Double Function(_CZoomFollowSettings)>>('CZoomFollowSettings_getZoomInBeforeManeuverAnimationAcceleration');
late final _CZoomFollowSettings_getZoomInBeforeManeuverAnimationAcceleration = _CZoomFollowSettings_getZoomInBeforeManeuverAnimationAccelerationPtr.asFunction<double Function(_CZoomFollowSettings)>();
late final _CZoomFollowSettings_setZoomInBeforeManeuverAnimationAcceleration_doublePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CZoomFollowSettings, ffi.Double)>>('CZoomFollowSettings_setZoomInBeforeManeuverAnimationAcceleration_double');
late final _CZoomFollowSettings_setZoomInBeforeManeuverAnimationAcceleration_double = _CZoomFollowSettings_setZoomInBeforeManeuverAnimationAcceleration_doublePtr.asFunction<void Function(_CZoomFollowSettings, double)>();
late final _CZoomFollowSettings_getDistanceGapToManeuverPtr = _lookup<ffi.NativeFunction<_CRouteDistance Function(_CZoomFollowSettings)>>('CZoomFollowSettings_getDistanceGapToManeuver');
late final _CZoomFollowSettings_getDistanceGapToManeuver = _CZoomFollowSettings_getDistanceGapToManeuverPtr.asFunction<_CRouteDistance Function(_CZoomFollowSettings)>();
late final _CZoomFollowSettings_setDistanceGapToManeuver_CRouteDistancePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CZoomFollowSettings, _CRouteDistance)>>('CZoomFollowSettings_setDistanceGapToManeuver_CRouteDistance');
late final _CZoomFollowSettings_setDistanceGapToManeuver_CRouteDistance = _CZoomFollowSettings_setDistanceGapToManeuver_CRouteDistancePtr.asFunction<void Function(_CZoomFollowSettings, _CRouteDistance)>();
late final _CZoomFollowSettings_getMinAnimationDurationPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CZoomFollowSettings)>>('CZoomFollowSettings_getMinAnimationDuration');
late final _CZoomFollowSettings_getMinAnimationDuration = _CZoomFollowSettings_getMinAnimationDurationPtr.asFunction<_CTimeInterval Function(_CZoomFollowSettings)>();
late final _CZoomFollowSettings_setMinAnimationDuration_CTimeIntervalPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CZoomFollowSettings, _CTimeInterval)>>('CZoomFollowSettings_setMinAnimationDuration_CTimeInterval');
late final _CZoomFollowSettings_setMinAnimationDuration_CTimeInterval = _CZoomFollowSettings_setMinAnimationDuration_CTimeIntervalPtr.asFunction<void Function(_CZoomFollowSettings, _CTimeInterval)>();

late final _CZoomFollowSettings_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CZoomFollowSettings_cg_objectIdentifier');
late final _CZoomFollowSettings_cg_objectIdentifier = _CZoomFollowSettings_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CZoomFollowSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CZoomFollowSettings_release');
late final _CZoomFollowSettings_release = _CZoomFollowSettings_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CZoomFollowSettings_retainPtr = _lookup<ffi.NativeFunction<_CZoomFollowSettings Function(ffi.Pointer<ffi.Void>)>>('CZoomFollowSettings_retain');
late final _CZoomFollowSettings_retain = _CZoomFollowSettings_retainPtr.asFunction<_CZoomFollowSettings Function(ffi.Pointer<ffi.Void>)>();
late final _CZoomFollowSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CZoomFollowSettings Function()>>('CZoomFollowSettingsMakeDefault');
late final _CZoomFollowSettingsMakeDefault = _CZoomFollowSettingsMakeDefaultPtr.asFunction<_CZoomFollowSettings Function()>();


late final _CArray_CSpeedRangeToStyleZoommakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSpeedRangeToStyleZoom Function()>>('CArray_CSpeedRangeToStyleZoom_makeEmpty');
late final _CArray_CSpeedRangeToStyleZoommakeEmpty = _CArray_CSpeedRangeToStyleZoommakeEmptyPtr.asFunction<_CArray_CSpeedRangeToStyleZoom Function()>();
late final _CArray_CSpeedRangeToStyleZoomaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSpeedRangeToStyleZoom, _CSpeedRangeToStyleZoom)>>('CArray_CSpeedRangeToStyleZoom_addElement');
late final _CArray_CSpeedRangeToStyleZoomaddElement = _CArray_CSpeedRangeToStyleZoomaddElementPtr.asFunction<void Function(_CArray_CSpeedRangeToStyleZoom, _CSpeedRangeToStyleZoom)>();
late final _forEach_CArray_CSpeedRangeToStyleZoomPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSpeedRangeToStyleZoom, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSpeedRangeToStyleZoom)>>)
>>('CArray_CSpeedRangeToStyleZoom_forEachWithFunctionPointer');
late final _forEach_CArray_CSpeedRangeToStyleZoom = _forEach_CArray_CSpeedRangeToStyleZoomPtr.asFunction<
  void Function(_CArray_CSpeedRangeToStyleZoom, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSpeedRangeToStyleZoom)
>>)>();
late final _CArray_CSpeedRangeToStyleZoom_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSpeedRangeToStyleZoom)>>('CArray_CSpeedRangeToStyleZoom_release');
late final _CArray_CSpeedRangeToStyleZoom_release = _CArray_CSpeedRangeToStyleZoom_releasePtr.asFunction<void Function(_CArray_CSpeedRangeToStyleZoom)>();
late final _CRouteMapSettings_onRouteDisplayFlagsPtr = _lookup<ffi.NativeFunction<_COptionSet_CRouteMapObjectDisplayFlag Function(_CRouteMapSettings)>>('CRouteMapSettings_onRouteDisplayFlags');
late final _CRouteMapSettings_onRouteDisplayFlags = _CRouteMapSettings_onRouteDisplayFlagsPtr.asFunction<_COptionSet_CRouteMapObjectDisplayFlag Function(_CRouteMapSettings)>();
late final _CRouteMapSettings_setOnRouteDisplayFlags_COptionSet_CRouteMapObjectDisplayFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapSettings, _COptionSet_CRouteMapObjectDisplayFlag)>>('CRouteMapSettings_setOnRouteDisplayFlags_COptionSet_CRouteMapObjectDisplayFlag');
late final _CRouteMapSettings_setOnRouteDisplayFlags_COptionSet_CRouteMapObjectDisplayFlag = _CRouteMapSettings_setOnRouteDisplayFlags_COptionSet_CRouteMapObjectDisplayFlagPtr.asFunction<void Function(_CRouteMapSettings, _COptionSet_CRouteMapObjectDisplayFlag)>();
late final _CRouteMapSettings_freeRoamDisplayFlagsPtr = _lookup<ffi.NativeFunction<_COptionSet_CRouteMapObjectDisplayFlag Function(_CRouteMapSettings)>>('CRouteMapSettings_freeRoamDisplayFlags');
late final _CRouteMapSettings_freeRoamDisplayFlags = _CRouteMapSettings_freeRoamDisplayFlagsPtr.asFunction<_COptionSet_CRouteMapObjectDisplayFlag Function(_CRouteMapSettings)>();
late final _CRouteMapSettings_setFreeRoamDisplayFlags_COptionSet_CRouteMapObjectDisplayFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapSettings, _COptionSet_CRouteMapObjectDisplayFlag)>>('CRouteMapSettings_setFreeRoamDisplayFlags_COptionSet_CRouteMapObjectDisplayFlag');
late final _CRouteMapSettings_setFreeRoamDisplayFlags_COptionSet_CRouteMapObjectDisplayFlag = _CRouteMapSettings_setFreeRoamDisplayFlags_COptionSet_CRouteMapObjectDisplayFlagPtr.asFunction<void Function(_CRouteMapSettings, _COptionSet_CRouteMapObjectDisplayFlag)>();
late final _CRouteMapSettings_onRoutePermanentDisplayFlagsPtr = _lookup<ffi.NativeFunction<_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CRouteMapSettings)>>('CRouteMapSettings_onRoutePermanentDisplayFlags');
late final _CRouteMapSettings_onRoutePermanentDisplayFlags = _CRouteMapSettings_onRoutePermanentDisplayFlagsPtr.asFunction<_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CRouteMapSettings)>();
late final _CRouteMapSettings_setOnRoutePermanentDisplayFlags_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapSettings, _COptionSet_CRouteMapObjectPermanentDisplayFlag)>>('CRouteMapSettings_setOnRoutePermanentDisplayFlags_COptionSet_CRouteMapObjectPermanentDisplayFlag');
late final _CRouteMapSettings_setOnRoutePermanentDisplayFlags_COptionSet_CRouteMapObjectPermanentDisplayFlag = _CRouteMapSettings_setOnRoutePermanentDisplayFlags_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr.asFunction<void Function(_CRouteMapSettings, _COptionSet_CRouteMapObjectPermanentDisplayFlag)>();
late final _CRouteMapSettings_freeRoamPermanentDisplayFlagsPtr = _lookup<ffi.NativeFunction<_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CRouteMapSettings)>>('CRouteMapSettings_freeRoamPermanentDisplayFlags');
late final _CRouteMapSettings_freeRoamPermanentDisplayFlags = _CRouteMapSettings_freeRoamPermanentDisplayFlagsPtr.asFunction<_COptionSet_CRouteMapObjectPermanentDisplayFlag Function(_CRouteMapSettings)>();
late final _CRouteMapSettings_setFreeRoamPermanentDisplayFlags_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteMapSettings, _COptionSet_CRouteMapObjectPermanentDisplayFlag)>>('CRouteMapSettings_setFreeRoamPermanentDisplayFlags_COptionSet_CRouteMapObjectPermanentDisplayFlag');
late final _CRouteMapSettings_setFreeRoamPermanentDisplayFlags_COptionSet_CRouteMapObjectPermanentDisplayFlag = _CRouteMapSettings_setFreeRoamPermanentDisplayFlags_COptionSet_CRouteMapObjectPermanentDisplayFlagPtr.asFunction<void Function(_CRouteMapSettings, _COptionSet_CRouteMapObjectPermanentDisplayFlag)>();

late final _CRouteMapSettings_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRouteMapSettings_cg_objectIdentifier');
late final _CRouteMapSettings_cg_objectIdentifier = _CRouteMapSettings_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CRouteMapSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRouteMapSettings_release');
late final _CRouteMapSettings_release = _CRouteMapSettings_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteMapSettings_retainPtr = _lookup<ffi.NativeFunction<_CRouteMapSettings Function(ffi.Pointer<ffi.Void>)>>('CRouteMapSettings_retain');
late final _CRouteMapSettings_retain = _CRouteMapSettings_retainPtr.asFunction<_CRouteMapSettings Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteMapSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteMapSettings Function()>>('CRouteMapSettingsMakeDefault');
late final _CRouteMapSettingsMakeDefault = _CRouteMapSettingsMakeDefaultPtr.asFunction<_CRouteMapSettings Function()>();

late final _CRouteMapObjectsProvider_objectsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CRouteMapObject Function(_CRouteMapObjectsProvider)>>('CRouteMapObjectsProvider_objectsChannel');
late final _CRouteMapObjectsProvider_objectsChannel = _CRouteMapObjectsProvider_objectsChannelPtr.asFunction<_CStatefulChannel_CArray_CRouteMapObject Function(_CRouteMapObjectsProvider)>();
late final _CRouteMapObjectsProvider_objectsPtr = _lookup<ffi.NativeFunction<_CArray_CRouteMapObject Function(_CRouteMapObjectsProvider)>>('CRouteMapObjectsProvider_objects');
late final _CRouteMapObjectsProvider_objects = _CRouteMapObjectsProvider_objectsPtr.asFunction<_CArray_CRouteMapObject Function(_CRouteMapObjectsProvider)>();

late final _CRouteMapObjectsProvider_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRouteMapObjectsProvider_cg_objectIdentifier');
late final _CRouteMapObjectsProvider_cg_objectIdentifier = _CRouteMapObjectsProvider_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CRouteMapObjectsProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRouteMapObjectsProvider_release');
late final _CRouteMapObjectsProvider_release = _CRouteMapObjectsProvider_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteMapObjectsProvider_retainPtr = _lookup<ffi.NativeFunction<_CRouteMapObjectsProvider Function(ffi.Pointer<ffi.Void>)>>('CRouteMapObjectsProvider_retain');
late final _CRouteMapObjectsProvider_retain = _CRouteMapObjectsProvider_retainPtr.asFunction<_CRouteMapObjectsProvider Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteMapObjectsProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteMapObjectsProvider Function()>>('CRouteMapObjectsProviderMakeDefault');
late final _CRouteMapObjectsProviderMakeDefault = _CRouteMapObjectsProviderMakeDefaultPtr.asFunction<_CRouteMapObjectsProvider Function()>();


late final _CStatefulChannel_CArray_CRouteMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CRouteMapObject Function()>>('CStatefulChannel_CArray_CRouteMapObjectMakeDefault');
late final _CStatefulChannel_CArray_CRouteMapObjectMakeDefault = _CStatefulChannel_CArray_CRouteMapObjectMakeDefaultPtr.asFunction<_CStatefulChannel_CArray_CRouteMapObject Function()>();
late final _CStatefulChannel_CArray_CRouteMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CArray_CRouteMapObject)>>('CStatefulChannel_CArray_CRouteMapObject_release');
late final _CStatefulChannel_CArray_CRouteMapObject_release = _CStatefulChannel_CArray_CRouteMapObject_releasePtr.asFunction<void Function(_CStatefulChannel_CArray_CRouteMapObject)>();
late final _CStatefulChannel_CArray_CRouteMapObject_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CRouteMapObject Function(_CStatefulChannel_CArray_CRouteMapObject)>>('CStatefulChannel_CArray_CRouteMapObject_retain');
late final _CStatefulChannel_CArray_CRouteMapObject_retain = _CStatefulChannel_CArray_CRouteMapObject_retainPtr.asFunction<_CStatefulChannel_CArray_CRouteMapObject Function(_CStatefulChannel_CArray_CRouteMapObject)>();
late final _CStatefulChannel_CArray_CRouteMapObjectGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CArray_CRouteMapObject Function(_CStatefulChannel_CArray_CRouteMapObject)>>('CStatefulChannel_CArray_CRouteMapObject_getCurrentValue');
late final _CStatefulChannel_CArray_CRouteMapObjectGetCurrentValue = _CStatefulChannel_CArray_CRouteMapObjectGetCurrentValuePtr.asFunction<_CArray_CRouteMapObject Function(_CStatefulChannel_CArray_CRouteMapObject)>();
late final _CStatefulChannel_CArray_CRouteMapObjectConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CRouteMapObject,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CRouteMapObject, ffi.Int64)>>
  )
>>('CStatefulChannel_CArray_CRouteMapObject_connect');
late final _CStatefulChannel_CArray_CRouteMapObjectConnect = _CStatefulChannel_CArray_CRouteMapObjectConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CRouteMapObject,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CRouteMapObject, ffi.Int64)>>
  )
>();

late final _CSimulationConstantSpeedMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimulationConstantSpeed Function()>>('CSimulationConstantSpeedMakeDefault');
late final _CSimulationConstantSpeedMakeDefault = _CSimulationConstantSpeedMakeDefaultPtr.asFunction<_CSimulationConstantSpeed Function()>();


late final _CSimulationAutoWithOverSpeedMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimulationAutoWithOverSpeed Function()>>('CSimulationAutoWithOverSpeedMakeDefault');
late final _CSimulationAutoWithOverSpeedMakeDefault = _CSimulationAutoWithOverSpeedMakeDefaultPtr.asFunction<_CSimulationAutoWithOverSpeed Function()>();


late final _CSimulationSpeedMode_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimulationSpeedMode)>>('CSimulationSpeedMode_release');
late final _CSimulationSpeedMode_release = _CSimulationSpeedMode_releasePtr.asFunction<void Function(_CSimulationSpeedMode)>();
late final _CSimulationSpeedModeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimulationSpeedMode Function()>>('CSimulationSpeedModeMakeDefault');
late final _CSimulationSpeedModeMakeDefault = _CSimulationSpeedModeMakeDefaultPtr.asFunction<_CSimulationSpeedMode Function()>();
late final _CSimulationSettings_speedModePtr = _lookup<ffi.NativeFunction<_CSimulationSpeedMode Function(_CSimulationSettings)>>('CSimulationSettings_speedMode');
late final _CSimulationSettings_speedMode = _CSimulationSettings_speedModePtr.asFunction<_CSimulationSpeedMode Function(_CSimulationSettings)>();
late final _CSimulationSettings_setSpeedMode_CSimulationSpeedModePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimulationSettings, _CSimulationSpeedMode)>>('CSimulationSettings_setSpeedMode_CSimulationSpeedMode');
late final _CSimulationSettings_setSpeedMode_CSimulationSpeedMode = _CSimulationSettings_setSpeedMode_CSimulationSpeedModePtr.asFunction<void Function(_CSimulationSettings, _CSimulationSpeedMode)>();

late final _CSimulationSettings_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSimulationSettings_cg_objectIdentifier');
late final _CSimulationSettings_cg_objectIdentifier = _CSimulationSettings_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSimulationSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSimulationSettings_release');
late final _CSimulationSettings_release = _CSimulationSettings_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSimulationSettings_retainPtr = _lookup<ffi.NativeFunction<_CSimulationSettings Function(ffi.Pointer<ffi.Void>)>>('CSimulationSettings_retain');
late final _CSimulationSettings_retain = _CSimulationSettings_retainPtr.asFunction<_CSimulationSettings Function(ffi.Pointer<ffi.Void>)>();
late final _CSimulationSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimulationSettings Function()>>('CSimulationSettingsMakeDefault');
late final _CSimulationSettingsMakeDefault = _CSimulationSettingsMakeDefaultPtr.asFunction<_CSimulationSettings Function()>();


late final _CNavigationVoice_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CNavigationVoice_cg_objectIdentifier');
late final _CNavigationVoice_cg_objectIdentifier = _CNavigationVoice_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CNavigationVoice_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CNavigationVoice_release');
late final _CNavigationVoice_release = _CNavigationVoice_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CNavigationVoice_retainPtr = _lookup<ffi.NativeFunction<_CNavigationVoice Function(ffi.Pointer<ffi.Void>)>>('CNavigationVoice_retain');
late final _CNavigationVoice_retain = _CNavigationVoice_retainPtr.asFunction<_CNavigationVoice Function(ffi.Pointer<ffi.Void>)>();
late final _CNavigationVoiceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CNavigationVoice Function()>>('CNavigationVoiceMakeDefault');
late final _CNavigationVoiceMakeDefault = _CNavigationVoiceMakeDefaultPtr.asFunction<_CNavigationVoice Function()>();

late final _CVoiceSelector_voicePtr = _lookup<ffi.NativeFunction<_COptional_CNavigationVoice Function(_CVoiceSelector)>>('CVoiceSelector_voice');
late final _CVoiceSelector_voice = _CVoiceSelector_voicePtr.asFunction<_COptional_CNavigationVoice Function(_CVoiceSelector)>();
late final _CVoiceSelector_setVoice_COptional_CNavigationVoicePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CVoiceSelector, _COptional_CNavigationVoice)>>('CVoiceSelector_setVoice_COptional_CNavigationVoice');
late final _CVoiceSelector_setVoice_COptional_CNavigationVoice = _CVoiceSelector_setVoice_COptional_CNavigationVoicePtr.asFunction<void Function(_CVoiceSelector, _COptional_CNavigationVoice)>();

late final _CVoiceSelector_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CVoiceSelector_cg_objectIdentifier');
late final _CVoiceSelector_cg_objectIdentifier = _CVoiceSelector_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CVoiceSelector_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CVoiceSelector_release');
late final _CVoiceSelector_release = _CVoiceSelector_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CVoiceSelector_retainPtr = _lookup<ffi.NativeFunction<_CVoiceSelector Function(ffi.Pointer<ffi.Void>)>>('CVoiceSelector_retain');
late final _CVoiceSelector_retain = _CVoiceSelector_retainPtr.asFunction<_CVoiceSelector Function(ffi.Pointer<ffi.Void>)>();
late final _CVoiceSelectorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CVoiceSelector Function()>>('CVoiceSelectorMakeDefault');
late final _CVoiceSelectorMakeDefault = _CVoiceSelectorMakeDefaultPtr.asFunction<_CVoiceSelector Function()>();


late final _COptional_CNavigationVoiceMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CNavigationVoice Function()>>('COptional_CNavigationVoiceMakeDefault');
late final _COptional_CNavigationVoiceMakeDefault = _COptional_CNavigationVoiceMakeDefaultPtr.asFunction<_COptional_CNavigationVoice Function()>();

late final _COptional_CNavigationVoice_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CNavigationVoice)>>('COptional_CNavigationVoice_release');
late final _COptional_CNavigationVoice_release = _COptional_CNavigationVoice_releasePtr.asFunction<void Function(_COptional_CNavigationVoice)>();
late final _CExceedSpeedLimitSettings_exceedSpeedNotificationEnabledPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CExceedSpeedLimitSettings)>>('CExceedSpeedLimitSettings_exceedSpeedNotificationEnabled');
late final _CExceedSpeedLimitSettings_exceedSpeedNotificationEnabled = _CExceedSpeedLimitSettings_exceedSpeedNotificationEnabledPtr.asFunction<bool Function(_CExceedSpeedLimitSettings)>();
late final _CExceedSpeedLimitSettings_setExceedSpeedNotificationEnabled_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CExceedSpeedLimitSettings, ffi.Bool)>>('CExceedSpeedLimitSettings_setExceedSpeedNotificationEnabled_bool');
late final _CExceedSpeedLimitSettings_setExceedSpeedNotificationEnabled_bool = _CExceedSpeedLimitSettings_setExceedSpeedNotificationEnabled_boolPtr.asFunction<void Function(_CExceedSpeedLimitSettings, bool)>();
late final _CExceedSpeedLimitSettings_allowableSpeedExcessPtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CExceedSpeedLimitSettings)>>('CExceedSpeedLimitSettings_allowableSpeedExcess');
late final _CExceedSpeedLimitSettings_allowableSpeedExcess = _CExceedSpeedLimitSettings_allowableSpeedExcessPtr.asFunction<double Function(_CExceedSpeedLimitSettings)>();
late final _CExceedSpeedLimitSettings_setAllowableSpeedExcess_floatPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CExceedSpeedLimitSettings, ffi.Float)>>('CExceedSpeedLimitSettings_setAllowableSpeedExcess_float');
late final _CExceedSpeedLimitSettings_setAllowableSpeedExcess_float = _CExceedSpeedLimitSettings_setAllowableSpeedExcess_floatPtr.asFunction<void Function(_CExceedSpeedLimitSettings, double)>();

late final _CExceedSpeedLimitSettings_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CExceedSpeedLimitSettings_cg_objectIdentifier');
late final _CExceedSpeedLimitSettings_cg_objectIdentifier = _CExceedSpeedLimitSettings_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CExceedSpeedLimitSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CExceedSpeedLimitSettings_release');
late final _CExceedSpeedLimitSettings_release = _CExceedSpeedLimitSettings_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CExceedSpeedLimitSettings_retainPtr = _lookup<ffi.NativeFunction<_CExceedSpeedLimitSettings Function(ffi.Pointer<ffi.Void>)>>('CExceedSpeedLimitSettings_retain');
late final _CExceedSpeedLimitSettings_retain = _CExceedSpeedLimitSettings_retainPtr.asFunction<_CExceedSpeedLimitSettings Function(ffi.Pointer<ffi.Void>)>();
late final _CExceedSpeedLimitSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CExceedSpeedLimitSettings Function()>>('CExceedSpeedLimitSettingsMakeDefault');
late final _CExceedSpeedLimitSettingsMakeDefault = _CExceedSpeedLimitSettingsMakeDefaultPtr.asFunction<_CExceedSpeedLimitSettings Function()>();

late final _CDynamicRouteInfoSettings_updatePeriodPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CDynamicRouteInfoSettings)>>('CDynamicRouteInfoSettings_updatePeriod');
late final _CDynamicRouteInfoSettings_updatePeriod = _CDynamicRouteInfoSettings_updatePeriodPtr.asFunction<_CTimeInterval Function(_CDynamicRouteInfoSettings)>();
late final _CDynamicRouteInfoSettings_setUpdatePeriod_CTimeIntervalPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDynamicRouteInfoSettings, _CTimeInterval)>>('CDynamicRouteInfoSettings_setUpdatePeriod_CTimeInterval');
late final _CDynamicRouteInfoSettings_setUpdatePeriod_CTimeInterval = _CDynamicRouteInfoSettings_setUpdatePeriod_CTimeIntervalPtr.asFunction<void Function(_CDynamicRouteInfoSettings, _CTimeInterval)>();

late final _CDynamicRouteInfoSettings_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDynamicRouteInfoSettings_cg_objectIdentifier');
late final _CDynamicRouteInfoSettings_cg_objectIdentifier = _CDynamicRouteInfoSettings_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CDynamicRouteInfoSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDynamicRouteInfoSettings_release');
late final _CDynamicRouteInfoSettings_release = _CDynamicRouteInfoSettings_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDynamicRouteInfoSettings_retainPtr = _lookup<ffi.NativeFunction<_CDynamicRouteInfoSettings Function(ffi.Pointer<ffi.Void>)>>('CDynamicRouteInfoSettings_retain');
late final _CDynamicRouteInfoSettings_retain = _CDynamicRouteInfoSettings_retainPtr.asFunction<_CDynamicRouteInfoSettings Function(ffi.Pointer<ffi.Void>)>();
late final _CDynamicRouteInfoSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDynamicRouteInfoSettings Function()>>('CDynamicRouteInfoSettingsMakeDefault');
late final _CDynamicRouteInfoSettingsMakeDefault = _CDynamicRouteInfoSettingsMakeDefaultPtr.asFunction<_CDynamicRouteInfoSettings Function()>();


late final _CSoundCategoryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSoundCategory Function()>>('CSoundCategoryMakeDefault');
late final _CSoundCategoryMakeDefault = _CSoundCategoryMakeDefaultPtr.asFunction<_CSoundCategory Function()>();
late final _CSoundNotificationSettings_enabledSoundCategoriesPtr = _lookup<ffi.NativeFunction<_COptionSet_CSoundCategory Function(_CSoundNotificationSettings)>>('CSoundNotificationSettings_enabledSoundCategories');
late final _CSoundNotificationSettings_enabledSoundCategories = _CSoundNotificationSettings_enabledSoundCategoriesPtr.asFunction<_COptionSet_CSoundCategory Function(_CSoundNotificationSettings)>();
late final _CSoundNotificationSettings_setEnabledSoundCategories_COptionSet_CSoundCategoryPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSoundNotificationSettings, _COptionSet_CSoundCategory)>>('CSoundNotificationSettings_setEnabledSoundCategories_COptionSet_CSoundCategory');
late final _CSoundNotificationSettings_setEnabledSoundCategories_COptionSet_CSoundCategory = _CSoundNotificationSettings_setEnabledSoundCategories_COptionSet_CSoundCategoryPtr.asFunction<void Function(_CSoundNotificationSettings, _COptionSet_CSoundCategory)>();

late final _CSoundNotificationSettings_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSoundNotificationSettings_cg_objectIdentifier');
late final _CSoundNotificationSettings_cg_objectIdentifier = _CSoundNotificationSettings_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSoundNotificationSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSoundNotificationSettings_release');
late final _CSoundNotificationSettings_release = _CSoundNotificationSettings_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSoundNotificationSettings_retainPtr = _lookup<ffi.NativeFunction<_CSoundNotificationSettings Function(ffi.Pointer<ffi.Void>)>>('CSoundNotificationSettings_retain');
late final _CSoundNotificationSettings_retain = _CSoundNotificationSettings_retainPtr.asFunction<_CSoundNotificationSettings Function(ffi.Pointer<ffi.Void>)>();
late final _CSoundNotificationSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSoundNotificationSettings Function()>>('CSoundNotificationSettingsMakeDefault');
late final _CSoundNotificationSettingsMakeDefault = _CSoundNotificationSettingsMakeDefaultPtr.asFunction<_CSoundNotificationSettings Function()>();


late final _COptionSet_CSoundCategoryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CSoundCategory Function()>>('COptionSet_CSoundCategoryMakeDefault');
late final _COptionSet_CSoundCategoryMakeDefault = _COptionSet_CSoundCategoryMakeDefaultPtr.asFunction<_COptionSet_CSoundCategory Function()>();
late final _CFreeRoamSettings_onRoutePrefetchLengthPtr = _lookup<ffi.NativeFunction<_CRouteDistance Function(_CFreeRoamSettings)>>('CFreeRoamSettings_onRoutePrefetchLength');
late final _CFreeRoamSettings_onRoutePrefetchLength = _CFreeRoamSettings_onRoutePrefetchLengthPtr.asFunction<_CRouteDistance Function(_CFreeRoamSettings)>();
late final _CFreeRoamSettings_setOnRoutePrefetchLength_CRouteDistancePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFreeRoamSettings, _CRouteDistance)>>('CFreeRoamSettings_setOnRoutePrefetchLength_CRouteDistance');
late final _CFreeRoamSettings_setOnRoutePrefetchLength_CRouteDistance = _CFreeRoamSettings_setOnRoutePrefetchLength_CRouteDistancePtr.asFunction<void Function(_CFreeRoamSettings, _CRouteDistance)>();
late final _CFreeRoamSettings_onRoutePrefetchRadiusMetersPtr = _lookup<ffi.NativeFunction<ffi.Double Function(_CFreeRoamSettings)>>('CFreeRoamSettings_onRoutePrefetchRadiusMeters');
late final _CFreeRoamSettings_onRoutePrefetchRadiusMeters = _CFreeRoamSettings_onRoutePrefetchRadiusMetersPtr.asFunction<double Function(_CFreeRoamSettings)>();
late final _CFreeRoamSettings_setOnRoutePrefetchRadiusMeters_doublePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFreeRoamSettings, ffi.Double)>>('CFreeRoamSettings_setOnRoutePrefetchRadiusMeters_double');
late final _CFreeRoamSettings_setOnRoutePrefetchRadiusMeters_double = _CFreeRoamSettings_setOnRoutePrefetchRadiusMeters_doublePtr.asFunction<void Function(_CFreeRoamSettings, double)>();
late final _CFreeRoamSettings_prefetchRadiusMetersPtr = _lookup<ffi.NativeFunction<ffi.Double Function(_CFreeRoamSettings)>>('CFreeRoamSettings_prefetchRadiusMeters');
late final _CFreeRoamSettings_prefetchRadiusMeters = _CFreeRoamSettings_prefetchRadiusMetersPtr.asFunction<double Function(_CFreeRoamSettings)>();
late final _CFreeRoamSettings_setPrefetchRadiusMeters_doublePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFreeRoamSettings, ffi.Double)>>('CFreeRoamSettings_setPrefetchRadiusMeters_double');
late final _CFreeRoamSettings_setPrefetchRadiusMeters_double = _CFreeRoamSettings_setPrefetchRadiusMeters_doublePtr.asFunction<void Function(_CFreeRoamSettings, double)>();

late final _CFreeRoamSettings_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CFreeRoamSettings_cg_objectIdentifier');
late final _CFreeRoamSettings_cg_objectIdentifier = _CFreeRoamSettings_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CFreeRoamSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CFreeRoamSettings_release');
late final _CFreeRoamSettings_release = _CFreeRoamSettings_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CFreeRoamSettings_retainPtr = _lookup<ffi.NativeFunction<_CFreeRoamSettings Function(ffi.Pointer<ffi.Void>)>>('CFreeRoamSettings_retain');
late final _CFreeRoamSettings_retain = _CFreeRoamSettings_retainPtr.asFunction<_CFreeRoamSettings Function(ffi.Pointer<ffi.Void>)>();
late final _CFreeRoamSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFreeRoamSettings Function()>>('CFreeRoamSettingsMakeDefault');
late final _CFreeRoamSettingsMakeDefault = _CFreeRoamSettingsMakeDefaultPtr.asFunction<_CFreeRoamSettings Function()>();


late final _CRouterTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouterType Function()>>('CRouterTypeMakeDefault');
late final _CRouterTypeMakeDefault = _CRouterTypeMakeDefaultPtr.asFunction<_CRouterType Function()>();
late final _CAlternativeRoutesProviderSettings_alternativeRoutesEnabledPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CAlternativeRoutesProviderSettings)>>('CAlternativeRoutesProviderSettings_alternativeRoutesEnabled');
late final _CAlternativeRoutesProviderSettings_alternativeRoutesEnabled = _CAlternativeRoutesProviderSettings_alternativeRoutesEnabledPtr.asFunction<bool Function(_CAlternativeRoutesProviderSettings)>();
late final _CAlternativeRoutesProviderSettings_setAlternativeRoutesEnabled_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAlternativeRoutesProviderSettings, ffi.Bool)>>('CAlternativeRoutesProviderSettings_setAlternativeRoutesEnabled_bool');
late final _CAlternativeRoutesProviderSettings_setAlternativeRoutesEnabled_bool = _CAlternativeRoutesProviderSettings_setAlternativeRoutesEnabled_boolPtr.asFunction<void Function(_CAlternativeRoutesProviderSettings, bool)>();
late final _CAlternativeRoutesProviderSettings_betterRouteEnabledPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CAlternativeRoutesProviderSettings)>>('CAlternativeRoutesProviderSettings_betterRouteEnabled');
late final _CAlternativeRoutesProviderSettings_betterRouteEnabled = _CAlternativeRoutesProviderSettings_betterRouteEnabledPtr.asFunction<bool Function(_CAlternativeRoutesProviderSettings)>();
late final _CAlternativeRoutesProviderSettings_setBetterRouteEnabled_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAlternativeRoutesProviderSettings, ffi.Bool)>>('CAlternativeRoutesProviderSettings_setBetterRouteEnabled_bool');
late final _CAlternativeRoutesProviderSettings_setBetterRouteEnabled_bool = _CAlternativeRoutesProviderSettings_setBetterRouteEnabled_boolPtr.asFunction<void Function(_CAlternativeRoutesProviderSettings, bool)>();
late final _CAlternativeRoutesProviderSettings_routeSearchDelayPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CAlternativeRoutesProviderSettings)>>('CAlternativeRoutesProviderSettings_routeSearchDelay');
late final _CAlternativeRoutesProviderSettings_routeSearchDelay = _CAlternativeRoutesProviderSettings_routeSearchDelayPtr.asFunction<_CTimeInterval Function(_CAlternativeRoutesProviderSettings)>();
late final _CAlternativeRoutesProviderSettings_setRouteSearchDelay_CTimeIntervalPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAlternativeRoutesProviderSettings, _CTimeInterval)>>('CAlternativeRoutesProviderSettings_setRouteSearchDelay_CTimeInterval');
late final _CAlternativeRoutesProviderSettings_setRouteSearchDelay_CTimeInterval = _CAlternativeRoutesProviderSettings_setRouteSearchDelay_CTimeIntervalPtr.asFunction<void Function(_CAlternativeRoutesProviderSettings, _CTimeInterval)>();
late final _CAlternativeRoutesProviderSettings_betterRouteTimeCostThresholdPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CAlternativeRoutesProviderSettings)>>('CAlternativeRoutesProviderSettings_betterRouteTimeCostThreshold');
late final _CAlternativeRoutesProviderSettings_betterRouteTimeCostThreshold = _CAlternativeRoutesProviderSettings_betterRouteTimeCostThresholdPtr.asFunction<_CTimeInterval Function(_CAlternativeRoutesProviderSettings)>();
late final _CAlternativeRoutesProviderSettings_setBetterRouteTimeCostThreshold_CTimeIntervalPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAlternativeRoutesProviderSettings, _CTimeInterval)>>('CAlternativeRoutesProviderSettings_setBetterRouteTimeCostThreshold_CTimeInterval');
late final _CAlternativeRoutesProviderSettings_setBetterRouteTimeCostThreshold_CTimeInterval = _CAlternativeRoutesProviderSettings_setBetterRouteTimeCostThreshold_CTimeIntervalPtr.asFunction<void Function(_CAlternativeRoutesProviderSettings, _CTimeInterval)>();
late final _CAlternativeRoutesProviderSettings_betterRouteLengthThresholdPtr = _lookup<ffi.NativeFunction<_CRouteDistance Function(_CAlternativeRoutesProviderSettings)>>('CAlternativeRoutesProviderSettings_betterRouteLengthThreshold');
late final _CAlternativeRoutesProviderSettings_betterRouteLengthThreshold = _CAlternativeRoutesProviderSettings_betterRouteLengthThresholdPtr.asFunction<_CRouteDistance Function(_CAlternativeRoutesProviderSettings)>();
late final _CAlternativeRoutesProviderSettings_setBetterRouteLengthThreshold_CRouteDistancePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAlternativeRoutesProviderSettings, _CRouteDistance)>>('CAlternativeRoutesProviderSettings_setBetterRouteLengthThreshold_CRouteDistance');
late final _CAlternativeRoutesProviderSettings_setBetterRouteLengthThreshold_CRouteDistance = _CAlternativeRoutesProviderSettings_setBetterRouteLengthThreshold_CRouteDistancePtr.asFunction<void Function(_CAlternativeRoutesProviderSettings, _CRouteDistance)>();
late final _CAlternativeRoutesProviderSettings_routerTypePtr = _lookup<ffi.NativeFunction<_CRouterType Function(_CAlternativeRoutesProviderSettings)>>('CAlternativeRoutesProviderSettings_routerType');
late final _CAlternativeRoutesProviderSettings_routerType = _CAlternativeRoutesProviderSettings_routerTypePtr.asFunction<_CRouterType Function(_CAlternativeRoutesProviderSettings)>();
late final _CAlternativeRoutesProviderSettings_setRouterType_CRouterTypePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAlternativeRoutesProviderSettings, _CRouterType)>>('CAlternativeRoutesProviderSettings_setRouterType_CRouterType');
late final _CAlternativeRoutesProviderSettings_setRouterType_CRouterType = _CAlternativeRoutesProviderSettings_setRouterType_CRouterTypePtr.asFunction<void Function(_CAlternativeRoutesProviderSettings, _CRouterType)>();

late final _CAlternativeRoutesProviderSettings_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CAlternativeRoutesProviderSettings_cg_objectIdentifier');
late final _CAlternativeRoutesProviderSettings_cg_objectIdentifier = _CAlternativeRoutesProviderSettings_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CAlternativeRoutesProviderSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CAlternativeRoutesProviderSettings_release');
late final _CAlternativeRoutesProviderSettings_release = _CAlternativeRoutesProviderSettings_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CAlternativeRoutesProviderSettings_retainPtr = _lookup<ffi.NativeFunction<_CAlternativeRoutesProviderSettings Function(ffi.Pointer<ffi.Void>)>>('CAlternativeRoutesProviderSettings_retain');
late final _CAlternativeRoutesProviderSettings_retain = _CAlternativeRoutesProviderSettings_retainPtr.asFunction<_CAlternativeRoutesProviderSettings Function(ffi.Pointer<ffi.Void>)>();
late final _CAlternativeRoutesProviderSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAlternativeRoutesProviderSettings Function()>>('CAlternativeRoutesProviderSettingsMakeDefault');
late final _CAlternativeRoutesProviderSettingsMakeDefault = _CAlternativeRoutesProviderSettingsMakeDefaultPtr.asFunction<_CAlternativeRoutesProviderSettings Function()>();


late final _CAlternativeRouteSelector_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CAlternativeRouteSelector_cg_objectIdentifier');
late final _CAlternativeRouteSelector_cg_objectIdentifier = _CAlternativeRouteSelector_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CAlternativeRouteSelector_selectAlternativeRoute_CTrafficRoutePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAlternativeRouteSelector, _CTrafficRoute)>>('CAlternativeRouteSelector_selectAlternativeRoute_CTrafficRoute');
late final _CAlternativeRouteSelector_selectAlternativeRoute_CTrafficRoute = _CAlternativeRouteSelector_selectAlternativeRoute_CTrafficRoutePtr.asFunction<void Function(_CAlternativeRouteSelector, _CTrafficRoute)>();

late final _CAlternativeRouteSelector_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CAlternativeRouteSelector_release');
late final _CAlternativeRouteSelector_release = _CAlternativeRouteSelector_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CAlternativeRouteSelector_retainPtr = _lookup<ffi.NativeFunction<_CAlternativeRouteSelector Function(ffi.Pointer<ffi.Void>)>>('CAlternativeRouteSelector_retain');
late final _CAlternativeRouteSelector_retain = _CAlternativeRouteSelector_retainPtr.asFunction<_CAlternativeRouteSelector Function(ffi.Pointer<ffi.Void>)>();
late final _CAlternativeRouteSelectorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAlternativeRouteSelector Function()>>('CAlternativeRouteSelectorMakeDefault');
late final _CAlternativeRouteSelectorMakeDefault = _CAlternativeRouteSelectorMakeDefaultPtr.asFunction<_CAlternativeRouteSelector Function()>();

late final _CMyLocationMapObjectSourceProvider_myLocationMapObjectSourcePtr = _lookup<ffi.NativeFunction<_CMyLocationMapObjectSource Function(_CMyLocationMapObjectSourceProvider)>>('CMyLocationMapObjectSourceProvider_myLocationMapObjectSource');
late final _CMyLocationMapObjectSourceProvider_myLocationMapObjectSource = _CMyLocationMapObjectSourceProvider_myLocationMapObjectSourcePtr.asFunction<_CMyLocationMapObjectSource Function(_CMyLocationMapObjectSourceProvider)>();

late final _CMyLocationMapObjectSourceProvider_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObjectSourceProvider_cg_objectIdentifier');
late final _CMyLocationMapObjectSourceProvider_cg_objectIdentifier = _CMyLocationMapObjectSourceProvider_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CMyLocationMapObjectSourceProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObjectSourceProvider_release');
late final _CMyLocationMapObjectSourceProvider_release = _CMyLocationMapObjectSourceProvider_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationMapObjectSourceProvider_retainPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObjectSourceProvider Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObjectSourceProvider_retain');
late final _CMyLocationMapObjectSourceProvider_retain = _CMyLocationMapObjectSourceProvider_retainPtr.asFunction<_CMyLocationMapObjectSourceProvider Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationMapObjectSourceProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObjectSourceProvider Function()>>('CMyLocationMapObjectSourceProviderMakeDefault');
late final _CMyLocationMapObjectSourceProviderMakeDefault = _CMyLocationMapObjectSourceProviderMakeDefaultPtr.asFunction<_CMyLocationMapObjectSourceProvider Function()>();

late final _CRouteRebuilder_enabledPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CRouteRebuilder)>>('CRouteRebuilder_enabled');
late final _CRouteRebuilder_enabled = _CRouteRebuilder_enabledPtr.asFunction<bool Function(_CRouteRebuilder)>();
late final _CRouteRebuilder_setEnabled_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRouteRebuilder, ffi.Bool)>>('CRouteRebuilder_setEnabled_bool');
late final _CRouteRebuilder_setEnabled_bool = _CRouteRebuilder_setEnabled_boolPtr.asFunction<void Function(_CRouteRebuilder, bool)>();

late final _CRouteRebuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRouteRebuilder_cg_objectIdentifier');
late final _CRouteRebuilder_cg_objectIdentifier = _CRouteRebuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CRouteRebuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRouteRebuilder_release');
late final _CRouteRebuilder_release = _CRouteRebuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteRebuilder_retainPtr = _lookup<ffi.NativeFunction<_CRouteRebuilder Function(ffi.Pointer<ffi.Void>)>>('CRouteRebuilder_retain');
late final _CRouteRebuilder_retain = _CRouteRebuilder_retainPtr.asFunction<_CRouteRebuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CRouteRebuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRouteRebuilder Function()>>('CRouteRebuilderMakeDefault');
late final _CRouteRebuilderMakeDefault = _CRouteRebuilderMakeDefaultPtr.asFunction<_CRouteRebuilder Function()>();

late final _CFreeRoamSelector_enabledPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CFreeRoamSelector)>>('CFreeRoamSelector_enabled');
late final _CFreeRoamSelector_enabled = _CFreeRoamSelector_enabledPtr.asFunction<bool Function(_CFreeRoamSelector)>();
late final _CFreeRoamSelector_setEnabled_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFreeRoamSelector, ffi.Bool)>>('CFreeRoamSelector_setEnabled_bool');
late final _CFreeRoamSelector_setEnabled_bool = _CFreeRoamSelector_setEnabled_boolPtr.asFunction<void Function(_CFreeRoamSelector, bool)>();

late final _CFreeRoamSelector_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CFreeRoamSelector_cg_objectIdentifier');
late final _CFreeRoamSelector_cg_objectIdentifier = _CFreeRoamSelector_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CFreeRoamSelector_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CFreeRoamSelector_release');
late final _CFreeRoamSelector_release = _CFreeRoamSelector_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CFreeRoamSelector_retainPtr = _lookup<ffi.NativeFunction<_CFreeRoamSelector Function(ffi.Pointer<ffi.Void>)>>('CFreeRoamSelector_retain');
late final _CFreeRoamSelector_retain = _CFreeRoamSelector_retainPtr.asFunction<_CFreeRoamSelector Function(ffi.Pointer<ffi.Void>)>();
late final _CFreeRoamSelectorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFreeRoamSelector Function()>>('CFreeRoamSelectorMakeDefault');
late final _CFreeRoamSelectorMakeDefault = _CFreeRoamSelectorMakeDefaultPtr.asFunction<_CFreeRoamSelector Function()>();

late final _CNavigationManager_uiModelPtr = _lookup<ffi.NativeFunction<_CModel Function(_CNavigationManager)>>('CNavigationManager_uiModel');
late final _CNavigationManager_uiModel = _CNavigationManager_uiModelPtr.asFunction<_CModel Function(_CNavigationManager)>();
late final _CNavigationManager_indoorDetectorPtr = _lookup<ffi.NativeFunction<_CIndoorDetector Function(_CNavigationManager)>>('CNavigationManager_indoorDetector');
late final _CNavigationManager_indoorDetector = _CNavigationManager_indoorDetectorPtr.asFunction<_CIndoorDetector Function(_CNavigationManager)>();
late final _CNavigationManager_mapFollowControllerPtr = _lookup<ffi.NativeFunction<_CNavigationFollowController Function(_CNavigationManager)>>('CNavigationManager_mapFollowController');
late final _CNavigationManager_mapFollowController = _CNavigationManager_mapFollowControllerPtr.asFunction<_CNavigationFollowController Function(_CNavigationManager)>();
late final _CNavigationManager_mapLocationControllerPtr = _lookup<ffi.NativeFunction<_CMapLocationController Function(_CNavigationManager)>>('CNavigationManager_mapLocationController');
late final _CNavigationManager_mapLocationController = _CNavigationManager_mapLocationControllerPtr.asFunction<_CMapLocationController Function(_CNavigationManager)>();
late final _CNavigationManager_mapManagerPtr = _lookup<ffi.NativeFunction<_CMapManager Function(_CNavigationManager)>>('CNavigationManager_mapManager');
late final _CNavigationManager_mapManager = _CNavigationManager_mapManagerPtr.asFunction<_CMapManager Function(_CNavigationManager)>();
late final _CNavigationManager_zoomFollowSettingsPtr = _lookup<ffi.NativeFunction<_CZoomFollowSettings Function(_CNavigationManager)>>('CNavigationManager_zoomFollowSettings');
late final _CNavigationManager_zoomFollowSettings = _CNavigationManager_zoomFollowSettingsPtr.asFunction<_CZoomFollowSettings Function(_CNavigationManager)>();
late final _CNavigationManager_routeMapSettingsPtr = _lookup<ffi.NativeFunction<_CRouteMapSettings Function(_CNavigationManager)>>('CNavigationManager_routeMapSettings');
late final _CNavigationManager_routeMapSettings = _CNavigationManager_routeMapSettingsPtr.asFunction<_CRouteMapSettings Function(_CNavigationManager)>();
late final _CNavigationManager_routeSourceSettingsPtr = _lookup<ffi.NativeFunction<_CRouteSourceSettings Function(_CNavigationManager)>>('CNavigationManager_routeSourceSettings');
late final _CNavigationManager_routeSourceSettings = _CNavigationManager_routeSourceSettingsPtr.asFunction<_CRouteSourceSettings Function(_CNavigationManager)>();
late final _CNavigationManager_routeMapObjectsProviderPtr = _lookup<ffi.NativeFunction<_CRouteMapObjectsProvider Function(_CNavigationManager)>>('CNavigationManager_routeMapObjectsProvider');
late final _CNavigationManager_routeMapObjectsProvider = _CNavigationManager_routeMapObjectsProviderPtr.asFunction<_CRouteMapObjectsProvider Function(_CNavigationManager)>();
late final _CNavigationManager_simulationSettingsPtr = _lookup<ffi.NativeFunction<_CSimulationSettings Function(_CNavigationManager)>>('CNavigationManager_simulationSettings');
late final _CNavigationManager_simulationSettings = _CNavigationManager_simulationSettingsPtr.asFunction<_CSimulationSettings Function(_CNavigationManager)>();
late final _CNavigationManager_voiceSelectorPtr = _lookup<ffi.NativeFunction<_CVoiceSelector Function(_CNavigationManager)>>('CNavigationManager_voiceSelector');
late final _CNavigationManager_voiceSelector = _CNavigationManager_voiceSelectorPtr.asFunction<_CVoiceSelector Function(_CNavigationManager)>();
late final _CNavigationManager_exceedSpeedLimitSettingsPtr = _lookup<ffi.NativeFunction<_CExceedSpeedLimitSettings Function(_CNavigationManager)>>('CNavigationManager_exceedSpeedLimitSettings');
late final _CNavigationManager_exceedSpeedLimitSettings = _CNavigationManager_exceedSpeedLimitSettingsPtr.asFunction<_CExceedSpeedLimitSettings Function(_CNavigationManager)>();
late final _CNavigationManager_dynamicRouteInfoSettingsPtr = _lookup<ffi.NativeFunction<_CDynamicRouteInfoSettings Function(_CNavigationManager)>>('CNavigationManager_dynamicRouteInfoSettings');
late final _CNavigationManager_dynamicRouteInfoSettings = _CNavigationManager_dynamicRouteInfoSettingsPtr.asFunction<_CDynamicRouteInfoSettings Function(_CNavigationManager)>();
late final _CNavigationManager_soundNotificationSettingsPtr = _lookup<ffi.NativeFunction<_CSoundNotificationSettings Function(_CNavigationManager)>>('CNavigationManager_soundNotificationSettings');
late final _CNavigationManager_soundNotificationSettings = _CNavigationManager_soundNotificationSettingsPtr.asFunction<_CSoundNotificationSettings Function(_CNavigationManager)>();
late final _CNavigationManager_freeRoamSettingsPtr = _lookup<ffi.NativeFunction<_CFreeRoamSettings Function(_CNavigationManager)>>('CNavigationManager_freeRoamSettings');
late final _CNavigationManager_freeRoamSettings = _CNavigationManager_freeRoamSettingsPtr.asFunction<_CFreeRoamSettings Function(_CNavigationManager)>();
late final _CNavigationManager_alternativeRoutesProviderSettingsPtr = _lookup<ffi.NativeFunction<_CAlternativeRoutesProviderSettings Function(_CNavigationManager)>>('CNavigationManager_alternativeRoutesProviderSettings');
late final _CNavigationManager_alternativeRoutesProviderSettings = _CNavigationManager_alternativeRoutesProviderSettingsPtr.asFunction<_CAlternativeRoutesProviderSettings Function(_CNavigationManager)>();
late final _CNavigationManager_alternativeRouteSelectorPtr = _lookup<ffi.NativeFunction<_CAlternativeRouteSelector Function(_CNavigationManager)>>('CNavigationManager_alternativeRouteSelector');
late final _CNavigationManager_alternativeRouteSelector = _CNavigationManager_alternativeRouteSelectorPtr.asFunction<_CAlternativeRouteSelector Function(_CNavigationManager)>();
late final _CNavigationManager_myLocationMapObjectSourceProviderPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObjectSourceProvider Function(_CNavigationManager)>>('CNavigationManager_myLocationMapObjectSourceProvider');
late final _CNavigationManager_myLocationMapObjectSourceProvider = _CNavigationManager_myLocationMapObjectSourceProviderPtr.asFunction<_CMyLocationMapObjectSourceProvider Function(_CNavigationManager)>();
late final _CNavigationManager_routeRebuilderPtr = _lookup<ffi.NativeFunction<_CRouteRebuilder Function(_CNavigationManager)>>('CNavigationManager_routeRebuilder');
late final _CNavigationManager_routeRebuilder = _CNavigationManager_routeRebuilderPtr.asFunction<_CRouteRebuilder Function(_CNavigationManager)>();
late final _CNavigationManager_freeRoamSelectorPtr = _lookup<ffi.NativeFunction<_CFreeRoamSelector Function(_CNavigationManager)>>('CNavigationManager_freeRoamSelector');
late final _CNavigationManager_freeRoamSelector = _CNavigationManager_freeRoamSelectorPtr.asFunction<_CFreeRoamSelector Function(_CNavigationManager)>();

late final _CNavigationManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CNavigationManager_cg_objectIdentifier');
late final _CNavigationManager_cg_objectIdentifier = _CNavigationManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CNavigationManager_startFreeRoamPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CNavigationManager)>>('CNavigationManager_startFreeRoam');
late final _CNavigationManager_startFreeRoam = _CNavigationManager_startFreeRoamPtr.asFunction<_CResult_CEmpty Function(_CNavigationManager)>();
late final _CNavigationManager_start_CRouteBuildOptions_COptional_CTrafficRoutePtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CNavigationManager, _CRouteBuildOptions, _COptional_CTrafficRoute)>>('CNavigationManager_start_CRouteBuildOptions_COptional_CTrafficRoute');
late final _CNavigationManager_start_CRouteBuildOptions_COptional_CTrafficRoute = _CNavigationManager_start_CRouteBuildOptions_COptional_CTrafficRoutePtr.asFunction<_CResult_CEmpty Function(_CNavigationManager, _CRouteBuildOptions, _COptional_CTrafficRoute)>();
late final _CNavigationManager_startSimulation_CRouteBuildOptions_CTrafficRoutePtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CNavigationManager, _CRouteBuildOptions, _CTrafficRoute)>>('CNavigationManager_startSimulation_CRouteBuildOptions_CTrafficRoute');
late final _CNavigationManager_startSimulation_CRouteBuildOptions_CTrafficRoute = _CNavigationManager_startSimulation_CRouteBuildOptions_CTrafficRoutePtr.asFunction<_CResult_CEmpty Function(_CNavigationManager, _CRouteBuildOptions, _CTrafficRoute)>();
late final _CNavigationManager_stopPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CNavigationManager)>>('CNavigationManager_stop');
late final _CNavigationManager_stop = _CNavigationManager_stopPtr.asFunction<void Function(_CNavigationManager)>();
late final _CNavigationManager_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CResult_CNavigationManager Function(_CContext)>>('CNavigationManager_C_createWith_CContext');
late final _CNavigationManager_C_createWith_CContext = _CNavigationManager_C_createWith_CContextPtr.asFunction<_CResult_CNavigationManager Function(_CContext)>();

late final _CNavigationManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CNavigationManager_release');
late final _CNavigationManager_release = _CNavigationManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CNavigationManager_retainPtr = _lookup<ffi.NativeFunction<_CNavigationManager Function(ffi.Pointer<ffi.Void>)>>('CNavigationManager_retain');
late final _CNavigationManager_retain = _CNavigationManager_retainPtr.asFunction<_CNavigationManager Function(ffi.Pointer<ffi.Void>)>();
late final _CNavigationManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CNavigationManager Function()>>('CNavigationManagerMakeDefault');
late final _CNavigationManagerMakeDefault = _CNavigationManagerMakeDefaultPtr.asFunction<_CNavigationManager Function()>();


late final _COptional_CTrafficRouteMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CTrafficRoute Function()>>('COptional_CTrafficRouteMakeDefault');
late final _COptional_CTrafficRouteMakeDefault = _COptional_CTrafficRouteMakeDefaultPtr.asFunction<_COptional_CTrafficRoute Function()>();

late final _COptional_CTrafficRoute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CTrafficRoute)>>('COptional_CTrafficRoute_release');
late final _COptional_CTrafficRoute_release = _COptional_CTrafficRoute_releasePtr.asFunction<void Function(_COptional_CTrafficRoute)>();

late final _CResult_CNavigationManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CNavigationManager)>>('CResult_CNavigationManager_release');
late final _CResult_CNavigationManager_release = _CResult_CNavigationManager_releasePtr.asFunction<void Function(_CResult_CNavigationManager)>();

late final _CInstructionManeuverMakeDefaultPtr = _lookup<ffi.NativeFunction<_CInstructionManeuver Function()>>('CInstructionManeuverMakeDefault');
late final _CInstructionManeuverMakeDefault = _CInstructionManeuverMakeDefaultPtr.asFunction<_CInstructionManeuver Function()>();
late final _CFunction_G_getInstructionManeuver_With_CExtraInstructionInfoPtr = _lookup<ffi.NativeFunction<_CInstructionManeuver Function(_CExtraInstructionInfo)>>('CFunction_G_getInstructionManeuver_With_CExtraInstructionInfo');
late final _CFunction_G_getInstructionManeuver_With_CExtraInstructionInfo = _CFunction_G_getInstructionManeuver_With_CExtraInstructionInfoPtr.asFunction<_CInstructionManeuver Function(_CExtraInstructionInfo)>();
late final _CFunction_G_getLanesControlImages_With_CRouteLaneSign_uint32_t_boolPtr = _lookup<ffi.NativeFunction<_CArray_CLanesControlImage Function(_CRouteLaneSign, ffi.Uint32, ffi.Bool)>>('CFunction_G_getLanesControlImages_With_CRouteLaneSign_uint32_t_bool');
late final _CFunction_G_getLanesControlImages_With_CRouteLaneSign_uint32_t_bool = _CFunction_G_getLanesControlImages_With_CRouteLaneSign_uint32_t_boolPtr.asFunction<_CArray_CLanesControlImage Function(_CRouteLaneSign, int, bool)>();

late final _CLanesControlImageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLanesControlImage Function()>>('CLanesControlImageMakeDefault');
late final _CLanesControlImageMakeDefault = _CLanesControlImageMakeDefaultPtr.asFunction<_CLanesControlImage Function()>();

late final _CArray_CLanesControlImagemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CLanesControlImage Function()>>('CArray_CLanesControlImage_makeEmpty');
late final _CArray_CLanesControlImagemakeEmpty = _CArray_CLanesControlImagemakeEmptyPtr.asFunction<_CArray_CLanesControlImage Function()>();
late final _CArray_CLanesControlImageaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLanesControlImage, _CLanesControlImage)>>('CArray_CLanesControlImage_addElement');
late final _CArray_CLanesControlImageaddElement = _CArray_CLanesControlImageaddElementPtr.asFunction<void Function(_CArray_CLanesControlImage, _CLanesControlImage)>();
late final _forEach_CArray_CLanesControlImagePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CLanesControlImage, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLanesControlImage)>>)
>>('CArray_CLanesControlImage_forEachWithFunctionPointer');
late final _forEach_CArray_CLanesControlImage = _forEach_CArray_CLanesControlImagePtr.asFunction<
  void Function(_CArray_CLanesControlImage, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLanesControlImage)
>>)>();
late final _CArray_CLanesControlImage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLanesControlImage)>>('CArray_CLanesControlImage_release');
late final _CArray_CLanesControlImage_release = _CArray_CLanesControlImage_releasePtr.asFunction<void Function(_CArray_CLanesControlImage)>();
late final _CFunction_G_getVoiceManager_With_CContextPtr = _lookup<ffi.NativeFunction<_CVoiceManager Function(_CContext)>>('CFunction_G_getVoiceManager_With_CContext');
late final _CFunction_G_getVoiceManager_With_CContext = _CFunction_G_getVoiceManager_With_CContextPtr.asFunction<_CVoiceManager Function(_CContext)>();
late final _CVoiceManager_voicesChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CVoice Function(_CVoiceManager)>>('CVoiceManager_voicesChannel');
late final _CVoiceManager_voicesChannel = _CVoiceManager_voicesChannelPtr.asFunction<_CStatefulChannel_CArray_CVoice Function(_CVoiceManager)>();
late final _CVoiceManager_voicesPtr = _lookup<ffi.NativeFunction<_CArray_CVoice Function(_CVoiceManager)>>('CVoiceManager_voices');
late final _CVoiceManager_voices = _CVoiceManager_voicesPtr.asFunction<_CArray_CVoice Function(_CVoiceManager)>();

late final _CVoiceManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CVoiceManager_cg_objectIdentifier');
late final _CVoiceManager_cg_objectIdentifier = _CVoiceManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CVoiceManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CVoiceManager_release');
late final _CVoiceManager_release = _CVoiceManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CVoiceManager_retainPtr = _lookup<ffi.NativeFunction<_CVoiceManager Function(ffi.Pointer<ffi.Void>)>>('CVoiceManager_retain');
late final _CVoiceManager_retain = _CVoiceManager_retainPtr.asFunction<_CVoiceManager Function(ffi.Pointer<ffi.Void>)>();
late final _CVoiceManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CVoiceManager Function()>>('CVoiceManagerMakeDefault');
late final _CVoiceManagerMakeDefault = _CVoiceManagerMakeDefaultPtr.asFunction<_CVoiceManager Function()>();


late final _CStatefulChannel_CArray_CVoiceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CVoice Function()>>('CStatefulChannel_CArray_CVoiceMakeDefault');
late final _CStatefulChannel_CArray_CVoiceMakeDefault = _CStatefulChannel_CArray_CVoiceMakeDefaultPtr.asFunction<_CStatefulChannel_CArray_CVoice Function()>();
late final _CStatefulChannel_CArray_CVoice_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CArray_CVoice)>>('CStatefulChannel_CArray_CVoice_release');
late final _CStatefulChannel_CArray_CVoice_release = _CStatefulChannel_CArray_CVoice_releasePtr.asFunction<void Function(_CStatefulChannel_CArray_CVoice)>();
late final _CStatefulChannel_CArray_CVoice_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CVoice Function(_CStatefulChannel_CArray_CVoice)>>('CStatefulChannel_CArray_CVoice_retain');
late final _CStatefulChannel_CArray_CVoice_retain = _CStatefulChannel_CArray_CVoice_retainPtr.asFunction<_CStatefulChannel_CArray_CVoice Function(_CStatefulChannel_CArray_CVoice)>();
late final _CStatefulChannel_CArray_CVoiceGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CArray_CVoice Function(_CStatefulChannel_CArray_CVoice)>>('CStatefulChannel_CArray_CVoice_getCurrentValue');
late final _CStatefulChannel_CArray_CVoiceGetCurrentValue = _CStatefulChannel_CArray_CVoiceGetCurrentValuePtr.asFunction<_CArray_CVoice Function(_CStatefulChannel_CArray_CVoice)>();
late final _CStatefulChannel_CArray_CVoiceConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CVoice,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CVoice, ffi.Int64)>>
  )
>>('CStatefulChannel_CArray_CVoice_connect');
late final _CStatefulChannel_CArray_CVoiceConnect = _CStatefulChannel_CArray_CVoiceConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CVoice,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CVoice, ffi.Int64)>>
  )
>();

late final _CArray_CVoicemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CVoice Function()>>('CArray_CVoice_makeEmpty');
late final _CArray_CVoicemakeEmpty = _CArray_CVoicemakeEmptyPtr.asFunction<_CArray_CVoice Function()>();
late final _CArray_CVoiceaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CVoice, _CVoice)>>('CArray_CVoice_addElement');
late final _CArray_CVoiceaddElement = _CArray_CVoiceaddElementPtr.asFunction<void Function(_CArray_CVoice, _CVoice)>();
late final _forEach_CArray_CVoicePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CVoice, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CVoice)>>)
>>('CArray_CVoice_forEachWithFunctionPointer');
late final _forEach_CArray_CVoice = _forEach_CArray_CVoicePtr.asFunction<
  void Function(_CArray_CVoice, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CVoice)
>>)>();
late final _CArray_CVoice_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CVoice)>>('CArray_CVoice_release');
late final _CArray_CVoice_release = _CArray_CVoice_releasePtr.asFunction<void Function(_CArray_CVoice)>();
late final _CVoice_navigationVoicePtr = _lookup<ffi.NativeFunction<_CNavigationVoice Function(_CVoice)>>('CVoice_navigationVoice');
late final _CVoice_navigationVoice = _CVoice_navigationVoicePtr.asFunction<_CNavigationVoice Function(_CVoice)>();
late final _CVoice_languagePtr = _lookup<ffi.NativeFunction<_CString Function(_CVoice)>>('CVoice_language');
late final _CVoice_language = _CVoice_languagePtr.asFunction<_CString Function(_CVoice)>();

late final _CVoice_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CVoice_cg_objectIdentifier');
late final _CVoice_cg_objectIdentifier = _CVoice_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CVoice_playWelcomePtr = _lookup<ffi.NativeFunction<_CFuture_void Function(_CVoice)>>('CVoice_playWelcome');
late final _CVoice_playWelcome = _CVoice_playWelcomePtr.asFunction<_CFuture_void Function(_CVoice)>();

late final _CVoice_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CVoice_release');
late final _CVoice_release = _CVoice_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CVoice_retainPtr = _lookup<ffi.NativeFunction<_CVoice Function(ffi.Pointer<ffi.Void>)>>('CVoice_retain');
late final _CVoice_retain = _CVoice_retainPtr.asFunction<_CVoice Function(ffi.Pointer<ffi.Void>)>();
late final _CVoiceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CVoice Function()>>('CVoiceMakeDefault');
late final _CVoiceMakeDefault = _CVoiceMakeDefaultPtr.asFunction<_CVoice Function()>();


late final _CFuture_voidMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_void Function()>>('CFuture_voidMakeDefault');
late final _CFuture_voidMakeDefault = _CFuture_voidMakeDefaultPtr.asFunction<_CFuture_void Function()>();
late final _CFuture_void_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_void)>>('CFuture_void_release');
late final _CFuture_void_release = _CFuture_void_releasePtr.asFunction<void Function(_CFuture_void)>();
late final _CFuture_void_retainPtr = _lookup<ffi.NativeFunction<_CFuture_void Function(_CFuture_void)>>('CFuture_void_retain');
late final _CFuture_void_retain = _CFuture_void_retainPtr.asFunction<_CFuture_void Function(_CFuture_void)>();
late final _CFuture_voidReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_void,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_void_receive');
late final _CFuture_voidReceive = _CFuture_voidReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_void,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();
late final _CActivityTracker_stopChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CActivityTracker)>>('CActivityTracker_stopChannel');
late final _CActivityTracker_stopChannel = _CActivityTracker_stopChannelPtr.asFunction<_CStatefulChannel_bool Function(_CActivityTracker)>();
late final _CActivityTracker_stopPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CActivityTracker)>>('CActivityTracker_stop');
late final _CActivityTracker_stop = _CActivityTracker_stopPtr.asFunction<bool Function(_CActivityTracker)>();

late final _CActivityTracker_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CActivityTracker_cg_objectIdentifier');
late final _CActivityTracker_cg_objectIdentifier = _CActivityTracker_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CActivityTracker_C_createWith_CContext_CModel_double_CTimeIntervalPtr = _lookup<ffi.NativeFunction<_CActivityTracker Function(_CContext, _CModel, ffi.Double, _CTimeInterval)>>('CActivityTracker_C_createWith_CContext_CModel_double_CTimeInterval');
late final _CActivityTracker_C_createWith_CContext_CModel_double_CTimeInterval = _CActivityTracker_C_createWith_CContext_CModel_double_CTimeIntervalPtr.asFunction<_CActivityTracker Function(_CContext, _CModel, double, _CTimeInterval)>();

late final _CActivityTracker_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CActivityTracker_release');
late final _CActivityTracker_release = _CActivityTracker_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CActivityTracker_retainPtr = _lookup<ffi.NativeFunction<_CActivityTracker Function(ffi.Pointer<ffi.Void>)>>('CActivityTracker_retain');
late final _CActivityTracker_retain = _CActivityTracker_retainPtr.asFunction<_CActivityTracker Function(ffi.Pointer<ffi.Void>)>();
late final _CActivityTrackerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CActivityTracker Function()>>('CActivityTrackerMakeDefault');
late final _CActivityTrackerMakeDefault = _CActivityTrackerMakeDefaultPtr.asFunction<_CActivityTracker Function()>();


late final _CCameraProgressInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraProgressInfo Function()>>('CCameraProgressInfoMakeDefault');
late final _CCameraProgressInfoMakeDefault = _CCameraProgressInfoMakeDefaultPtr.asFunction<_CCameraProgressInfo Function()>();

late final _CCameraNotifier_cameraProgressChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CCameraProgressInfo Function(_CCameraNotifier)>>('CCameraNotifier_cameraProgressChannel');
late final _CCameraNotifier_cameraProgressChannel = _CCameraNotifier_cameraProgressChannelPtr.asFunction<_CStatefulChannel_COptional_CCameraProgressInfo Function(_CCameraNotifier)>();
late final _CCameraNotifier_cameraProgressPtr = _lookup<ffi.NativeFunction<_COptional_CCameraProgressInfo Function(_CCameraNotifier)>>('CCameraNotifier_cameraProgress');
late final _CCameraNotifier_cameraProgress = _CCameraNotifier_cameraProgressPtr.asFunction<_COptional_CCameraProgressInfo Function(_CCameraNotifier)>();

late final _CCameraNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCameraNotifier_cg_objectIdentifier');
late final _CCameraNotifier_cg_objectIdentifier = _CCameraNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCameraNotifier_C_createWith_CModelPtr = _lookup<ffi.NativeFunction<_CCameraNotifier Function(_CModel)>>('CCameraNotifier_C_createWith_CModel');
late final _CCameraNotifier_C_createWith_CModel = _CCameraNotifier_C_createWith_CModelPtr.asFunction<_CCameraNotifier Function(_CModel)>();

late final _CCameraNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCameraNotifier_release');
late final _CCameraNotifier_release = _CCameraNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCameraNotifier_retainPtr = _lookup<ffi.NativeFunction<_CCameraNotifier Function(ffi.Pointer<ffi.Void>)>>('CCameraNotifier_retain');
late final _CCameraNotifier_retain = _CCameraNotifier_retainPtr.asFunction<_CCameraNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CCameraNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraNotifier Function()>>('CCameraNotifierMakeDefault');
late final _CCameraNotifierMakeDefault = _CCameraNotifierMakeDefaultPtr.asFunction<_CCameraNotifier Function()>();


late final _CStatefulChannel_COptional_CCameraProgressInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CCameraProgressInfo Function()>>('CStatefulChannel_COptional_CCameraProgressInfoMakeDefault');
late final _CStatefulChannel_COptional_CCameraProgressInfoMakeDefault = _CStatefulChannel_COptional_CCameraProgressInfoMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CCameraProgressInfo Function()>();
late final _CStatefulChannel_COptional_CCameraProgressInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CCameraProgressInfo)>>('CStatefulChannel_COptional_CCameraProgressInfo_release');
late final _CStatefulChannel_COptional_CCameraProgressInfo_release = _CStatefulChannel_COptional_CCameraProgressInfo_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CCameraProgressInfo)>();
late final _CStatefulChannel_COptional_CCameraProgressInfo_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CCameraProgressInfo Function(_CStatefulChannel_COptional_CCameraProgressInfo)>>('CStatefulChannel_COptional_CCameraProgressInfo_retain');
late final _CStatefulChannel_COptional_CCameraProgressInfo_retain = _CStatefulChannel_COptional_CCameraProgressInfo_retainPtr.asFunction<_CStatefulChannel_COptional_CCameraProgressInfo Function(_CStatefulChannel_COptional_CCameraProgressInfo)>();
late final _CStatefulChannel_COptional_CCameraProgressInfoGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CCameraProgressInfo Function(_CStatefulChannel_COptional_CCameraProgressInfo)>>('CStatefulChannel_COptional_CCameraProgressInfo_getCurrentValue');
late final _CStatefulChannel_COptional_CCameraProgressInfoGetCurrentValue = _CStatefulChannel_COptional_CCameraProgressInfoGetCurrentValuePtr.asFunction<_COptional_CCameraProgressInfo Function(_CStatefulChannel_COptional_CCameraProgressInfo)>();
late final _CStatefulChannel_COptional_CCameraProgressInfoConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CCameraProgressInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CCameraProgressInfo, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CCameraProgressInfo_connect');
late final _CStatefulChannel_COptional_CCameraProgressInfoConnect = _CStatefulChannel_COptional_CCameraProgressInfoConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CCameraProgressInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CCameraProgressInfo, ffi.Int64)>>
  )
>();

late final _COptional_CCameraProgressInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CCameraProgressInfo Function()>>('COptional_CCameraProgressInfoMakeDefault');
late final _COptional_CCameraProgressInfoMakeDefault = _COptional_CCameraProgressInfoMakeDefaultPtr.asFunction<_COptional_CCameraProgressInfo Function()>();
late final _CFunction_G_makeLocale_With_CStringPtr = _lookup<ffi.NativeFunction<_COptional_CLocale Function(_CString)>>('CFunction_G_makeLocale_With_CString');
late final _CFunction_G_makeLocale_With_CString = _CFunction_G_makeLocale_With_CStringPtr.asFunction<_COptional_CLocale Function(_CString)>();

late final _CLocaleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocale Function()>>('CLocaleMakeDefault');
late final _CLocaleMakeDefault = _CLocaleMakeDefaultPtr.asFunction<_CLocale Function()>();


late final _CApplicationStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CApplicationState Function()>>('CApplicationStateMakeDefault');
late final _CApplicationStateMakeDefault = _CApplicationStateMakeDefaultPtr.asFunction<_CApplicationState Function()>();
late final _CHttpCacheManager_getCurrentSizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CHttpCacheManager)>>('CHttpCacheManager_getCurrentSize');
late final _CHttpCacheManager_getCurrentSize = _CHttpCacheManager_getCurrentSizePtr.asFunction<int Function(_CHttpCacheManager)>();
late final _CHttpCacheManager_getMaxSizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CHttpCacheManager)>>('CHttpCacheManager_getMaxSize');
late final _CHttpCacheManager_getMaxSize = _CHttpCacheManager_getMaxSizePtr.asFunction<int Function(_CHttpCacheManager)>();
late final _CHttpCacheManager_setMaxSize_uint64_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CHttpCacheManager, ffi.Uint64)>>('CHttpCacheManager_setMaxSize_uint64_t');
late final _CHttpCacheManager_setMaxSize_uint64_t = _CHttpCacheManager_setMaxSize_uint64_tPtr.asFunction<void Function(_CHttpCacheManager, int)>();

late final _CHttpCacheManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CHttpCacheManager_cg_objectIdentifier');
late final _CHttpCacheManager_cg_objectIdentifier = _CHttpCacheManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CHttpCacheManager_clearPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CHttpCacheManager)>>('CHttpCacheManager_clear');
late final _CHttpCacheManager_clear = _CHttpCacheManager_clearPtr.asFunction<void Function(_CHttpCacheManager)>();

late final _CHttpCacheManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CHttpCacheManager_release');
late final _CHttpCacheManager_release = _CHttpCacheManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CHttpCacheManager_retainPtr = _lookup<ffi.NativeFunction<_CHttpCacheManager Function(ffi.Pointer<ffi.Void>)>>('CHttpCacheManager_retain');
late final _CHttpCacheManager_retain = _CHttpCacheManager_retainPtr.asFunction<_CHttpCacheManager Function(ffi.Pointer<ffi.Void>)>();
late final _CHttpCacheManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CHttpCacheManager Function()>>('CHttpCacheManagerMakeDefault');
late final _CHttpCacheManagerMakeDefault = _CHttpCacheManagerMakeDefaultPtr.asFunction<_CHttpCacheManager Function()>();


late final _CLocaleChangeNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLocaleChangeNotifier_cg_objectIdentifier');
late final _CLocaleChangeNotifier_cg_objectIdentifier = _CLocaleChangeNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLocaleChangeNotifier_changed_CArray_CLocalePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocaleChangeNotifier, _CArray_CLocale)>>('CLocaleChangeNotifier_changed_CArray_CLocale');
late final _CLocaleChangeNotifier_changed_CArray_CLocale = _CLocaleChangeNotifier_changed_CArray_CLocalePtr.asFunction<void Function(_CLocaleChangeNotifier, _CArray_CLocale)>();

late final _CLocaleChangeNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLocaleChangeNotifier_release');
late final _CLocaleChangeNotifier_release = _CLocaleChangeNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLocaleChangeNotifier_retainPtr = _lookup<ffi.NativeFunction<_CLocaleChangeNotifier Function(ffi.Pointer<ffi.Void>)>>('CLocaleChangeNotifier_retain');
late final _CLocaleChangeNotifier_retain = _CLocaleChangeNotifier_retainPtr.asFunction<_CLocaleChangeNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CLocaleChangeNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocaleChangeNotifier Function()>>('CLocaleChangeNotifierMakeDefault');
late final _CLocaleChangeNotifierMakeDefault = _CLocaleChangeNotifierMakeDefaultPtr.asFunction<_CLocaleChangeNotifier Function()>();


late final _CArray_CLocalemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CLocale Function()>>('CArray_CLocale_makeEmpty');
late final _CArray_CLocalemakeEmpty = _CArray_CLocalemakeEmptyPtr.asFunction<_CArray_CLocale Function()>();
late final _CArray_CLocaleaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLocale, _CLocale)>>('CArray_CLocale_addElement');
late final _CArray_CLocaleaddElement = _CArray_CLocaleaddElementPtr.asFunction<void Function(_CArray_CLocale, _CLocale)>();
late final _forEach_CArray_CLocalePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CLocale, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLocale)>>)
>>('CArray_CLocale_forEachWithFunctionPointer');
late final _forEach_CArray_CLocale = _forEach_CArray_CLocalePtr.asFunction<
  void Function(_CArray_CLocale, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLocale)
>>)>();
late final _CArray_CLocale_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLocale)>>('CArray_CLocale_release');
late final _CArray_CLocale_release = _CArray_CLocale_releasePtr.asFunction<void Function(_CArray_CLocale)>();
late final _CLocaleManager_localesChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CLocale Function(_CLocaleManager)>>('CLocaleManager_localesChannel');
late final _CLocaleManager_localesChannel = _CLocaleManager_localesChannelPtr.asFunction<_CStatefulChannel_CArray_CLocale Function(_CLocaleManager)>();
late final _CLocaleManager_localesPtr = _lookup<ffi.NativeFunction<_CArray_CLocale Function(_CLocaleManager)>>('CLocaleManager_locales');
late final _CLocaleManager_locales = _CLocaleManager_localesPtr.asFunction<_CArray_CLocale Function(_CLocaleManager)>();
late final _CLocaleManager_systemLocalesChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CLocale Function(_CLocaleManager)>>('CLocaleManager_systemLocalesChannel');
late final _CLocaleManager_systemLocalesChannel = _CLocaleManager_systemLocalesChannelPtr.asFunction<_CStatefulChannel_CArray_CLocale Function(_CLocaleManager)>();
late final _CLocaleManager_systemLocalesPtr = _lookup<ffi.NativeFunction<_CArray_CLocale Function(_CLocaleManager)>>('CLocaleManager_systemLocales');
late final _CLocaleManager_systemLocales = _CLocaleManager_systemLocalesPtr.asFunction<_CArray_CLocale Function(_CLocaleManager)>();

late final _CLocaleManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLocaleManager_cg_objectIdentifier');
late final _CLocaleManager_cg_objectIdentifier = _CLocaleManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLocaleManager_overrideLocales_CArray_CLocalePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocaleManager, _CArray_CLocale)>>('CLocaleManager_overrideLocales_CArray_CLocale');
late final _CLocaleManager_overrideLocales_CArray_CLocale = _CLocaleManager_overrideLocales_CArray_CLocalePtr.asFunction<void Function(_CLocaleManager, _CArray_CLocale)>();

late final _CLocaleManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLocaleManager_release');
late final _CLocaleManager_release = _CLocaleManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLocaleManager_retainPtr = _lookup<ffi.NativeFunction<_CLocaleManager Function(ffi.Pointer<ffi.Void>)>>('CLocaleManager_retain');
late final _CLocaleManager_retain = _CLocaleManager_retainPtr.asFunction<_CLocaleManager Function(ffi.Pointer<ffi.Void>)>();
late final _CLocaleManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocaleManager Function()>>('CLocaleManagerMakeDefault');
late final _CLocaleManagerMakeDefault = _CLocaleManagerMakeDefaultPtr.asFunction<_CLocaleManager Function()>();


late final _CStatefulChannel_CArray_CLocaleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CLocale Function()>>('CStatefulChannel_CArray_CLocaleMakeDefault');
late final _CStatefulChannel_CArray_CLocaleMakeDefault = _CStatefulChannel_CArray_CLocaleMakeDefaultPtr.asFunction<_CStatefulChannel_CArray_CLocale Function()>();
late final _CStatefulChannel_CArray_CLocale_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CArray_CLocale)>>('CStatefulChannel_CArray_CLocale_release');
late final _CStatefulChannel_CArray_CLocale_release = _CStatefulChannel_CArray_CLocale_releasePtr.asFunction<void Function(_CStatefulChannel_CArray_CLocale)>();
late final _CStatefulChannel_CArray_CLocale_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CLocale Function(_CStatefulChannel_CArray_CLocale)>>('CStatefulChannel_CArray_CLocale_retain');
late final _CStatefulChannel_CArray_CLocale_retain = _CStatefulChannel_CArray_CLocale_retainPtr.asFunction<_CStatefulChannel_CArray_CLocale Function(_CStatefulChannel_CArray_CLocale)>();
late final _CStatefulChannel_CArray_CLocaleGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CArray_CLocale Function(_CStatefulChannel_CArray_CLocale)>>('CStatefulChannel_CArray_CLocale_getCurrentValue');
late final _CStatefulChannel_CArray_CLocaleGetCurrentValue = _CStatefulChannel_CArray_CLocaleGetCurrentValuePtr.asFunction<_CArray_CLocale Function(_CStatefulChannel_CArray_CLocale)>();
late final _CStatefulChannel_CArray_CLocaleConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CLocale,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CLocale, ffi.Int64)>>
  )
>>('CStatefulChannel_CArray_CLocale_connect');
late final _CStatefulChannel_CArray_CLocaleConnect = _CStatefulChannel_CArray_CLocaleConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CLocale,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CLocale, ffi.Int64)>>
  )
>();

late final _CPlatformLocaleManagerCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPlatformLocaleManagerCpp_cg_objectIdentifier');
late final _CPlatformLocaleManagerCpp_cg_objectIdentifier = _CPlatformLocaleManagerCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPlatformLocaleManagerCpp_localesPtr = _lookup<ffi.NativeFunction<_CArray_CLocale Function(_CPlatformLocaleManagerCpp)>>('CPlatformLocaleManagerCpp_locales');
late final _CPlatformLocaleManagerCpp_locales = _CPlatformLocaleManagerCpp_localesPtr.asFunction<_CArray_CLocale Function(_CPlatformLocaleManagerCpp)>();
late final _CPlatformLocaleManagerCpp_setLocalesChangeNotifier_CLocaleChangeNotifierPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPlatformLocaleManagerCpp, _CLocaleChangeNotifier)>>('CPlatformLocaleManagerCpp_setLocalesChangeNotifier_CLocaleChangeNotifier');
late final _CPlatformLocaleManagerCpp_setLocalesChangeNotifier_CLocaleChangeNotifier = _CPlatformLocaleManagerCpp_setLocalesChangeNotifier_CLocaleChangeNotifierPtr.asFunction<void Function(_CPlatformLocaleManagerCpp, _CLocaleChangeNotifier)>();
late final _CPlatformLocaleManagerCpp_systemLocalesPtr = _lookup<ffi.NativeFunction<_CArray_CLocale Function(_CPlatformLocaleManagerCpp)>>('CPlatformLocaleManagerCpp_systemLocales');
late final _CPlatformLocaleManagerCpp_systemLocales = _CPlatformLocaleManagerCpp_systemLocalesPtr.asFunction<_CArray_CLocale Function(_CPlatformLocaleManagerCpp)>();
late final _CPlatformLocaleManagerCpp_setSystemLocalesChangeNotifier_CLocaleChangeNotifierPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPlatformLocaleManagerCpp, _CLocaleChangeNotifier)>>('CPlatformLocaleManagerCpp_setSystemLocalesChangeNotifier_CLocaleChangeNotifier');
late final _CPlatformLocaleManagerCpp_setSystemLocalesChangeNotifier_CLocaleChangeNotifier = _CPlatformLocaleManagerCpp_setSystemLocalesChangeNotifier_CLocaleChangeNotifierPtr.asFunction<void Function(_CPlatformLocaleManagerCpp, _CLocaleChangeNotifier)>();
late final _CPlatformLocaleManagerCpp_overrideLocales_CArray_CLocalePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPlatformLocaleManagerCpp, _CArray_CLocale)>>('CPlatformLocaleManagerCpp_overrideLocales_CArray_CLocale');
late final _CPlatformLocaleManagerCpp_overrideLocales_CArray_CLocale = _CPlatformLocaleManagerCpp_overrideLocales_CArray_CLocalePtr.asFunction<void Function(_CPlatformLocaleManagerCpp, _CArray_CLocale)>();

late final _CPlatformLocaleManagerCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPlatformLocaleManagerCpp_release');
late final _CPlatformLocaleManagerCpp_release = _CPlatformLocaleManagerCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPlatformLocaleManagerCpp_retainPtr = _lookup<ffi.NativeFunction<_CPlatformLocaleManagerCpp Function(ffi.Pointer<ffi.Void>)>>('CPlatformLocaleManagerCpp_retain');
late final _CPlatformLocaleManagerCpp_retain = _CPlatformLocaleManagerCpp_retainPtr.asFunction<_CPlatformLocaleManagerCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CPlatformLocaleManagerCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPlatformLocaleManagerCpp Function()>>('CPlatformLocaleManagerCppMakeDefault');
late final _CPlatformLocaleManagerCppMakeDefault = _CPlatformLocaleManagerCppMakeDefaultPtr.asFunction<_CPlatformLocaleManagerCpp Function()>();


late final _CPlatformLocaleManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPlatformLocaleManager Function()>>('CPlatformLocaleManagerMakeDefault');
late final _CPlatformLocaleManagerMakeDefault = _CPlatformLocaleManagerMakeDefaultPtr.asFunction<_CPlatformLocaleManager Function()>();
late final _CPlatformLocaleManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPlatformLocaleManager)>>('CPlatformLocaleManager_release');
late final _CPlatformLocaleManager_release = _CPlatformLocaleManager_releasePtr.asFunction<void Function(_CPlatformLocaleManager)>();
late final _CFunction_G_getHttpCacheManager_With_CContextPtr = _lookup<ffi.NativeFunction<_COptional_CHttpCacheManager Function(_CContext)>>('CFunction_G_getHttpCacheManager_With_CContext');
late final _CFunction_G_getHttpCacheManager_With_CContext = _CFunction_G_getHttpCacheManager_With_CContextPtr.asFunction<_COptional_CHttpCacheManager Function(_CContext)>();

late final _COptional_CHttpCacheManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CHttpCacheManager Function()>>('COptional_CHttpCacheManagerMakeDefault');
late final _COptional_CHttpCacheManagerMakeDefault = _COptional_CHttpCacheManagerMakeDefaultPtr.asFunction<_COptional_CHttpCacheManager Function()>();

late final _COptional_CHttpCacheManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CHttpCacheManager)>>('COptional_CHttpCacheManager_release');
late final _COptional_CHttpCacheManager_release = _COptional_CHttpCacheManager_releasePtr.asFunction<void Function(_COptional_CHttpCacheManager)>();
late final _CFunction_G_getLocaleManager_With_CContextPtr = _lookup<ffi.NativeFunction<_CLocaleManager Function(_CContext)>>('CFunction_G_getLocaleManager_With_CContext');
late final _CFunction_G_getLocaleManager_With_CContext = _CFunction_G_getLocaleManager_With_CContextPtr.asFunction<_CLocaleManager Function(_CContext)>();
late final _CFunction_G_toLocaleManager_With_CPlatformLocaleManagerPtr = _lookup<ffi.NativeFunction<_CLocaleManager Function(_CPlatformLocaleManager)>>('CFunction_G_toLocaleManager_With_CPlatformLocaleManager');
late final _CFunction_G_toLocaleManager_With_CPlatformLocaleManager = _CFunction_G_toLocaleManager_With_CPlatformLocaleManagerPtr.asFunction<_CLocaleManager Function(_CPlatformLocaleManager)>();

late final _COptional_CLocaleMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocale Function()>>('COptional_CLocaleMakeDefault');
late final _COptional_CLocaleMakeDefault = _COptional_CLocaleMakeDefaultPtr.asFunction<_COptional_CLocale Function()>();

late final _COptional_CLocale_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CLocale)>>('COptional_CLocale_release');
late final _COptional_CLocale_release = _COptional_CLocale_releasePtr.asFunction<void Function(_COptional_CLocale)>();
late final _CFunction_G_toLocalePosix_With_CLocalePtr = _lookup<ffi.NativeFunction<_CString Function(_CLocale)>>('CFunction_G_toLocalePosix_With_CLocale');
late final _CFunction_G_toLocalePosix_With_CLocale = _CFunction_G_toLocalePosix_With_CLocalePtr.asFunction<_CString Function(_CLocale)>();
late final _CFunction_G_getAudioSettings_With_CContextPtr = _lookup<ffi.NativeFunction<_COptional_CAudioSettings Function(_CContext)>>('CFunction_G_getAudioSettings_With_CContext');
late final _CFunction_G_getAudioSettings_With_CContext = _CFunction_G_getAudioSettings_With_CContextPtr.asFunction<_COptional_CAudioSettings Function(_CContext)>();

late final _CAudioFocusPolicyMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAudioFocusPolicy Function()>>('CAudioFocusPolicyMakeDefault');
late final _CAudioFocusPolicyMakeDefault = _CAudioFocusPolicyMakeDefaultPtr.asFunction<_CAudioFocusPolicy Function()>();
late final _CAudioSettings_volumePtr = _lookup<ffi.NativeFunction<ffi.Uint32 Function(_CAudioSettings)>>('CAudioSettings_volume');
late final _CAudioSettings_volume = _CAudioSettings_volumePtr.asFunction<int Function(_CAudioSettings)>();
late final _CAudioSettings_setVolume_uint32_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAudioSettings, ffi.Uint32)>>('CAudioSettings_setVolume_uint32_t');
late final _CAudioSettings_setVolume_uint32_t = _CAudioSettings_setVolume_uint32_tPtr.asFunction<void Function(_CAudioSettings, int)>();
late final _CAudioSettings_mutePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CAudioSettings)>>('CAudioSettings_mute');
late final _CAudioSettings_mute = _CAudioSettings_mutePtr.asFunction<bool Function(_CAudioSettings)>();
late final _CAudioSettings_setMute_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAudioSettings, ffi.Bool)>>('CAudioSettings_setMute_bool');
late final _CAudioSettings_setMute_bool = _CAudioSettings_setMute_boolPtr.asFunction<void Function(_CAudioSettings, bool)>();
late final _CAudioSettings_audioFocusPolicyPtr = _lookup<ffi.NativeFunction<_CAudioFocusPolicy Function(_CAudioSettings)>>('CAudioSettings_audioFocusPolicy');
late final _CAudioSettings_audioFocusPolicy = _CAudioSettings_audioFocusPolicyPtr.asFunction<_CAudioFocusPolicy Function(_CAudioSettings)>();
late final _CAudioSettings_setAudioFocusPolicy_CAudioFocusPolicyPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAudioSettings, _CAudioFocusPolicy)>>('CAudioSettings_setAudioFocusPolicy_CAudioFocusPolicy');
late final _CAudioSettings_setAudioFocusPolicy_CAudioFocusPolicy = _CAudioSettings_setAudioFocusPolicy_CAudioFocusPolicyPtr.asFunction<void Function(_CAudioSettings, _CAudioFocusPolicy)>();

late final _CAudioSettings_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CAudioSettings_cg_objectIdentifier');
late final _CAudioSettings_cg_objectIdentifier = _CAudioSettings_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CAudioSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CAudioSettings_release');
late final _CAudioSettings_release = _CAudioSettings_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CAudioSettings_retainPtr = _lookup<ffi.NativeFunction<_CAudioSettings Function(ffi.Pointer<ffi.Void>)>>('CAudioSettings_retain');
late final _CAudioSettings_retain = _CAudioSettings_retainPtr.asFunction<_CAudioSettings Function(ffi.Pointer<ffi.Void>)>();
late final _CAudioSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAudioSettings Function()>>('CAudioSettingsMakeDefault');
late final _CAudioSettingsMakeDefault = _CAudioSettingsMakeDefaultPtr.asFunction<_CAudioSettings Function()>();


late final _COptional_CAudioSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CAudioSettings Function()>>('COptional_CAudioSettingsMakeDefault');
late final _COptional_CAudioSettingsMakeDefault = _COptional_CAudioSettingsMakeDefaultPtr.asFunction<_COptional_CAudioSettings Function()>();

late final _COptional_CAudioSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CAudioSettings)>>('COptional_CAudioSettings_release');
late final _COptional_CAudioSettings_release = _COptional_CAudioSettings_releasePtr.asFunction<void Function(_COptional_CAudioSettings)>();

late final _CLocationService_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLocationService_cg_objectIdentifier');
late final _CLocationService_cg_objectIdentifier = _CLocationService_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLocationService_lastLocationPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CLocation Function(_CLocationService)>>('CLocationService_lastLocation');
late final _CLocationService_lastLocation = _CLocationService_lastLocationPtr.asFunction<_CStatefulChannel_COptional_CLocation Function(_CLocationService)>();
late final _CLocationService_onPermissionGrantedPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocationService)>>('CLocationService_onPermissionGranted');
late final _CLocationService_onPermissionGranted = _CLocationService_onPermissionGrantedPtr.asFunction<void Function(_CLocationService)>();
late final _CLocationService_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CLocationService Function(_CContext)>>('CLocationService_C_createWith_CContext');
late final _CLocationService_C_createWith_CContext = _CLocationService_C_createWith_CContextPtr.asFunction<_CLocationService Function(_CContext)>();

late final _CLocationService_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLocationService_release');
late final _CLocationService_release = _CLocationService_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationService_retainPtr = _lookup<ffi.NativeFunction<_CLocationService Function(ffi.Pointer<ffi.Void>)>>('CLocationService_retain');
late final _CLocationService_retain = _CLocationService_retainPtr.asFunction<_CLocationService Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationServiceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationService Function()>>('CLocationServiceMakeDefault');
late final _CLocationServiceMakeDefault = _CLocationServiceMakeDefaultPtr.asFunction<_CLocationService Function()>();


late final _CAddEventErrorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddEventError Function()>>('CAddEventErrorMakeDefault');
late final _CAddEventErrorMakeDefault = _CAddEventErrorMakeDefaultPtr.asFunction<_CAddEventError Function()>();

late final _CAddEventResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAddEventResult)>>('CAddEventResult_release');
late final _CAddEventResult_release = _CAddEventResult_releasePtr.asFunction<void Function(_CAddEventResult)>();
late final _CAddEventResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddEventResult Function()>>('CAddEventResultMakeDefault');
late final _CAddEventResultMakeDefault = _CAddEventResultMakeDefaultPtr.asFunction<_CAddEventResult Function()>();

late final _CRoadEventManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEventManager_cg_objectIdentifier');
late final _CRoadEventManager_cg_objectIdentifier = _CRoadEventManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadEventManager_createAccident_CGeoPoint_COptionSet_CLane_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _COptionSet_CLane, _CString)>>('CRoadEventManager_createAccident_CGeoPoint_COptionSet_CLane_CString');
late final _CRoadEventManager_createAccident_CGeoPoint_COptionSet_CLane_CString = _CRoadEventManager_createAccident_CGeoPoint_COptionSet_CLane_CStringPtr.asFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _COptionSet_CLane, _CString)>();
late final _CRoadEventManager_createCamera_CGeoPoint_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _CString)>>('CRoadEventManager_createCamera_CGeoPoint_CString');
late final _CRoadEventManager_createCamera_CGeoPoint_CString = _CRoadEventManager_createCamera_CGeoPoint_CStringPtr.asFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _CString)>();
late final _CRoadEventManager_createRoadRestriction_CGeoPoint_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _CString)>>('CRoadEventManager_createRoadRestriction_CGeoPoint_CString');
late final _CRoadEventManager_createRoadRestriction_CGeoPoint_CString = _CRoadEventManager_createRoadRestriction_CGeoPoint_CStringPtr.asFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _CString)>();
late final _CRoadEventManager_createComment_CGeoPoint_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _CString)>>('CRoadEventManager_createComment_CGeoPoint_CString');
late final _CRoadEventManager_createComment_CGeoPoint_CString = _CRoadEventManager_createComment_CGeoPoint_CStringPtr.asFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _CString)>();
late final _CRoadEventManager_createOther_CGeoPoint_COptionSet_CLane_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _COptionSet_CLane, _CString)>>('CRoadEventManager_createOther_CGeoPoint_COptionSet_CLane_CString');
late final _CRoadEventManager_createOther_CGeoPoint_COptionSet_CLane_CString = _CRoadEventManager_createOther_CGeoPoint_COptionSet_CLane_CStringPtr.asFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _COptionSet_CLane, _CString)>();
late final _CRoadEventManager_createRoadWorks_CGeoPoint_COptionSet_CLane_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _COptionSet_CLane, _CString)>>('CRoadEventManager_createRoadWorks_CGeoPoint_COptionSet_CLane_CString');
late final _CRoadEventManager_createRoadWorks_CGeoPoint_COptionSet_CLane_CString = _CRoadEventManager_createRoadWorks_CGeoPoint_COptionSet_CLane_CStringPtr.asFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _COptionSet_CLane, _CString)>();
late final _CRoadEventManager_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CRoadEventManager Function(_CContext)>>('CRoadEventManager_C_createWith_CContext');
late final _CRoadEventManager_C_createWith_CContext = _CRoadEventManager_C_createWith_CContextPtr.asFunction<_CRoadEventManager Function(_CContext)>();

late final _CRoadEventManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEventManager_release');
late final _CRoadEventManager_release = _CRoadEventManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventManager_retainPtr = _lookup<ffi.NativeFunction<_CRoadEventManager Function(ffi.Pointer<ffi.Void>)>>('CRoadEventManager_retain');
late final _CRoadEventManager_retain = _CRoadEventManager_retainPtr.asFunction<_CRoadEventManager Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventManager Function()>>('CRoadEventManagerMakeDefault');
late final _CRoadEventManagerMakeDefault = _CRoadEventManagerMakeDefaultPtr.asFunction<_CRoadEventManager Function()>();


late final _CFuture_CAddEventResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function()>>('CFuture_CAddEventResultMakeDefault');
late final _CFuture_CAddEventResultMakeDefault = _CFuture_CAddEventResultMakeDefaultPtr.asFunction<_CFuture_CAddEventResult Function()>();
late final _CFuture_CAddEventResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CAddEventResult)>>('CFuture_CAddEventResult_release');
late final _CFuture_CAddEventResult_release = _CFuture_CAddEventResult_releasePtr.asFunction<void Function(_CFuture_CAddEventResult)>();
late final _CFuture_CAddEventResult_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CFuture_CAddEventResult)>>('CFuture_CAddEventResult_retain');
late final _CFuture_CAddEventResult_retain = _CFuture_CAddEventResult_retainPtr.asFunction<_CFuture_CAddEventResult Function(_CFuture_CAddEventResult)>();
late final _CFuture_CAddEventResultReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CAddEventResult,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAddEventResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CAddEventResult_receive');
late final _CFuture_CAddEventResultReceive = _CFuture_CAddEventResultReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CAddEventResult,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAddEventResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();
late final _CIntRouteAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CIntRouteAttribute)>>('CIntRouteAttribute_size');
late final _CIntRouteAttribute_size = _CIntRouteAttribute_sizePtr.asFunction<int Function(_CIntRouteAttribute)>();
late final _CIntRouteAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CIntRouteAttribute)>>('CIntRouteAttribute_isEmpty');
late final _CIntRouteAttribute_isEmpty = _CIntRouteAttribute_isEmptyPtr.asFunction<bool Function(_CIntRouteAttribute)>();
late final _CIntRouteAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CIntRouteEntry Function(_CIntRouteAttribute)>>('CIntRouteAttribute_first');
late final _CIntRouteAttribute_first = _CIntRouteAttribute_firstPtr.asFunction<_COptional_CIntRouteEntry Function(_CIntRouteAttribute)>();
late final _CIntRouteAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CIntRouteEntry Function(_CIntRouteAttribute)>>('CIntRouteAttribute_last');
late final _CIntRouteAttribute_last = _CIntRouteAttribute_lastPtr.asFunction<_COptional_CIntRouteEntry Function(_CIntRouteAttribute)>();
late final _CIntRouteAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CIntRouteEntry Function(_CIntRouteAttribute)>>('CIntRouteAttribute_entries');
late final _CIntRouteAttribute_entries = _CIntRouteAttribute_entriesPtr.asFunction<_CArray_CIntRouteEntry Function(_CIntRouteAttribute)>();

late final _CIntRouteAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CIntRouteAttribute_cg_objectIdentifier');
late final _CIntRouteAttribute_cg_objectIdentifier = _CIntRouteAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CIntRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CIntRouteEntry Function(_CIntRouteAttribute, _CRoutePoint, _CRoutePoint)>>('CIntRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CIntRouteAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CIntRouteAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CIntRouteEntry Function(_CIntRouteAttribute, _CRoutePoint, _CRoutePoint)>();
late final _CIntRouteAttribute_findNearBackward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CIntRouteEntry Function(_CIntRouteAttribute, _CRoutePoint)>>('CIntRouteAttribute_findNearBackward_CRoutePoint');
late final _CIntRouteAttribute_findNearBackward_CRoutePoint = _CIntRouteAttribute_findNearBackward_CRoutePointPtr.asFunction<_COptional_CIntRouteEntry Function(_CIntRouteAttribute, _CRoutePoint)>();
late final _CIntRouteAttribute_findNearForward_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CIntRouteEntry Function(_CIntRouteAttribute, _CRoutePoint)>>('CIntRouteAttribute_findNearForward_CRoutePoint');
late final _CIntRouteAttribute_findNearForward_CRoutePoint = _CIntRouteAttribute_findNearForward_CRoutePointPtr.asFunction<_COptional_CIntRouteEntry Function(_CIntRouteAttribute, _CRoutePoint)>();

late final _CIntRouteAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CIntRouteAttribute_release');
late final _CIntRouteAttribute_release = _CIntRouteAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CIntRouteAttribute_retainPtr = _lookup<ffi.NativeFunction<_CIntRouteAttribute Function(ffi.Pointer<ffi.Void>)>>('CIntRouteAttribute_retain');
late final _CIntRouteAttribute_retain = _CIntRouteAttribute_retainPtr.asFunction<_CIntRouteAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CIntRouteAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIntRouteAttribute Function()>>('CIntRouteAttributeMakeDefault');
late final _CIntRouteAttributeMakeDefault = _CIntRouteAttributeMakeDefaultPtr.asFunction<_CIntRouteAttribute Function()>();


late final _CIntRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIntRouteEntry Function()>>('CIntRouteEntryMakeDefault');
late final _CIntRouteEntryMakeDefault = _CIntRouteEntryMakeDefaultPtr.asFunction<_CIntRouteEntry Function()>();


late final _COptional_CIntRouteEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CIntRouteEntry Function()>>('COptional_CIntRouteEntryMakeDefault');
late final _COptional_CIntRouteEntryMakeDefault = _COptional_CIntRouteEntryMakeDefaultPtr.asFunction<_COptional_CIntRouteEntry Function()>();

late final _CArray_CIntRouteEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CIntRouteEntry Function()>>('CArray_CIntRouteEntry_makeEmpty');
late final _CArray_CIntRouteEntrymakeEmpty = _CArray_CIntRouteEntrymakeEmptyPtr.asFunction<_CArray_CIntRouteEntry Function()>();
late final _CArray_CIntRouteEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CIntRouteEntry, _CIntRouteEntry)>>('CArray_CIntRouteEntry_addElement');
late final _CArray_CIntRouteEntryaddElement = _CArray_CIntRouteEntryaddElementPtr.asFunction<void Function(_CArray_CIntRouteEntry, _CIntRouteEntry)>();
late final _forEach_CArray_CIntRouteEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CIntRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CIntRouteEntry)>>)
>>('CArray_CIntRouteEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CIntRouteEntry = _forEach_CArray_CIntRouteEntryPtr.asFunction<
  void Function(_CArray_CIntRouteEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CIntRouteEntry)
>>)>();
late final _CArray_CIntRouteEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CIntRouteEntry)>>('CArray_CIntRouteEntry_release');
late final _CArray_CIntRouteEntry_release = _CArray_CIntRouteEntry_releasePtr.asFunction<void Function(_CArray_CIntRouteEntry)>();
late final _CObstacleInfoRouteLongAttribute_sizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CObstacleInfoRouteLongAttribute)>>('CObstacleInfoRouteLongAttribute_size');
late final _CObstacleInfoRouteLongAttribute_size = _CObstacleInfoRouteLongAttribute_sizePtr.asFunction<int Function(_CObstacleInfoRouteLongAttribute)>();
late final _CObstacleInfoRouteLongAttribute_isEmptyPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CObstacleInfoRouteLongAttribute)>>('CObstacleInfoRouteLongAttribute_isEmpty');
late final _CObstacleInfoRouteLongAttribute_isEmpty = _CObstacleInfoRouteLongAttribute_isEmptyPtr.asFunction<bool Function(_CObstacleInfoRouteLongAttribute)>();
late final _CObstacleInfoRouteLongAttribute_firstPtr = _lookup<ffi.NativeFunction<_COptional_CObstacleInfoRouteLongEntry Function(_CObstacleInfoRouteLongAttribute)>>('CObstacleInfoRouteLongAttribute_first');
late final _CObstacleInfoRouteLongAttribute_first = _CObstacleInfoRouteLongAttribute_firstPtr.asFunction<_COptional_CObstacleInfoRouteLongEntry Function(_CObstacleInfoRouteLongAttribute)>();
late final _CObstacleInfoRouteLongAttribute_lastPtr = _lookup<ffi.NativeFunction<_COptional_CObstacleInfoRouteLongEntry Function(_CObstacleInfoRouteLongAttribute)>>('CObstacleInfoRouteLongAttribute_last');
late final _CObstacleInfoRouteLongAttribute_last = _CObstacleInfoRouteLongAttribute_lastPtr.asFunction<_COptional_CObstacleInfoRouteLongEntry Function(_CObstacleInfoRouteLongAttribute)>();
late final _CObstacleInfoRouteLongAttribute_entriesPtr = _lookup<ffi.NativeFunction<_CArray_CObstacleInfoRouteLongEntry Function(_CObstacleInfoRouteLongAttribute)>>('CObstacleInfoRouteLongAttribute_entries');
late final _CObstacleInfoRouteLongAttribute_entries = _CObstacleInfoRouteLongAttribute_entriesPtr.asFunction<_CArray_CObstacleInfoRouteLongEntry Function(_CObstacleInfoRouteLongAttribute)>();

late final _CObstacleInfoRouteLongAttribute_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CObstacleInfoRouteLongAttribute_cg_objectIdentifier');
late final _CObstacleInfoRouteLongAttribute_cg_objectIdentifier = _CObstacleInfoRouteLongAttribute_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CObstacleInfoRouteLongAttribute_entry_CRoutePointPtr = _lookup<ffi.NativeFunction<_COptional_CObstacleInfoRouteLongEntry Function(_CObstacleInfoRouteLongAttribute, _CRoutePoint)>>('CObstacleInfoRouteLongAttribute_entry_CRoutePoint');
late final _CObstacleInfoRouteLongAttribute_entry_CRoutePoint = _CObstacleInfoRouteLongAttribute_entry_CRoutePointPtr.asFunction<_COptional_CObstacleInfoRouteLongEntry Function(_CObstacleInfoRouteLongAttribute, _CRoutePoint)>();
late final _CObstacleInfoRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr = _lookup<ffi.NativeFunction<_CArray_CObstacleInfoRouteLongEntry Function(_CObstacleInfoRouteLongAttribute, _CRoutePoint, _CRoutePoint)>>('CObstacleInfoRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint');
late final _CObstacleInfoRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePoint = _CObstacleInfoRouteLongAttribute_entriesInRange_CRoutePoint_CRoutePointPtr.asFunction<_CArray_CObstacleInfoRouteLongEntry Function(_CObstacleInfoRouteLongAttribute, _CRoutePoint, _CRoutePoint)>();

late final _CObstacleInfoRouteLongAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CObstacleInfoRouteLongAttribute_release');
late final _CObstacleInfoRouteLongAttribute_release = _CObstacleInfoRouteLongAttribute_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CObstacleInfoRouteLongAttribute_retainPtr = _lookup<ffi.NativeFunction<_CObstacleInfoRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>>('CObstacleInfoRouteLongAttribute_retain');
late final _CObstacleInfoRouteLongAttribute_retain = _CObstacleInfoRouteLongAttribute_retainPtr.asFunction<_CObstacleInfoRouteLongAttribute Function(ffi.Pointer<ffi.Void>)>();
late final _CObstacleInfoRouteLongAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CObstacleInfoRouteLongAttribute Function()>>('CObstacleInfoRouteLongAttributeMakeDefault');
late final _CObstacleInfoRouteLongAttributeMakeDefault = _CObstacleInfoRouteLongAttributeMakeDefaultPtr.asFunction<_CObstacleInfoRouteLongAttribute Function()>();


late final _CObstacleInfoRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CObstacleInfoRouteLongEntry Function()>>('CObstacleInfoRouteLongEntryMakeDefault');
late final _CObstacleInfoRouteLongEntryMakeDefault = _CObstacleInfoRouteLongEntryMakeDefaultPtr.asFunction<_CObstacleInfoRouteLongEntry Function()>();


late final _COptional_CObstacleInfoRouteLongEntryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CObstacleInfoRouteLongEntry Function()>>('COptional_CObstacleInfoRouteLongEntryMakeDefault');
late final _COptional_CObstacleInfoRouteLongEntryMakeDefault = _COptional_CObstacleInfoRouteLongEntryMakeDefaultPtr.asFunction<_COptional_CObstacleInfoRouteLongEntry Function()>();

late final _CArray_CObstacleInfoRouteLongEntrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CObstacleInfoRouteLongEntry Function()>>('CArray_CObstacleInfoRouteLongEntry_makeEmpty');
late final _CArray_CObstacleInfoRouteLongEntrymakeEmpty = _CArray_CObstacleInfoRouteLongEntrymakeEmptyPtr.asFunction<_CArray_CObstacleInfoRouteLongEntry Function()>();
late final _CArray_CObstacleInfoRouteLongEntryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CObstacleInfoRouteLongEntry, _CObstacleInfoRouteLongEntry)>>('CArray_CObstacleInfoRouteLongEntry_addElement');
late final _CArray_CObstacleInfoRouteLongEntryaddElement = _CArray_CObstacleInfoRouteLongEntryaddElementPtr.asFunction<void Function(_CArray_CObstacleInfoRouteLongEntry, _CObstacleInfoRouteLongEntry)>();
late final _forEach_CArray_CObstacleInfoRouteLongEntryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CObstacleInfoRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CObstacleInfoRouteLongEntry)>>)
>>('CArray_CObstacleInfoRouteLongEntry_forEachWithFunctionPointer');
late final _forEach_CArray_CObstacleInfoRouteLongEntry = _forEach_CArray_CObstacleInfoRouteLongEntryPtr.asFunction<
  void Function(_CArray_CObstacleInfoRouteLongEntry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CObstacleInfoRouteLongEntry)
>>)>();
late final _CArray_CObstacleInfoRouteLongEntry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CObstacleInfoRouteLongEntry)>>('CArray_CObstacleInfoRouteLongEntry_release');
late final _CArray_CObstacleInfoRouteLongEntry_release = _CArray_CObstacleInfoRouteLongEntry_releasePtr.asFunction<void Function(_CArray_CObstacleInfoRouteLongEntry)>();

late final _CBicycleBriefRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBicycleBriefRouteInfo Function()>>('CBicycleBriefRouteInfoMakeDefault');
late final _CBicycleBriefRouteInfoMakeDefault = _CBicycleBriefRouteInfoMakeDefaultPtr.asFunction<_CBicycleBriefRouteInfo Function()>();


late final _CCarBriefRouteInfoTrafficSpeedMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCarBriefRouteInfoTrafficSpeed Function()>>('CCarBriefRouteInfoTrafficSpeedMakeDefault');
late final _CCarBriefRouteInfoTrafficSpeedMakeDefault = _CCarBriefRouteInfoTrafficSpeedMakeDefaultPtr.asFunction<_CCarBriefRouteInfoTrafficSpeed Function()>();

late final _CCarBriefRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCarBriefRouteInfo Function()>>('CCarBriefRouteInfoMakeDefault');
late final _CCarBriefRouteInfoMakeDefault = _CCarBriefRouteInfoMakeDefaultPtr.asFunction<_CCarBriefRouteInfo Function()>();


late final _CPedestrianBriefRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPedestrianBriefRouteInfo Function()>>('CPedestrianBriefRouteInfoMakeDefault');
late final _CPedestrianBriefRouteInfoMakeDefault = _CPedestrianBriefRouteInfoMakeDefaultPtr.asFunction<_CPedestrianBriefRouteInfo Function()>();


late final _CPublicBriefRouteTransportInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPublicBriefRouteTransportInfo Function()>>('CPublicBriefRouteTransportInfoMakeDefault');
late final _CPublicBriefRouteTransportInfoMakeDefault = _CPublicBriefRouteTransportInfoMakeDefaultPtr.asFunction<_CPublicBriefRouteTransportInfo Function()>();


late final _CArray_CPublicBriefRouteTransportInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CPublicBriefRouteTransportInfo Function()>>('CArray_CPublicBriefRouteTransportInfo_makeEmpty');
late final _CArray_CPublicBriefRouteTransportInfomakeEmpty = _CArray_CPublicBriefRouteTransportInfomakeEmptyPtr.asFunction<_CArray_CPublicBriefRouteTransportInfo Function()>();
late final _CArray_CPublicBriefRouteTransportInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPublicBriefRouteTransportInfo, _CPublicBriefRouteTransportInfo)>>('CArray_CPublicBriefRouteTransportInfo_addElement');
late final _CArray_CPublicBriefRouteTransportInfoaddElement = _CArray_CPublicBriefRouteTransportInfoaddElementPtr.asFunction<void Function(_CArray_CPublicBriefRouteTransportInfo, _CPublicBriefRouteTransportInfo)>();
late final _forEach_CArray_CPublicBriefRouteTransportInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CPublicBriefRouteTransportInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPublicBriefRouteTransportInfo)>>)
>>('CArray_CPublicBriefRouteTransportInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CPublicBriefRouteTransportInfo = _forEach_CArray_CPublicBriefRouteTransportInfoPtr.asFunction<
  void Function(_CArray_CPublicBriefRouteTransportInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPublicBriefRouteTransportInfo)
>>)>();
late final _CArray_CPublicBriefRouteTransportInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPublicBriefRouteTransportInfo)>>('CArray_CPublicBriefRouteTransportInfo_release');
late final _CArray_CPublicBriefRouteTransportInfo_release = _CArray_CPublicBriefRouteTransportInfo_releasePtr.asFunction<void Function(_CArray_CPublicBriefRouteTransportInfo)>();

late final _CPublicBriefRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPublicBriefRouteInfo Function()>>('CPublicBriefRouteInfoMakeDefault');
late final _CPublicBriefRouteInfoMakeDefault = _CPublicBriefRouteInfoMakeDefaultPtr.asFunction<_CPublicBriefRouteInfo Function()>();


late final _CScooterBriefRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScooterBriefRouteInfo Function()>>('CScooterBriefRouteInfoMakeDefault');
late final _CScooterBriefRouteInfoMakeDefault = _CScooterBriefRouteInfoMakeDefaultPtr.asFunction<_CScooterBriefRouteInfo Function()>();


late final _CBriefExtraRouteInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CBriefExtraRouteInfo)>>('CBriefExtraRouteInfo_release');
late final _CBriefExtraRouteInfo_release = _CBriefExtraRouteInfo_releasePtr.asFunction<void Function(_CBriefExtraRouteInfo)>();
late final _CBriefExtraRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBriefExtraRouteInfo Function()>>('CBriefExtraRouteInfoMakeDefault');
late final _CBriefExtraRouteInfoMakeDefault = _CBriefExtraRouteInfoMakeDefaultPtr.asFunction<_CBriefExtraRouteInfo Function()>();

late final _CBriefRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBriefRouteInfo Function()>>('CBriefRouteInfoMakeDefault');
late final _CBriefRouteInfoMakeDefault = _CBriefRouteInfoMakeDefaultPtr.asFunction<_CBriefRouteInfo Function()>();


late final _CBriefRouteInfoSearchPointsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBriefRouteInfoSearchPoints Function()>>('CBriefRouteInfoSearchPointsMakeDefault');
late final _CBriefRouteInfoSearchPointsMakeDefault = _CBriefRouteInfoSearchPointsMakeDefaultPtr.asFunction<_CBriefRouteInfoSearchPoints Function()>();


late final _CSet_CTruckPassZoneIdmakeEmptyPtr = _lookup<ffi.NativeFunction<_CSet_CTruckPassZoneId Function()>>('CSet_CTruckPassZoneId_makeEmpty');
late final _CSet_CTruckPassZoneIdmakeEmpty = _CSet_CTruckPassZoneIdmakeEmptyPtr.asFunction<_CSet_CTruckPassZoneId Function()>();
late final _CSet_CTruckPassZoneIdaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSet_CTruckPassZoneId, _CTruckPassZoneId)>>('CSet_CTruckPassZoneId_addElement');
late final _CSet_CTruckPassZoneIdaddElement = _CSet_CTruckPassZoneIdaddElementPtr.asFunction<void Function(_CSet_CTruckPassZoneId, _CTruckPassZoneId)>();
late final _forEach_CSet_CTruckPassZoneIdPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CSet_CTruckPassZoneId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTruckPassZoneId)>>)
>>('CSet_CTruckPassZoneId_forEachWithFunctionPointer');
late final _forEach_CSet_CTruckPassZoneId = _forEach_CSet_CTruckPassZoneIdPtr.asFunction<
  void Function(_CSet_CTruckPassZoneId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTruckPassZoneId)
>>)>();
late final _CSet_CTruckPassZoneId_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSet_CTruckPassZoneId)>>('CSet_CTruckPassZoneId_release');
late final _CSet_CTruckPassZoneId_release = _CSet_CTruckPassZoneId_releasePtr.asFunction<void Function(_CSet_CTruckPassZoneId)>();

late final _CTruckPassZonePassMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTruckPassZonePass Function()>>('CTruckPassZonePassMakeDefault');
late final _CTruckPassZonePassMakeDefault = _CTruckPassZonePassMakeDefaultPtr.asFunction<_CTruckPassZonePass Function()>();

late final _CTrafficRouter_truckPassZonePassesPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CTruckPassZonePass Function(_CTrafficRouter)>>('CTrafficRouter_truckPassZonePasses');
late final _CTrafficRouter_truckPassZonePasses = _CTrafficRouter_truckPassZonePassesPtr.asFunction<_CFuture_CArray_CTruckPassZonePass Function(_CTrafficRouter)>();

late final _CTrafficRouter_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTrafficRouter_cg_objectIdentifier');
late final _CTrafficRouter_cg_objectIdentifier = _CTrafficRouter_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTrafficRouter_findRoute_CRouteSearchPoint_CRouteSearchPoint_CRouteSearchOptions_CArray_CRouteSearchPointPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CTrafficRoute Function(_CTrafficRouter, _CRouteSearchPoint, _CRouteSearchPoint, _CRouteSearchOptions, _CArray_CRouteSearchPoint)>>('CTrafficRouter_findRoute_CRouteSearchPoint_CRouteSearchPoint_CRouteSearchOptions_CArray_CRouteSearchPoint');
late final _CTrafficRouter_findRoute_CRouteSearchPoint_CRouteSearchPoint_CRouteSearchOptions_CArray_CRouteSearchPoint = _CTrafficRouter_findRoute_CRouteSearchPoint_CRouteSearchPoint_CRouteSearchOptions_CArray_CRouteSearchPointPtr.asFunction<_CFuture_CArray_CTrafficRoute Function(_CTrafficRouter, _CRouteSearchPoint, _CRouteSearchPoint, _CRouteSearchOptions, _CArray_CRouteSearchPoint)>();
late final _CTrafficRouter_requestRoute_CData_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CTrafficRoute Function(_CTrafficRouter, _CData, _CString)>>('CTrafficRouter_requestRoute_CData_CString');
late final _CTrafficRouter_requestRoute_CData_CString = _CTrafficRouter_requestRoute_CData_CStringPtr.asFunction<_CFuture_CArray_CTrafficRoute Function(_CTrafficRouter, _CData, _CString)>();
late final _CTrafficRouter_findBriefRouteInfos_CArray_CBriefRouteInfoSearchPoints_CRouteSearchOptionsPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_COptional_CBriefRouteInfo Function(_CTrafficRouter, _CArray_CBriefRouteInfoSearchPoints, _CRouteSearchOptions)>>('CTrafficRouter_findBriefRouteInfos_CArray_CBriefRouteInfoSearchPoints_CRouteSearchOptions');
late final _CTrafficRouter_findBriefRouteInfos_CArray_CBriefRouteInfoSearchPoints_CRouteSearchOptions = _CTrafficRouter_findBriefRouteInfos_CArray_CBriefRouteInfoSearchPoints_CRouteSearchOptionsPtr.asFunction<_CFuture_CArray_COptional_CBriefRouteInfo Function(_CTrafficRouter, _CArray_CBriefRouteInfoSearchPoints, _CRouteSearchOptions)>();
late final _CTrafficRouter_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CTrafficRouter Function(_CContext)>>('CTrafficRouter_C_createWith_CContext');
late final _CTrafficRouter_C_createWith_CContext = _CTrafficRouter_C_createWith_CContextPtr.asFunction<_CTrafficRouter Function(_CContext)>();

late final _CTrafficRouter_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTrafficRouter_release');
late final _CTrafficRouter_release = _CTrafficRouter_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficRouter_retainPtr = _lookup<ffi.NativeFunction<_CTrafficRouter Function(ffi.Pointer<ffi.Void>)>>('CTrafficRouter_retain');
late final _CTrafficRouter_retain = _CTrafficRouter_retainPtr.asFunction<_CTrafficRouter Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficRouterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficRouter Function()>>('CTrafficRouterMakeDefault');
late final _CTrafficRouterMakeDefault = _CTrafficRouterMakeDefaultPtr.asFunction<_CTrafficRouter Function()>();


late final _CFuture_CArray_CTrafficRouteMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CTrafficRoute Function()>>('CFuture_CArray_CTrafficRouteMakeDefault');
late final _CFuture_CArray_CTrafficRouteMakeDefault = _CFuture_CArray_CTrafficRouteMakeDefaultPtr.asFunction<_CFuture_CArray_CTrafficRoute Function()>();
late final _CFuture_CArray_CTrafficRoute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CTrafficRoute)>>('CFuture_CArray_CTrafficRoute_release');
late final _CFuture_CArray_CTrafficRoute_release = _CFuture_CArray_CTrafficRoute_releasePtr.asFunction<void Function(_CFuture_CArray_CTrafficRoute)>();
late final _CFuture_CArray_CTrafficRoute_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CTrafficRoute Function(_CFuture_CArray_CTrafficRoute)>>('CFuture_CArray_CTrafficRoute_retain');
late final _CFuture_CArray_CTrafficRoute_retain = _CFuture_CArray_CTrafficRoute_retainPtr.asFunction<_CFuture_CArray_CTrafficRoute Function(_CFuture_CArray_CTrafficRoute)>();
late final _CFuture_CArray_CTrafficRouteReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CArray_CTrafficRoute,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CTrafficRoute, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CArray_CTrafficRoute_receive');
late final _CFuture_CArray_CTrafficRouteReceive = _CFuture_CArray_CTrafficRouteReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CArray_CTrafficRoute,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CTrafficRoute, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CFuture_CArray_CTruckPassZonePassMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CTruckPassZonePass Function()>>('CFuture_CArray_CTruckPassZonePassMakeDefault');
late final _CFuture_CArray_CTruckPassZonePassMakeDefault = _CFuture_CArray_CTruckPassZonePassMakeDefaultPtr.asFunction<_CFuture_CArray_CTruckPassZonePass Function()>();
late final _CFuture_CArray_CTruckPassZonePass_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CTruckPassZonePass)>>('CFuture_CArray_CTruckPassZonePass_release');
late final _CFuture_CArray_CTruckPassZonePass_release = _CFuture_CArray_CTruckPassZonePass_releasePtr.asFunction<void Function(_CFuture_CArray_CTruckPassZonePass)>();
late final _CFuture_CArray_CTruckPassZonePass_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CTruckPassZonePass Function(_CFuture_CArray_CTruckPassZonePass)>>('CFuture_CArray_CTruckPassZonePass_retain');
late final _CFuture_CArray_CTruckPassZonePass_retain = _CFuture_CArray_CTruckPassZonePass_retainPtr.asFunction<_CFuture_CArray_CTruckPassZonePass Function(_CFuture_CArray_CTruckPassZonePass)>();
late final _CFuture_CArray_CTruckPassZonePassReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CArray_CTruckPassZonePass,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CTruckPassZonePass, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CArray_CTruckPassZonePass_receive');
late final _CFuture_CArray_CTruckPassZonePassReceive = _CFuture_CArray_CTruckPassZonePassReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CArray_CTruckPassZonePass,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CTruckPassZonePass, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CArray_CTruckPassZonePassmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CTruckPassZonePass Function()>>('CArray_CTruckPassZonePass_makeEmpty');
late final _CArray_CTruckPassZonePassmakeEmpty = _CArray_CTruckPassZonePassmakeEmptyPtr.asFunction<_CArray_CTruckPassZonePass Function()>();
late final _CArray_CTruckPassZonePassaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CTruckPassZonePass, _CTruckPassZonePass)>>('CArray_CTruckPassZonePass_addElement');
late final _CArray_CTruckPassZonePassaddElement = _CArray_CTruckPassZonePassaddElementPtr.asFunction<void Function(_CArray_CTruckPassZonePass, _CTruckPassZonePass)>();
late final _forEach_CArray_CTruckPassZonePassPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CTruckPassZonePass, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTruckPassZonePass)>>)
>>('CArray_CTruckPassZonePass_forEachWithFunctionPointer');
late final _forEach_CArray_CTruckPassZonePass = _forEach_CArray_CTruckPassZonePassPtr.asFunction<
  void Function(_CArray_CTruckPassZonePass, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTruckPassZonePass)
>>)>();
late final _CArray_CTruckPassZonePass_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CTruckPassZonePass)>>('CArray_CTruckPassZonePass_release');
late final _CArray_CTruckPassZonePass_release = _CArray_CTruckPassZonePass_releasePtr.asFunction<void Function(_CArray_CTruckPassZonePass)>();

late final _CFuture_CArray_COptional_CBriefRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_COptional_CBriefRouteInfo Function()>>('CFuture_CArray_COptional_CBriefRouteInfoMakeDefault');
late final _CFuture_CArray_COptional_CBriefRouteInfoMakeDefault = _CFuture_CArray_COptional_CBriefRouteInfoMakeDefaultPtr.asFunction<_CFuture_CArray_COptional_CBriefRouteInfo Function()>();
late final _CFuture_CArray_COptional_CBriefRouteInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_COptional_CBriefRouteInfo)>>('CFuture_CArray_COptional_CBriefRouteInfo_release');
late final _CFuture_CArray_COptional_CBriefRouteInfo_release = _CFuture_CArray_COptional_CBriefRouteInfo_releasePtr.asFunction<void Function(_CFuture_CArray_COptional_CBriefRouteInfo)>();
late final _CFuture_CArray_COptional_CBriefRouteInfo_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_COptional_CBriefRouteInfo Function(_CFuture_CArray_COptional_CBriefRouteInfo)>>('CFuture_CArray_COptional_CBriefRouteInfo_retain');
late final _CFuture_CArray_COptional_CBriefRouteInfo_retain = _CFuture_CArray_COptional_CBriefRouteInfo_retainPtr.asFunction<_CFuture_CArray_COptional_CBriefRouteInfo Function(_CFuture_CArray_COptional_CBriefRouteInfo)>();
late final _CFuture_CArray_COptional_CBriefRouteInfoReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CArray_COptional_CBriefRouteInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_COptional_CBriefRouteInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CArray_COptional_CBriefRouteInfo_receive');
late final _CFuture_CArray_COptional_CBriefRouteInfoReceive = _CFuture_CArray_COptional_CBriefRouteInfoReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CArray_COptional_CBriefRouteInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_COptional_CBriefRouteInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CArray_COptional_CBriefRouteInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_COptional_CBriefRouteInfo Function()>>('CArray_COptional_CBriefRouteInfo_makeEmpty');
late final _CArray_COptional_CBriefRouteInfomakeEmpty = _CArray_COptional_CBriefRouteInfomakeEmptyPtr.asFunction<_CArray_COptional_CBriefRouteInfo Function()>();
late final _CArray_COptional_CBriefRouteInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_COptional_CBriefRouteInfo, _COptional_CBriefRouteInfo)>>('CArray_COptional_CBriefRouteInfo_addElement');
late final _CArray_COptional_CBriefRouteInfoaddElement = _CArray_COptional_CBriefRouteInfoaddElementPtr.asFunction<void Function(_CArray_COptional_CBriefRouteInfo, _COptional_CBriefRouteInfo)>();
late final _forEach_CArray_COptional_CBriefRouteInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_COptional_CBriefRouteInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CBriefRouteInfo)>>)
>>('CArray_COptional_CBriefRouteInfo_forEachWithFunctionPointer');
late final _forEach_CArray_COptional_CBriefRouteInfo = _forEach_CArray_COptional_CBriefRouteInfoPtr.asFunction<
  void Function(_CArray_COptional_CBriefRouteInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CBriefRouteInfo)
>>)>();
late final _CArray_COptional_CBriefRouteInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_COptional_CBriefRouteInfo)>>('CArray_COptional_CBriefRouteInfo_release');
late final _CArray_COptional_CBriefRouteInfo_release = _CArray_COptional_CBriefRouteInfo_releasePtr.asFunction<void Function(_CArray_COptional_CBriefRouteInfo)>();

late final _COptional_CBriefRouteInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CBriefRouteInfo Function()>>('COptional_CBriefRouteInfoMakeDefault');
late final _COptional_CBriefRouteInfoMakeDefault = _COptional_CBriefRouteInfoMakeDefaultPtr.asFunction<_COptional_CBriefRouteInfo Function()>();

late final _COptional_CBriefRouteInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CBriefRouteInfo)>>('COptional_CBriefRouteInfo_release');
late final _COptional_CBriefRouteInfo_release = _COptional_CBriefRouteInfo_releasePtr.asFunction<void Function(_COptional_CBriefRouteInfo)>();

late final _CArray_CBriefRouteInfoSearchPointsmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CBriefRouteInfoSearchPoints Function()>>('CArray_CBriefRouteInfoSearchPoints_makeEmpty');
late final _CArray_CBriefRouteInfoSearchPointsmakeEmpty = _CArray_CBriefRouteInfoSearchPointsmakeEmptyPtr.asFunction<_CArray_CBriefRouteInfoSearchPoints Function()>();
late final _CArray_CBriefRouteInfoSearchPointsaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CBriefRouteInfoSearchPoints, _CBriefRouteInfoSearchPoints)>>('CArray_CBriefRouteInfoSearchPoints_addElement');
late final _CArray_CBriefRouteInfoSearchPointsaddElement = _CArray_CBriefRouteInfoSearchPointsaddElementPtr.asFunction<void Function(_CArray_CBriefRouteInfoSearchPoints, _CBriefRouteInfoSearchPoints)>();
late final _forEach_CArray_CBriefRouteInfoSearchPointsPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CBriefRouteInfoSearchPoints, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CBriefRouteInfoSearchPoints)>>)
>>('CArray_CBriefRouteInfoSearchPoints_forEachWithFunctionPointer');
late final _forEach_CArray_CBriefRouteInfoSearchPoints = _forEach_CArray_CBriefRouteInfoSearchPointsPtr.asFunction<
  void Function(_CArray_CBriefRouteInfoSearchPoints, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CBriefRouteInfoSearchPoints)
>>)>();
late final _CArray_CBriefRouteInfoSearchPoints_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CBriefRouteInfoSearchPoints)>>('CArray_CBriefRouteInfoSearchPoints_release');
late final _CArray_CBriefRouteInfoSearchPoints_release = _CArray_CBriefRouteInfoSearchPoints_releasePtr.asFunction<void Function(_CArray_CBriefRouteInfoSearchPoints)>();

late final _CTerritoriesAlongRouteProvider_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTerritoriesAlongRouteProvider_cg_objectIdentifier');
late final _CTerritoriesAlongRouteProvider_cg_objectIdentifier = _CTerritoriesAlongRouteProvider_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTerritoriesAlongRouteProvider_getTerritories_CRoutePtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CTerritory Function(_CTerritoriesAlongRouteProvider, _CRoute)>>('CTerritoriesAlongRouteProvider_getTerritories_CRoute');
late final _CTerritoriesAlongRouteProvider_getTerritories_CRoute = _CTerritoriesAlongRouteProvider_getTerritories_CRoutePtr.asFunction<_CFuture_CArray_CTerritory Function(_CTerritoriesAlongRouteProvider, _CRoute)>();

late final _CTerritoriesAlongRouteProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTerritoriesAlongRouteProvider_release');
late final _CTerritoriesAlongRouteProvider_release = _CTerritoriesAlongRouteProvider_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTerritoriesAlongRouteProvider_retainPtr = _lookup<ffi.NativeFunction<_CTerritoriesAlongRouteProvider Function(ffi.Pointer<ffi.Void>)>>('CTerritoriesAlongRouteProvider_retain');
late final _CTerritoriesAlongRouteProvider_retain = _CTerritoriesAlongRouteProvider_retainPtr.asFunction<_CTerritoriesAlongRouteProvider Function(ffi.Pointer<ffi.Void>)>();
late final _CTerritoriesAlongRouteProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTerritoriesAlongRouteProvider Function()>>('CTerritoriesAlongRouteProviderMakeDefault');
late final _CTerritoriesAlongRouteProviderMakeDefault = _CTerritoriesAlongRouteProviderMakeDefaultPtr.asFunction<_CTerritoriesAlongRouteProvider Function()>();


late final _CFuture_CArray_CTerritoryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CTerritory Function()>>('CFuture_CArray_CTerritoryMakeDefault');
late final _CFuture_CArray_CTerritoryMakeDefault = _CFuture_CArray_CTerritoryMakeDefaultPtr.asFunction<_CFuture_CArray_CTerritory Function()>();
late final _CFuture_CArray_CTerritory_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CTerritory)>>('CFuture_CArray_CTerritory_release');
late final _CFuture_CArray_CTerritory_release = _CFuture_CArray_CTerritory_releasePtr.asFunction<void Function(_CFuture_CArray_CTerritory)>();
late final _CFuture_CArray_CTerritory_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CTerritory Function(_CFuture_CArray_CTerritory)>>('CFuture_CArray_CTerritory_retain');
late final _CFuture_CArray_CTerritory_retain = _CFuture_CArray_CTerritory_retainPtr.asFunction<_CFuture_CArray_CTerritory Function(_CFuture_CArray_CTerritory)>();
late final _CFuture_CArray_CTerritoryReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CArray_CTerritory,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CTerritory, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CArray_CTerritory_receive');
late final _CFuture_CArray_CTerritoryReceive = _CFuture_CArray_CTerritoryReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CArray_CTerritory,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CTerritory, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CArray_CTerritorymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CTerritory Function()>>('CArray_CTerritory_makeEmpty');
late final _CArray_CTerritorymakeEmpty = _CArray_CTerritorymakeEmptyPtr.asFunction<_CArray_CTerritory Function()>();
late final _CArray_CTerritoryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CTerritory, _CTerritory)>>('CArray_CTerritory_addElement');
late final _CArray_CTerritoryaddElement = _CArray_CTerritoryaddElementPtr.asFunction<void Function(_CArray_CTerritory, _CTerritory)>();
late final _forEach_CArray_CTerritoryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CTerritory, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTerritory)>>)
>>('CArray_CTerritory_forEachWithFunctionPointer');
late final _forEach_CArray_CTerritory = _forEach_CArray_CTerritoryPtr.asFunction<
  void Function(_CArray_CTerritory, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTerritory)
>>)>();
late final _CArray_CTerritory_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CTerritory)>>('CArray_CTerritory_release');
late final _CArray_CTerritory_release = _CArray_CTerritory_releasePtr.asFunction<void Function(_CArray_CTerritory)>();

late final _CTerritory_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTerritory_cg_objectIdentifier');
late final _CTerritory_cg_objectIdentifier = _CTerritory_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CTerritory_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTerritory_release');
late final _CTerritory_release = _CTerritory_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTerritory_retainPtr = _lookup<ffi.NativeFunction<_CTerritory Function(ffi.Pointer<ffi.Void>)>>('CTerritory_retain');
late final _CTerritory_retain = _CTerritory_retainPtr.asFunction<_CTerritory Function(ffi.Pointer<ffi.Void>)>();
late final _CTerritoryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTerritory Function()>>('CTerritoryMakeDefault');
late final _CTerritoryMakeDefault = _CTerritoryMakeDefaultPtr.asFunction<_CTerritory Function()>();

late final _CFunction_G_remainingRouteGeometry_With_CGeoPointRouteAttribute_CRoutePointPtr = _lookup<ffi.NativeFunction<_CGeoPointRouteAttribute Function(_CGeoPointRouteAttribute, _CRoutePoint)>>('CFunction_G_remainingRouteGeometry_With_CGeoPointRouteAttribute_CRoutePoint');
late final _CFunction_G_remainingRouteGeometry_With_CGeoPointRouteAttribute_CRoutePoint = _CFunction_G_remainingRouteGeometry_With_CGeoPointRouteAttribute_CRoutePointPtr.asFunction<_CGeoPointRouteAttribute Function(_CGeoPointRouteAttribute, _CRoutePoint)>();
late final _CFunction_G_routeMatchesTruckPassZonePasses_With_CTruckPassZoneIdRouteLongAttribute_CArray_CTruckPassZonePassPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CTruckPassZoneIdRouteLongAttribute, _CArray_CTruckPassZonePass)>>('CFunction_G_routeMatchesTruckPassZonePasses_With_CTruckPassZoneIdRouteLongAttribute_CArray_CTruckPassZonePass');
late final _CFunction_G_routeMatchesTruckPassZonePasses_With_CTruckPassZoneIdRouteLongAttribute_CArray_CTruckPassZonePass = _CFunction_G_routeMatchesTruckPassZonePasses_With_CTruckPassZoneIdRouteLongAttribute_CArray_CTruckPassZonePassPtr.asFunction<bool Function(_CTruckPassZoneIdRouteLongAttribute, _CArray_CTruckPassZonePass)>();
late final _CFunction_G_getRoadMacroGraph_With_CContextPtr = _lookup<ffi.NativeFunction<_CRoadMacroGraph Function(_CContext)>>('CFunction_G_getRoadMacroGraph_With_CContext');
late final _CFunction_G_getRoadMacroGraph_With_CContext = _CFunction_G_getRoadMacroGraph_With_CContextPtr.asFunction<_CRoadMacroGraph Function(_CContext)>();

late final _CRoadMacroGraph_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadMacroGraph_cg_objectIdentifier');
late final _CRoadMacroGraph_cg_objectIdentifier = _CRoadMacroGraph_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CRoadMacroGraph_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadMacroGraph_release');
late final _CRoadMacroGraph_release = _CRoadMacroGraph_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadMacroGraph_retainPtr = _lookup<ffi.NativeFunction<_CRoadMacroGraph Function(ffi.Pointer<ffi.Void>)>>('CRoadMacroGraph_retain');
late final _CRoadMacroGraph_retain = _CRoadMacroGraph_retainPtr.asFunction<_CRoadMacroGraph Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadMacroGraphMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadMacroGraph Function()>>('CRoadMacroGraphMakeDefault');
late final _CRoadMacroGraphMakeDefault = _CRoadMacroGraphMakeDefaultPtr.asFunction<_CRoadMacroGraph Function()>();

late final _CFunction_G_getTerritoriesAlongRouteProvider_With_CContextPtr = _lookup<ffi.NativeFunction<_CTerritoriesAlongRouteProvider Function(_CContext)>>('CFunction_G_getTerritoriesAlongRouteProvider_With_CContext');
late final _CFunction_G_getTerritoriesAlongRouteProvider_With_CContext = _CFunction_G_getTerritoriesAlongRouteProvider_With_CContextPtr.asFunction<_CTerritoriesAlongRouteProvider Function(_CContext)>();
late final _CTrafficCollector_trafficCollectingAllowedPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CTrafficCollector)>>('CTrafficCollector_trafficCollectingAllowed');
late final _CTrafficCollector_trafficCollectingAllowed = _CTrafficCollector_trafficCollectingAllowedPtr.asFunction<bool Function(_CTrafficCollector)>();
late final _CTrafficCollector_setTrafficCollectingAllowed_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CTrafficCollector, ffi.Bool)>>('CTrafficCollector_setTrafficCollectingAllowed_bool');
late final _CTrafficCollector_setTrafficCollectingAllowed_bool = _CTrafficCollector_setTrafficCollectingAllowed_boolPtr.asFunction<void Function(_CTrafficCollector, bool)>();

late final _CTrafficCollector_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTrafficCollector_cg_objectIdentifier');
late final _CTrafficCollector_cg_objectIdentifier = _CTrafficCollector_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTrafficCollector_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CTrafficCollector Function(_CContext)>>('CTrafficCollector_C_createWith_CContext');
late final _CTrafficCollector_C_createWith_CContext = _CTrafficCollector_C_createWith_CContextPtr.asFunction<_CTrafficCollector Function(_CContext)>();

late final _CTrafficCollector_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTrafficCollector_release');
late final _CTrafficCollector_release = _CTrafficCollector_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficCollector_retainPtr = _lookup<ffi.NativeFunction<_CTrafficCollector Function(ffi.Pointer<ffi.Void>)>>('CTrafficCollector_retain');
late final _CTrafficCollector_retain = _CTrafficCollector_retainPtr.asFunction<_CTrafficCollector Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficCollectorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficCollector Function()>>('CTrafficCollectorMakeDefault');
late final _CTrafficCollectorMakeDefault = _CTrafficCollectorMakeDefaultPtr.asFunction<_CTrafficCollector Function()>();


late final _CTrafficScoreStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficScoreState Function()>>('CTrafficScoreStateMakeDefault');
late final _CTrafficScoreStateMakeDefault = _CTrafficScoreStateMakeDefaultPtr.asFunction<_CTrafficScoreState Function()>();

late final _CTrafficScoreMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficScore Function()>>('CTrafficScoreMakeDefault');
late final _CTrafficScoreMakeDefault = _CTrafficScoreMakeDefaultPtr.asFunction<_CTrafficScore Function()>();

late final _CTrafficScoreProvider_scoreChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CTrafficScore Function(_CTrafficScoreProvider)>>('CTrafficScoreProvider_scoreChannel');
late final _CTrafficScoreProvider_scoreChannel = _CTrafficScoreProvider_scoreChannelPtr.asFunction<_CStatefulChannel_CTrafficScore Function(_CTrafficScoreProvider)>();
late final _CTrafficScoreProvider_scorePtr = _lookup<ffi.NativeFunction<_CTrafficScore Function(_CTrafficScoreProvider)>>('CTrafficScoreProvider_score');
late final _CTrafficScoreProvider_score = _CTrafficScoreProvider_scorePtr.asFunction<_CTrafficScore Function(_CTrafficScoreProvider)>();

late final _CTrafficScoreProvider_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTrafficScoreProvider_cg_objectIdentifier');
late final _CTrafficScoreProvider_cg_objectIdentifier = _CTrafficScoreProvider_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTrafficScoreProvider_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CTrafficScoreProvider Function(_CMap)>>('CTrafficScoreProvider_C_createWith_CMap');
late final _CTrafficScoreProvider_C_createWith_CMap = _CTrafficScoreProvider_C_createWith_CMapPtr.asFunction<_CTrafficScoreProvider Function(_CMap)>();
late final _CTrafficScoreProvider_C_createWith_CContext_CGeoPointPtr = _lookup<ffi.NativeFunction<_CTrafficScoreProvider Function(_CContext, _CGeoPoint)>>('CTrafficScoreProvider_C_createWith_CContext_CGeoPoint');
late final _CTrafficScoreProvider_C_createWith_CContext_CGeoPoint = _CTrafficScoreProvider_C_createWith_CContext_CGeoPointPtr.asFunction<_CTrafficScoreProvider Function(_CContext, _CGeoPoint)>();

late final _CTrafficScoreProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTrafficScoreProvider_release');
late final _CTrafficScoreProvider_release = _CTrafficScoreProvider_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficScoreProvider_retainPtr = _lookup<ffi.NativeFunction<_CTrafficScoreProvider Function(ffi.Pointer<ffi.Void>)>>('CTrafficScoreProvider_retain');
late final _CTrafficScoreProvider_retain = _CTrafficScoreProvider_retainPtr.asFunction<_CTrafficScoreProvider Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficScoreProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficScoreProvider Function()>>('CTrafficScoreProviderMakeDefault');
late final _CTrafficScoreProviderMakeDefault = _CTrafficScoreProviderMakeDefaultPtr.asFunction<_CTrafficScoreProvider Function()>();


late final _CStatefulChannel_CTrafficScoreMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CTrafficScore Function()>>('CStatefulChannel_CTrafficScoreMakeDefault');
late final _CStatefulChannel_CTrafficScoreMakeDefault = _CStatefulChannel_CTrafficScoreMakeDefaultPtr.asFunction<_CStatefulChannel_CTrafficScore Function()>();
late final _CStatefulChannel_CTrafficScore_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CTrafficScore)>>('CStatefulChannel_CTrafficScore_release');
late final _CStatefulChannel_CTrafficScore_release = _CStatefulChannel_CTrafficScore_releasePtr.asFunction<void Function(_CStatefulChannel_CTrafficScore)>();
late final _CStatefulChannel_CTrafficScore_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CTrafficScore Function(_CStatefulChannel_CTrafficScore)>>('CStatefulChannel_CTrafficScore_retain');
late final _CStatefulChannel_CTrafficScore_retain = _CStatefulChannel_CTrafficScore_retainPtr.asFunction<_CStatefulChannel_CTrafficScore Function(_CStatefulChannel_CTrafficScore)>();
late final _CStatefulChannel_CTrafficScoreGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CTrafficScore Function(_CStatefulChannel_CTrafficScore)>>('CStatefulChannel_CTrafficScore_getCurrentValue');
late final _CStatefulChannel_CTrafficScoreGetCurrentValue = _CStatefulChannel_CTrafficScoreGetCurrentValuePtr.asFunction<_CTrafficScore Function(_CStatefulChannel_CTrafficScore)>();
late final _CStatefulChannel_CTrafficScoreConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CTrafficScore,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTrafficScore, ffi.Int64)>>
  )
>>('CStatefulChannel_CTrafficScore_connect');
late final _CStatefulChannel_CTrafficScoreConnect = _CStatefulChannel_CTrafficScoreConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CTrafficScore,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTrafficScore, ffi.Int64)>>
  )
>();

late final _CTrafficControlStatusMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficControlStatus Function()>>('CTrafficControlStatusMakeDefault');
late final _CTrafficControlStatusMakeDefault = _CTrafficControlStatusMakeDefaultPtr.asFunction<_CTrafficControlStatus Function()>();

late final _CTrafficControlStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficControlState Function()>>('CTrafficControlStateMakeDefault');
late final _CTrafficControlStateMakeDefault = _CTrafficControlStateMakeDefaultPtr.asFunction<_CTrafficControlState Function()>();

late final _CTrafficControlModel_stateChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CTrafficControlState Function(_CTrafficControlModel)>>('CTrafficControlModel_stateChannel');
late final _CTrafficControlModel_stateChannel = _CTrafficControlModel_stateChannelPtr.asFunction<_CStatefulChannel_CTrafficControlState Function(_CTrafficControlModel)>();
late final _CTrafficControlModel_statePtr = _lookup<ffi.NativeFunction<_CTrafficControlState Function(_CTrafficControlModel)>>('CTrafficControlModel_state');
late final _CTrafficControlModel_state = _CTrafficControlModel_statePtr.asFunction<_CTrafficControlState Function(_CTrafficControlModel)>();

late final _CTrafficControlModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTrafficControlModel_cg_objectIdentifier');
late final _CTrafficControlModel_cg_objectIdentifier = _CTrafficControlModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTrafficControlModel_onClickedPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CTrafficControlModel)>>('CTrafficControlModel_onClicked');
late final _CTrafficControlModel_onClicked = _CTrafficControlModel_onClickedPtr.asFunction<void Function(_CTrafficControlModel)>();
late final _CTrafficControlModel_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CTrafficControlModel Function(_CMap)>>('CTrafficControlModel_C_createWith_CMap');
late final _CTrafficControlModel_C_createWith_CMap = _CTrafficControlModel_C_createWith_CMapPtr.asFunction<_CTrafficControlModel Function(_CMap)>();

late final _CTrafficControlModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTrafficControlModel_release');
late final _CTrafficControlModel_release = _CTrafficControlModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficControlModel_retainPtr = _lookup<ffi.NativeFunction<_CTrafficControlModel Function(ffi.Pointer<ffi.Void>)>>('CTrafficControlModel_retain');
late final _CTrafficControlModel_retain = _CTrafficControlModel_retainPtr.asFunction<_CTrafficControlModel Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficControlModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficControlModel Function()>>('CTrafficControlModelMakeDefault');
late final _CTrafficControlModelMakeDefault = _CTrafficControlModelMakeDefaultPtr.asFunction<_CTrafficControlModel Function()>();


late final _CStatefulChannel_CTrafficControlStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CTrafficControlState Function()>>('CStatefulChannel_CTrafficControlStateMakeDefault');
late final _CStatefulChannel_CTrafficControlStateMakeDefault = _CStatefulChannel_CTrafficControlStateMakeDefaultPtr.asFunction<_CStatefulChannel_CTrafficControlState Function()>();
late final _CStatefulChannel_CTrafficControlState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CTrafficControlState)>>('CStatefulChannel_CTrafficControlState_release');
late final _CStatefulChannel_CTrafficControlState_release = _CStatefulChannel_CTrafficControlState_releasePtr.asFunction<void Function(_CStatefulChannel_CTrafficControlState)>();
late final _CStatefulChannel_CTrafficControlState_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CTrafficControlState Function(_CStatefulChannel_CTrafficControlState)>>('CStatefulChannel_CTrafficControlState_retain');
late final _CStatefulChannel_CTrafficControlState_retain = _CStatefulChannel_CTrafficControlState_retainPtr.asFunction<_CStatefulChannel_CTrafficControlState Function(_CStatefulChannel_CTrafficControlState)>();
late final _CStatefulChannel_CTrafficControlStateGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CTrafficControlState Function(_CStatefulChannel_CTrafficControlState)>>('CStatefulChannel_CTrafficControlState_getCurrentValue');
late final _CStatefulChannel_CTrafficControlStateGetCurrentValue = _CStatefulChannel_CTrafficControlStateGetCurrentValuePtr.asFunction<_CTrafficControlState Function(_CStatefulChannel_CTrafficControlState)>();
late final _CStatefulChannel_CTrafficControlStateConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CTrafficControlState,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTrafficControlState, ffi.Int64)>>
  )
>>('CStatefulChannel_CTrafficControlState_connect');
late final _CStatefulChannel_CTrafficControlStateConnect = _CStatefulChannel_CTrafficControlStateConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CTrafficControlState,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTrafficControlState, ffi.Int64)>>
  )
>();

late final _CPackageInfoErrorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPackageInfoError Function()>>('CPackageInfoErrorMakeDefault');
late final _CPackageInfoErrorMakeDefault = _CPackageInfoErrorMakeDefaultPtr.asFunction<_CPackageInfoError Function()>();

late final _CPackageUpdateStatusMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPackageUpdateStatus Function()>>('CPackageUpdateStatusMakeDefault');
late final _CPackageUpdateStatusMakeDefault = _CPackageUpdateStatusMakeDefaultPtr.asFunction<_CPackageUpdateStatus Function()>();

late final _COptional_CPackageInfoErrorMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CPackageInfoError Function()>>('COptional_CPackageInfoErrorMakeDefault');
late final _COptional_CPackageInfoErrorMakeDefault = _COptional_CPackageInfoErrorMakeDefaultPtr.asFunction<_COptional_CPackageInfoError Function()>();

late final _CPackageInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPackageInfo Function()>>('CPackageInfoMakeDefault');
late final _CPackageInfoMakeDefault = _CPackageInfoMakeDefaultPtr.asFunction<_CPackageInfo Function()>();

late final _CPackage_idPtr = _lookup<ffi.NativeFunction<_CString Function(_CPackage)>>('CPackage_id');
late final _CPackage_id = _CPackage_idPtr.asFunction<_CString Function(_CPackage)>();
late final _CPackage_infoChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CPackageInfo Function(_CPackage)>>('CPackage_infoChannel');
late final _CPackage_infoChannel = _CPackage_infoChannelPtr.asFunction<_CStatefulChannel_CPackageInfo Function(_CPackage)>();
late final _CPackage_infoPtr = _lookup<ffi.NativeFunction<_CPackageInfo Function(_CPackage)>>('CPackage_info');
late final _CPackage_info = _CPackage_infoPtr.asFunction<_CPackageInfo Function(_CPackage)>();
late final _CPackage_progressChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_uint8_t Function(_CPackage)>>('CPackage_progressChannel');
late final _CPackage_progressChannel = _CPackage_progressChannelPtr.asFunction<_CStatefulChannel_uint8_t Function(_CPackage)>();
late final _CPackage_progressPtr = _lookup<ffi.NativeFunction<ffi.Uint8 Function(_CPackage)>>('CPackage_progress');
late final _CPackage_progress = _CPackage_progressPtr.asFunction<int Function(_CPackage)>();

late final _CPackage_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPackage_cg_objectIdentifier');
late final _CPackage_cg_objectIdentifier = _CPackage_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPackage_installPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackage)>>('CPackage_install');
late final _CPackage_install = _CPackage_installPtr.asFunction<void Function(_CPackage)>();
late final _CPackage_uninstallPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackage)>>('CPackage_uninstall');
late final _CPackage_uninstall = _CPackage_uninstallPtr.asFunction<void Function(_CPackage)>();
late final _CPackage_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CPackage)>>('CPackage_cg_getSelector');
late final _CPackage_cg_getSelector = _CPackage_cg_getSelectorPtr.asFunction<int Function(_CPackage)>();

late final _CPackage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPackage_release');
late final _CPackage_release = _CPackage_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPackage_retainPtr = _lookup<ffi.NativeFunction<_CPackage Function(ffi.Pointer<ffi.Void>)>>('CPackage_retain');
late final _CPackage_retain = _CPackage_retainPtr.asFunction<_CPackage Function(ffi.Pointer<ffi.Void>)>();
late final _CPackageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPackage Function()>>('CPackageMakeDefault');
late final _CPackageMakeDefault = _CPackageMakeDefaultPtr.asFunction<_CPackage Function()>();


late final _CStatefulChannel_CPackageInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CPackageInfo Function()>>('CStatefulChannel_CPackageInfoMakeDefault');
late final _CStatefulChannel_CPackageInfoMakeDefault = _CStatefulChannel_CPackageInfoMakeDefaultPtr.asFunction<_CStatefulChannel_CPackageInfo Function()>();
late final _CStatefulChannel_CPackageInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CPackageInfo)>>('CStatefulChannel_CPackageInfo_release');
late final _CStatefulChannel_CPackageInfo_release = _CStatefulChannel_CPackageInfo_releasePtr.asFunction<void Function(_CStatefulChannel_CPackageInfo)>();
late final _CStatefulChannel_CPackageInfo_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CPackageInfo Function(_CStatefulChannel_CPackageInfo)>>('CStatefulChannel_CPackageInfo_retain');
late final _CStatefulChannel_CPackageInfo_retain = _CStatefulChannel_CPackageInfo_retainPtr.asFunction<_CStatefulChannel_CPackageInfo Function(_CStatefulChannel_CPackageInfo)>();
late final _CStatefulChannel_CPackageInfoGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CPackageInfo Function(_CStatefulChannel_CPackageInfo)>>('CStatefulChannel_CPackageInfo_getCurrentValue');
late final _CStatefulChannel_CPackageInfoGetCurrentValue = _CStatefulChannel_CPackageInfoGetCurrentValuePtr.asFunction<_CPackageInfo Function(_CStatefulChannel_CPackageInfo)>();
late final _CStatefulChannel_CPackageInfoConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CPackageInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPackageInfo, ffi.Int64)>>
  )
>>('CStatefulChannel_CPackageInfo_connect');
late final _CStatefulChannel_CPackageInfoConnect = _CStatefulChannel_CPackageInfoConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CPackageInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPackageInfo, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_uint8_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_uint8_t Function()>>('CStatefulChannel_uint8_tMakeDefault');
late final _CStatefulChannel_uint8_tMakeDefault = _CStatefulChannel_uint8_tMakeDefaultPtr.asFunction<_CStatefulChannel_uint8_t Function()>();
late final _CStatefulChannel_uint8_t_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_uint8_t)>>('CStatefulChannel_uint8_t_release');
late final _CStatefulChannel_uint8_t_release = _CStatefulChannel_uint8_t_releasePtr.asFunction<void Function(_CStatefulChannel_uint8_t)>();
late final _CStatefulChannel_uint8_t_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_uint8_t Function(_CStatefulChannel_uint8_t)>>('CStatefulChannel_uint8_t_retain');
late final _CStatefulChannel_uint8_t_retain = _CStatefulChannel_uint8_t_retainPtr.asFunction<_CStatefulChannel_uint8_t Function(_CStatefulChannel_uint8_t)>();
late final _CStatefulChannel_uint8_tGetCurrentValuePtr = _lookup<ffi.NativeFunction<ffi.Uint8 Function(_CStatefulChannel_uint8_t)>>('CStatefulChannel_uint8_t_getCurrentValue');
late final _CStatefulChannel_uint8_tGetCurrentValue = _CStatefulChannel_uint8_tGetCurrentValuePtr.asFunction<int Function(_CStatefulChannel_uint8_t)>();
late final _CStatefulChannel_uint8_tConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_uint8_t,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint8, ffi.Int64)>>
  )
>>('CStatefulChannel_uint8_t_connect');
late final _CStatefulChannel_uint8_tConnect = _CStatefulChannel_uint8_tConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_uint8_t,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint8, ffi.Int64)>>
  )
>();
late final _CPackageManager_autoupdateEnabledPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CPackageManager)>>('CPackageManager_autoupdateEnabled');
late final _CPackageManager_autoupdateEnabled = _CPackageManager_autoupdateEnabledPtr.asFunction<bool Function(_CPackageManager)>();
late final _CPackageManager_setAutoupdateEnabled_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackageManager, ffi.Bool)>>('CPackageManager_setAutoupdateEnabled_bool');
late final _CPackageManager_setAutoupdateEnabled_bool = _CPackageManager_setAutoupdateEnabled_boolPtr.asFunction<void Function(_CPackageManager, bool)>();
late final _CPackageManager_packagesChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CPackage Function(_CPackageManager)>>('CPackageManager_packagesChannel');
late final _CPackageManager_packagesChannel = _CPackageManager_packagesChannelPtr.asFunction<_CStatefulChannel_CArray_CPackage Function(_CPackageManager)>();
late final _CPackageManager_packagesPtr = _lookup<ffi.NativeFunction<_CArray_CPackage Function(_CPackageManager)>>('CPackageManager_packages');
late final _CPackageManager_packages = _CPackageManager_packagesPtr.asFunction<_CArray_CPackage Function(_CPackageManager)>();

late final _CPackageManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPackageManager_cg_objectIdentifier');
late final _CPackageManager_cg_objectIdentifier = _CPackageManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPackageManager_checkForUpdatesPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackageManager)>>('CPackageManager_checkForUpdates');
late final _CPackageManager_checkForUpdates = _CPackageManager_checkForUpdatesPtr.asFunction<void Function(_CPackageManager)>();

late final _CPackageManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPackageManager_release');
late final _CPackageManager_release = _CPackageManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPackageManager_retainPtr = _lookup<ffi.NativeFunction<_CPackageManager Function(ffi.Pointer<ffi.Void>)>>('CPackageManager_retain');
late final _CPackageManager_retain = _CPackageManager_retainPtr.asFunction<_CPackageManager Function(ffi.Pointer<ffi.Void>)>();
late final _CPackageManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPackageManager Function()>>('CPackageManagerMakeDefault');
late final _CPackageManagerMakeDefault = _CPackageManagerMakeDefaultPtr.asFunction<_CPackageManager Function()>();


late final _CStatefulChannel_CArray_CPackageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CPackage Function()>>('CStatefulChannel_CArray_CPackageMakeDefault');
late final _CStatefulChannel_CArray_CPackageMakeDefault = _CStatefulChannel_CArray_CPackageMakeDefaultPtr.asFunction<_CStatefulChannel_CArray_CPackage Function()>();
late final _CStatefulChannel_CArray_CPackage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CArray_CPackage)>>('CStatefulChannel_CArray_CPackage_release');
late final _CStatefulChannel_CArray_CPackage_release = _CStatefulChannel_CArray_CPackage_releasePtr.asFunction<void Function(_CStatefulChannel_CArray_CPackage)>();
late final _CStatefulChannel_CArray_CPackage_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CPackage Function(_CStatefulChannel_CArray_CPackage)>>('CStatefulChannel_CArray_CPackage_retain');
late final _CStatefulChannel_CArray_CPackage_retain = _CStatefulChannel_CArray_CPackage_retainPtr.asFunction<_CStatefulChannel_CArray_CPackage Function(_CStatefulChannel_CArray_CPackage)>();
late final _CStatefulChannel_CArray_CPackageGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CArray_CPackage Function(_CStatefulChannel_CArray_CPackage)>>('CStatefulChannel_CArray_CPackage_getCurrentValue');
late final _CStatefulChannel_CArray_CPackageGetCurrentValue = _CStatefulChannel_CArray_CPackageGetCurrentValuePtr.asFunction<_CArray_CPackage Function(_CStatefulChannel_CArray_CPackage)>();
late final _CStatefulChannel_CArray_CPackageConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CPackage,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CPackage, ffi.Int64)>>
  )
>>('CStatefulChannel_CArray_CPackage_connect');
late final _CStatefulChannel_CArray_CPackageConnect = _CStatefulChannel_CArray_CPackageConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CPackage,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CPackage, ffi.Int64)>>
  )
>();

late final _CArray_CPackagemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CPackage Function()>>('CArray_CPackage_makeEmpty');
late final _CArray_CPackagemakeEmpty = _CArray_CPackagemakeEmptyPtr.asFunction<_CArray_CPackage Function()>();
late final _CArray_CPackageaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPackage, _CPackage)>>('CArray_CPackage_addElement');
late final _CArray_CPackageaddElement = _CArray_CPackageaddElementPtr.asFunction<void Function(_CArray_CPackage, _CPackage)>();
late final _forEach_CArray_CPackagePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CPackage, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPackage)>>)
>>('CArray_CPackage_forEachWithFunctionPointer');
late final _forEach_CArray_CPackage = _forEach_CArray_CPackagePtr.asFunction<
  void Function(_CArray_CPackage, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPackage)
>>)>();
late final _CArray_CPackage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CPackage)>>('CArray_CPackage_release');
late final _CArray_CPackage_release = _CArray_CPackage_releasePtr.asFunction<void Function(_CArray_CPackage)>();
late final _CFunction_G_getPackageManager_With_CContextPtr = _lookup<ffi.NativeFunction<_CPackageManager Function(_CContext)>>('CFunction_G_getPackageManager_With_CContext');
late final _CFunction_G_getPackageManager_With_CContext = _CFunction_G_getPackageManager_With_CContextPtr.asFunction<_CPackageManager Function(_CContext)>();
late final _CFunction_G_getTerritoryManager_With_CContextPtr = _lookup<ffi.NativeFunction<_CTerritoryManager Function(_CContext)>>('CFunction_G_getTerritoryManager_With_CContext');
late final _CFunction_G_getTerritoryManager_With_CContext = _CFunction_G_getTerritoryManager_With_CContextPtr.asFunction<_CTerritoryManager Function(_CContext)>();
late final _CTerritoryManager_territoriesChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CTerritory Function(_CTerritoryManager)>>('CTerritoryManager_territoriesChannel');
late final _CTerritoryManager_territoriesChannel = _CTerritoryManager_territoriesChannelPtr.asFunction<_CStatefulChannel_CArray_CTerritory Function(_CTerritoryManager)>();
late final _CTerritoryManager_territoriesPtr = _lookup<ffi.NativeFunction<_CArray_CTerritory Function(_CTerritoryManager)>>('CTerritoryManager_territories');
late final _CTerritoryManager_territories = _CTerritoryManager_territoriesPtr.asFunction<_CArray_CTerritory Function(_CTerritoryManager)>();

late final _CTerritoryManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTerritoryManager_cg_objectIdentifier');
late final _CTerritoryManager_cg_objectIdentifier = _CTerritoryManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTerritoryManager_findByPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<_CArray_CTerritory Function(_CTerritoryManager, _CGeoPoint)>>('CTerritoryManager_findByPoint_CGeoPoint');
late final _CTerritoryManager_findByPoint_CGeoPoint = _CTerritoryManager_findByPoint_CGeoPointPtr.asFunction<_CArray_CTerritory Function(_CTerritoryManager, _CGeoPoint)>();
late final _CTerritoryManager_findByRect_CGeoRectPtr = _lookup<ffi.NativeFunction<_CArray_CTerritory Function(_CTerritoryManager, _CGeoRect)>>('CTerritoryManager_findByRect_CGeoRect');
late final _CTerritoryManager_findByRect_CGeoRect = _CTerritoryManager_findByRect_CGeoRectPtr.asFunction<_CArray_CTerritory Function(_CTerritoryManager, _CGeoRect)>();
late final _CTerritoryManager_pausePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CTerritoryManager)>>('CTerritoryManager_pause');
late final _CTerritoryManager_pause = _CTerritoryManager_pausePtr.asFunction<void Function(_CTerritoryManager)>();
late final _CTerritoryManager_resumePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CTerritoryManager)>>('CTerritoryManager_resume');
late final _CTerritoryManager_resume = _CTerritoryManager_resumePtr.asFunction<void Function(_CTerritoryManager)>();

late final _CTerritoryManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTerritoryManager_release');
late final _CTerritoryManager_release = _CTerritoryManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTerritoryManager_retainPtr = _lookup<ffi.NativeFunction<_CTerritoryManager Function(ffi.Pointer<ffi.Void>)>>('CTerritoryManager_retain');
late final _CTerritoryManager_retain = _CTerritoryManager_retainPtr.asFunction<_CTerritoryManager Function(ffi.Pointer<ffi.Void>)>();
late final _CTerritoryManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTerritoryManager Function()>>('CTerritoryManagerMakeDefault');
late final _CTerritoryManagerMakeDefault = _CTerritoryManagerMakeDefaultPtr.asFunction<_CTerritoryManager Function()>();


late final _CStatefulChannel_CArray_CTerritoryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CTerritory Function()>>('CStatefulChannel_CArray_CTerritoryMakeDefault');
late final _CStatefulChannel_CArray_CTerritoryMakeDefault = _CStatefulChannel_CArray_CTerritoryMakeDefaultPtr.asFunction<_CStatefulChannel_CArray_CTerritory Function()>();
late final _CStatefulChannel_CArray_CTerritory_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CArray_CTerritory)>>('CStatefulChannel_CArray_CTerritory_release');
late final _CStatefulChannel_CArray_CTerritory_release = _CStatefulChannel_CArray_CTerritory_releasePtr.asFunction<void Function(_CStatefulChannel_CArray_CTerritory)>();
late final _CStatefulChannel_CArray_CTerritory_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CTerritory Function(_CStatefulChannel_CArray_CTerritory)>>('CStatefulChannel_CArray_CTerritory_retain');
late final _CStatefulChannel_CArray_CTerritory_retain = _CStatefulChannel_CArray_CTerritory_retainPtr.asFunction<_CStatefulChannel_CArray_CTerritory Function(_CStatefulChannel_CArray_CTerritory)>();
late final _CStatefulChannel_CArray_CTerritoryGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CArray_CTerritory Function(_CStatefulChannel_CArray_CTerritory)>>('CStatefulChannel_CArray_CTerritory_getCurrentValue');
late final _CStatefulChannel_CArray_CTerritoryGetCurrentValue = _CStatefulChannel_CArray_CTerritoryGetCurrentValuePtr.asFunction<_CArray_CTerritory Function(_CStatefulChannel_CArray_CTerritory)>();
late final _CStatefulChannel_CArray_CTerritoryConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CTerritory,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CTerritory, ffi.Int64)>>
  )
>>('CStatefulChannel_CArray_CTerritory_connect');
late final _CStatefulChannel_CArray_CTerritoryConnect = _CStatefulChannel_CArray_CTerritoryConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CTerritory,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CTerritory, ffi.Int64)>>
  )
>();

//ApplicationState, BaseCameraInternalMethods, ImageLoader, LocaleChangeNotifier, MapBuilder, MapGestureRecognizer, MapInternalMethods, MapRenderer, MapSurfaceProvider, ModelDataLoader, PlatformLocaleManager, ProductType, calculateBearing, calculateDistance, createImage, createModelData, downloadData, makeSystemContext, move, toLocaleManager